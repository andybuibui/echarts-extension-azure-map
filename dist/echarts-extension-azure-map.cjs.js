/*!
 * echarts-extension-azure-map 
 * @version 1.0.0
 * @author andybuibui
 * 
 * MIT License
 * 
 * Copyright (c) 2024 andybuibui
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */
'use strict';

var echarts = require('echarts');

var ecVer = echarts.version.split('.');
var isNewEC = ecVer[0] > 4;
var COMPONENT_TYPE = 'azuremap';
var ACTION_TYPE = "".concat(COMPONENT_TYPE, "Roam");
function v2Equal(a, b) {
  return a && b && a[0] === b[0] && a[1] === b[1];
}

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

/*!
MICROSOFT SOFTWARE LICENSE TERMS
MICROSOFT AZURE MAPS WEB SDK
These license terms are an agreement between you and Microsoft Corporation (or one of its affiliates). They apply to the software named above and any Microsoft services or software updates (except to the extent such services or updates are accompanied by new or additional terms, in which case those different terms apply prospectively and do not alter your or Microsoft’s rights relating to pre-updated software or services). IF YOU COMPLY WITH THESE LICENSE TERMS, YOU HAVE THE RIGHTS BELOW.  BY USING THE SOFTWARE, YOU ACCEPT THESE TERMS.
1. INSTALLATION AND USE RIGHTS.
  a) General. You may install and use any number of copies of the software to develop and test your applications.
  b) User Region Parameters. The software will allow you to select from a View list to set the map view within your application for a given customer. By default the View parameter (also referred to as “user region parameter” is set to “Unified”.  Countries/Regions that are not on the View list will default to the “Unified” View. It is your responsibility to determine the location of your users, and then set the View parameter correctly for that location. The View parameter must be used in compliance with applicable laws, including those regarding mapping, of the country where maps, images and other data and third party content that You are authorized to access via the software is made available. 
  c) Third Party Software. The software may include third party applications that Microsoft, not the third party, licenses to you under this agreement. Any included notices for third party applications are for your information only.
  d) Microsoft Online Subscription Agreement. Some features of the software provide access to, or rely on, Microsoft Azure Services. The use of those services (but not the software) is governed by the separate terms and privacy policies associated with your Microsoft Azure subscription. The services may not be available in all regions. For more information see https://go.microsoft.com/fwLink/?LinkID=522330&amp;clcid=0x9.
2. DISTRIBUTABLE CODE. The software is comprised of “Distributable Code”. “Distributable Code” is code that you are permitted to distribute in applications you develop if you comply with the terms below and otherwise set forth in these license terms. 
  a) Distribution Rights. 
    i. You may copy and distribute the object code form of the software.
    i. Third Party Distribution. You may permit distributors of your applications to copy and distribute any of this distributable code you elect to distribute with your applications.
  b) Distribution Requirements. For any code you distribute, you must:
    i. add significant primary functionality to it in your applications;
    ii. require distributors and external end users to agree to terms that protect it and Microsoft at least as much as this agreement; and
    iii. indemnify, defend, and hold harmless Microsoft from any claims, including attorneys’ fees, related to the distribution or use of your applications, except to the extent that any claim is based solely on the unmodified distributable code.
  c) Distribution Restrictions. You may not:
    i. use Microsoft’s trademarks or trade dress in your application in any way that suggests your application comes from or is endorsed by Microsoft; or
    ii. modify or distribute the source code of any distributable code so that any part of it becomes subject to any license that requires that the distributable code, any other part of the software, or any of Microsoft’s other intellectual property be disclosed or distributed in source code form, or that others have the right to modify it.
3. DATA COLLECTION. The software may collect information about you and your use of the software and send that to Microsoft. Microsoft may use this information to provide services and improve Microsoft’s products and services. Your opt-out rights, if any, are described in the product documentation. Some features in the software may enable collection of data from users of your applications that access or use the software. If you use these features to enable data collection in your applications, you must comply with applicable law, including getting any required user consent, and maintain a prominent privacy policy that accurately informs users about how you use, collect, and share their data. You can learn more about Microsoft’s data collection and use in the product documentation and the Microsoft Privacy Statement at https://go.microsoft.com/fwlink/?LinkId=512132. You agree to comply with all applicable provisions of the Microsoft Privacy Statement.
4. SCOPE OF LICENSE. The software is licensed, not sold. Microsoft reserves all other rights. Unless applicable law gives you more rights despite this limitation, you will not (and have no right to):
  a) work around any technical limitations in the software that only allow you to use it in certain ways;
  b) reverse engineer, decompile, or disassemble the software, or attempt to do so, except and only to the extent permitted by licensing terms governing the use of open-source components that may be included with the software;
  c) remove, minimize, block, or modify any notices of Microsoft or its suppliers in the software;
  d) use the software in any way that is against the law or to create or propagate malware; or
  e) share, publish, distribute, or lend the software (except for any distributable code, subject to the terms above), provide the software as a stand-alone hosted solution for others to use, or transfer the software or this agreement to any third party.
5. EXPORT RESTRICTIONS. You must comply with all domestic and international export laws and regulations that apply to the software, which include restrictions on destinations, end users, and end use. For further information on export restrictions, visit http://aka.ms/exporting.
6. SUPPORT SERVICES. Microsoft is not obligated under this agreement to provide any support services for the software. Any support provided is “as is”, “with all faults”, and without warranty of any kind.
7. UPDATES. The software may periodically check for updates, and download and install them for you. You may obtain updates only from Microsoft or authorized sources. Microsoft may need to update your system to provide you with updates. You agree to receive these automatic updates without any additional notice. Updates may not include or support all existing software features, services, or peripheral devices.
8. ENTIRE AGREEMENT. This agreement, and any other terms Microsoft may provide for supplements, updates, or third-party applications, is the entire agreement for the software.
9. APPLICABLE LAW AND PLACE TO RESOLVE DISPUTES. If you acquired the software in the United States or Canada, the laws of the state or province where you live (or, if a business, where your principal place of business is located) govern the interpretation of this agreement, claims for its breach, and all other claims (including consumer protection, unfair competition, and tort claims), regardless of conflict of laws principles. If you acquired the software in any other country, its laws apply. If U.S. federal jurisdiction exists, you and Microsoft consent to exclusive jurisdiction and venue in the federal court in King County, Washington for all disputes heard in court. If not, you and Microsoft consent to exclusive jurisdiction and venue in the Superior Court of King County, Washington for all disputes heard in court.
10. CONSUMER RIGHTS; REGIONAL VARIATIONS. This agreement describes certain legal rights. You may have other rights, including consumer rights, under the laws of your state or country. Separate and apart from your relationship with Microsoft, you may also have rights with respect to the party from which you acquired the software. This agreement does not change those other rights if the laws of your state or country do not permit it to do so. For example, if you acquired the software in one of the below regions, or mandatory country law applies, then the following provisions apply to you:
  a) Australia. You have statutory guarantees under the Australian Consumer Law and nothing in this agreement is intended to affect those rights.
  b) Canada. If you acquired this software in Canada, you may stop receiving updates by turning off the automatic update feature, disconnecting your device from the Internet (if and when you re-connect to the Internet, however, the software will resume checking for and installing updates), or uninstalling the software. The product documentation, if any, may also specify how to turn off updates for your specific device or software.
  c) Germany and Austria.
    i. Warranty. The properly licensed software will perform substantially as described in any Microsoft materials that accompany the software. However, Microsoft gives no contractual guarantee in relation to the licensed software.
    ii. Limitation of Liability. In case of intentional conduct, gross negligence, claims based on the Product Liability Act, as well as, in case of death or personal or physical injury, Microsoft is liable according to the statutory law.
  Subject to the foregoing clause ii., Microsoft will only be liable for slight negligence if Microsoft is in breach of such material contractual obligations, the fulfillment of which facilitate the due performance of this agreement, the breach of which would endanger the purpose of this agreement and the compliance with which a party may constantly trust in (so-called "cardinal obligations"). In other cases of slight negligence, Microsoft will not be liable for slight negligence.
11. DISCLAIMER OF WARRANTY. THE SOFTWARE IS LICENSED “AS IS.” YOU BEAR THE RISK OF USING IT. MICROSOFT GIVES NO EXPRESS WARRANTIES, GUARANTEES, OR CONDITIONS. TO THE EXTENT PERMITTED UNDER APPLICABLE LAWS, MICROSOFT EXCLUDES ALL IMPLIED WARRANTIES, INCLUDING MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
12. LIMITATION ON AND EXCLUSION OF DAMAGES. IF YOU HAVE ANY BASIS FOR RECOVERING DAMAGES DESPITE THE PRECEDING DISCLAIMER OF WARRANTY, YOU CAN RECOVER FROM MICROSOFT AND ITS SUPPLIERS ONLY DIRECT DAMAGES UP TO U.S. $5.00. YOU CANNOT RECOVER ANY OTHER DAMAGES, INCLUDING CONSEQUENTIAL, LOST PROFITS, SPECIAL, INDIRECT, OR INCIDENTAL DAMAGES.
This limitation applies to (a) anything related to the software, services, content (including code) on third party Internet sites, or third party applications; and (b) claims for breach of contract, warranty, guarantee, or condition; strict liability, negligence, or other tort; or any other claim; in each case to the extent permitted by applicable law.
It also applies even if Microsoft knew or should have known about the possibility of the damages. The above limitation or exclusion may not apply to you because your state, province, or country may not allow the exclusion or limitation of incidental, consequential, or other damages.
Please note: As this software is distributed in Canada, some of the clauses in this agreement are provided below in French.
Remarque: Ce logiciel étant distribué au Canada, certaines des clauses dans ce contrat sont fournies ci-dessous en français.
EXONÉRATION DE GARANTIE. Le logiciel visé par une licence est offert « tel quel ». Toute utilisation de ce logiciel est à votre seule risque et péril. Microsoft n’accorde aucune autre garantie expresse. Vous pouvez bénéficier de droits additionnels en vertu du droit local sur la protection des consommateurs, que ce contrat ne peut modifier. La ou elles sont permises par le droit locale, les garanties implicites de qualité marchande, d’adéquation à un usage particulier et d’absence de contrefaçon sont exclues.
LIMITATION DES DOMMAGES-INTÉRÊTS ET EXCLUSION DE RESPONSABILITÉ POUR LES DOMMAGES. Vous pouvez obtenir de Microsoft et de ses fournisseurs une indemnisation en cas de dommages directs uniquement à hauteur de 5,00 $ US. Vous ne pouvez prétendre à aucune indemnisation pour les autres dommages, y compris les dommages spéciaux, indirects ou accessoires et pertes de bénéfices.
Cette limitation concerne:
• tout ce qui est relié au logiciel, aux services ou au contenu (y compris le code) figurant sur des sites Internet tiers ou dans des programmes tiers; et
• les réclamations au titre de violation de contrat ou de garantie, ou au titre de responsabilité stricte, de négligence ou d’une autre faute dans la limite autorisée par la loi en vigueur.
Elle s’applique également, même si Microsoft connaissait ou devrait connaître l’éventualité d’un tel dommage. Si votre pays n’autorise pas l’exclusion ou la limitation de responsabilité pour les dommages indirects, accessoires ou de quelque nature que ce soit, il se peut que la limitation ou l’exclusion ci-dessus ne s’appliquera pas à votre égard.
EFFET JURIDIQUE. Le présent contrat décrit certains droits juridiques. Vous pourriez avoir d’autres droits prévus par les lois de votre pays. Le présent contrat ne modifie pas les droits que vous confèrent les lois de votre pays si celles-ci ne le permettent pas.
*/

var commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function getAugmentedNamespace(r) {
  var t, n;
  return r.__esModule ? r : ("function" == typeof (t = r.default) ? (n = function e() {
    return this instanceof e ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
  }).prototype = t.prototype : n = {}, Object.defineProperty(n, "__esModule", {
    value: !0
  }), Object.keys(r).forEach(function (e) {
    var t = Object.getOwnPropertyDescriptor(r, e);
    Object.defineProperty(n, e, t.get ? t : {
      enumerable: !0,
      get: function () {
        return r[e];
      }
    });
  }), n);
}
var ControlPosition,
  ControlStyle,
  azuremapsMaplibreGlDev = {
    exports: {}
  },
  azuremapsMaplibreGlDevExports = (!function () {
    var e;
    e = function () {
      var i, o, a;
      function e(e, t) {
        var r, n;
        i ? o ? (r = "var sharedChunk = {}; (" + i + ")(sharedChunk); (" + o + ")(sharedChunk);", i(n = {}), a = t(n), "undefined" != typeof window && (a.workerUrl = window.URL.createObjectURL(new Blob([r], {
          type: "text/javascript"
        })))) : o = t : i = t;
      }
      return e(0, function (ue) {
        function A(e, a, s, l) {
          return new (s = s || Promise)(function (r, t) {
            function n(e) {
              try {
                o(l.next(e));
              } catch (e) {
                t(e);
              }
            }
            function i(e) {
              try {
                o(l.throw(e));
              } catch (e) {
                t(e);
              }
            }
            function o(e) {
              var t;
              e.done ? r(e.value) : ((t = e.value) instanceof s ? t : new s(function (e) {
                e(t);
              })).then(n, i);
            }
            o((l = l.apply(e, a || [])).next());
          });
        }
        function I(e) {
          return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
        }
        var P = D;
        function D(e, t) {
          this.x = e, this.y = t;
        }
        D.prototype = {
          clone: function () {
            return new D(this.x, this.y);
          },
          add: function (e) {
            return this.clone()._add(e);
          },
          sub: function (e) {
            return this.clone()._sub(e);
          },
          multByPoint: function (e) {
            return this.clone()._multByPoint(e);
          },
          divByPoint: function (e) {
            return this.clone()._divByPoint(e);
          },
          mult: function (e) {
            return this.clone()._mult(e);
          },
          div: function (e) {
            return this.clone()._div(e);
          },
          rotate: function (e) {
            return this.clone()._rotate(e);
          },
          rotateAround: function (e, t) {
            return this.clone()._rotateAround(e, t);
          },
          matMult: function (e) {
            return this.clone()._matMult(e);
          },
          unit: function () {
            return this.clone()._unit();
          },
          perp: function () {
            return this.clone()._perp();
          },
          round: function () {
            return this.clone()._round();
          },
          mag: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          },
          equals: function (e) {
            return this.x === e.x && this.y === e.y;
          },
          dist: function (e) {
            return Math.sqrt(this.distSqr(e));
          },
          distSqr: function (e) {
            var t = e.x - this.x,
              e = e.y - this.y;
            return t * t + e * e;
          },
          angle: function () {
            return Math.atan2(this.y, this.x);
          },
          angleTo: function (e) {
            return Math.atan2(this.y - e.y, this.x - e.x);
          },
          angleWith: function (e) {
            return this.angleWithSep(e.x, e.y);
          },
          angleWithSep: function (e, t) {
            return Math.atan2(this.x * t - this.y * e, this.x * e + this.y * t);
          },
          _matMult: function (e) {
            var t = e[0] * this.x + e[1] * this.y,
              e = e[2] * this.x + e[3] * this.y;
            return this.x = t, this.y = e, this;
          },
          _add: function (e) {
            return this.x += e.x, this.y += e.y, this;
          },
          _sub: function (e) {
            return this.x -= e.x, this.y -= e.y, this;
          },
          _mult: function (e) {
            return this.x *= e, this.y *= e, this;
          },
          _div: function (e) {
            return this.x /= e, this.y /= e, this;
          },
          _multByPoint: function (e) {
            return this.x *= e.x, this.y *= e.y, this;
          },
          _divByPoint: function (e) {
            return this.x /= e.x, this.y /= e.y, this;
          },
          _unit: function () {
            return this._div(this.mag()), this;
          },
          _perp: function () {
            var e = this.y;
            return this.y = this.x, this.x = -e, this;
          },
          _rotate: function (e) {
            var t = Math.cos(e),
              e = Math.sin(e),
              r = t * this.x - e * this.y,
              e = e * this.x + t * this.y;
            return this.x = r, this.y = e, this;
          },
          _rotateAround: function (e, t) {
            var r = Math.cos(e),
              e = Math.sin(e),
              n = t.x + r * (this.x - t.x) - e * (this.y - t.y),
              e = t.y + e * (this.x - t.x) + r * (this.y - t.y);
            return this.x = n, this.y = e, this;
          },
          _round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          }
        }, D.convert = function (e) {
          return !(e instanceof D) && Array.isArray(e) ? new D(e[0], e[1]) : e;
        };
        var F = I(P),
          O = M;
        function M(e, t, r, n) {
          this.cx = 3 * e, this.bx = 3 * (r - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (n - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = r, this.p2y = n;
        }
        M.prototype = {
          sampleCurveX: function (e) {
            return ((this.ax * e + this.bx) * e + this.cx) * e;
          },
          sampleCurveY: function (e) {
            return ((this.ay * e + this.by) * e + this.cy) * e;
          },
          sampleCurveDerivativeX: function (e) {
            return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
          },
          solveCurveX: function (e, t) {
            if (void 0 === t && (t = 1e-6), e < 0) return 0;
            if (1 < e) return 1;
            for (var r = e, n = 0; n < 8; n++) {
              var i = this.sampleCurveX(r) - e;
              if (Math.abs(i) < t) return r;
              var o = this.sampleCurveDerivativeX(r);
              if (Math.abs(o) < 1e-6) break;
              r -= i / o;
            }
            for (var a = 0, s = 1, r = e, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - e) < t)); n++) i < e ? a = r : s = r, r = .5 * (s - a) + a;
            return r;
          },
          solve: function (e, t) {
            return this.sampleCurveY(this.solveCurveX(e, t));
          }
        };
        var k = I(O);
        let L;
        function U() {
          return L = null == L ? "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap : L;
        }
        let B;
        function $() {
          if (null == B && (B = !1, U())) {
            var t = new OffscreenCanvas(5, 5).getContext("2d", {
              willReadFrequently: !0
            });
            if (t) {
              for (let e = 0; e < 25; e++) {
                var r = 4 * e;
                t.fillStyle = `rgb(${r},${1 + r},${2 + r})`, t.fillRect(e % 5, Math.floor(e / 5), 1, 1);
              }
              var n = t.getImageData(0, 0, 5, 5).data;
              for (let e = 0; e < 100; e++) if (e % 4 != 3 && n[e] !== e) {
                B = !0;
                break;
              }
            }
          }
          return B || !1;
        }
        function z(e) {
          var t, r;
          return e <= 0 ? 0 : 1 <= e ? 1 : (r = (t = e * e) * e, 4 * (e < .5 ? r : 3 * (e - t) + r - .75));
        }
        function Y(e, t, r, n) {
          const i = new k(e, t, r, n);
          return function (e) {
            return i.solve(e);
          };
        }
        O = Y(.25, .1, .25, 1);
        function H(e, t, r) {
          return Math.min(r, Math.max(t, e));
        }
        function j(e, t, r) {
          var n = r - t,
            e = ((e - t) % n + n) % n + t;
          return e === t ? r : e;
        }
        function G(e, ...t) {
          for (const r of t) for (const n in r) e[n] = r[n];
          return e;
        }
        let q = 1;
        function V(e, t, r) {
          var n = {};
          for (const i in e) n[i] = t.call(r || this, e[i], i, e);
          return n;
        }
        function K(e, t, r) {
          var n = {};
          for (const i in e) t.call(r || this, e[i], i, e) && (n[i] = e[i]);
          return n;
        }
        function W(e) {
          return Array.isArray(e) ? e.map(W) : "object" == typeof e && e ? V(e, W) : e;
        }
        function Z(t, r) {
          for (let e = 0; e < t.length; e++) if (0 <= r.indexOf(t[e])) return 1;
        }
        const X = {};
        function he(e) {
          X[e] || ("undefined" != typeof console && console.warn(e), X[e] = !0);
        }
        function J(e, t, r) {
          return (r.y - e.y) * (t.x - e.x) > (t.y - e.y) * (r.x - e.x);
        }
        function Q() {
          return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        let ee = null;
        function te(e) {
          return "undefined" != typeof ImageBitmap && e instanceof ImageBitmap;
        }
        const re = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function oe(f, _, m, g, y) {
          return A(this, void 0, void 0, function* () {
            if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported");
            var e,
              t,
              r,
              n,
              i,
              o,
              a,
              s,
              l,
              c = new VideoFrame(f, {
                timestamp: 0
              });
            try {
              var u = null == c ? void 0 : c.format;
              if (!u || !u.startsWith("BGR") && !u.startsWith("RGB")) throw new Error("Unrecognized format " + u);
              var h = u.startsWith("BGR"),
                d = new Uint8ClampedArray(g * y * 4);
              if (yield c.copyTo(d, (e = f, t = _, r = m, n = g, i = y, o = 4 * Math.max(-t, 0), o = (Math.max(0, r) - r) * n * 4 + o, a = 4 * n, s = Math.max(0, t), l = Math.max(0, r), {
                rect: {
                  x: s,
                  y: l,
                  width: Math.min(e.width, t + n) - s,
                  height: Math.min(e.height, r + i) - l
                },
                layout: [{
                  offset: o,
                  stride: a
                }]
              })), h) for (let e = 0; e < d.length; e += 4) {
                var p = d[e];
                d[e] = d[e + 2], d[e + 2] = p;
              }
              return d;
            } finally {
              c.close();
            }
          });
        }
        let ae, se;
        var le = "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date);
        let ce, fe;
        const _e = {
            now: le,
            frame(e) {
              const t = requestAnimationFrame(e);
              return {
                cancel: () => cancelAnimationFrame(t)
              };
            },
            getImageData(e, t = 0) {
              return this.getImageCanvasContext(e).getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t);
            },
            getImageCanvasContext(e) {
              var t = window.document.createElement("canvas"),
                r = t.getContext("2d", {
                  willReadFrequently: !0
                });
              if (r) return t.width = e.width, t.height = e.height, r.drawImage(e, 0, 0, e.width, e.height), r;
              throw new Error("failed to create canvas 2d context");
            },
            resolveURL(e) {
              return (ce = ce || document.createElement("a")).href = e, ce.href;
            },
            hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4,
            get prefersReducedMotion() {
              return !!matchMedia && (fe = null == fe ? matchMedia("(prefers-reduced-motion: reduce)") : fe).matches;
            }
          },
          me = {
            MAX_PARALLEL_IMAGE_REQUESTS: 16,
            MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
            MAX_TILE_CACHE_ZOOM_LEVELS: 5,
            REGISTERED_PROTOCOLS: {},
            WORKER_URL: ""
          };
        class ge extends Error {
          constructor(e, t, r, n) {
            super(`AJAXError: ${t} (${e}): ` + r), this.status = e, this.statusText = t, this.url = r, this.body = n;
          }
        }
        const ye = Q() ? () => self.worker && self.worker.referrer : () => ("blob:" === window.location.protocol ? window.parent : window).location.href,
          ve = e => me.REGISTERED_PROTOCOLS[e.substring(0, e.indexOf("://"))],
          Ee = e => /^file:/.test(e) || /^file:/.test(ye()) && !/^\w+:/.test(e);
        function be(n, i) {
          const e = new AbortController(),
            o = new Request(n.url, {
              method: n.method || "GET",
              body: n.body,
              credentials: n.credentials,
              headers: n.headers,
              cache: n.cache,
              referrer: ye(),
              signal: e.signal
            });
          let r = !1,
            a = !1;
          "json" === n.type && o.headers.set("Accept", "application/json");
          const s = t => {
            ("arrayBuffer" === n.type || "image" === n.type ? t.arrayBuffer() : "json" === n.type ? t.json() : t.text()).then(e => {
              a || (r = !0, i(null, e, t.headers.get("Cache-Control"), t.headers.get("Expires")));
            }).catch(e => {
              a || i(new Error(e.message));
            });
          };
          return ((e, t, r) => {
            if (!a) {
              fetch(o).then(t => t.ok ? s(t) : t.blob().then(e => i(new ge(t.status, t.statusText, n.url, e)))).catch(e => {
                20 !== e.code && i(new Error(e.message));
              });
            }
          })(), {
            cancel: () => {
              a = !0, r || e.abort();
            }
          };
        }
        function we(e, t) {
          if (/:\/\//.test(e.url) && !/^https?:|^file:/.test(e.url)) {
            if (Q() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", e, t);
            if (!Q()) return (ve(e.url) || be)(e, t);
          }
          if (!Ee(e.url)) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return be(e, t);
            if (Q() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", e, t, void 0, !0);
          }
          {
            var r = e,
              n = t;
            const i = new XMLHttpRequest();
            i.open(r.method || "GET", r.url, !0), "arrayBuffer" !== r.type && "image" !== r.type || (i.responseType = "arraybuffer");
            for (const o in r.headers) i.setRequestHeader(o, r.headers[o]);
            return "json" === r.type && (i.responseType = "text", i.setRequestHeader("Accept", "application/json")), i.withCredentials = "include" === r.credentials, i.onerror = () => {
              n(new Error(i.statusText));
            }, i.onload = () => {
              if ((200 <= i.status && i.status < 300 || 0 === i.status) && null !== i.response) {
                let e = i.response;
                if ("json" === r.type) try {
                  e = JSON.parse(i.response);
                } catch (e) {
                  return n(e);
                }
                n(null, e, i.getResponseHeader("Cache-Control"), i.getResponseHeader("Expires"));
              } else {
                var e = new Blob([i.response], {
                  type: i.getResponseHeader("Content-Type")
                });
                n(new ge(i.status, i.statusText, r.url, e));
              }
            }, i.send(r.body), {
              cancel: () => i.abort()
            };
          }
        }
        const Te = function (e, t) {
          return we(G(e, {
            type: "arrayBuffer"
          }), t);
        };
        function Se(e) {
          var t;
          return !e || e.indexOf("://") <= 0 || 0 === e.indexOf("data:image/") || 0 === e.indexOf("blob:") || (e = new URL(e), t = window.location, e.protocol === t.protocol && e.host === t.host);
        }
        function xe(e, t, r) {
          r[e] && -1 !== r[e].indexOf(t) || (r[e] = r[e] || [], r[e].push(t));
        }
        function Ce(e, t, r) {
          r && r[e] && -1 !== (t = r[e].indexOf(t)) && r[e].splice(t, 1);
        }
        class Ae {
          constructor(e, t = {}) {
            G(this, t), this.type = e;
          }
        }
        class Ie extends Ae {
          constructor(e, t = {}) {
            super("error", G({
              error: e
            }, t));
          }
        }
        class Ne {
          on(e, t) {
            return this._listeners = this._listeners || {}, xe(e, t, this._listeners), this;
          }
          off(e, t) {
            return Ce(e, t, this._listeners), Ce(e, t, this._oneTimeListeners), this;
          }
          once(t, e) {
            return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, xe(t, e, this._oneTimeListeners), this) : new Promise(e => this.once(t, e));
          }
          fire(e, t) {
            var r = (e = "string" == typeof e ? new Ae(e, t || {}) : e).type;
            if (this.listens(r)) {
              for (const n of (e.target = this)._listeners && this._listeners[r] ? this._listeners[r].slice() : []) n.call(this, e);
              for (const i of this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : []) Ce(r, i, this._oneTimeListeners), i.call(this, e);
              t = this._eventedParent;
              t && (G(e, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), t.fire(e));
            } else e instanceof Ie && console.error(e.error);
            return this;
          }
          listens(e) {
            return this._listeners && this._listeners[e] && 0 < this._listeners[e].length || this._oneTimeListeners && this._oneTimeListeners[e] && 0 < this._oneTimeListeners[e].length || this._eventedParent && this._eventedParent.listens(e);
          }
          setEventedParent(e, t) {
            return this._eventedParent = e, this._eventedParentData = t, this;
          }
        }
        var o = {
          $version: 8,
          $root: {
            version: {
              required: !0,
              type: "enum",
              values: [8]
            },
            name: {
              type: "string"
            },
            metadata: {
              type: "*"
            },
            center: {
              type: "array",
              value: "number"
            },
            zoom: {
              type: "number"
            },
            bearing: {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees"
            },
            pitch: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            light: {
              type: "light"
            },
            terrain: {
              type: "terrain"
            },
            sources: {
              required: !0,
              type: "sources"
            },
            sprite: {
              type: "sprite"
            },
            glyphs: {
              type: "string"
            },
            transition: {
              type: "transition"
            },
            layers: {
              required: !0,
              type: "array",
              value: "layer"
            }
          },
          sources: {
            "*": {
              type: "source"
            }
          },
          source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
          source_vector: {
            type: {
              required: !0,
              type: "enum",
              values: {
                vector: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            attribution: {
              type: "string"
            },
            promoteId: {
              type: "promoteId"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster: {
            type: {
              required: !0,
              type: "enum",
              values: {
                raster: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            attribution: {
              type: "string"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster_dem: {
            type: {
              required: !0,
              type: "enum",
              values: {
                "raster-dem": {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            attribution: {
              type: "string"
            },
            encoding: {
              type: "enum",
              values: {
                terrarium: {},
                mapbox: {},
                custom: {}
              },
              default: "mapbox"
            },
            redFactor: {
              type: "number",
              default: 1
            },
            blueFactor: {
              type: "number",
              default: 1
            },
            greenFactor: {
              type: "number",
              default: 1
            },
            baseShift: {
              type: "number",
              default: 0
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_geojson: {
            type: {
              required: !0,
              type: "enum",
              values: {
                geojson: {}
              }
            },
            data: {
              required: !0,
              type: "*"
            },
            maxzoom: {
              type: "number",
              default: 18
            },
            attribution: {
              type: "string"
            },
            buffer: {
              type: "number",
              default: 128,
              maximum: 512,
              minimum: 0
            },
            filter: {
              type: "*"
            },
            tolerance: {
              type: "number",
              default: .375
            },
            cluster: {
              type: "boolean",
              default: !1
            },
            clusterRadius: {
              type: "number",
              default: 50,
              minimum: 0
            },
            clusterMaxZoom: {
              type: "number"
            },
            clusterMinPoints: {
              type: "number"
            },
            clusterProperties: {
              type: "*"
            },
            lineMetrics: {
              type: "boolean",
              default: !1
            },
            generateId: {
              type: "boolean",
              default: !1
            },
            promoteId: {
              type: "promoteId"
            }
          },
          source_video: {
            type: {
              required: !0,
              type: "enum",
              values: {
                video: {}
              }
            },
            urls: {
              required: !0,
              type: "array",
              value: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          source_image: {
            type: {
              required: !0,
              type: "enum",
              values: {
                image: {}
              }
            },
            url: {
              required: !0,
              type: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          layer: {
            id: {
              type: "string",
              required: !0
            },
            type: {
              type: "enum",
              values: {
                fill: {},
                line: {},
                symbol: {},
                circle: {},
                heatmap: {},
                "fill-extrusion": {},
                raster: {},
                hillshade: {},
                background: {}
              },
              required: !0
            },
            metadata: {
              type: "*"
            },
            source: {
              type: "string"
            },
            "source-layer": {
              type: "string"
            },
            minzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            maxzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            filter: {
              type: "filter"
            },
            layout: {
              type: "layout"
            },
            paint: {
              type: "paint"
            }
          },
          layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"],
          layout_background: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_fill: {
            "fill-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_circle: {
            "circle-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_heatmap: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_fill-extrusion": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_line: {
            "line-cap": {
              type: "enum",
              values: {
                butt: {},
                round: {},
                square: {}
              },
              default: "butt",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-join": {
              type: "enum",
              values: {
                bevel: {},
                round: {},
                miter: {}
              },
              default: "miter",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "line-miter-limit": {
              type: "number",
              default: 2,
              requires: [{
                "line-join": "miter"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-round-limit": {
              type: "number",
              default: 1.05,
              requires: [{
                "line-join": "round"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_symbol: {
            "symbol-placement": {
              type: "enum",
              values: {
                point: {},
                line: {},
                "line-center": {}
              },
              default: "point",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-spacing": {
              type: "number",
              default: 250,
              minimum: 1,
              units: "pixels",
              requires: [{
                "symbol-placement": "line"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-avoid-edges": {
              type: "boolean",
              default: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "symbol-z-order": {
              type: "enum",
              values: {
                auto: {},
                "viewport-y": {},
                source: {}
              },
              default: "auto",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "!": "icon-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-optional": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-size": {
              type: "number",
              default: 1,
              minimum: 0,
              units: "factor of the original icon size",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-text-fit": {
              type: "enum",
              values: {
                none: {},
                width: {},
                height: {},
                both: {}
              },
              default: "none",
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-text-fit-padding": {
              type: "array",
              value: "number",
              length: 4,
              default: [0, 0, 0, 0],
              units: "pixels",
              requires: ["icon-image", "text-field", {
                "icon-text-fit": ["both", "width", "height"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-image": {
              type: "resolvedImage",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-padding": {
              type: "padding",
              default: [2],
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-keep-upright": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "icon-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-offset": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                "viewport-glyph": {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-field": {
              type: "formatted",
              default: "",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-font": {
              type: "array",
              value: "string",
              default: ["Open Sans Regular", "Arial Unicode MS Regular"],
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-size": {
              type: "number",
              default: 16,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-width": {
              type: "number",
              default: 10,
              minimum: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-line-height": {
              type: "number",
              default: 1.2,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-letter-spacing": {
              type: "number",
              default: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-justify": {
              type: "enum",
              values: {
                auto: {},
                left: {},
                center: {},
                right: {}
              },
              default: "center",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-radial-offset": {
              type: "number",
              units: "ems",
              default: 0,
              requires: ["text-field"],
              "property-type": "data-driven",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              }
            },
            "text-variable-anchor": {
              type: "array",
              value: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-variable-anchor-offset": {
              type: "variableAnchorOffsetCollection",
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["text-field", {
                "!": "text-variable-anchor"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-angle": {
              type: "number",
              default: 45,
              units: "degrees",
              requires: ["text-field", {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-writing-mode": {
              type: "array",
              value: "enum",
              values: {
                horizontal: {},
                vertical: {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-padding": {
              type: "number",
              default: 2,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-keep-upright": {
              type: "boolean",
              default: !0,
              requires: ["text-field", {
                "text-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-transform": {
              type: "enum",
              values: {
                none: {},
                uppercase: {},
                lowercase: {}
              },
              default: "none",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-offset": {
              type: "array",
              value: "number",
              units: "ems",
              length: 2,
              default: [0, 0],
              requires: ["text-field", {
                "!": "text-radial-offset"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["text-field", {
                "!": "text-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-optional": {
              type: "boolean",
              default: !1,
              requires: ["text-field", "icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_raster: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_hillshade: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          filter: {
            type: "array",
            value: "*"
          },
          filter_operator: {
            type: "enum",
            values: {
              "==": {},
              "!=": {},
              ">": {},
              ">=": {},
              "<": {},
              "<=": {},
              in: {},
              "!in": {},
              all: {},
              any: {},
              none: {},
              has: {},
              "!has": {},
              within: {}
            }
          },
          geometry_type: {
            type: "enum",
            values: {
              Point: {},
              LineString: {},
              Polygon: {}
            }
          },
          function: {
            expression: {
              type: "expression"
            },
            stops: {
              type: "array",
              value: "function_stop"
            },
            base: {
              type: "number",
              default: 1,
              minimum: 0
            },
            property: {
              type: "string",
              default: "$zoom"
            },
            type: {
              type: "enum",
              values: {
                identity: {},
                exponential: {},
                interval: {},
                categorical: {}
              },
              default: "exponential"
            },
            colorSpace: {
              type: "enum",
              values: {
                rgb: {},
                lab: {},
                hcl: {}
              },
              default: "rgb"
            },
            default: {
              type: "*",
              required: !1
            }
          },
          function_stop: {
            type: "array",
            minimum: 0,
            maximum: 24,
            value: ["number", "color"],
            length: 2
          },
          expression: {
            type: "array",
            value: "*",
            minimum: 1
          },
          light: {
            anchor: {
              type: "enum",
              default: "viewport",
              values: {
                map: {},
                viewport: {}
              },
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              }
            },
            position: {
              type: "array",
              default: [1.15, 210, 30],
              length: 3,
              value: "number",
              "property-type": "data-constant",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            },
            color: {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            intensity: {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          terrain: {
            source: {
              type: "string",
              required: !0
            },
            exaggeration: {
              type: "number",
              minimum: 0,
              default: 1
            }
          },
          paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"],
          paint_fill: {
            "fill-antialias": {
              type: "boolean",
              default: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-outline-color": {
              type: "color",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }, {
                "fill-antialias": !0
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            }
          },
          "paint_fill-extrusion": {
            "fill-extrusion-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-extrusion-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-extrusion-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "fill-extrusion-height": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-base": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              requires: ["fill-extrusion-height"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-vertical-gradient": {
              type: "boolean",
              default: !0,
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_line: {
            "line-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["line-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-width": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-gap-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-offset": {
              type: "number",
              default: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-dasharray": {
              type: "array",
              value: "number",
              minimum: 0,
              transition: !0,
              units: "line widths",
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "line-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-gradient": {
              type: "color",
              transition: !1,
              requires: [{
                "!": "line-dasharray"
              }, {
                "!": "line-pattern"
              }, {
                source: "geojson",
                has: {
                  lineMetrics: !0
                }
              }],
              expression: {
                interpolated: !0,
                parameters: ["line-progress"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_circle: {
            "circle-radius": {
              type: "number",
              default: 5,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-blur": {
              type: "number",
              default: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["circle-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-scale": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-stroke-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            }
          },
          paint_heatmap: {
            "heatmap-radius": {
              type: "number",
              default: 30,
              minimum: 1,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-weight": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-intensity": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "heatmap-color": {
              type: "color",
              default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"],
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["heatmap-density"]
              },
              "property-type": "color-ramp"
            },
            "heatmap-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_symbol: {
            "icon-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["icon-image", "icon-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              overridable: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["text-field", "text-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_raster: {
            "raster-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-hue-rotate": {
              type: "number",
              default: 0,
              period: 360,
              transition: !0,
              units: "degrees",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-min": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-max": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-saturation": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-contrast": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-resampling": {
              type: "enum",
              values: {
                linear: {},
                nearest: {}
              },
              default: "linear",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-fade-duration": {
              type: "number",
              default: 300,
              minimum: 0,
              transition: !1,
              units: "milliseconds",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_hillshade: {
            "hillshade-illumination-direction": {
              type: "number",
              default: 335,
              minimum: 0,
              maximum: 359,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-exaggeration": {
              type: "number",
              default: .5,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-shadow-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-highlight-color": {
              type: "color",
              default: "#FFFFFF",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-accent-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_background: {
            "background-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "background-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "background-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "background-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          transition: {
            duration: {
              type: "number",
              default: 300,
              minimum: 0,
              units: "milliseconds"
            },
            delay: {
              type: "number",
              default: 0,
              minimum: 0,
              units: "milliseconds"
            }
          },
          "property-type": {
            "data-driven": {
              type: "property-type"
            },
            "cross-faded": {
              type: "property-type"
            },
            "cross-faded-data-driven": {
              type: "property-type"
            },
            "color-ramp": {
              type: "property-type"
            },
            "data-constant": {
              type: "property-type"
            },
            constant: {
              type: "property-type"
            }
          },
          promoteId: {
            "*": {
              type: "string"
            }
          }
        };
        const Pe = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function v(t, r) {
          if (Array.isArray(t)) {
            if (!Array.isArray(r) || t.length !== r.length) return;
            for (let e = 0; e < t.length; e++) if (!v(t[e], r[e])) return;
            return 1;
          }
          if ("object" != typeof t || null === t || null === r) return t === r;
          if ("object" == typeof r && Object.keys(t).length === Object.keys(r).length) {
            for (const e in t) if (!v(t[e], r[e])) return;
            return 1;
          }
        }
        const E = {
          setStyle: "setStyle",
          addLayer: "addLayer",
          removeLayer: "removeLayer",
          setPaintProperty: "setPaintProperty",
          setLayoutProperty: "setLayoutProperty",
          setFilter: "setFilter",
          addSource: "addSource",
          removeSource: "removeSource",
          setGeoJSONSourceData: "setGeoJSONSourceData",
          setLayerZoomRange: "setLayerZoomRange",
          setLayerProperty: "setLayerProperty",
          setCenter: "setCenter",
          setZoom: "setZoom",
          setBearing: "setBearing",
          setPitch: "setPitch",
          setSprite: "setSprite",
          setGlyphs: "setGlyphs",
          setTransition: "setTransition",
          setLight: "setLight"
        };
        function De(e, t, r) {
          r.push({
            command: E.addSource,
            args: [e, t[e]]
          });
        }
        function Re(e, t, r) {
          t.push({
            command: E.removeSource,
            args: [e]
          }), r[e] = !0;
        }
        function Oe(e, t, r, n) {
          t = t || {};
          let i;
          for (i in e = e || {}) !Object.prototype.hasOwnProperty.call(e, i) || Object.prototype.hasOwnProperty.call(t, i) || Re(i, r, n);
          for (i in t) Object.prototype.hasOwnProperty.call(t, i) && (Object.prototype.hasOwnProperty.call(e, i) ? v(e[i], t[i]) || ("geojson" === e[i].type && "geojson" === t[i].type && function (e, t, r) {
            let n;
            for (n in e[r]) if (Object.prototype.hasOwnProperty.call(e[r], n) && "data" !== n && !v(e[r][n], t[r][n])) return;
            for (n in t[r]) if (Object.prototype.hasOwnProperty.call(t[r], n) && "data" !== n && !v(e[r][n], t[r][n])) return;
            return 1;
          }(e, t, i) ? r.push({
            command: E.setGeoJSONSourceData,
            args: [i, t[i].data]
          }) : (o = i, a = t, Re(o, s = r, n), De(o, a, s))) : De(i, t, r));
          var o, a, s;
        }
        function Me(e, t, r, n, i, o) {
          t = t || {};
          let a;
          for (a in e = e || {}) !Object.prototype.hasOwnProperty.call(e, a) || v(e[a], t[a]) || r.push({
            command: o,
            args: [n, a, t[a], i]
          });
          for (a in t) !Object.prototype.hasOwnProperty.call(t, a) || Object.prototype.hasOwnProperty.call(e, a) || v(e[a], t[a]) || r.push({
            command: o,
            args: [n, a, t[a], i]
          });
        }
        function ke(e) {
          return e.id;
        }
        function Le(e, t) {
          return e[t.id] = t, e;
        }
        class p {
          constructor(e, t, r, n) {
            this.message = (e ? e + ": " : "") + r, n && (this.identifier = n), null != t && t.__line__ && (this.line = t.__line__);
          }
        }
        function Ue(e, ...t) {
          for (const r of t) for (const n in r) e[n] = r[n];
          return e;
        }
        class Fe extends Error {
          constructor(e, t) {
            super(t), this.message = t, this.key = e;
          }
        }
        class Be {
          constructor(e, t = []) {
            this.parent = e, this.bindings = {};
            for (var [r, n] of t) this.bindings[r] = n;
          }
          concat(e) {
            return new Be(this, e);
          }
          get(e) {
            if (this.bindings[e]) return this.bindings[e];
            if (this.parent) return this.parent.get(e);
            throw new Error(e + " not found in scope.");
          }
          has(e) {
            return !!this.bindings[e] || !!this.parent && this.parent.has(e);
          }
        }
        const $e = {
            kind: "null"
          },
          f = {
            kind: "number"
          },
          s = {
            kind: "string"
          },
          u = {
            kind: "boolean"
          },
          ze = {
            kind: "color"
          },
          Ye = {
            kind: "object"
          },
          h = {
            kind: "value"
          };
        const He = {
            kind: "collator"
          },
          je = {
            kind: "formatted"
          },
          Ge = {
            kind: "padding"
          },
          qe = {
            kind: "resolvedImage"
          },
          Ve = {
            kind: "variableAnchorOffsetCollection"
          };
        function Ke(e, t) {
          return {
            kind: "array",
            itemType: e,
            N: t
          };
        }
        function m(e) {
          var t;
          return "array" === e.kind ? (t = m(e.itemType), "number" == typeof e.N ? `array<${t}, ${e.N}>` : "value" === e.itemType.kind ? "array" : `array<${t}>`) : e.kind;
        }
        const We = [$e, f, s, u, ze, je, Ye, Ke(h), Ge, qe, Ve];
        function Ze(e, t) {
          if ("error" === t.kind) return null;
          if ("array" === e.kind) {
            if ("array" === t.kind && (0 === t.N && "value" === t.itemType.kind || !Ze(e.itemType, t.itemType)) && ("number" != typeof e.N || e.N === t.N)) return null;
          } else {
            if (e.kind === t.kind) return null;
            if ("value" === e.kind) for (const r of We) if (!Ze(r, t)) return null;
          }
          return `Expected ${m(e)} but found ${m(t)} instead.`;
        }
        function Xe(t, e) {
          return e.some(e => e.kind === t.kind);
        }
        function Je(t, e) {
          return e.some(e => "null" === e ? null === t : "array" === e ? Array.isArray(t) : "object" === e ? t && !Array.isArray(t) && "object" == typeof t : e === typeof t);
        }
        function Qe(e, t) {
          return "array" === e.kind && "array" === t.kind ? e.itemType.kind === t.itemType.kind && "number" == typeof e.N : e.kind === t.kind;
        }
        const et = .96422,
          tt = 1,
          rt = .82521,
          nt = 4 / 29,
          it = 6 / 29,
          ot = 3 * it * it,
          at = it * it * it,
          st = Math.PI / 180,
          lt = 180 / Math.PI;
        function ct(e) {
          return (e %= 360) < 0 && (e += 360), e;
        }
        function ut([e, t, r, n]) {
          let i, o;
          var a = dt((.2225045 * (e = ht(e)) + .7168786 * (t = ht(t)) + .0606169 * (r = ht(r))) / tt),
            e = (e === t && t === r ? i = o = a : (i = dt((.4360747 * e + .3850649 * t + .1430804 * r) / et), o = dt((.0139322 * e + .0971045 * t + .7141733 * r) / rt)), 116 * a - 16);
          return [e < 0 ? 0 : e, 500 * (i - a), 200 * (a - o), n];
        }
        function ht(e) {
          return e <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);
        }
        function dt(e) {
          return e > at ? Math.pow(e, 1 / 3) : e / ot + nt;
        }
        function pt([e, t, r, n]) {
          e = (e + 16) / 116, t = isNaN(t) ? e : e + t / 500, r = isNaN(r) ? e : e - r / 200, e = tt * _t(e);
          return [ft(3.1338561 * (t = et * _t(t)) - 1.6168667 * e - .4906146 * (r = rt * _t(r))), ft(-.9787684 * t + 1.9161415 * e + .033454 * r), ft(.0719453 * t - .2289914 * e + 1.4052427 * r), n];
        }
        function ft(e) {
          return (e = e <= .00304 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055) < 0 ? 0 : 1 < e ? 1 : e;
        }
        function _t(e) {
          return e > it ? e * e * e : ot * (e - nt);
        }
        function mt(e) {
          var [e, t, r, n] = ut(e),
            i = Math.sqrt(t * t + r * r);
          return [Math.round(1e4 * i) ? ct(Math.atan2(r, t) * lt) : NaN, i, e, n];
        }
        function gt(e) {
          if ("transparent" === (e = e.toLowerCase().trim())) return [0, 0, 0, 0];
          var t = wt[e];
          if (t) return [t, n, r] = t, [t / 255, n / 255, r / 255, 1];
          if (e.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(e)) return t = e.length < 6 ? 1 : 2, [yt(e.slice(n = 1, n += t)), yt(e.slice(n, n += t)), yt(e.slice(n, n += t)), yt(e.slice(n, n + t) || "ff")];
          if (e.startsWith("rgb")) {
            var r = e.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (r) {
              var [, n, t, r, i, o, a, s, l, c, u, h] = r,
                r = [r || " ", a || " ", c].join("");
              if ("  " === r || "  /" === r || ",," === r || ",,," === r) {
                a = [t, o, l].join(""), c = "%%%" === a ? 100 : "" === a ? 255 : 0;
                if (c) {
                  r = [Et(+n / c, 0, 1), Et(+i / c, 0, 1), Et(+s / c, 0, 1), u ? vt(+u, h) : 1];
                  if (bt(r)) return r;
                }
              }
              return;
            }
          }
          var d,
            p,
            f,
            t = e.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
          if (t) {
            var [, o, l, a, n, i, s, c, u] = t,
              h = [l || " ", n || " ", s].join("");
            if ("  " === h || "  /" === h || ",," === h || ",,," === h) {
              r = [+o, Et(+a, 0, 100), Et(+i, 0, 100), c ? vt(+c, u) : 1];
              if (bt(r)) return [d, p, f, e] = [r][0], d = ct(d), p /= 100, f /= 100, [_(0), _(8), _(4), e];
            }
          }
          function _(e) {
            var e = (e + d / 30) % 12,
              t = p * Math.min(f, 1 - f);
            return f - t * Math.max(-1, Math.min(e - 3, 9 - e, 1));
          }
        }
        function yt(e) {
          return parseInt(e.padEnd(2, e), 16) / 255;
        }
        function vt(e, t) {
          return Et(t ? e / 100 : e, 0, 1);
        }
        function Et(e, t, r) {
          return Math.min(Math.max(t, e), r);
        }
        function bt(e) {
          return !e.some(Number.isNaN);
        }
        const wt = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        };
        class g {
          constructor(e, t, r, n = 1, i = !0) {
            this.r = e, this.g = t, this.b = r, this.a = n, i || (this.r *= n, this.g *= n, this.b *= n, n) || this.overwriteGetter("rgb", [e, t, r, n]);
          }
          static parse(e) {
            return e instanceof g ? e : "string" == typeof e && (e = gt(e)) ? new g(...e, !1) : void 0;
          }
          get rgb() {
            var {
                r: e,
                g: t,
                b: r,
                a: n
              } = this,
              i = n || 1 / 0;
            return this.overwriteGetter("rgb", [e / i, t / i, r / i, n]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", mt(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", ut(this.rgb));
          }
          overwriteGetter(e, t) {
            return Object.defineProperty(this, e, {
              value: t
            }), t;
          }
          toString() {
            var [e, t, r, n] = this.rgb;
            return `rgba(${[e, t, r].map(e => Math.round(255 * e)).join(",")},${n})`;
          }
        }
        g.black = new g(0, 0, 0, 1), g.white = new g(1, 1, 1, 1), g.transparent = new g(0, 0, 0, 0), g.red = new g(1, 0, 0, 1);
        class Tt {
          constructor(e, t, r) {
            this.sensitivity = e ? t ? "variant" : "case" : t ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale || [], {
              sensitivity: this.sensitivity,
              usage: "search"
            });
          }
          compare(e, t) {
            return this.collator.compare(e, t);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale || []).resolvedOptions().locale;
          }
        }
        class St {
          constructor(e, t, r, n, i) {
            this.text = e, this.image = t, this.scale = r, this.fontStack = n, this.textColor = i;
          }
        }
        class xt {
          constructor(e) {
            this.sections = e;
          }
          static fromString(e) {
            return new xt([new St(e, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some(e => 0 !== e.text.length || e.image && 0 !== e.image.name.length);
          }
          static factory(e) {
            return e instanceof xt ? e : xt.fromString(e);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map(e => e.text).join("");
          }
        }
        class Ct {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(e) {
            if (e instanceof Ct) return e;
            if ("number" == typeof e) return new Ct([e, e, e, e]);
            if (Array.isArray(e) && !(e.length < 1 || 4 < e.length)) {
              for (const t of e) if ("number" != typeof t) return;
              switch (e.length) {
                case 1:
                  e = [e[0], e[0], e[0], e[0]];
                  break;
                case 2:
                  e = [e[0], e[1], e[0], e[1]];
                  break;
                case 3:
                  e = [e[0], e[1], e[2], e[1]];
              }
              return new Ct(e);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
        }
        const At = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class It {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(t) {
            if (t instanceof It) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let e = 0; e < t.length; e += 2) {
                var r = t[e],
                  n = t[e + 1];
                if ("string" != typeof r || !At.has(r)) return;
                if (!Array.isArray(n) || 2 !== n.length || "number" != typeof n[0] || "number" != typeof n[1]) return;
              }
              return new It(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
        }
        class Nt {
          constructor(e) {
            this.name = e.name, this.available = e.available;
          }
          toString() {
            return this.name;
          }
          static fromString(e) {
            return e ? new Nt({
              name: e,
              available: !1
            }) : null;
          }
        }
        function Pt(e, t, r, n) {
          return "number" == typeof e && 0 <= e && e <= 255 && "number" == typeof t && 0 <= t && t <= 255 && "number" == typeof r && 0 <= r && r <= 255 ? void 0 === n || "number" == typeof n && 0 <= n && n <= 1 ? null : `Invalid rgba value [${[e, t, r, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [e, t, r, n] : [e, t, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Dt(e) {
          if (null === e || "string" == typeof e || "boolean" == typeof e || "number" == typeof e || e instanceof g || e instanceof Tt || e instanceof xt || e instanceof Ct || e instanceof It || e instanceof Nt) return 1;
          if (Array.isArray(e)) {
            for (const t of e) if (!Dt(t)) return;
            return 1;
          }
          if ("object" == typeof e) {
            for (const r in e) if (!Dt(e[r])) return;
            return 1;
          }
        }
        function d(t) {
          if (null === t) return $e;
          if ("string" == typeof t) return s;
          if ("boolean" == typeof t) return u;
          if ("number" == typeof t) return f;
          if (t instanceof g) return ze;
          if (t instanceof Tt) return He;
          if (t instanceof xt) return je;
          if (t instanceof Ct) return Ge;
          if (t instanceof It) return Ve;
          if (t instanceof Nt) return qe;
          if (Array.isArray(t)) {
            var r = t.length;
            let e;
            for (const i of t) {
              var n = d(i);
              if (e) {
                if (e !== n) {
                  e = h;
                  break;
                }
              } else e = n;
            }
            return Ke(e || h, r);
          }
          return Ye;
        }
        function Rt(e) {
          var t = typeof e;
          return null === e ? "" : "string" == t || "number" == t || "boolean" == t ? String(e) : e instanceof g || e instanceof xt || e instanceof Ct || e instanceof It || e instanceof Nt ? e.toString() : JSON.stringify(e);
        }
        class Ot {
          constructor(e, t) {
            this.type = e, this.value = t;
          }
          static parse(e, t) {
            if (2 !== e.length) return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (!Dt(e[1])) return t.error("invalid value");
            e = e[1];
            let r = d(e);
            t = t.expectedType;
            return "array" !== r.kind || 0 !== r.N || !t || "array" !== t.kind || "number" == typeof t.N && 0 !== t.N || (r = t), new Ot(r, e);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {}
          outputDefined() {
            return !0;
          }
        }
        class _ {
          constructor(e) {
            this.name = "ExpressionEvaluationError", this.message = e;
          }
          toJSON() {
            return this.message;
          }
        }
        const Mt = {
          string: s,
          number: f,
          boolean: u,
          object: Ye
        };
        class kt {
          constructor(e, t) {
            this.type = e, this.args = t;
          }
          static parse(r, n) {
            if (r.length < 2) return n.error("Expected at least one argument.");
            let i = 1,
              o;
            var e = r[0];
            if ("array" === e) {
              let e;
              if (2 < r.length) {
                const o = r[1];
                if ("string" != typeof o || !(o in Mt) || "object" === o) return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
                e = Mt[o], i++;
              } else e = h;
              let t;
              if (3 < r.length) {
                if (null !== r[2] && ("number" != typeof r[2] || r[2] < 0 || r[2] !== Math.floor(r[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
                t = r[2], i++;
              }
              o = Ke(e, t);
            } else {
              if (!Mt[e]) throw new Error("Types doesn't contain name = " + e);
              o = Mt[e];
            }
            for (var t = []; i < r.length; i++) {
              var a = n.parse(r[i], i, h);
              if (!a) return null;
              t.push(a);
            }
            return new kt(o, t);
          }
          evaluate(t) {
            for (let e = 0; e < this.args.length; e++) {
              var r = this.args[e].evaluate(t);
              if (!Ze(this.type, d(r))) return r;
              if (e === this.args.length - 1) throw new _(`Expected value to be of type ${m(this.type)}, but found ${m(d(r))} instead.`);
            }
            throw new Error();
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every(e => e.outputDefined());
          }
        }
        const Lt = {
          "to-boolean": u,
          "to-color": ze,
          "to-number": f,
          "to-string": s
        };
        class Ut {
          constructor(e, t) {
            this.type = e, this.args = t;
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            var e = t[0];
            if (!Lt[e]) throw new Error(`Can't parse ${e} as it is not part of the known types`);
            if (("to-boolean" === e || "to-string" === e) && 2 !== t.length) return r.error("Expected one argument.");
            var e = Lt[e],
              n = [];
            for (let e = 1; e < t.length; e++) {
              var i = r.parse(t[e], e, h);
              if (!i) return null;
              n.push(i);
            }
            return new Ut(e, n);
          }
          evaluate(r) {
            switch (this.type.kind) {
              case "boolean":
                return Boolean(this.args[0].evaluate(r));
              case "color":
                {
                  let e, t;
                  for (const a of this.args) {
                    if (e = a.evaluate(r), t = null, e instanceof g) return e;
                    if ("string" == typeof e) {
                      var n = r.parseColor(e);
                      if (n) return n;
                    } else if (Array.isArray(e) && !(t = e.length < 3 || 4 < e.length ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : Pt(e[0], e[1], e[2], e[3]))) return new g(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);
                  }
                  throw new _(t || `Could not parse color from value '${"string" == typeof e ? e : JSON.stringify(e)}'`);
                }
              case "padding":
                {
                  let e;
                  for (const s of this.args) {
                    e = s.evaluate(r);
                    var t = Ct.parse(e);
                    if (t) return t;
                  }
                  throw new _(`Could not parse padding from value '${"string" == typeof e ? e : JSON.stringify(e)}'`);
                }
              case "variableAnchorOffsetCollection":
                {
                  let e;
                  for (const l of this.args) {
                    e = l.evaluate(r);
                    var i = It.parse(e);
                    if (i) return i;
                  }
                  throw new _(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e ? e : JSON.stringify(e)}'`);
                }
              case "number":
                {
                  let e = null;
                  for (const c of this.args) {
                    if (null === (e = c.evaluate(r))) return 0;
                    var o = Number(e);
                    if (!isNaN(o)) return o;
                  }
                  throw new _(`Could not convert ${JSON.stringify(e)} to number.`);
                }
              case "formatted":
                return xt.fromString(Rt(this.args[0].evaluate(r)));
              case "resolvedImage":
                return Nt.fromString(Rt(this.args[0].evaluate(r)));
              default:
                return Rt(this.args[0].evaluate(r));
            }
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every(e => e.outputDefined());
          }
        }
        const Ft = ["Unknown", "Point", "LineString", "Polygon"];
        class Bt {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? Ft[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(e) {
            let t = this._parseColorCache[e];
            return t = t || (this._parseColorCache[e] = g.parse(e));
          }
        }
        class $t {
          constructor(e, t, r = [], n, i = new Be(), o = []) {
            this.registry = e, this.path = r, this.key = r.map(e => `[${e}]`).join(""), this.scope = i, this.errors = o, this.expectedType = n, this._isConstant = t;
          }
          parse(e, t, r, n, i = {}) {
            return (t ? this.concat(t, r, n) : this)._parse(e, i);
          }
          _parse(t, r) {
            function n(e, t, r) {
              return "assert" === r ? new kt(t, [e]) : "coerce" === r ? new Ut(t, [e]) : e;
            }
            if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]), Array.isArray(t)) {
              if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              var e = t[0];
              if ("string" != typeof e) return this.error(`Expression name must be a string, but found ${typeof e} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              var i = this.registry[e];
              if (i) {
                let e = i.parse(t, this);
                if (!e) return null;
                if (this.expectedType) {
                  var i = this.expectedType,
                    o = e.type;
                  if ("string" !== i.kind && "number" !== i.kind && "boolean" !== i.kind && "object" !== i.kind && "array" !== i.kind || "value" !== o.kind) {
                    if ("color" !== i.kind && "formatted" !== i.kind && "resolvedImage" !== i.kind || "value" !== o.kind && "string" !== o.kind) {
                      if ("padding" !== i.kind || "value" !== o.kind && "number" !== o.kind && "array" !== o.kind) {
                        if ("variableAnchorOffsetCollection" !== i.kind || "value" !== o.kind && "array" !== o.kind) {
                          if (this.checkSubtype(i, o)) return null;
                        } else e = n(e, i, r.typeAnnotation || "coerce");
                      } else e = n(e, i, r.typeAnnotation || "coerce");
                    } else e = n(e, i, r.typeAnnotation || "coerce");
                  } else e = n(e, i, r.typeAnnotation || "assert");
                }
                if (!(e instanceof Ot) && "resolvedImage" !== e.type.kind && this._isConstant(e)) {
                  o = new Bt();
                  try {
                    e = new Ot(e.type, e.evaluate(o));
                  } catch (e) {
                    return this.error(e.message), null;
                  }
                }
                return e;
              }
              return this.error(`Unknown expression "${e}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return void 0 === t ? this.error("'undefined' value invalid. Use null instead.") : "object" == typeof t ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error(`Expected an array, but found ${typeof t} instead.`);
          }
          concat(e, t, r) {
            e = "number" == typeof e ? this.path.concat(e) : this.path, r = r ? this.scope.concat(r) : this.scope;
            return new $t(this.registry, this._isConstant, e, t || null, r, this.errors);
          }
          error(e, ...t) {
            t = "" + this.key + t.map(e => `[${e}]`).join("");
            this.errors.push(new Fe(t, e));
          }
          checkSubtype(e, t) {
            e = Ze(e, t);
            return e && this.error(e), e;
          }
        }
        class zt {
          constructor(e, t, r) {
            this.type = He, this.locale = r, this.caseSensitive = e, this.diacriticSensitive = t;
          }
          static parse(e, t) {
            if (2 !== e.length) return t.error("Expected one argument.");
            e = e[1];
            if ("object" != typeof e || Array.isArray(e)) return t.error("Collator options argument must be an object.");
            var r = t.parse(void 0 !== e["case-sensitive"] && e["case-sensitive"], 1, u);
            if (!r) return null;
            var n = t.parse(void 0 !== e["diacritic-sensitive"] && e["diacritic-sensitive"], 1, u);
            if (!n) return null;
            let i = null;
            return e.locale && !(i = t.parse(e.locale, 1, s)) ? null : new zt(r, n, i);
          }
          evaluate(e) {
            return new Tt(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
          }
          eachChild(e) {
            e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
          }
          outputDefined() {
            return !1;
          }
        }
        const Yt = 8192;
        function Ht(e, t) {
          e[0] = Math.min(e[0], t[0]), e[1] = Math.min(e[1], t[1]), e[2] = Math.max(e[2], t[0]), e[3] = Math.max(e[3], t[1]);
        }
        function jt(e, t) {
          return !(e[0] <= t[0] || e[2] >= t[2] || e[1] <= t[1] || e[3] >= t[3]);
        }
        function Gt(e, t) {
          var r = (180 + e[0]) / 360,
            e = (e = e[1], (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e * Math.PI / 360))) / 360),
            t = Math.pow(2, t.z);
          return [Math.round(r * t * Yt), Math.round(e * t * Yt)];
        }
        function qt(r, n) {
          let i = !1;
          for (let e = 0, t = n.length; e < t; e++) {
            var o = n[e];
            for (let e = 0, t = o.length; e < t - 1; e++) {
              if (a = r, s = o[e], l = o[e + 1], u = c = void 0, c = a[0] - s[0], s = a[1] - s[1], u = a[0] - l[0], a = a[1] - l[1], c * a - u * s == 0 && c * u <= 0 && s * a <= 0) return;
              l = r, c = o[e], u = o[e + 1], c[1] > l[1] != u[1] > l[1] && l[0] < (u[0] - c[0]) * (l[1] - c[1]) / (u[1] - c[1]) + c[0] && (i = !i);
            }
          }
          var a, s, l, c, u;
          return i;
        }
        function Vt(e, t, r, n) {
          var i = e[0] - r[0],
            e = e[1] - r[1],
            o = t[0] - r[0],
            t = t[1] - r[1],
            a = n[0] - r[0],
            n = n[1] - r[1],
            r = i * n - a * e,
            i = o * n - a * t;
          return 0 < r && i < 0 || r < 0 && 0 < i;
        }
        function Kt(t, r, e) {
          for (const c of e) for (let e = 0; e < c.length - 1; ++e) if (n = t, i = r, o = c[e], a = c[e + 1], l = s = void 0, s = [i[0] - n[0], i[1] - n[1]], 0 != (l = [a[0] - o[0], a[1] - o[1]])[0] * s[1] - l[1] * s[0] && !(!Vt(n, i, o, a) || !Vt(o, a, n, i))) return 1;
          var n, i, o, a, s, l;
        }
        function Wt(t, r) {
          for (let e = 0; e < t.length; ++e) if (!qt(t[e], r)) return;
          for (let e = 0; e < t.length - 1; ++e) if (Kt(t[e], t[e + 1], r)) return;
          return 1;
        }
        function Zt(r, n, i) {
          var e = [];
          for (let t = 0; t < r.length; t++) {
            var o = [];
            for (let e = 0; e < r[t].length; e++) {
              var a = Gt(r[t][e], i);
              Ht(n, a), o.push(a);
            }
            e.push(o);
          }
          return e;
        }
        function Xt(t, r, n) {
          var i = [];
          for (let e = 0; e < t.length; e++) {
            var o = Zt(t[e], r, n);
            i.push(o);
          }
          return i;
        }
        function Jt(t, e, r, n) {
          if (t[0] < r[0] || t[0] > r[2]) {
            var i = .5 * n;
            let e = t[0] - r[0] > i ? -n : r[0] - t[0] > i ? n : 0;
            0 === e && (e = t[0] - r[2] > i ? -n : r[2] - t[0] > i ? n : 0), t[0] += e;
          }
          Ht(e, t);
        }
        function Qt(e, t, r, n) {
          var i = Math.pow(2, n.z) * Yt,
            o = [n.x * Yt, n.y * Yt],
            a = [];
          for (const l of e) for (const c of l) {
            var s = [c.x + o[0], c.y + o[1]];
            Jt(s, t, r, i), a.push(s);
          }
          return a;
        }
        function er(e, t, r, n) {
          var i = Math.pow(2, n.z) * Yt,
            o = [n.x * Yt, n.y * Yt],
            a = [];
          for (const c of e) {
            var s = [];
            for (const u of c) {
              var l = [u.x + o[0], u.y + o[1]];
              Ht(t, l), s.push(l);
            }
            a.push(s);
          }
          if (t[2] - t[0] <= i / 2) {
            (n = t)[0] = n[1] = 1 / 0, n[2] = n[3] = -1 / 0;
            for (const h of a) for (const d of h) Jt(d, t, r, i);
          }
          return a;
        }
        function tr(e, t) {
          var r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
            n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
            i = e.canonicalID();
          if ("Polygon" === t.type) {
            var o = Zt(t.coordinates, n, i),
              a = Qt(e.geometry(), r, n, i);
            if (!jt(r, n)) return !1;
            for (const l of a) if (!qt(l, o)) return !1;
          }
          if ("MultiPolygon" === t.type) {
            var s = Xt(t.coordinates, n, i),
              a = Qt(e.geometry(), r, n, i);
            if (!jt(r, n)) return !1;
            for (const c of a) if (!function (t, r) {
              for (let e = 0; e < r.length; e++) if (qt(t, r[e])) return 1;
            }(c, s)) return !1;
          }
          return !0;
        }
        function rr(e, t) {
          var r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
            n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
            i = e.canonicalID();
          if ("Polygon" === t.type) {
            var o = Zt(t.coordinates, n, i),
              a = er(e.geometry(), r, n, i);
            if (!jt(r, n)) return !1;
            for (const l of a) if (!Wt(l, o)) return !1;
          }
          if ("MultiPolygon" === t.type) {
            var s = Xt(t.coordinates, n, i),
              a = er(e.geometry(), r, n, i);
            if (!jt(r, n)) return !1;
            for (const c of a) if (!function (t, r) {
              for (let e = 0; e < r.length; e++) if (Wt(t, r[e])) return 1;
            }(c, s)) return !1;
          }
          return !0;
        }
        class nr {
          constructor(e, t) {
            this.type = u, this.geojson = e, this.geometries = t;
          }
          static parse(e, t) {
            if (2 !== e.length) return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (Dt(e[1])) {
              var r = e[1];
              if ("FeatureCollection" === r.type) for (let e = 0; e < r.features.length; ++e) {
                var n = r.features[e].geometry.type;
                if ("Polygon" === n || "MultiPolygon" === n) return new nr(r, r.features[e].geometry);
              } else if ("Feature" === r.type) {
                e = r.geometry.type;
                if ("Polygon" === e || "MultiPolygon" === e) return new nr(r, r.geometry);
              } else if ("Polygon" === r.type || "MultiPolygon" === r.type) return new nr(r, r);
            }
            return t.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(e) {
            if (null != e.geometry() && null != e.canonicalID()) {
              if ("Point" === e.geometryType()) return tr(e, this.geometries);
              if ("LineString" === e.geometryType()) return rr(e, this.geometries);
            }
            return !1;
          }
          eachChild() {}
          outputDefined() {
            return !0;
          }
        }
        class ir {
          constructor(e, t) {
            this.type = t.type, this.name = e, this.boundExpression = t;
          }
          static parse(e, t) {
            return 2 !== e.length || "string" != typeof e[1] ? t.error("'var' expression requires exactly one string literal argument.") : (e = e[1], t.scope.has(e) ? new ir(e, t.scope.get(e)) : t.error(`Unknown variable "${e}". Make sure "${e}" has been bound in an enclosing "let" expression before using it.`, 1));
          }
          evaluate(e) {
            return this.boundExpression.evaluate(e);
          }
          eachChild() {}
          outputDefined() {
            return !1;
          }
        }
        class or {
          constructor(e, t, r, n) {
            this.name = e, this.type = t, this._evaluate = r, this.args = n;
          }
          evaluate(e) {
            return this._evaluate(e, this.args);
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return !1;
          }
          static parse(r, n) {
            var e = r[0],
              t = or.definitions[e];
            if (!t) return n.error(`Unknown expression "${e}". If you wanted a literal array, use ["literal", [...]].`, 0);
            var i,
              o,
              a = Array.isArray(t) ? t[0] : t.type,
              t = Array.isArray(t) ? [[t[1], t[2]]] : t.overloads,
              s = t.filter(([e]) => !Array.isArray(e) || e.length === r.length - 1);
            let l = null;
            for ([i, o] of s) {
              l = new $t(n.registry, sr, n.path, null, n.scope);
              var c = [];
              let t = !1;
              for (let e = 1; e < r.length; e++) {
                var u = r[e],
                  h = Array.isArray(i) ? i[e - 1] : i.type,
                  u = l.parse(u, 1 + c.length, h);
                if (!u) {
                  t = !0;
                  break;
                }
                c.push(u);
              }
              if (!t) if (Array.isArray(i) && i.length !== c.length) l.error(`Expected ${i.length} arguments, but found ${c.length} instead.`);else {
                for (let e = 0; e < c.length; e++) {
                  var d = Array.isArray(i) ? i[e] : i.type,
                    p = c[e];
                  l.concat(e + 1).checkSubtype(d, p.type);
                }
                if (0 === l.errors.length) return new or(e, a, o, c);
              }
            }
            if (1 === s.length) n.errors.push(...l.errors);else {
              var s = (s.length ? s : t).map(([e]) => ar(e)).join(" | "),
                f = [];
              for (let e = 1; e < r.length; e++) {
                var _ = n.parse(r[e], 1 + f.length);
                if (!_) return null;
                f.push(m(_.type));
              }
              n.error(`Expected arguments of type ${s}, but found (${f.join(", ")}) instead.`);
            }
            return null;
          }
          static register(e, t) {
            for (const r in or.definitions = t) e[r] = or;
          }
        }
        function ar(e) {
          return Array.isArray(e) ? `(${e.map(m).join(", ")})` : `(${m(e.type)}...)`;
        }
        function sr(e) {
          if (e instanceof ir) return sr(e.boundExpression);
          if (e instanceof or && "error" === e.name) return !1;
          if (e instanceof zt) return !1;
          if (e instanceof nr) return !1;
          const t = e instanceof Ut || e instanceof kt;
          let r = !0;
          return e.eachChild(e => {
            r = t ? r && sr(e) : r && e instanceof Ot;
          }), !!r && lr(e) && ur(e, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
        }
        function lr(e) {
          if (e instanceof or) {
            if ("get" === e.name && 1 === e.args.length) return !1;
            if ("feature-state" === e.name) return !1;
            if ("has" === e.name && 1 === e.args.length) return !1;
            if ("properties" === e.name || "geometry-type" === e.name || "id" === e.name) return !1;
            if (/^filter-/.test(e.name)) return !1;
          }
          if (e instanceof nr) return !1;
          let t = !0;
          return e.eachChild(e => {
            t && !lr(e) && (t = !1);
          }), t;
        }
        function cr(e) {
          if (!(e instanceof or && "feature-state" === e.name)) {
            let t = !0;
            return e.eachChild(e => {
              t && !cr(e) && (t = !1);
            }), t;
          }
        }
        function ur(e, t) {
          if (e instanceof or && 0 <= t.indexOf(e.name)) return !1;
          let r = !0;
          return e.eachChild(e => {
            r && !ur(e, t) && (r = !1);
          }), r;
        }
        function hr(e, t) {
          var r = e.length - 1;
          let n = 0,
            i = r;
          for (var o, a, s; n <= i;) if (a = e[o = Math.floor((n + i) / 2)], s = e[o + 1], a <= t) {
            if (o === r || t < s) return o;
            n = o + 1;
          } else {
            if (!(t < a)) throw new _("Input is not a number.");
            i = o - 1;
          }
          return 0;
        }
        class dr {
          constructor(e, t, r) {
            this.type = e, this.input = t, this.labels = [], this.outputs = [];
            for (var [n, i] of r) this.labels.push(n), this.outputs.push(i);
          }
          static parse(t, r) {
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            var e = r.parse(t[1], 1, f);
            if (!e) return null;
            var n = [];
            let i = null;
            r.expectedType && "value" !== r.expectedType.kind && (i = r.expectedType);
            for (let e = 1; e < t.length; e += 2) {
              var o = 1 === e ? -1 / 0 : t[e],
                a = t[e + 1],
                s = e,
                l = e + 1;
              if ("number" != typeof o) return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', s);
              if (n.length && n[n.length - 1][0] >= o) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', s);
              s = r.parse(a, l, i);
              if (!s) return null;
              i = i || s.type, n.push([o, s]);
            }
            return new dr(i, e, n);
          }
          evaluate(e) {
            var t,
              r,
              n = this.labels,
              i = this.outputs;
            return (1 === n.length || (t = this.input.evaluate(e)) <= n[0] ? i[0] : t >= n[(r = n.length) - 1] ? i[r - 1] : i[hr(n, t)]).evaluate(e);
          }
          eachChild(e) {
            e(this.input);
            for (const t of this.outputs) e(t);
          }
          outputDefined() {
            return this.outputs.every(e => e.outputDefined());
          }
        }
        function pr(e, t, r) {
          return e + r * (t - e);
        }
        function fr(e, r, n) {
          return e.map((e, t) => pr(e, r[t], n));
        }
        const _r = {
          number: pr,
          color: function (r, n, i, e = "rgb") {
            switch (e) {
              case "rgb":
                var [o, a, s, l] = fr(r.rgb, n.rgb, i);
                return new g(o, a, s, l, !1);
              case "hcl":
                {
                  var [o, a, s, l] = r.hcl,
                    [c, u, h, d] = n.hcl;
                  let t, e;
                  if (isNaN(o) || isNaN(c)) isNaN(o) ? isNaN(c) ? t = NaN : (t = c, 1 !== s && 0 !== s || (e = u)) : (t = o, 1 !== h && 0 !== h || (e = a));else {
                    let e = c - o;
                    o < c && 180 < e ? e -= 360 : c < o && 180 < o - c && (e += 360), t = o + i * e;
                  }
                  [c, o, a, u] = [[t, null !== e && void 0 !== e ? e : pr(a, u, i), pr(s, h, i), pr(l, d, i)]][0], c = isNaN(c) ? 0 : c * st;
                  var [s, h, l, d] = pt([a, Math.cos(c) * o, Math.sin(c) * o, u]);
                  return new g(s, h, l, d, !1);
                }
              case "lab":
                var [c, u, s, h] = pt(fr(r.lab, n.lab, i));
                return new g(c, u, s, h, !1);
            }
          },
          array: fr,
          padding: function (e, t, r) {
            return new Ct(fr(e.values, t.values, r));
          },
          variableAnchorOffsetCollection: function (e, t, r) {
            var n = e.values,
              i = t.values;
            if (n.length !== i.length) throw new _(`Cannot interpolate values of different length. from: ${e.toString()}, to: ` + t.toString());
            var o = [];
            for (let e = 0; e < n.length; e += 2) {
              if (n[e] !== i[e]) throw new _(`Cannot interpolate values containing mismatched anchors. from[${e}]: ${n[e]}, to[${e}]: ` + i[e]);
              o.push(n[e]);
              var [a, s] = n[e + 1],
                [l, c] = i[e + 1];
              o.push([pr(a, l, r), pr(s, c, r)]);
            }
            return new It(o);
          }
        };
        class mr {
          constructor(e, t, r, n, i) {
            this.type = e, this.operator = t, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];
            for (var [o, a] of i) this.labels.push(o), this.outputs.push(a);
          }
          static interpolationFactor(e, t, r, n) {
            let i = 0;
            return "exponential" === e.name ? i = gr(t, e.base, r, n) : "linear" === e.name ? i = gr(t, 1, r, n) : "cubic-bezier" === e.name && (e = e.controlPoints, e = new k(e[0], e[1], e[2], e[3]), i = e.solve(gr(t, 1, r, n))), i;
          }
          static parse(e, t) {
            let [r, n, i, ...o] = e;
            if (!Array.isArray(n) || 0 === n.length) return t.error("Expected an interpolation type expression.", 1);
            if ("linear" === n[0]) n = {
              name: "linear"
            };else if ("exponential" === n[0]) {
              var a = n[1];
              if ("number" != typeof a) return t.error("Exponential interpolation requires a numeric base.", 1, 1);
              n = {
                name: "exponential",
                base: a
              };
            } else {
              if ("cubic-bezier" !== n[0]) return t.error("Unknown interpolation type " + String(n[0]), 1, 0);
              a = n.slice(1);
              if (4 !== a.length || a.some(e => "number" != typeof e || e < 0 || 1 < e)) return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              n = {
                name: "cubic-bezier",
                controlPoints: a
              };
            }
            if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if ((e.length - 1) % 2 != 0) return t.error("Expected an even number of arguments.");
            if (!(i = t.parse(i, 2, f))) return null;
            var s = [];
            let l = null;
            "interpolate-hcl" === r || "interpolate-lab" === r ? l = ze : t.expectedType && "value" !== t.expectedType.kind && (l = t.expectedType);
            for (let e = 0; e < o.length; e += 2) {
              var c = o[e],
                u = o[e + 1],
                h = e + 3,
                d = e + 4;
              if ("number" != typeof c) return t.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', h);
              if (s.length && s[s.length - 1][0] >= c) return t.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', h);
              h = t.parse(u, d, l);
              if (!h) return null;
              l = l || h.type, s.push([c, h]);
            }
            return Qe(l, f) || Qe(l, ze) || Qe(l, Ge) || Qe(l, Ve) || Qe(l, Ke(f)) ? new mr(l, r, n, i, s) : t.error(`Type ${m(l)} is not interpolatable.`);
          }
          evaluate(e) {
            var t = this.labels,
              r = this.outputs;
            if (1 === t.length) return r[0].evaluate(e);
            var n = this.input.evaluate(e);
            if (n <= t[0]) return r[0].evaluate(e);
            var i = t.length;
            if (n >= t[i - 1]) return r[i - 1].evaluate(e);
            var i = hr(t, n),
              o = t[i],
              t = t[i + 1],
              a = mr.interpolationFactor(this.interpolation, n, o, t),
              s = r[i].evaluate(e),
              l = r[i + 1].evaluate(e);
            switch (this.operator) {
              case "interpolate":
                return _r[this.type.kind](s, l, a);
              case "interpolate-hcl":
                return _r.color(s, l, a, "hcl");
              case "interpolate-lab":
                return _r.color(s, l, a, "lab");
            }
          }
          eachChild(e) {
            e(this.input);
            for (const t of this.outputs) e(t);
          }
          outputDefined() {
            return this.outputs.every(e => e.outputDefined());
          }
        }
        function gr(e, t, r, n) {
          n -= r, e -= r;
          return 0 == n ? 0 : 1 === t ? e / n : (Math.pow(t, e) - 1) / (Math.pow(t, n) - 1);
        }
        class yr {
          constructor(e, t) {
            this.type = e, this.args = t;
          }
          static parse(e, t) {
            if (e.length < 2) return t.error("Expectected at least one argument.");
            let r = null;
            const n = t.expectedType;
            n && "value" !== n.kind && (r = n);
            var i = [];
            for (const a of e.slice(1)) {
              var o = t.parse(a, 1 + i.length, r, void 0, {
                typeAnnotation: "omit"
              });
              if (!o) return null;
              r = r || o.type, i.push(o);
            }
            if (r) return n && i.some(e => Ze(n, e.type)) ? new yr(h, i) : new yr(r, i);
            throw new Error("No output type");
          }
          evaluate(e) {
            let t = null,
              r = 0,
              n;
            for (const i of this.args) if (r++, null !== (t = (t = i.evaluate(e)) && t instanceof Nt && !t.available && (n = n || t.name, t = null, r === this.args.length) ? n : t)) break;
            return t;
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every(e => e.outputDefined());
          }
        }
        class vr {
          constructor(e, t) {
            this.type = t.type, this.bindings = [].concat(e), this.result = t;
          }
          evaluate(e) {
            return this.result.evaluate(e);
          }
          eachChild(e) {
            for (const t of this.bindings) e(t[1]);
            e(this.result);
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
            var n = [];
            for (let e = 1; e < t.length - 1; e += 2) {
              var i = t[e];
              if ("string" != typeof i) return r.error(`Expected string, but found ${typeof i} instead.`, e);
              if (/[^a-zA-Z0-9_]/.test(i)) return r.error("Variable names must contain only alphanumeric characters or '_'.", e);
              var o = r.parse(t[e + 1], e + 1);
              if (!o) return null;
              n.push([i, o]);
            }
            var e = r.parse(t[t.length - 1], t.length - 1, r.expectedType, n);
            return e ? new vr(n, e) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        function Er(e, t) {
          return "==" === e || "!=" === e ? "boolean" === t.kind || "string" === t.kind || "number" === t.kind || "null" === t.kind || "value" === t.kind : "string" === t.kind || "number" === t.kind || "value" === t.kind;
        }
        function br(e, t, r, n) {
          return 0 === n.compare(t, r);
        }
        function wr(o, a, s) {
          const l = "==" !== o && "!=" !== o;
          return class c {
            constructor(e, t, r) {
              this.type = u, this.lhs = e, this.rhs = t, this.collator = r, this.hasUntypedArgument = "value" === e.type.kind || "value" === t.type.kind;
            }
            static parse(e, t) {
              if (3 !== e.length && 4 !== e.length) return t.error("Expected two or three arguments.");
              var r = e[0];
              let n = t.parse(e[1], 1, h);
              if (!n) return null;
              if (!Er(r, n.type)) return t.concat(1).error(`"${r}" comparisons are not supported for type '${m(n.type)}'.`);
              let i = t.parse(e[2], 2, h);
              if (!i) return null;
              if (!Er(r, i.type)) return t.concat(2).error(`"${r}" comparisons are not supported for type '${m(i.type)}'.`);
              if (n.type.kind !== i.type.kind && "value" !== n.type.kind && "value" !== i.type.kind) return t.error(`Cannot compare types '${m(n.type)}' and '${m(i.type)}'.`);
              l && ("value" === n.type.kind && "value" !== i.type.kind ? n = new kt(i.type, [n]) : "value" !== n.type.kind && "value" === i.type.kind && (i = new kt(n.type, [i])));
              let o = null;
              if (4 === e.length) {
                if ("string" !== n.type.kind && "string" !== i.type.kind && "value" !== n.type.kind && "value" !== i.type.kind) return t.error("Cannot use collator to compare non-string types.");
                if (!(o = t.parse(e[3], 3, He))) return null;
              }
              return new c(n, i, o);
            }
            evaluate(e) {
              var t = this.lhs.evaluate(e),
                r = this.rhs.evaluate(e);
              if (l && this.hasUntypedArgument) {
                var n = d(t),
                  i = d(r);
                if (n.kind !== i.kind || "string" !== n.kind && "number" !== n.kind) throw new _(`Expected arguments for "${o}" to be (string, string) or (number, number), but found (${n.kind}, ${i.kind}) instead.`);
              }
              if (this.collator && !l && this.hasUntypedArgument) {
                n = d(t), i = d(r);
                if ("string" !== n.kind || "string" !== i.kind) return a(e, t, r);
              }
              return this.collator ? s(e, t, r, this.collator.evaluate(e)) : a(e, t, r);
            }
            eachChild(e) {
              e(this.lhs), e(this.rhs), this.collator && e(this.collator);
            }
            outputDefined() {
              return !0;
            }
          };
        }
        var le = wr("==", function (e, t, r) {
            return t === r;
          }, br),
          e = wr("!=", function (e, t, r) {
            return t !== r;
          }, function (e, t, r, n) {
            return !br(0, t, r, n);
          }),
          Tr = wr("<", function (e, t, r) {
            return t < r;
          }, function (e, t, r, n) {
            return n.compare(t, r) < 0;
          }),
          Sr = wr(">", function (e, t, r) {
            return r < t;
          }, function (e, t, r, n) {
            return 0 < n.compare(t, r);
          }),
          xr = wr("<=", function (e, t, r) {
            return t <= r;
          }, function (e, t, r, n) {
            return n.compare(t, r) <= 0;
          }),
          t = wr(">=", function (e, t, r) {
            return r <= t;
          }, function (e, t, r, n) {
            return 0 <= n.compare(t, r);
          });
        class Cr {
          constructor(e) {
            this.type = je, this.sections = e;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            var e = t[1];
            if (!Array.isArray(e) && "object" == typeof e) return n.error("First argument must be an image or text section.");
            var i = [];
            let o = !1;
            for (let e = 1; e <= t.length - 1; ++e) {
              var a = t[e];
              if (o && "object" == typeof a && !Array.isArray(a)) {
                o = !1;
                let e = null;
                if (a["font-scale"] && !(e = n.parse(a["font-scale"], 1, f))) return null;
                let t = null;
                if (a["text-font"] && !(t = n.parse(a["text-font"], 1, Ke(s)))) return null;
                let r = null;
                if (a["text-color"] && !(r = n.parse(a["text-color"], 1, ze))) return null;
                a = i[i.length - 1];
                a.scale = e, a.font = t, a.textColor = r;
              } else {
                a = n.parse(t[e], 1, h);
                if (!a) return null;
                var r = a.type.kind;
                if ("string" !== r && "value" !== r && "null" !== r && "resolvedImage" !== r) return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                o = !0, i.push({
                  content: a,
                  scale: null,
                  font: null,
                  textColor: null
                });
              }
            }
            return new Cr(i);
          }
          evaluate(r) {
            return new xt(this.sections.map(e => {
              var t = e.content.evaluate(r);
              return d(t) === qe ? new St("", t, null, null, null) : new St(Rt(t), null, e.scale ? e.scale.evaluate(r) : null, e.font ? e.font.evaluate(r).join(",") : null, e.textColor ? e.textColor.evaluate(r) : null);
            }));
          }
          eachChild(e) {
            for (const t of this.sections) e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor);
          }
          outputDefined() {
            return !1;
          }
        }
        const Ar = {
          "==": le,
          "!=": e,
          ">": Sr,
          "<": Tr,
          ">=": t,
          "<=": xr,
          array: kt,
          at: class Mu {
            constructor(e, t, r) {
              this.type = e, this.index = t, this.input = r;
            }
            static parse(e, t) {
              var r;
              return 3 !== e.length ? t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`) : (r = t.parse(e[1], 1, f), e = t.parse(e[2], 2, Ke(t.expectedType || h)), r && e ? (t = e.type, new Mu(t.itemType, r, e)) : null);
            }
            evaluate(e) {
              var t = this.index.evaluate(e),
                e = this.input.evaluate(e);
              if (t < 0) throw new _(`Array index out of bounds: ${t} < 0.`);
              if (t >= e.length) throw new _(`Array index out of bounds: ${t} > ${e.length - 1}.`);
              if (t !== Math.floor(t)) throw new _(`Array index must be an integer, but found ${t} instead.`);
              return e[t];
            }
            eachChild(e) {
              e(this.index), e(this.input);
            }
            outputDefined() {
              return !1;
            }
          },
          boolean: kt,
          case: class ku {
            constructor(e, t, r) {
              this.type = e, this.branches = t, this.otherwise = r;
            }
            static parse(t, r) {
              if (t.length < 4) return r.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
              if (t.length % 2 != 0) return r.error("Expected an odd number of arguments.");
              let n;
              r.expectedType && "value" !== r.expectedType.kind && (n = r.expectedType);
              var i = [];
              for (let e = 1; e < t.length - 1; e += 2) {
                var o = r.parse(t[e], e, u);
                if (!o) return null;
                var a = r.parse(t[e + 1], e + 1, n);
                if (!a) return null;
                i.push([o, a]), n = n || a.type;
              }
              var e = r.parse(t[t.length - 1], t.length - 1, n);
              if (!e) return null;
              if (n) return new ku(n, i, e);
              throw new Error("Can't infer output type");
            }
            evaluate(e) {
              for (var [t, r] of this.branches) if (t.evaluate(e)) return r.evaluate(e);
              return this.otherwise.evaluate(e);
            }
            eachChild(e) {
              for (var [t, r] of this.branches) e(t), e(r);
              e(this.otherwise);
            }
            outputDefined() {
              return this.branches.every(([, e]) => e.outputDefined()) && this.otherwise.outputDefined();
            }
          },
          coalesce: yr,
          collator: zt,
          format: Cr,
          image: class Lu {
            constructor(e) {
              this.type = qe, this.input = e;
            }
            static parse(e, t) {
              return 2 !== e.length ? t.error("Expected two arguments.") : (e = t.parse(e[1], 1, s)) ? new Lu(e) : t.error("No image name provided.");
            }
            evaluate(e) {
              var t = this.input.evaluate(e),
                r = Nt.fromString(t);
              return r && e.availableImages && (r.available = -1 < e.availableImages.indexOf(t)), r;
            }
            eachChild(e) {
              e(this.input);
            }
            outputDefined() {
              return !1;
            }
          },
          in: class Uu {
            constructor(e, t) {
              this.type = u, this.needle = e, this.haystack = t;
            }
            static parse(e, t) {
              var r;
              return 3 !== e.length ? t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`) : (r = t.parse(e[1], 1, h), e = t.parse(e[2], 2, h), r && e ? Xe(r.type, [u, s, f, $e, h]) ? new Uu(r, e) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${m(r.type)} instead`) : null);
            }
            evaluate(e) {
              var t = this.needle.evaluate(e);
              if (!(e = this.haystack.evaluate(e))) return !1;
              if (!Je(t, ["boolean", "string", "number", "null"])) throw new _(`Expected first argument to be of type boolean, string, number or null, but found ${m(d(t))} instead.`);
              if (Je(e, ["string", "array"])) return 0 <= e.indexOf(t);
              throw new _(`Expected second argument to be of type array or string, but found ${m(d(e))} instead.`);
            }
            eachChild(e) {
              e(this.needle), e(this.haystack);
            }
            outputDefined() {
              return !0;
            }
          },
          "index-of": class Fu {
            constructor(e, t, r) {
              this.type = f, this.needle = e, this.haystack = t, this.fromIndex = r;
            }
            static parse(e, t) {
              var r, n;
              return e.length <= 2 || 5 <= e.length ? t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`) : (r = t.parse(e[1], 1, h), n = t.parse(e[2], 2, h), r && n ? Xe(r.type, [u, s, f, $e, h]) ? 4 === e.length ? (e = t.parse(e[3], 3, f)) ? new Fu(r, n, e) : null : new Fu(r, n) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${m(r.type)} instead`) : null);
            }
            evaluate(e) {
              var t = this.needle.evaluate(e),
                r = this.haystack.evaluate(e);
              if (!Je(t, ["boolean", "string", "number", "null"])) throw new _(`Expected first argument to be of type boolean, string, number or null, but found ${m(d(t))} instead.`);
              if (Je(r, ["string", "array"])) return this.fromIndex ? (e = this.fromIndex.evaluate(e), r.indexOf(t, e)) : r.indexOf(t);
              throw new _(`Expected second argument to be of type array or string, but found ${m(d(r))} instead.`);
            }
            eachChild(e) {
              e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
            }
            outputDefined() {
              return !1;
            }
          },
          interpolate: mr,
          "interpolate-hcl": mr,
          "interpolate-lab": mr,
          length: class Bu {
            constructor(e) {
              this.type = f, this.input = e;
            }
            static parse(e, t) {
              return 2 !== e.length ? t.error(`Expected 1 argument, but found ${e.length - 1} instead.`) : (e = t.parse(e[1], 1)) ? "array" !== e.type.kind && "string" !== e.type.kind && "value" !== e.type.kind ? t.error(`Expected argument of type string or array, but found ${m(e.type)} instead.`) : new Bu(e) : null;
            }
            evaluate(e) {
              if ("string" == typeof (e = this.input.evaluate(e))) return e.length;
              if (Array.isArray(e)) return e.length;
              throw new _(`Expected value to be of type string or array, but found ${m(d(e))} instead.`);
            }
            eachChild(e) {
              e(this.input);
            }
            outputDefined() {
              return !1;
            }
          },
          let: vr,
          literal: Ot,
          match: class $u {
            constructor(e, t, r, n, i, o) {
              this.inputType = e, this.type = t, this.input = r, this.cases = n, this.outputs = i, this.otherwise = o;
            }
            static parse(r, n) {
              if (r.length < 5) return n.error(`Expected at least 4 arguments, but found only ${r.length - 1}.`);
              if (r.length % 2 != 1) return n.error("Expected an even number of arguments.");
              let i, o;
              n.expectedType && "value" !== n.expectedType.kind && (o = n.expectedType);
              var a = {},
                s = [];
              for (let t = 2; t < r.length - 1; t += 2) {
                let e = r[t];
                var l = r[t + 1],
                  c = (Array.isArray(e) || (e = [e]), n.concat(t));
                if (0 === e.length) return c.error("Expected at least one branch label.");
                for (const u of e) {
                  if ("number" != typeof u && "string" != typeof u) return c.error("Branch labels must be numbers or strings.");
                  if ("number" == typeof u && Math.abs(u) > Number.MAX_SAFE_INTEGER) return c.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                  if ("number" == typeof u && Math.floor(u) !== u) return c.error("Numeric branch labels must be integer values.");
                  if (i) {
                    if (c.checkSubtype(i, d(u))) return null;
                  } else i = d(u);
                  if (void 0 !== a[String(u)]) return c.error("Branch labels must be unique.");
                  a[String(u)] = s.length;
                }
                if (!(l = n.parse(l, t, o))) return null;
                o = o || l.type, s.push(l);
              }
              var e,
                t = n.parse(r[1], 1, h);
              return !t || !(e = n.parse(r[r.length - 1], r.length - 1, o)) || "value" !== t.type.kind && n.concat(1).checkSubtype(i, t.type) ? null : new $u(i, o, t, a, s, e);
            }
            evaluate(e) {
              var t = this.input.evaluate(e);
              return (d(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);
            }
            eachChild(e) {
              e(this.input), this.outputs.forEach(e), e(this.otherwise);
            }
            outputDefined() {
              return this.outputs.every(e => e.outputDefined()) && this.otherwise.outputDefined();
            }
          },
          number: kt,
          "number-format": class zu {
            constructor(e, t, r, n, i) {
              this.type = s, this.number = e, this.locale = t, this.currency = r, this.minFractionDigits = n, this.maxFractionDigits = i;
            }
            static parse(e, t) {
              if (3 !== e.length) return t.error("Expected two arguments.");
              var r = t.parse(e[1], 1, f);
              if (!r) return null;
              if ("object" != typeof (e = e[2]) || Array.isArray(e)) return t.error("NumberFormat options argument must be an object.");
              let n = null;
              if (e.locale && !(n = t.parse(e.locale, 1, s))) return null;
              let i = null;
              if (e.currency && !(i = t.parse(e.currency, 1, s))) return null;
              let o = null;
              if (e["min-fraction-digits"] && !(o = t.parse(e["min-fraction-digits"], 1, f))) return null;
              let a = null;
              return e["max-fraction-digits"] && !(a = t.parse(e["max-fraction-digits"], 1, f)) ? null : new zu(r, n, i, o, a);
            }
            evaluate(e) {
              return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {
                style: this.currency ? "currency" : "decimal",
                currency: this.currency ? this.currency.evaluate(e) : void 0,
                minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
                maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
              }).format(this.number.evaluate(e));
            }
            eachChild(e) {
              e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
            }
            outputDefined() {
              return !1;
            }
          },
          object: kt,
          slice: class Yu {
            constructor(e, t, r, n) {
              this.type = e, this.input = t, this.beginIndex = r, this.endIndex = n;
            }
            static parse(e, t) {
              var r, n;
              return e.length <= 2 || 5 <= e.length ? t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`) : (r = t.parse(e[1], 1, h), n = t.parse(e[2], 2, f), r && n ? Xe(r.type, [Ke(h), s, h]) ? 4 === e.length ? (e = t.parse(e[3], 3, f)) ? new Yu(r.type, r, n, e) : null : new Yu(r.type, r, n) : t.error(`Expected first argument to be of type array or string, but found ${m(r.type)} instead`) : null);
            }
            evaluate(e) {
              var t = this.input.evaluate(e),
                r = this.beginIndex.evaluate(e);
              if (Je(t, ["string", "array"])) return this.endIndex ? (e = this.endIndex.evaluate(e), t.slice(r, e)) : t.slice(r);
              throw new _(`Expected first argument to be of type array or string, but found ${m(d(t))} instead.`);
            }
            eachChild(e) {
              e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
            }
            outputDefined() {
              return !1;
            }
          },
          step: dr,
          string: kt,
          "to-boolean": Ut,
          "to-color": Ut,
          "to-number": Ut,
          "to-string": Ut,
          var: ir,
          within: nr
        };
        function Ir(e, [t, r, n, i]) {
          t = t.evaluate(e), r = r.evaluate(e), n = n.evaluate(e);
          i = i ? i.evaluate(e) : 1, e = Pt(t, r, n, i);
          if (e) throw new _(e);
          return new g(t / 255, r / 255, n / 255, i, !1);
        }
        function Nr(e, t) {
          t = t[e];
          return void 0 === t ? null : t;
        }
        function Pr(e) {
          return {
            type: e
          };
        }
        function Dr(e) {
          return {
            result: "success",
            value: e
          };
        }
        function Rr(e) {
          return {
            result: "error",
            value: e
          };
        }
        function Or(e) {
          return "data-driven" === e["property-type"] || "cross-faded-data-driven" === e["property-type"];
        }
        function Mr(e) {
          return e.expression && -1 < e.expression.parameters.indexOf("zoom");
        }
        function kr(e) {
          return e.expression && e.expression.interpolated;
        }
        function y(e) {
          return e instanceof Number ? "number" : e instanceof String ? "string" : e instanceof Boolean ? "boolean" : Array.isArray(e) ? "array" : null === e ? "null" : typeof e;
        }
        function Lr(e) {
          return "object" == typeof e && null !== e && !Array.isArray(e);
        }
        function Ur(e) {
          return e;
        }
        function Fr(r, n) {
          var e = "color" === n.type,
            t = r.stops && "object" == typeof r.stops[0][0],
            i = t || void 0 !== r.property,
            i = t || !i,
            o = r.type || (kr(n) ? "exponential" : "interval");
          if (e || "padding" === n.type) {
            const p = (e ? g : Ct).parse;
            (r = Ue({}, r)).stops && (r.stops = r.stops.map(e => [e[0], p(e[1])])), r.default ? r.default = p(r.default) : r.default = p(n.default);
          }
          if (r.colorSpace && "rgb" !== (e = r.colorSpace) && "hcl" !== e && "lab" !== e) throw new Error(`Unknown color space: "${r.colorSpace}"`);
          let a, s, l;
          if ("exponential" === o) a = Yr;else if ("interval" === o) a = zr;else if ("categorical" === o) {
            a = $r, s = Object.create(null);
            for (const f of r.stops) s[f[0]] = f[1];
            l = typeof r.stops[0][0];
          } else {
            if ("identity" !== o) throw new Error(`Unknown function type "${o}"`);
            a = Hr;
          }
          if (t) {
            var c = {},
              u = [];
            for (let e = 0; e < r.stops.length; e++) {
              var h = r.stops[e],
                d = h[0].zoom;
              void 0 === c[d] && (c[d] = {
                zoom: d,
                type: r.type,
                property: r.property,
                default: r.default,
                stops: []
              }, u.push(d)), c[d].stops.push([h[0].value, h[1]]);
            }
            const _ = [];
            for (const m of u) _.push([c[m].zoom, Fr(c[m], n)]);
            e = {
              name: "linear"
            };
            return {
              kind: "composite",
              interpolationType: e,
              interpolationFactor: mr.interpolationFactor.bind(void 0, e),
              zoomStops: _.map(e => e[0]),
              evaluate({
                zoom: e
              }, t) {
                return Yr({
                  stops: _,
                  base: r.base
                }, n, e).evaluate(e, t);
              }
            };
          }
          return i ? {
            kind: "camera",
            interpolationType: t = "exponential" === o ? {
              name: "exponential",
              base: void 0 !== r.base ? r.base : 1
            } : null,
            interpolationFactor: mr.interpolationFactor.bind(void 0, t),
            zoomStops: r.stops.map(e => e[0]),
            evaluate: ({
              zoom: e
            }) => a(r, n, e, s, l)
          } : {
            kind: "source",
            evaluate(e, t) {
              t = t && t.properties ? t.properties[r.property] : void 0;
              return void 0 === t ? Br(r.default, n.default) : a(r, n, t, s, l);
            }
          };
        }
        function Br(e, t, r) {
          return void 0 !== e ? e : void 0 !== t ? t : void 0 !== r ? r : void 0;
        }
        function $r(e, t, r, n, i) {
          return Br(typeof r === i ? n[r] : void 0, e.default, t.default);
        }
        function zr(e, t, r) {
          return "number" !== y(r) ? Br(e.default, t.default) : (1 === (t = e.stops.length) || r <= e.stops[0][0] ? e.stops[0] : r >= e.stops[t - 1][0] ? e.stops[t - 1] : (t = hr(e.stops.map(e => e[0]), r), e.stops[t]))[1];
        }
        function Yr(r, e, t) {
          var n = void 0 !== r.base ? r.base : 1;
          if ("number" !== y(t)) return Br(r.default, e.default);
          var i = r.stops.length;
          if (1 === i) return r.stops[0][1];
          if (t <= r.stops[0][0]) return r.stops[0][1];
          if (t >= r.stops[i - 1][0]) return r.stops[i - 1][1];
          i = hr(r.stops.map(e => e[0]), t);
          const o = function (e, t, r, n) {
              n -= r, e -= r;
              return 0 == n ? 0 : 1 === t ? e / n : (Math.pow(t, e) - 1) / (Math.pow(t, n) - 1);
            }(t, n, r.stops[i][0], r.stops[i + 1][0]),
            a = r.stops[i][1],
            s = r.stops[i + 1][1],
            l = _r[e.type] || Ur;
          return "function" == typeof a.evaluate ? {
            evaluate(...e) {
              var t = a.evaluate.apply(void 0, e),
                e = s.evaluate.apply(void 0, e);
              if (void 0 !== t && void 0 !== e) return l(t, e, o, r.colorSpace);
            }
          } : l(a, s, o, r.colorSpace);
        }
        function Hr(e, t, r) {
          switch (t.type) {
            case "color":
              r = g.parse(r);
              break;
            case "formatted":
              r = xt.fromString(r.toString());
              break;
            case "resolvedImage":
              r = Nt.fromString(r.toString());
              break;
            case "padding":
              r = Ct.parse(r);
              break;
            default:
              y(r) === t.type || "enum" === t.type && t.values[r] || (r = void 0);
          }
          return Br(r, e.default, t.default);
        }
        or.register(Ar, {
          error: [{
            kind: "error"
          }, [s], (e, [t]) => {
            throw new _(t.evaluate(e));
          }],
          typeof: [s, [h], (e, [t]) => m(d(t.evaluate(e)))],
          "to-rgba": [Ke(f, 4), [ze], (e, [t]) => {
            var [t, e, r, n] = t.evaluate(e).rgb;
            return [255 * t, 255 * e, 255 * r, n];
          }],
          rgb: [ze, [f, f, f], Ir],
          rgba: [ze, [f, f, f, f], Ir],
          has: {
            type: u,
            overloads: [[[s], (e, [t]) => t.evaluate(e) in e.properties()], [[s, Ye], (e, [t, r]) => t.evaluate(e) in r.evaluate(e)]]
          },
          get: {
            type: h,
            overloads: [[[s], (e, [t]) => Nr(t.evaluate(e), e.properties())], [[s, Ye], (e, [t, r]) => Nr(t.evaluate(e), r.evaluate(e))]]
          },
          "feature-state": [h, [s], (e, [t]) => Nr(t.evaluate(e), e.featureState || {})],
          properties: [Ye, [], e => e.properties()],
          "geometry-type": [s, [], e => e.geometryType()],
          id: [h, [], e => e.id()],
          zoom: [f, [], e => e.globals.zoom],
          "heatmap-density": [f, [], e => e.globals.heatmapDensity || 0],
          "line-progress": [f, [], e => e.globals.lineProgress || 0],
          accumulated: [h, [], e => void 0 === e.globals.accumulated ? null : e.globals.accumulated],
          "+": [f, Pr(f), (e, t) => {
            let r = 0;
            for (const n of t) r += n.evaluate(e);
            return r;
          }],
          "*": [f, Pr(f), (e, t) => {
            let r = 1;
            for (const n of t) r *= n.evaluate(e);
            return r;
          }],
          "-": {
            type: f,
            overloads: [[[f, f], (e, [t, r]) => t.evaluate(e) - r.evaluate(e)], [[f], (e, [t]) => -t.evaluate(e)]]
          },
          "/": [f, [f, f], (e, [t, r]) => t.evaluate(e) / r.evaluate(e)],
          "%": [f, [f, f], (e, [t, r]) => t.evaluate(e) % r.evaluate(e)],
          ln2: [f, [], () => Math.LN2],
          pi: [f, [], () => Math.PI],
          e: [f, [], () => Math.E],
          "^": [f, [f, f], (e, [t, r]) => Math.pow(t.evaluate(e), r.evaluate(e))],
          sqrt: [f, [f], (e, [t]) => Math.sqrt(t.evaluate(e))],
          log10: [f, [f], (e, [t]) => Math.log(t.evaluate(e)) / Math.LN10],
          ln: [f, [f], (e, [t]) => Math.log(t.evaluate(e))],
          log2: [f, [f], (e, [t]) => Math.log(t.evaluate(e)) / Math.LN2],
          sin: [f, [f], (e, [t]) => Math.sin(t.evaluate(e))],
          cos: [f, [f], (e, [t]) => Math.cos(t.evaluate(e))],
          tan: [f, [f], (e, [t]) => Math.tan(t.evaluate(e))],
          asin: [f, [f], (e, [t]) => Math.asin(t.evaluate(e))],
          acos: [f, [f], (e, [t]) => Math.acos(t.evaluate(e))],
          atan: [f, [f], (e, [t]) => Math.atan(t.evaluate(e))],
          min: [f, Pr(f), (t, e) => Math.min(...e.map(e => e.evaluate(t)))],
          max: [f, Pr(f), (t, e) => Math.max(...e.map(e => e.evaluate(t)))],
          abs: [f, [f], (e, [t]) => Math.abs(t.evaluate(e))],
          round: [f, [f], (e, [t]) => {
            t = t.evaluate(e);
            return t < 0 ? -Math.round(-t) : Math.round(t);
          }],
          floor: [f, [f], (e, [t]) => Math.floor(t.evaluate(e))],
          ceil: [f, [f], (e, [t]) => Math.ceil(t.evaluate(e))],
          "filter-==": [u, [s, h], (e, [t, r]) => e.properties()[t.value] === r.value],
          "filter-id-==": [u, [h], (e, [t]) => e.id() === t.value],
          "filter-type-==": [u, [s], (e, [t]) => e.geometryType() === t.value],
          "filter-<": [u, [s, h], (e, [t, r]) => {
            e = e.properties()[t.value], t = r.value;
            return typeof e == typeof t && e < t;
          }],
          "filter-id-<": [u, [h], (e, [t]) => {
            e = e.id(), t = t.value;
            return typeof e == typeof t && e < t;
          }],
          "filter->": [u, [s, h], (e, [t, r]) => {
            e = e.properties()[t.value], t = r.value;
            return typeof e == typeof t && t < e;
          }],
          "filter-id->": [u, [h], (e, [t]) => {
            e = e.id(), t = t.value;
            return typeof e == typeof t && t < e;
          }],
          "filter-<=": [u, [s, h], (e, [t, r]) => {
            e = e.properties()[t.value], t = r.value;
            return typeof e == typeof t && e <= t;
          }],
          "filter-id-<=": [u, [h], (e, [t]) => {
            e = e.id(), t = t.value;
            return typeof e == typeof t && e <= t;
          }],
          "filter->=": [u, [s, h], (e, [t, r]) => {
            e = e.properties()[t.value], t = r.value;
            return typeof e == typeof t && t <= e;
          }],
          "filter-id->=": [u, [h], (e, [t]) => {
            e = e.id(), t = t.value;
            return typeof e == typeof t && t <= e;
          }],
          "filter-has": [u, [h], (e, [t]) => t.value in e.properties()],
          "filter-has-id": [u, [], e => null !== e.id() && void 0 !== e.id()],
          "filter-type-in": [u, [Ke(s)], (e, [t]) => 0 <= t.value.indexOf(e.geometryType())],
          "filter-id-in": [u, [Ke(h)], (e, [t]) => 0 <= t.value.indexOf(e.id())],
          "filter-in-small": [u, [s, Ke(h)], (e, [t, r]) => 0 <= r.value.indexOf(e.properties()[t.value])],
          "filter-in-large": [u, [s, Ke(h)], (e, [t, r]) => {
            for (var n = e.properties()[t.value], i = r.value, o = 0, a = r.value.length - 1; o <= a;) {
              var s = o + a >> 1;
              if (i[s] === n) return !0;
              i[s] > n ? a = s - 1 : o = 1 + s;
            }
            return !1;
          }],
          all: {
            type: u,
            overloads: [[[u, u], (e, [t, r]) => t.evaluate(e) && r.evaluate(e)], [Pr(u), (e, t) => {
              for (const r of t) if (!r.evaluate(e)) return !1;
              return !0;
            }]]
          },
          any: {
            type: u,
            overloads: [[[u, u], (e, [t, r]) => t.evaluate(e) || r.evaluate(e)], [Pr(u), (e, t) => {
              for (const r of t) if (r.evaluate(e)) return !0;
              return !1;
            }]]
          },
          "!": [u, [u], (e, [t]) => !t.evaluate(e)],
          "is-supported-script": [u, [s], (e, [t]) => {
            var r = e.globals && e.globals.isSupportedScript;
            return !r || r(t.evaluate(e));
          }],
          upcase: [s, [s], (e, [t]) => t.evaluate(e).toUpperCase()],
          downcase: [s, [s], (e, [t]) => t.evaluate(e).toLowerCase()],
          concat: [s, Pr(h), (t, e) => e.map(e => Rt(e.evaluate(t))).join("")],
          "resolved-locale": [s, [He], (e, [t]) => t.evaluate(e).resolvedLocale()]
        });
        class jr {
          constructor(e, t) {
            this.expression = e, this._warningHistory = {}, this._evaluator = new Bt(), this._defaultValue = t ? Qr(t) : null, this._enumValues = t && "enum" === t.type ? t.values : null;
          }
          evaluateWithoutErrorHandling(e, t, r, n, i, o) {
            return this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = r, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = o, this.expression.evaluate(this._evaluator);
          }
          evaluate(e, t, r, n, i, o) {
            this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = o || null;
            try {
              var a = this.expression.evaluate(this._evaluator);
              if (null == a || "number" == typeof a && a != a) return this._defaultValue;
              if (!this._enumValues || a in this._enumValues) return a;
              throw new _(`Expected value to be one of ${Object.keys(this._enumValues).map(e => JSON.stringify(e)).join(", ")}, but found ${JSON.stringify(a)} instead.`);
            } catch (e) {
              return this._warningHistory[e.message] || (this._warningHistory[e.message] = !0, "undefined" != typeof console && console.warn(e.message)), this._defaultValue;
            }
          }
        }
        function Gr(e) {
          return Array.isArray(e) && 0 < e.length && "string" == typeof e[0] && e[0] in Ar;
        }
        function qr(e, t) {
          var r = new $t(Ar, sr, [], t ? (n = t, r = {
              color: ze,
              string: s,
              number: f,
              enum: s,
              boolean: u,
              formatted: je,
              padding: Ge,
              resolvedImage: qe,
              variableAnchorOffsetCollection: Ve
            }, "array" !== n.type ? r[n.type] : Ke(r[n.value] || h, n.length)) : void 0),
            n = r.parse(e, void 0, void 0, void 0, t && "string" === t.type ? {
              typeAnnotation: "coerce"
            } : void 0);
          return n ? Dr(new jr(n, t)) : Rr(r.errors);
        }
        class Vr {
          constructor(e, t) {
            this.kind = e, this._styleExpression = t, this.isStateDependent = "constant" !== e && !cr(t.expression);
          }
          evaluateWithoutErrorHandling(e, t, r, n, i, o) {
            return this._styleExpression.evaluateWithoutErrorHandling(e, t, r, n, i, o);
          }
          evaluate(e, t, r, n, i, o) {
            return this._styleExpression.evaluate(e, t, r, n, i, o);
          }
        }
        class Kr {
          constructor(e, t, r, n) {
            this.kind = e, this.zoomStops = r, this._styleExpression = t, this.isStateDependent = "camera" !== e && !cr(t.expression), this.interpolationType = n;
          }
          evaluateWithoutErrorHandling(e, t, r, n, i, o) {
            return this._styleExpression.evaluateWithoutErrorHandling(e, t, r, n, i, o);
          }
          evaluate(e, t, r, n, i, o) {
            return this._styleExpression.evaluate(e, t, r, n, i, o);
          }
          interpolationFactor(e, t, r) {
            return this.interpolationType ? mr.interpolationFactor(this.interpolationType, e, t, r) : 0;
          }
        }
        function Wr(e) {
          return void 0 !== e._styleExpression;
        }
        function Zr(e, t) {
          var r,
            n,
            i,
            e = qr(e, t);
          return "error" === e.result ? e : (r = lr(n = e.value.expression)) || Or(t) ? (i = ur(n, ["zoom"])) || Mr(t) ? (n = function r(e) {
            let n = null;
            if (e instanceof vr) n = r(e.result);else if (e instanceof yr) {
              for (const t of e.args) if (n = r(t)) break;
            } else (e instanceof dr || e instanceof mr) && e.input instanceof or && "zoom" === e.input.name && (n = e);
            if (n instanceof Fe) return n;
            e.eachChild(e => {
              const t = r(e);
              t instanceof Fe ? n = t : !n && t ? n = new Fe("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : n && t && n !== t && (n = new Fe("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            });
            return n;
          }(n)) || i ? n instanceof Fe ? Rr([n]) : n instanceof mr && !kr(t) ? Rr([new Fe("", '"interpolate" expressions cannot be used with this property')]) : n ? (i = n instanceof mr ? n.interpolation : void 0, Dr(r ? new Kr("camera", e.value, n.labels, i) : new Kr("composite", e.value, n.labels, i))) : Dr(r ? new Vr("constant", e.value) : new Vr("source", e.value)) : Rr([new Fe("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]) : Rr([new Fe("", "zoom expressions not supported")]) : Rr([new Fe("", "data expressions not supported")]);
        }
        class Xr {
          constructor(e, t) {
            this._parameters = e, this._specification = t, Ue(this, Fr(this._parameters, this._specification));
          }
          static deserialize(e) {
            return new Xr(e._parameters, e._specification);
          }
          static serialize(e) {
            return {
              _parameters: e._parameters,
              _specification: e._specification
            };
          }
        }
        function Jr(t, r) {
          if (Lr(t)) return new Xr(t, r);
          if (Gr(t)) {
            var e = Zr(t, r);
            if ("error" === e.result) throw new Error(e.value.map(e => e.key + ": " + e.message).join(", "));
            return e.value;
          }
          {
            let e = t;
            return "color" === r.type && "string" == typeof t ? e = g.parse(t) : "padding" !== r.type || "number" != typeof t && !Array.isArray(t) ? "variableAnchorOffsetCollection" === r.type && Array.isArray(t) && (e = It.parse(t)) : e = Ct.parse(t), {
              kind: "constant",
              evaluate: () => e
            };
          }
        }
        function Qr(e) {
          return "color" === e.type && Lr(e.default) ? new g(0, 0, 0, 0) : "color" === e.type ? g.parse(e.default) || null : "padding" === e.type ? Ct.parse(e.default) || null : "variableAnchorOffsetCollection" === e.type ? It.parse(e.default) || null : void 0 === e.default ? null : e.default;
        }
        function en(e) {
          if (!0 === e || !1 === e) return 1;
          if (Array.isArray(e) && 0 !== e.length) switch (e[0]) {
            case "has":
              return 2 <= e.length && "$id" !== e[1] && "$type" !== e[1];
            case "in":
              return 3 <= e.length && ("string" != typeof e[1] || Array.isArray(e[2]));
            case "!in":
            case "!has":
            case "none":
              return;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== e.length || Array.isArray(e[1]) || Array.isArray(e[2]);
            case "any":
            case "all":
              for (const t of e.slice(1)) if (!en(t) && "boolean" != typeof t) return;
              return 1;
            default:
              return 1;
          }
        }
        const tn = {
          type: "boolean",
          default: !1,
          transition: !1,
          "property-type": "data-driven",
          expression: {
            interpolated: !1,
            parameters: ["zoom", "feature"]
          }
        };
        function rn(e) {
          if (null == e) return {
            filter: () => !0,
            needGeometry: !1
          };
          const n = qr(e = en(e) ? e : on(e), tn);
          if ("error" === n.result) throw new Error(n.value.map(e => e.key + ": " + e.message).join(", "));
          return {
            filter: (e, t, r) => n.value.evaluate(e, t, {}, r),
            needGeometry: function t(r) {
              if (!Array.isArray(r)) return !1;
              if ("within" === r[0]) return !0;
              for (let e = 1; e < r.length; e++) if (t(r[e])) return !0;
              return !1;
            }(e)
          };
        }
        function nn(e, t) {
          return e < t ? -1 : t < e ? 1 : 0;
        }
        function on(e) {
          var t, r;
          return !e || (t = e[0], e.length <= 1 ? "any" !== t : "==" === t ? an(e[1], e[2], "==") : "!=" === t ? cn(an(e[1], e[2], "==")) : "<" === t || ">" === t || "<=" === t || ">=" === t ? an(e[1], e[2], t) : "any" === t ? (r = e.slice(1), ["any"].concat(r.map(on))) : "all" === t ? ["all"].concat(e.slice(1).map(on)) : "none" === t ? ["all"].concat(e.slice(1).map(on).map(cn)) : "in" === t ? sn(e[1], e.slice(2)) : "!in" === t ? cn(sn(e[1], e.slice(2))) : "has" === t ? ln(e[1]) : "!has" === t ? cn(ln(e[1])) : "within" !== t || e);
        }
        function an(e, t, r) {
          switch (e) {
            case "$type":
              return ["filter-type-" + r, t];
            case "$id":
              return ["filter-id-" + r, t];
            default:
              return ["filter-" + r, e, t];
          }
        }
        function sn(e, t) {
          if (0 === t.length) return !1;
          switch (e) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return 200 < t.length && !t.some(e => typeof e != typeof t[0]) ? ["filter-in-large", e, ["literal", t.sort(nn)]] : ["filter-in-small", e, ["literal", t]];
          }
        }
        function ln(e) {
          switch (e) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", e];
          }
        }
        function cn(e) {
          return ["!", e];
        }
        function un(e) {
          let t = "";
          for (const r of Pe) t += "/" + function t(r) {
            var e = typeof r;
            if ("number" == e || "boolean" == e || "string" == e || null == r) return JSON.stringify(r);
            if (Array.isArray(r)) {
              let e = "[";
              for (const o of r) e += t(o) + ",";
              return e + "]";
            }
            var n = Object.keys(r).sort();
            let i = "{";
            for (let e = 0; e < n.length; e++) i += `${JSON.stringify(n[e])}:${t(r[n[e]])},`;
            return i + "}";
          }(e[r]);
          return t;
        }
        function hn(e) {
          var t = e.key,
            e = e.value;
          return e ? [new p(t, e, "constants have been deprecated as of v8")] : [];
        }
        function b(e) {
          return e instanceof Number || e instanceof String || e instanceof Boolean ? e.valueOf() : e;
        }
        function dn(e) {
          if (Array.isArray(e)) return e.map(dn);
          if (e instanceof Object && !(e instanceof Number || e instanceof String || e instanceof Boolean)) {
            var t = {};
            for (const r in e) t[r] = dn(e[r]);
            return t;
          }
          return b(e);
        }
        function pn(e) {
          var t = e.key,
            r = e.value,
            n = e.valueSpec || {},
            i = e.objectElementValidators || {},
            o = e.style,
            a = e.styleSpec,
            s = e.validateSpec;
          let l = [];
          e = y(r);
          if ("object" !== e) return [new p(t, r, `object expected, ${e} found`)];
          for (const h in r) {
            var c = h.split(".")[0],
              u = n[c] || n["*"];
            let e;
            if (i[c]) e = i[c];else if (n[c]) e = s;else if (i["*"]) e = i["*"];else {
              if (!n["*"]) {
                l.push(new p(t, r[h], `unknown property "${h}"`));
                continue;
              }
              e = s;
            }
            l = l.concat(e({
              key: (t && t + ".") + h,
              value: r[h],
              valueSpec: u,
              style: o,
              styleSpec: a,
              object: r,
              objectKey: h,
              validateSpec: s
            }, r));
          }
          for (const d in n) i[d] || n[d].required && void 0 === n[d].default && void 0 === r[d] && l.push(new p(t, r, `missing required property "${d}"`));
          return l;
        }
        function fn(t) {
          var r = t.value,
            e = t.valueSpec,
            n = t.validateSpec,
            i = t.style,
            o = t.styleSpec,
            a = t.key,
            s = t.arrayElementValidator || n;
          if ("array" !== y(r)) return [new p(a, r, `array expected, ${y(r)} found`)];
          if (e.length && r.length !== e.length) return [new p(a, r, `array length ${e.length} expected, length ${r.length} found`)];
          if (e["min-length"] && r.length < e["min-length"]) return [new p(a, r, `array length at least ${e["min-length"]} expected, length ${r.length} found`)];
          let l = {
              type: e.value,
              values: e.values
            },
            c = (o.$version < 7 && (l.function = e.function), "object" === y(e.value) && (l = e.value), []);
          for (let e = 0; e < r.length; e++) c = c.concat(s({
            array: r,
            arrayIndex: e,
            value: r[e],
            valueSpec: l,
            validateSpec: t.validateSpec,
            style: i,
            styleSpec: o,
            key: `${a}[${e}]`
          }));
          return c;
        }
        function _n(e) {
          var t = e.key,
            r = e.value,
            e = e.valueSpec;
          let n = y(r);
          return "number" !== (n = "number" === n && r != r ? "NaN" : n) ? [new p(t, r, `number expected, ${n} found`)] : "minimum" in e && r < e.minimum ? [new p(t, r, r + " is less than the minimum value " + e.minimum)] : "maximum" in e && r > e.maximum ? [new p(t, r, r + " is greater than the maximum value " + e.maximum)] : [];
        }
        function mn(e) {
          const i = e.valueSpec,
            o = b(e.value.type);
          let a,
            s = {},
            l,
            c;
          var t = "categorical" !== o && void 0 === e.value.property,
            r = !t;
          const u = "array" === y(e.value.stops) && "array" === y(e.value.stops[0]) && "object" === y(e.value.stops[0][0]);
          var n = pn({
            key: e.key,
            value: e.value,
            valueSpec: e.styleSpec.function,
            validateSpec: e.validateSpec,
            style: e.style,
            styleSpec: e.styleSpec,
            objectElementValidators: {
              stops: function (e) {
                if ("identity" === o) return [new p(e.key, e.value, 'identity function may not have a "stops" property')];
                let t = [];
                var r = e.value;
                t = t.concat(fn({
                  key: e.key,
                  value: r,
                  valueSpec: e.valueSpec,
                  validateSpec: e.validateSpec,
                  style: e.style,
                  styleSpec: e.styleSpec,
                  arrayElementValidator: h
                })), "array" === y(r) && 0 === r.length && t.push(new p(e.key, r, "array must have at least one stop"));
                return t;
              },
              default: function (e) {
                return e.validateSpec({
                  key: e.key,
                  value: e.value,
                  valueSpec: i,
                  validateSpec: e.validateSpec,
                  style: e.style,
                  styleSpec: e.styleSpec
                });
              }
            }
          });
          return "identity" === o && t && n.push(new p(e.key, e.value, 'missing required property "property"')), "identity" === o || e.value.stops || n.push(new p(e.key, e.value, 'missing required property "stops"')), "exponential" === o && e.valueSpec.expression && !kr(e.valueSpec) && n.push(new p(e.key, e.value, "exponential functions not supported")), 8 <= e.styleSpec.$version && (r && !Or(e.valueSpec) ? n.push(new p(e.key, e.value, "property functions not supported")) : t && !Mr(e.valueSpec) && n.push(new p(e.key, e.value, "zoom functions not supported"))), "categorical" !== o && !u || void 0 !== e.value.property || n.push(new p(e.key, e.value, '"property" property is required')), n;
          function h(e) {
            let t = [];
            var r = e.value,
              n = e.key;
            if ("array" !== y(r)) return [new p(n, r, `array expected, ${y(r)} found`)];
            if (2 !== r.length) return [new p(n, r, `array length 2 expected, length ${r.length} found`)];
            if (u) {
              if ("object" !== y(r[0])) return [new p(n, r, `object expected, ${y(r[0])} found`)];
              if (void 0 === r[0].zoom) return [new p(n, r, "object stop key must have zoom")];
              if (void 0 === r[0].value) return [new p(n, r, "object stop key must have value")];
              if (c && c > b(r[0].zoom)) return [new p(n, r[0].zoom, "stop zoom values must appear in ascending order")];
              b(r[0].zoom) !== c && (c = b(r[0].zoom), l = void 0, s = {}), t = t.concat(pn({
                key: n + "[0]",
                value: r[0],
                valueSpec: {
                  zoom: {}
                },
                validateSpec: e.validateSpec,
                style: e.style,
                styleSpec: e.styleSpec,
                objectElementValidators: {
                  zoom: _n,
                  value: d
                }
              }));
            } else t = t.concat(d({
              key: n + "[0]",
              value: r[0],
              valueSpec: {},
              validateSpec: e.validateSpec,
              style: e.style,
              styleSpec: e.styleSpec
            }, r));
            return Gr(dn(r[1])) ? t.concat([new p(n + "[1]", r[1], "expressions are not allowed in function stops.")]) : t.concat(e.validateSpec({
              key: n + "[1]",
              value: r[1],
              valueSpec: i,
              validateSpec: e.validateSpec,
              style: e.style,
              styleSpec: e.styleSpec
            }));
          }
          function d(t, r) {
            var n = y(t.value),
              e = b(t.value),
              r = null !== t.value ? t.value : r;
            if (a) {
              if (n !== a) return [new p(t.key, r, n + " stop domain type must match previous stop domain type " + a)];
            } else a = n;
            if ("number" !== n && "string" !== n && "boolean" !== n) return [new p(t.key, r, "stop domain value must be a number, string, or boolean")];
            if ("number" === n || "categorical" === o) return "categorical" !== o || "number" !== n || isFinite(e) && Math.floor(e) === e ? "categorical" !== o && "number" === n && void 0 !== l && e < l ? [new p(t.key, r, "stop domain values must appear in ascending order")] : (l = e, "categorical" === o && e in s ? [new p(t.key, r, "stop domain values must be unique")] : (s[e] = !0, [])) : [new p(t.key, r, "integer expected, found " + e)];
            {
              let e = `number expected, ${n} found`;
              return Or(i) && void 0 === o && (e += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new p(t.key, r, e)];
            }
          }
        }
        function gn(t) {
          var e = ("property" === t.expressionContext ? Zr : qr)(dn(t.value), t.valueSpec);
          if ("error" === e.result) return e.value.map(e => new p("" + t.key + e.key, t.value, e.message));
          e = e.value.expression || e.value._styleExpression.expression;
          if ("property" === t.expressionContext && "text-font" === t.propertyKey && !e.outputDefined()) return [new p(t.key, t.value, `Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t.expressionContext && "layout" === t.propertyType && !cr(e)) return [new p(t.key, t.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t.expressionContext && !cr(e)) return [new p(t.key, t.value, '"feature-state" data expressions are not supported with filters.')];
          if (t.expressionContext && 0 === t.expressionContext.indexOf("cluster")) {
            if (!ur(e, ["zoom", "feature-state"])) return [new p(t.key, t.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t.expressionContext && !lr(e)) return [new p(t.key, t.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function yn(e) {
          var t = e.key,
            r = e.value,
            e = e.valueSpec,
            n = [];
          return Array.isArray(e.values) ? -1 === e.values.indexOf(b(r)) && n.push(new p(t, r, `expected one of [${e.values.join(", ")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(e.values).indexOf(b(r)) && n.push(new p(t, r, `expected one of [${Object.keys(e.values).join(", ")}], ${JSON.stringify(r)} found`)), n;
        }
        function vn(e) {
          return en(dn(e.value)) ? gn(Ue({}, e, {
            expressionContext: "filter",
            valueSpec: {
              value: "boolean"
            }
          })) : function t(r) {
            const n = r.value;
            const i = r.key;
            if ("array" !== y(n)) return [new p(i, n, `array expected, ${y(n)} found`)];
            const o = r.styleSpec;
            let a;
            let s = [];
            if (n.length < 1) return [new p(i, n, "filter array must have at least 1 element")];
            s = s.concat(yn({
              key: i + "[0]",
              value: n[0],
              valueSpec: o.filter_operator,
              style: r.style,
              styleSpec: r.styleSpec
            }));
            switch (b(n[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                2 <= n.length && "$type" === b(n[1]) && s.push(new p(i, n, `"$type" cannot be use with operator "${n[0]}"`));
              case "==":
              case "!=":
                3 !== n.length && s.push(new p(i, n, `filter array for operator "${n[0]}" must have 3 elements`));
              case "in":
              case "!in":
                2 <= n.length && "string" !== (a = y(n[1])) && s.push(new p(i + "[1]", n[1], `string expected, ${a} found`));
                for (let e = 2; e < n.length; e++) a = y(n[e]), "$type" === b(n[1]) ? s = s.concat(yn({
                  key: `${i}[${e}]`,
                  value: n[e],
                  valueSpec: o.geometry_type,
                  style: r.style,
                  styleSpec: r.styleSpec
                })) : "string" !== a && "number" !== a && "boolean" !== a && s.push(new p(`${i}[${e}]`, n[e], `string, number, or boolean expected, ${a} found`));
                break;
              case "any":
              case "all":
              case "none":
                for (let e = 1; e < n.length; e++) s = s.concat(t({
                  key: `${i}[${e}]`,
                  value: n[e],
                  style: r.style,
                  styleSpec: r.styleSpec
                }));
                break;
              case "has":
              case "!has":
                a = y(n[1]), 2 !== n.length ? s.push(new p(i, n, `filter array for "${n[0]}" operator must have 2 elements`)) : "string" !== a && s.push(new p(i + "[1]", n[1], `string expected, ${a} found`));
                break;
              case "within":
                a = y(n[1]), 2 !== n.length ? s.push(new p(i, n, `filter array for "${n[0]}" operator must have 2 elements`)) : "object" !== a && s.push(new p(i + "[1]", n[1], `object expected, ${a} found`));
            }
            return s;
          }(e);
        }
        function En(e, t) {
          var r = e.key,
            n = e.validateSpec,
            i = e.style,
            o = e.styleSpec,
            a = e.value,
            s = e.objectKey,
            l = o[t + "_" + e.layerType];
          if (!l) return [];
          var c = s.match(/^(.*)-transition$/);
          if ("paint" === t && c && l[c[1]] && l[c[1]].transition) return n({
            key: r,
            value: a,
            valueSpec: o.transition,
            style: i,
            styleSpec: o
          });
          c = e.valueSpec || l[s];
          if (!c) return [new p(r, a, `unknown property "${s}"`)];
          let u;
          return "string" === y(a) && Or(c) && !c.tokens && (u = /^{([^}]+)}$/.exec(a)) ? [new p(r, a, `"${s}" does not support interpolation syntax
` + `Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(u[1])} }\`.`)] : (l = [], "symbol" === e.layerType && ("text-field" === s && i && !i.glyphs && l.push(new p(r, a, 'use of "text-field" requires a style "glyphs" property')), "text-font" === s) && Lr(dn(a)) && "identity" === b(a.type) && l.push(new p(r, a, '"text-font" does not support identity functions')), l.concat(n({
            key: e.key,
            value: a,
            valueSpec: c,
            style: i,
            styleSpec: o,
            expressionContext: "property",
            propertyType: t,
            propertyKey: s
          })));
        }
        function bn(e) {
          return En(e, "paint");
        }
        function wn(e) {
          return En(e, "layout");
        }
        function Tn(t) {
          let r = [];
          const n = t.value,
            i = t.key;
          var e,
            o,
            a = t.style;
          const s = t.styleSpec;
          n.type || n.ref || r.push(new p(i, n, 'either "type" or "ref" is required'));
          let l = b(n.type);
          const c = b(n.ref);
          if (n.id) {
            var u = b(n.id);
            for (let e = 0; e < t.arrayIndex; e++) {
              var h = a.layers[e];
              b(h.id) === u && r.push(new p(i, n.id, `duplicate layer id "${n.id}", previously used at line ` + h.id.__line__));
            }
          }
          if ("ref" in n) {
            ["type", "source", "source-layer", "filter", "layout"].forEach(e => {
              e in n && r.push(new p(i, n[e], `"${e}" is prohibited for ref layers`));
            });
            let t;
            a.layers.forEach(e => {
              b(e.id) === c && (t = e);
            }), t ? t.ref ? r.push(new p(i, n.ref, "ref cannot reference another ref layer")) : l = b(t.type) : r.push(new p(i, n.ref, `ref layer "${c}" not found`));
          } else "background" !== l && (n.source ? (o = (e = a.sources && a.sources[n.source]) && b(e.type), e ? "vector" === o && "raster" === l ? r.push(new p(i, n.source, `layer "${n.id}" requires a raster source`)) : "raster-dem" !== o && "hillshade" === l ? r.push(new p(i, n.source, `layer "${n.id}" requires a raster-dem source`)) : "raster" === o && "raster" !== l ? r.push(new p(i, n.source, `layer "${n.id}" requires a vector source`)) : "vector" !== o || n["source-layer"] ? "raster-dem" === o && "hillshade" !== l ? r.push(new p(i, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== l || !n.paint || !n.paint["line-gradient"] || "geojson" === o && e.lineMetrics || r.push(new p(i, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : r.push(new p(i, n, `layer "${n.id}" must specify a "source-layer"`)) : r.push(new p(i, n.source, `source "${n.source}" not found`))) : r.push(new p(i, n, 'missing required property "source"')));
          return r = r.concat(pn({
            key: i,
            value: n,
            valueSpec: s.layer,
            style: t.style,
            styleSpec: t.styleSpec,
            validateSpec: t.validateSpec,
            objectElementValidators: {
              "*"() {
                return [];
              },
              type() {
                return t.validateSpec({
                  key: i + ".type",
                  value: n.type,
                  valueSpec: s.layer.type,
                  style: t.style,
                  styleSpec: t.styleSpec,
                  validateSpec: t.validateSpec,
                  object: n,
                  objectKey: "type"
                });
              },
              filter: vn,
              layout(e) {
                return pn({
                  layer: n,
                  key: e.key,
                  value: e.value,
                  style: e.style,
                  styleSpec: e.styleSpec,
                  validateSpec: e.validateSpec,
                  objectElementValidators: {
                    "*"(e) {
                      return wn(Ue({
                        layerType: l
                      }, e));
                    }
                  }
                });
              },
              paint(e) {
                return pn({
                  layer: n,
                  key: e.key,
                  value: e.value,
                  style: e.style,
                  styleSpec: e.styleSpec,
                  validateSpec: e.validateSpec,
                  objectElementValidators: {
                    "*"(e) {
                      return bn(Ue({
                        layerType: l
                      }, e));
                    }
                  }
                });
              }
            }
          }));
        }
        function Sn(e) {
          var t = e.value,
            e = e.key,
            r = y(t);
          return "string" !== r ? [new p(e, t, `string expected, ${r} found`)] : [];
        }
        const xn = {
          promoteId: function ({
            key: e,
            value: t
          }) {
            {
              if ("string" === y(t)) return Sn({
                key: e,
                value: t
              });
              var r = [];
              for (const n in t) r.push(...Sn({
                key: e + "." + n,
                value: t[n]
              }));
              return r;
            }
          }
        };
        function Cn(e) {
          var t = e.value,
            r = e.key,
            n = e.styleSpec,
            i = e.style,
            o = e.validateSpec;
          if (!t.type) return [new p(r, t, '"type" is required')];
          var a = b(t.type);
          let s;
          switch (a) {
            case "vector":
            case "raster":
              return s = pn({
                key: r,
                value: t,
                valueSpec: n["source_" + a.replace("-", "_")],
                style: e.style,
                styleSpec: n,
                objectElementValidators: xn,
                validateSpec: o
              });
            case "raster-dem":
              return s = function (e) {
                var t = null != (s = e.sourceName) ? s : "",
                  r = e.value,
                  n = e.styleSpec,
                  i = n.source_raster_dem,
                  o = e.style;
                let a = [];
                var s = y(r);
                if (void 0 !== r) if ("object" !== s) a.push(new p("source_raster_dem", r, `object expected, ${s} found`));else {
                  var l = "custom" === b(r.encoding),
                    c = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                    u = e.value.encoding ? `"${e.value.encoding}"` : "Default";
                  for (const h in r) !l && c.includes(h) ? a.push(new p(h, r[h], `In "${t}": "${h}" is only valid when "encoding" is set to "custom". ${u} encoding found`)) : i[h] ? a = a.concat(e.validateSpec({
                    key: h,
                    value: r[h],
                    valueSpec: i[h],
                    validateSpec: e.validateSpec,
                    style: o,
                    styleSpec: n
                  })) : a.push(new p(h, r[h], `unknown property "${h}"`));
                }
                return a;
              }({
                sourceName: r,
                value: t,
                style: e.style,
                styleSpec: n,
                validateSpec: o
              });
            case "geojson":
              if (s = pn({
                key: r,
                value: t,
                valueSpec: n.source_geojson,
                style: i,
                styleSpec: n,
                validateSpec: o,
                objectElementValidators: xn
              }), t.cluster) for (const u in t.clusterProperties) {
                var [l, c] = t.clusterProperties[u],
                  l = "string" == typeof l ? [l, ["accumulated"], ["get", u]] : l;
                s.push(...gn({
                  key: `${r}.${u}.map`,
                  value: c,
                  validateSpec: o,
                  expressionContext: "cluster-map"
                })), s.push(...gn({
                  key: `${r}.${u}.reduce`,
                  value: l,
                  validateSpec: o,
                  expressionContext: "cluster-reduce"
                }));
              }
              return s;
            case "video":
              return pn({
                key: r,
                value: t,
                valueSpec: n.source_video,
                style: i,
                validateSpec: o,
                styleSpec: n
              });
            case "image":
              return pn({
                key: r,
                value: t,
                valueSpec: n.source_image,
                style: i,
                validateSpec: o,
                styleSpec: n
              });
            case "canvas":
              return [new p(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return yn({
                key: r + ".type",
                value: t.type,
                valueSpec: {
                  values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                },
                style: i,
                validateSpec: o,
                styleSpec: n
              });
          }
        }
        function An(e) {
          var t = e.value,
            r = e.styleSpec,
            n = r.light,
            i = e.style;
          let o = [];
          var a = y(t);
          if (void 0 !== t) {
            if ("object" !== a) return o = o.concat([new p("light", t, `object expected, ${a} found`)]);
            for (const l in t) {
              var s = l.match(/^(.*)-transition$/);
              o = s && n[s[1]] && n[s[1]].transition ? o.concat(e.validateSpec({
                key: l,
                value: t[l],
                valueSpec: r.transition,
                validateSpec: e.validateSpec,
                style: i,
                styleSpec: r
              })) : n[l] ? o.concat(e.validateSpec({
                key: l,
                value: t[l],
                valueSpec: n[l],
                validateSpec: e.validateSpec,
                style: i,
                styleSpec: r
              })) : o.concat([new p(l, t[l], `unknown property "${l}"`)]);
            }
          }
          return o;
        }
        function In(e) {
          var t = e.value,
            r = e.styleSpec,
            n = r.terrain,
            i = e.style;
          let o = [];
          var a = y(t);
          if (void 0 !== t) {
            if ("object" !== a) return o = o.concat([new p("terrain", t, `object expected, ${a} found`)]);
            for (const s in t) o = n[s] ? o.concat(e.validateSpec({
              key: s,
              value: t[s],
              valueSpec: n[s],
              validateSpec: e.validateSpec,
              style: i,
              styleSpec: r
            })) : o.concat([new p(s, t[s], `unknown property "${s}"`)]);
          }
          return o;
        }
        function Nn(e) {
          let t = [];
          var r = e.value,
            n = e.key;
          if (Array.isArray(r)) {
            var i = [],
              o = [];
            for (const a in r) r[a].id && i.includes(r[a].id) && t.push(new p(n, r, `all the sprites' ids must be unique, but ${r[a].id} is duplicated`)), i.push(r[a].id), r[a].url && o.includes(r[a].url) && t.push(new p(n, r, `all the sprites' URLs must be unique, but ${r[a].url} is duplicated`)), o.push(r[a].url), t = t.concat(pn({
              key: `${n}[${a}]`,
              value: r[a],
              valueSpec: {
                id: {
                  type: "string",
                  required: !0
                },
                url: {
                  type: "string",
                  required: !0
                }
              },
              validateSpec: e.validateSpec
            }));
            return t;
          }
          return Sn({
            key: n,
            value: r
          });
        }
        const Pn = {
          "*"() {
            return [];
          },
          array: fn,
          boolean: function (e) {
            var t = e.value,
              e = e.key,
              r = y(t);
            return "boolean" !== r ? [new p(e, t, `boolean expected, ${r} found`)] : [];
          },
          number: _n,
          color: function (e) {
            var t = e.key,
              r = y(e = e.value);
            return "string" !== r ? [new p(t, e, `color expected, ${r} found`)] : g.parse(String(e)) ? [] : [new p(t, e, `color expected, "${e}" found`)];
          },
          constants: hn,
          enum: yn,
          filter: vn,
          function: mn,
          layer: Tn,
          object: pn,
          source: Cn,
          light: An,
          terrain: In,
          string: Sn,
          formatted: function (e) {
            return 0 === Sn(e).length ? [] : gn(e);
          },
          resolvedImage: function (e) {
            return 0 === Sn(e).length ? [] : gn(e);
          },
          padding: function (r) {
            var n = r.key,
              i = r.value;
            if ("array" !== y(i)) return _n({
              key: n,
              value: i,
              valueSpec: {}
            });
            {
              if (i.length < 1 || 4 < i.length) return [new p(n, i, `padding requires 1 to 4 values; ${i.length} values found`)];
              var o = {
                type: "number"
              };
              let t = [];
              for (let e = 0; e < i.length; e++) t = t.concat(r.validateSpec({
                key: `${n}[${e}]`,
                value: i[e],
                validateSpec: r.validateSpec,
                valueSpec: o
              }));
              return t;
            }
          },
          variableAnchorOffsetCollection: function (t) {
            var r = t.key,
              n = t.value,
              e = y(n),
              i = t.styleSpec;
            if ("array" !== e || n.length < 1 || n.length % 2 != 0) return [new p(r, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let o = [];
            for (let e = 0; e < n.length; e += 2) o = (o = o.concat(yn({
              key: `${r}[${e}]`,
              value: n[e],
              valueSpec: i.layout_symbol["text-anchor"]
            }))).concat(fn({
              key: `${r}[${e + 1}]`,
              value: n[e + 1],
              valueSpec: {
                length: 2,
                value: "number"
              },
              validateSpec: t.validateSpec,
              style: t.style,
              styleSpec: i
            }));
            return o;
          },
          sprite: Nn
        };
        function Dn(e) {
          var t = e.value,
            r = e.valueSpec,
            n = e.styleSpec;
          return e.validateSpec = Dn, r.expression && Lr(b(t)) ? mn(e) : r.expression && Gr(dn(t)) ? gn(e) : r.type && Pn[r.type] ? Pn[r.type](e) : pn(Ue({}, e, {
            valueSpec: r.type ? n[r.type] : r
          }));
        }
        function Rn(e) {
          var t = e.value,
            r = e.key,
            e = Sn(e);
          return e.length || (-1 === t.indexOf("{fontstack}") && e.push(new p(r, t, '"glyphs" url must include a "{fontstack}" token')), -1 === t.indexOf("{range}") && e.push(new p(r, t, '"glyphs" url must include a "{range}" token'))), e;
        }
        function On(e, t = o) {
          let r = [];
          return r = r.concat(Dn({
            key: "",
            value: e,
            valueSpec: t.$root,
            styleSpec: t,
            style: e,
            validateSpec: Dn,
            objectElementValidators: {
              glyphs: Rn,
              "*"() {
                return [];
              }
            }
          })), kn(r = e.constants ? r.concat(hn({
            key: "constants",
            value: e.constants,
            style: e,
            styleSpec: t,
            validateSpec: Dn
          })) : r);
        }
        function Mn(t) {
          return function (e) {
            return t({
              ...e,
              validateSpec: Dn
            });
          };
        }
        function kn(e) {
          return [].concat(e).sort((e, t) => e.line - t.line);
        }
        function Ln(t) {
          return function (...e) {
            return kn(t.apply(this, e));
          };
        }
        On.source = Ln(Mn(Cn)), On.sprite = Ln(Mn(Nn)), On.glyphs = Ln(Mn(Rn)), On.light = Ln(Mn(An)), On.terrain = Ln(Mn(In)), On.layer = Ln(Mn(Tn)), On.filter = Ln(Mn(vn)), On.paintProperty = Ln(Mn(bn)), On.layoutProperty = Ln(Mn(wn));
        const Un = On;
        le = Un.light;
        const Fn = Un.paintProperty,
          Bn = Un.layoutProperty;
        function $n(e, t) {
          let r = !1;
          if (t && t.length) for (const n of t) e.fire(new Ie(new Error(n.message))), r = !0;
          return r;
        }
        class zn {
          constructor(e, t, r) {
            var n = this.cells = [];
            if (e instanceof ArrayBuffer) {
              this.arrayBuffer = e;
              var i = new Int32Array(this.arrayBuffer);
              e = i[0], t = i[1], r = i[2], this.d = t + 2 * r;
              for (let e = 0; e < this.d * this.d; e++) {
                var o = i[3 + e],
                  a = i[3 + e + 1];
                n.push(o === a ? null : i.subarray(o, a));
              }
              var s = i[3 + n.length],
                l = i[3 + n.length + 1];
              this.keys = i.subarray(s, l), this.bboxes = i.subarray(l), this.insert = this._insertReadonly;
            } else {
              this.d = t + 2 * r;
              for (let e = 0; e < this.d * this.d; e++) n.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = t, this.extent = e, this.padding = r, this.scale = t / e, this.uid = 0;
            s = r / t * e;
            this.min = -s, this.max = e + s;
          }
          insert(e, t, r, n, i) {
            this._forEachCell(t, r, n, i, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e), this.bboxes.push(t), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(e, t, r, n, i, o) {
            this.cells[i].push(o);
          }
          query(e, t, r, n, i) {
            var o = this.min,
              a = this.max;
            return e <= o && t <= o && a <= r && a <= n && !i ? Array.prototype.slice.call(this.keys) : (this._forEachCell(e, t, r, n, this._queryCell, o = [], {}, i), o);
          }
          _queryCell(t, r, n, i, e, o, a, s) {
            var l = this.cells[e];
            if (null !== l) {
              var c = this.keys,
                u = this.bboxes;
              for (let e = 0; e < l.length; e++) {
                var h,
                  d = l[e];
                void 0 === a[d] && (h = 4 * d, (s ? s(u[0 + h], u[1 + h], u[2 + h], u[3 + h]) : t <= u[2 + h] && r <= u[3 + h] && n >= u[0 + h] && i >= u[1 + h]) ? (a[d] = !0, o.push(c[d])) : a[d] = !1);
              }
            }
          }
          _forEachCell(r, n, i, o, a, s, l, c) {
            var e = this._convertToCellCoord(r),
              u = this._convertToCellCoord(n),
              h = this._convertToCellCoord(i),
              d = this._convertToCellCoord(o);
            for (let t = e; t <= h; t++) for (let e = u; e <= d; e++) {
              var p = this.d * e + t;
              if ((!c || c(this._convertFromCellCoord(t), this._convertFromCellCoord(e), this._convertFromCellCoord(t + 1), this._convertFromCellCoord(e + 1))) && a.call(this, r, n, i, o, p, s, l, c)) return;
            }
          }
          _convertFromCellCoord(e) {
            return (e - this.padding) / this.scale;
          }
          _convertToCellCoord(e) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            var t = this.cells,
              e = 3 + this.cells.length + 1 + 1;
            let r = 0;
            for (let e = 0; e < this.cells.length; e++) r += this.cells[e].length;
            var n = new Int32Array(e + r + this.keys.length + this.bboxes.length);
            n[0] = this.extent, n[1] = this.n, n[2] = this.padding;
            let i = e;
            for (let e = 0; e < t.length; e++) {
              var o = t[e];
              n[3 + e] = i, n.set(o, i), i += o.length;
            }
            return n[3 + t.length] = i, n.set(this.keys, i), i += this.keys.length, n[3 + t.length + 1] = i, n.set(this.bboxes, i), i += this.bboxes.length, n.buffer;
          }
          static serialize(e, t) {
            e = e.toArrayBuffer();
            return t && t.push(e), {
              buffer: e
            };
          }
          static deserialize(e) {
            return new zn(e.buffer);
          }
        }
        const Yn = {};
        function r(e, t, r = {}) {
          if (Yn[e]) throw new Error(e + " is already registered.");
          Object.defineProperty(t, "_classRegistryKey", {
            value: e,
            writeable: !1
          }), Yn[e] = {
            klass: t,
            omit: r.omit || [],
            shallow: r.shallow || []
          };
        }
        r("Object", Object), r("TransferableGridIndex", zn), r("Color", g), r("Error", Error), r("AJAXError", ge), r("ResolvedImage", Nt), r("StylePropertyFunction", Xr), r("StyleExpression", jr, {
          omit: ["_evaluator"]
        }), r("ZoomDependentExpression", Kr), r("ZoomConstantExpression", Vr), r("CompoundExpression", or, {
          omit: ["_evaluate"]
        });
        for (const Hu in Ar) Ar[Hu]._classRegistryKey || r("Expression_" + Hu, Ar[Hu]);
        function Hn(e) {
          return e && "undefined" != typeof ArrayBuffer && (e instanceof ArrayBuffer || e.constructor && "ArrayBuffer" === e.constructor.name);
        }
        function jn(e, t) {
          if (null == e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || e instanceof Boolean || e instanceof Number || e instanceof String || e instanceof Date || e instanceof RegExp || e instanceof Blob) return e;
          if (Hn(e)) return t && t.push(e), e;
          if (te(e)) return t && t.push(e), e;
          if (ArrayBuffer.isView(e)) return n = e, t && t.push(n.buffer), n;
          if (e instanceof ImageData) return t && t.push(e.data.buffer), e;
          if (Array.isArray(e)) {
            var r = [];
            for (const s of e) r.push(jn(s, t));
            return r;
          }
          if ("object" != typeof e) throw new Error("can't serialize object of type " + typeof e);
          var n = e.constructor,
            i = n._classRegistryKey;
          if (!i) throw new Error("can't serialize object of unregistered class");
          if (!Yn[i]) throw new Error(i + " is not registered.");
          var o,
            a = n.serialize ? n.serialize(e, t) : {};
          if (n.serialize) {
            if (t && a === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const l in e) !e.hasOwnProperty(l) || 0 <= Yn[i].omit.indexOf(l) || (o = e[l], a[l] = 0 <= Yn[i].shallow.indexOf(l) ? o : jn(o, t));
            e instanceof Error && (a.message = e.message);
          }
          if (a.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return "Object" !== i && (a.$name = i), a;
        }
        function Gn(e) {
          if (null == e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || e instanceof Boolean || e instanceof Number || e instanceof String || e instanceof Date || e instanceof RegExp || e instanceof Blob || Hn(e) || te(e) || ArrayBuffer.isView(e) || e instanceof ImageData) return e;
          if (Array.isArray(e)) return e.map(Gn);
          if ("object" != typeof e) throw new Error("can't deserialize object of type " + typeof e);
          var t = e.$name || "Object";
          if (!Yn[t]) throw new Error("can't deserialize unregistered class " + t);
          var r = Yn[t]["klass"];
          if (!r) throw new Error("can't deserialize unregistered class " + t);
          if (r.deserialize) return r.deserialize(e);
          var n,
            i = Object.create(r.prototype);
          for (const o of Object.keys(e)) "$name" !== o && (n = e[o], i[o] = 0 <= Yn[t].shallow.indexOf(o) ? n : Gn(n));
          return i;
        }
        class qn {
          constructor() {
            this.first = !0;
          }
          update(e, t) {
            var r = Math.floor(e);
            return this.first ? (this.first = !1, this.lastIntegerZoom = r, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = r, !0) : (this.lastFloorZoom > r ? (this.lastIntegerZoom = r + 1, this.lastIntegerZoomTime = t) : this.lastFloorZoom < r && (this.lastIntegerZoom = r, this.lastIntegerZoomTime = t), e !== this.lastZoom && (this.lastZoom = e, this.lastFloorZoom = r, !0));
          }
        }
        const ne = {
          "Latin-1 Supplement": e => 128 <= e && e <= 255,
          Arabic: e => 1536 <= e && e <= 1791,
          "Arabic Supplement": e => 1872 <= e && e <= 1919,
          "Arabic Extended-A": e => 2208 <= e && e <= 2303,
          "Hangul Jamo": e => 4352 <= e && e <= 4607,
          "Unified Canadian Aboriginal Syllabics": e => 5120 <= e && e <= 5759,
          Khmer: e => 6016 <= e && e <= 6143,
          "Unified Canadian Aboriginal Syllabics Extended": e => 6320 <= e && e <= 6399,
          "General Punctuation": e => 8192 <= e && e <= 8303,
          "Letterlike Symbols": e => 8448 <= e && e <= 8527,
          "Number Forms": e => 8528 <= e && e <= 8591,
          "Miscellaneous Technical": e => 8960 <= e && e <= 9215,
          "Control Pictures": e => 9216 <= e && e <= 9279,
          "Optical Character Recognition": e => 9280 <= e && e <= 9311,
          "Enclosed Alphanumerics": e => 9312 <= e && e <= 9471,
          "Geometric Shapes": e => 9632 <= e && e <= 9727,
          "Miscellaneous Symbols": e => 9728 <= e && e <= 9983,
          "Miscellaneous Symbols and Arrows": e => 11008 <= e && e <= 11263,
          "CJK Radicals Supplement": e => 11904 <= e && e <= 12031,
          "Kangxi Radicals": e => 12032 <= e && e <= 12255,
          "Ideographic Description Characters": e => 12272 <= e && e <= 12287,
          "CJK Symbols and Punctuation": e => 12288 <= e && e <= 12351,
          Hiragana: e => 12352 <= e && e <= 12447,
          Katakana: e => 12448 <= e && e <= 12543,
          Bopomofo: e => 12544 <= e && e <= 12591,
          "Hangul Compatibility Jamo": e => 12592 <= e && e <= 12687,
          Kanbun: e => 12688 <= e && e <= 12703,
          "Bopomofo Extended": e => 12704 <= e && e <= 12735,
          "CJK Strokes": e => 12736 <= e && e <= 12783,
          "Katakana Phonetic Extensions": e => 12784 <= e && e <= 12799,
          "Enclosed CJK Letters and Months": e => 12800 <= e && e <= 13055,
          "CJK Compatibility": e => 13056 <= e && e <= 13311,
          "CJK Unified Ideographs Extension A": e => 13312 <= e && e <= 19903,
          "Yijing Hexagram Symbols": e => 19904 <= e && e <= 19967,
          "CJK Unified Ideographs": e => 19968 <= e && e <= 40959,
          "Yi Syllables": e => 40960 <= e && e <= 42127,
          "Yi Radicals": e => 42128 <= e && e <= 42191,
          "Hangul Jamo Extended-A": e => 43360 <= e && e <= 43391,
          "Hangul Syllables": e => 44032 <= e && e <= 55215,
          "Hangul Jamo Extended-B": e => 55216 <= e && e <= 55295,
          "Private Use Area": e => 57344 <= e && e <= 63743,
          "CJK Compatibility Ideographs": e => 63744 <= e && e <= 64255,
          "Arabic Presentation Forms-A": e => 64336 <= e && e <= 65023,
          "Vertical Forms": e => 65040 <= e && e <= 65055,
          "CJK Compatibility Forms": e => 65072 <= e && e <= 65103,
          "Small Form Variants": e => 65104 <= e && e <= 65135,
          "Arabic Presentation Forms-B": e => 65136 <= e && e <= 65279,
          "Halfwidth and Fullwidth Forms": e => 65280 <= e && e <= 65519
        };
        function Vn(e) {
          for (const t of e) if (Wn(t.charCodeAt(0))) return !0;
          return !1;
        }
        function Kn(e) {
          for (const r of e) if (t = r.charCodeAt(0), ne.Arabic(t) || ne["Arabic Supplement"](t) || ne["Arabic Extended-A"](t) || ne["Arabic Presentation Forms-A"](t) || ne["Arabic Presentation Forms-B"](t)) return;
          var t;
          return 1;
        }
        function Wn(e) {
          return 746 === e || 747 === e || !(e < 4352) && (ne["Bopomofo Extended"](e) || ne.Bopomofo(e) || ne["CJK Compatibility Forms"](e) && !(65097 <= e && e <= 65103) || ne["CJK Compatibility Ideographs"](e) || ne["CJK Compatibility"](e) || ne["CJK Radicals Supplement"](e) || ne["CJK Strokes"](e) || !(!ne["CJK Symbols and Punctuation"](e) || 12296 <= e && e <= 12305 || 12308 <= e && e <= 12319 || 12336 === e) || ne["CJK Unified Ideographs Extension A"](e) || ne["CJK Unified Ideographs"](e) || ne["Enclosed CJK Letters and Months"](e) || ne["Hangul Compatibility Jamo"](e) || ne["Hangul Jamo Extended-A"](e) || ne["Hangul Jamo Extended-B"](e) || ne["Hangul Jamo"](e) || ne["Hangul Syllables"](e) || ne.Hiragana(e) || ne["Ideographic Description Characters"](e) || ne.Kanbun(e) || ne["Kangxi Radicals"](e) || ne["Katakana Phonetic Extensions"](e) || ne.Katakana(e) && 12540 !== e || !(!ne["Halfwidth and Fullwidth Forms"](e) || 65288 === e || 65289 === e || 65293 === e || 65306 <= e && e <= 65310 || 65339 === e || 65341 === e || 65343 === e || 65371 <= e && e <= 65503 || 65507 === e || 65512 <= e && e <= 65519) || !(!ne["Small Form Variants"](e) || 65112 <= e && e <= 65118 || 65123 <= e && e <= 65126) || ne["Unified Canadian Aboriginal Syllabics"](e) || ne["Unified Canadian Aboriginal Syllabics Extended"](e) || ne["Vertical Forms"](e) || ne["Yijing Hexagram Symbols"](e) || ne["Yi Syllables"](e) || !!ne["Yi Radicals"](e));
        }
        function Zn(e) {
          return !(Wn(e) || (e = e, ne["Latin-1 Supplement"](e) && (167 === e || 169 === e || 174 === e || 177 === e || 188 === e || 189 === e || 190 === e || 215 === e || 247 === e)) || ne["General Punctuation"](e) && (8214 === e || 8224 === e || 8225 === e || 8240 === e || 8241 === e || 8251 === e || 8252 === e || 8258 === e || 8263 === e || 8264 === e || 8265 === e || 8273 === e) || ne["Letterlike Symbols"](e) || ne["Number Forms"](e) || ne["Miscellaneous Technical"](e) && (8960 <= e && e <= 8967 || 8972 <= e && e <= 8991 || 8996 <= e && e <= 9e3 || 9003 === e || 9085 <= e && e <= 9114 || 9150 <= e && e <= 9165 || 9167 === e || 9169 <= e && e <= 9179 || 9186 <= e && e <= 9215) || ne["Control Pictures"](e) && 9251 !== e || ne["Optical Character Recognition"](e) || ne["Enclosed Alphanumerics"](e) || ne["Geometric Shapes"](e) || ne["Miscellaneous Symbols"](e) && !(9754 <= e && e <= 9759) || ne["Miscellaneous Symbols and Arrows"](e) && (11026 <= e && e <= 11055 || 11088 <= e && e <= 11097 || 11192 <= e && e <= 11243) || ne["CJK Symbols and Punctuation"](e) || ne.Katakana(e) || ne["Private Use Area"](e) || ne["CJK Compatibility Forms"](e) || ne["Small Form Variants"](e) || ne["Halfwidth and Fullwidth Forms"](e) || 8734 === e || 8756 === e || 8757 === e || 9984 <= e && e <= 10087 || 10102 <= e && e <= 10131 || 65532 === e || 65533 === e);
        }
        function Xn(e) {
          return 1424 <= e && e <= 2303 || ne["Arabic Presentation Forms-A"](e) || ne["Arabic Presentation Forms-B"](e);
        }
        function Jn(e, t) {
          for (const n of e) if (r = n.charCodeAt(0), !t && Xn(r) || 2304 <= r && r <= 3583 || 3840 <= r && r <= 4255 || ne.Khmer(r)) return !1;
          var r;
          return !0;
        }
        const Qn = {
          unavailable: "unavailable",
          deferred: "deferred",
          loading: "loading",
          loaded: "loaded",
          error: "error"
        };
        let ei = null,
          n = Qn.unavailable,
          ti = null;
        const ri = function (e) {
          e && "string" == typeof e && -1 < e.indexOf("NetworkError") && (n = Qn.error), ei && ei(e);
        };
        function ni() {
          oi.fire(new Ae("pluginStateChange", {
            pluginStatus: n,
            pluginURL: ti
          }));
        }
        function ii() {
          return n;
        }
        const oi = new Ne();
        function ai() {
          if (n !== Qn.deferred || !ti) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          n = Qn.loading, ni(), ti && Te({
            url: ti
          }, e => {
            e ? ri(e) : (n = Qn.loaded, ni());
          });
        }
        const si = {
          applyArabicShaping: null,
          processBidirectionalText: null,
          processStyledBidirectionalText: null,
          isLoaded() {
            return n === Qn.loaded || null != si.applyArabicShaping;
          },
          isLoading() {
            return n === Qn.loading;
          },
          setState(e) {
            if (!Q()) throw new Error("Cannot set the state of the rtl-text-plugin when not in the web-worker context");
            n = e.pluginStatus, ti = e.pluginURL;
          },
          isParsed() {
            if (Q()) return null != si.applyArabicShaping && null != si.processBidirectionalText && null != si.processStyledBidirectionalText;
            throw new Error("rtl-text-plugin is only parsed on the worker-threads");
          },
          getPluginURL() {
            if (Q()) return ti;
            throw new Error("rtl-text-plugin url can only be queried from the worker threads");
          }
        };
        class N {
          constructor(e, t) {
            this.zoom = e, t ? (this.now = t.now, this.fadeDuration = t.fadeDuration, this.zoomHistory = t.zoomHistory, this.transition = t.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new qn(), this.transition = {});
          }
          isSupportedScript(e) {
            return Jn(e, si.isLoaded());
          }
          crossFadingFactor() {
            return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            var e = this.zoom,
              t = e - Math.floor(e),
              r = this.crossFadingFactor();
            return e > this.zoomHistory.lastIntegerZoom ? {
              fromScale: 2,
              toScale: 1,
              t: t + (1 - t) * r
            } : {
              fromScale: .5,
              toScale: 1,
              t: 1 - (1 - r) * t
            };
          }
        }
        class li {
          constructor(e, t) {
            this.property = e, this.value = t, this.expression = Jr(void 0 === t ? e.specification.default : t, e.specification);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(e, t, r) {
            return this.property.possiblyEvaluate(this, e, t, r);
          }
        }
        class ci {
          constructor(e) {
            this.property = e, this.value = new li(e, void 0);
          }
          transitioned(e, t) {
            return new hi(this.property, this.value, t, G({}, e.transition, this.transition), e.now);
          }
          untransitioned() {
            return new hi(this.property, this.value, null, {}, 0);
          }
        }
        class ui {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues);
          }
          getValue(e) {
            return W(this._values[e].value.value);
          }
          setValue(e, t) {
            Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new ci(this._values[e].property)), this._values[e].value = new li(this._values[e].property, null === t ? void 0 : W(t));
          }
          getTransition(e) {
            return W(this._values[e].transition);
          }
          setTransition(e, t) {
            Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new ci(this._values[e].property)), this._values[e].transition = W(t) || void 0;
          }
          serialize() {
            var e = {};
            for (const r of Object.keys(this._values)) {
              var t = this.getValue(r),
                t = (void 0 !== t && (e[r] = t), this.getTransition(r));
              void 0 !== t && (e[r + "-transition"] = t);
            }
            return e;
          }
          transitioned(e, t) {
            var r = new di(this._properties);
            for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(e, t._values[n]);
            return r;
          }
          untransitioned() {
            var e = new di(this._properties);
            for (const t of Object.keys(this._values)) e._values[t] = this._values[t].untransitioned();
            return e;
          }
        }
        class hi {
          constructor(e, t, r, n, i) {
            this.property = e, this.value = t, this.begin = i + n.delay || 0, this.end = this.begin + n.duration || 0, e.specification.transition && (n.delay || n.duration) && (this.prior = r);
          }
          possiblyEvaluate(e, t, r) {
            var n = e.now || 0,
              i = this.value.possiblyEvaluate(e, t, r),
              o = this.prior;
            return o ? n > this.end || this.value.isDataDriven() ? (this.prior = null, i) : n < this.begin ? o.possiblyEvaluate(e, t, r) : (n = (n - this.begin) / (this.end - this.begin), this.property.interpolate(o.possiblyEvaluate(e, t, r), i, z(n))) : i;
          }
        }
        class di {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(e, t, r) {
            var n = new _i(this._properties);
            for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(e, t, r);
            return n;
          }
          hasTransition() {
            for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0;
            return !1;
          }
        }
        class pi {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultPropertyValues);
          }
          hasValue(e) {
            return void 0 !== this._values[e].value;
          }
          getValue(e) {
            return W(this._values[e].value);
          }
          setValue(e, t) {
            this._values[e] = new li(this._values[e].property, null === t ? void 0 : W(t));
          }
          serialize() {
            var e = {};
            for (const r of Object.keys(this._values)) {
              var t = this.getValue(r);
              void 0 !== t && (e[r] = t);
            }
            return e;
          }
          possiblyEvaluate(e, t, r) {
            var n = new _i(this._properties);
            for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(e, t, r);
            return n;
          }
        }
        class fi {
          constructor(e, t, r) {
            this.property = e, this.value = t, this.parameters = r;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(e) {
            return "constant" === this.value.kind ? this.value.value : e;
          }
          evaluate(e, t, r, n) {
            return this.property.evaluate(this.value, this.parameters, e, t, r, n);
          }
        }
        class _i {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
          }
          get(e) {
            return this._values[e];
          }
        }
        class i {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, t) {
            if (e.isDataDriven()) throw new Error("Value should not be data driven");
            return e.expression.evaluate(t);
          }
          interpolate(e, t, r) {
            var n = this.specification.type,
              n = _r[n];
            return n ? n(e, t, r) : e;
          }
        }
        class a {
          constructor(e, t) {
            this.specification = e, this.overrides = t;
          }
          possiblyEvaluate(e, t, r, n) {
            return "constant" === e.expression.kind || "camera" === e.expression.kind ? new fi(this, {
              kind: "constant",
              value: e.expression.evaluate(t, null, {}, r, n)
            }, t) : new fi(this, e.expression, t);
          }
          interpolate(e, t, r) {
            var n;
            return "constant" !== e.value.kind || "constant" !== t.value.kind ? e : void 0 === e.value.value || void 0 === t.value.value ? new fi(this, {
              kind: "constant",
              value: void 0
            }, e.parameters) : (n = this.specification.type, (n = _r[n]) ? (n = n(e.value.value, t.value.value, r), new fi(this, {
              kind: "constant",
              value: n
            }, e.parameters)) : e);
          }
          evaluate(e, t, r, n, i, o) {
            return "constant" === e.kind ? e.value : e.evaluate(t, r, n, i, o);
          }
        }
        class mi extends a {
          possiblyEvaluate(e, t, r, n) {
            return void 0 === e.value ? new fi(this, {
              kind: "constant",
              value: void 0
            }, t) : "constant" === e.expression.kind ? (r = e.expression.evaluate(t, null, {}, r, n), n = "resolvedImage" === e.property.specification.type && "string" != typeof r ? r.name : r, r = this._calculate(n, n, n, t), new fi(this, {
              kind: "constant",
              value: r
            }, t)) : "camera" === e.expression.kind ? (n = this._calculate(e.expression.evaluate({
              zoom: t.zoom - 1
            }), e.expression.evaluate({
              zoom: t.zoom
            }), e.expression.evaluate({
              zoom: t.zoom + 1
            }), t), new fi(this, {
              kind: "constant",
              value: n
            }, t)) : new fi(this, e.expression, t);
          }
          evaluate(e, t, r, n, i, o) {
            return "source" === e.kind ? (i = e.evaluate(t, r, n, i, o), this._calculate(i, i, i, t)) : "composite" === e.kind ? this._calculate(e.evaluate({
              zoom: Math.floor(t.zoom) - 1
            }, r, n), e.evaluate({
              zoom: Math.floor(t.zoom)
            }, r, n), e.evaluate({
              zoom: Math.floor(t.zoom) + 1
            }, r, n), t) : e.value;
          }
          _calculate(e, t, r, n) {
            return n.zoom > n.zoomHistory.lastIntegerZoom ? {
              from: e,
              to: t
            } : {
              from: r,
              to: t
            };
          }
          interpolate(e) {
            return e;
          }
        }
        class gi {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, t, r, n) {
            if (void 0 !== e.value) return "constant" === e.expression.kind ? (r = e.expression.evaluate(t, null, {}, r, n), this._calculate(r, r, r, t)) : this._calculate(e.expression.evaluate(new N(Math.floor(t.zoom - 1), t)), e.expression.evaluate(new N(Math.floor(t.zoom), t)), e.expression.evaluate(new N(Math.floor(t.zoom + 1), t)), t);
          }
          _calculate(e, t, r, n) {
            return n.zoom > n.zoomHistory.lastIntegerZoom ? {
              from: e,
              to: t
            } : {
              from: r,
              to: t
            };
          }
          interpolate(e) {
            return e;
          }
        }
        class yi {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, t, r, n) {
            return !!e.expression.evaluate(t, null, {}, r, n);
          }
          interpolate() {
            return !1;
          }
        }
        class l {
          constructor(e) {
            this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const n in e) {
              var t = e[n],
                r = (t.specification.overridable && this.overridableProperties.push(n), this.defaultPropertyValues[n] = new li(t, void 0)),
                t = this.defaultTransitionablePropertyValues[n] = new ci(t);
              this.defaultTransitioningPropertyValues[n] = t.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = r.possiblyEvaluate({});
            }
          }
        }
        r("DataDrivenProperty", a), r("DataConstantProperty", i), r("CrossFadedDataDrivenProperty", mi), r("CrossFadedProperty", gi), r("ColorRampProperty", yi);
        const vi = "-transition";
        class Ei extends Ne {
          constructor(e, t) {
            if (super(), this.id = e.id, this.type = e.type, this._featureFilter = {
              filter: () => !0,
              needGeometry: !1
            }, "custom" !== e.type && (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, "background" !== e.type && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), t.layout && (this._unevaluatedLayout = new pi(t.layout)), t.paint)) {
              this._transitionablePaint = new ui(t.paint);
              for (const r in e.paint) this.setPaintProperty(r, e.paint[r], {
                validate: !1
              });
              for (const n in e.layout) this.setLayoutProperty(n, e.layout[n], {
                validate: !1
              });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new _i(t.paint);
            }
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(e) {
            return "visibility" === e ? this.visibility : this._unevaluatedLayout.getValue(e);
          }
          setLayoutProperty(e, t, r = {}) {
            if (null != t) {
              var n = `layers.${this.id}.layout.` + e;
              if (this._validate(Bn, n, e, t, r)) return;
            }
            "visibility" === e ? this.visibility = t : this._unevaluatedLayout.setValue(e, t);
          }
          getPaintProperty(e) {
            return e.endsWith(vi) ? this._transitionablePaint.getTransition(e.slice(0, -vi.length)) : this._transitionablePaint.getValue(e);
          }
          setPaintProperty(e, t, r = {}) {
            if (null != t) {
              var n = `layers.${this.id}.paint.` + e;
              if (this._validate(Fn, n, e, t, r)) return !1;
            }
            var i;
            return e.endsWith(vi) ? (this._transitionablePaint.setTransition(e.slice(0, -vi.length), t || void 0), !1) : (r = "cross-faded-data-driven" === (n = this._transitionablePaint._values[e]).property.specification["property-type"], i = n.value.isDataDriven(), n = n.value, this._transitionablePaint.setValue(e, t), this._handleSpecialPaintPropertyUpdate(e), (t = this._transitionablePaint._values[e].value).isDataDriven() || i || r || this._handleOverridablePaintPropertyUpdate(e, n, t));
          }
          _handleSpecialPaintPropertyUpdate(e) {}
          _handleOverridablePaintPropertyUpdate(e, t, r) {
            return !1;
          }
          isHidden(e) {
            return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(e) {
            this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(e, t) {
            e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, t)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, t);
          }
          serialize() {
            var e = {
              id: this.id,
              type: this.type,
              source: this.source,
              "source-layer": this.sourceLayer,
              metadata: this.metadata,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              filter: this.filter,
              layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
              paint: this._transitionablePaint && this._transitionablePaint.serialize()
            };
            return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), K(e, (e, t) => !(void 0 === e || "layout" === t && !Object.keys(e).length || "paint" === t && !Object.keys(e).length));
          }
          _validate(e, t, r, n, i = {}) {
            return (!i || !1 !== i.validate) && $n(this, e.call(Un, {
              key: t,
              layerType: this.type,
              objectKey: r,
              value: n,
              styleSpec: o,
              style: {
                glyphs: !0,
                sprite: !0
              }
            }));
          }
          is3D() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          resize() {}
          isStateDependent() {
            for (const t in this.paint._values) {
              var e = this.paint.get(t);
              if (e instanceof fi && Or(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0;
            }
            return !1;
          }
        }
        const bi = {
          Int8: Int8Array,
          Uint8: Uint8Array,
          Int16: Int16Array,
          Uint16: Uint16Array,
          Int32: Int32Array,
          Uint32: Uint32Array,
          Float32: Float32Array
        };
        class wi {
          constructor(e, t) {
            this._structArray = e, this._pos1 = t * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class c {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(e, t) {
            return e._trim(), t && (e.isTransferred = !0, t.push(e.arrayBuffer)), {
              length: e.length,
              arrayBuffer: e.arrayBuffer
            };
          }
          static deserialize(e) {
            var t = Object.create(this.prototype);
            return t.arrayBuffer = e.arrayBuffer, t.length = e.length, t.capacity = e.arrayBuffer.byteLength / t.bytesPerElement, t._refreshViews(), t;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(e) {
            this.reserve(e), this.length = e;
          }
          reserve(e) {
            e > this.capacity && (this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement), e = this.uint8, this._refreshViews(), e) && this.uint8.set(e);
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function w(e, i = 1) {
          let o = 0,
            a = 0;
          return {
            members: e.map(e => {
              t = e.type;
              var t = bi[t].BYTES_PER_ELEMENT,
                r = o = Ti(o, Math.max(i, t)),
                n = e.components || 1;
              return a = Math.max(a, t), o += t * n, {
                name: e.name,
                type: e.type,
                components: n,
                offset: r
              };
            }),
            size: Ti(o, Math.max(a, i)),
            alignment: i
          };
        }
        function Ti(e, t) {
          return Math.ceil(e / t) * t;
        }
        class Si extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, t) {
            var r = this.length;
            return this.resize(r + 1), this.emplace(r, e, t);
          }
          emplace(e, t, r) {
            var n = 2 * e;
            return this.int16[0 + n] = t, this.int16[1 + n] = r, e;
          }
        }
        Si.prototype.bytesPerElement = 4, r("StructArrayLayout2i4", Si);
        class xi extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r) {
            var n = this.length;
            return this.resize(n + 1), this.emplace(n, e, t, r);
          }
          emplace(e, t, r, n) {
            var i = 3 * e;
            return this.int16[0 + i] = t, this.int16[1 + i] = r, this.int16[2 + i] = n, e;
          }
        }
        xi.prototype.bytesPerElement = 6, r("StructArrayLayout3i6", xi);
        class Ci extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r, n) {
            var i = this.length;
            return this.resize(i + 1), this.emplace(i, e, t, r, n);
          }
          emplace(e, t, r, n, i) {
            var o = 4 * e;
            return this.int16[0 + o] = t, this.int16[1 + o] = r, this.int16[2 + o] = n, this.int16[3 + o] = i, e;
          }
        }
        Ci.prototype.bytesPerElement = 8, r("StructArrayLayout4i8", Ci);
        class Ai extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r, n, i, o) {
            var a = this.length;
            return this.resize(a + 1), this.emplace(a, e, t, r, n, i, o);
          }
          emplace(e, t, r, n, i, o, a) {
            var s = 6 * e;
            return this.int16[0 + s] = t, this.int16[1 + s] = r, this.int16[2 + s] = n, this.int16[3 + s] = i, this.int16[4 + s] = o, this.int16[5 + s] = a, e;
          }
        }
        Ai.prototype.bytesPerElement = 12, r("StructArrayLayout2i4i12", Ai);
        class Ii extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r, n, i, o) {
            var a = this.length;
            return this.resize(a + 1), this.emplace(a, e, t, r, n, i, o);
          }
          emplace(e, t, r, n, i, o, a) {
            var s = 4 * e,
              l = 8 * e;
            return this.int16[0 + s] = t, this.int16[1 + s] = r, this.uint8[4 + l] = n, this.uint8[5 + l] = i, this.uint8[6 + l] = o, this.uint8[7 + l] = a, e;
          }
        }
        Ii.prototype.bytesPerElement = 8, r("StructArrayLayout2i4ub8", Ii);
        class Ni extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, t) {
            var r = this.length;
            return this.resize(r + 1), this.emplace(r, e, t);
          }
          emplace(e, t, r) {
            var n = 2 * e;
            return this.float32[0 + n] = t, this.float32[1 + n] = r, e;
          }
        }
        Ni.prototype.bytesPerElement = 8, r("StructArrayLayout2f8", Ni);
        class Pi extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r, n, i, o, a, s, l, c) {
            var u = this.length;
            return this.resize(u + 1), this.emplace(u, e, t, r, n, i, o, a, s, l, c);
          }
          emplace(e, t, r, n, i, o, a, s, l, c, u) {
            var h = 10 * e;
            return this.uint16[0 + h] = t, this.uint16[1 + h] = r, this.uint16[2 + h] = n, this.uint16[3 + h] = i, this.uint16[4 + h] = o, this.uint16[5 + h] = a, this.uint16[6 + h] = s, this.uint16[7 + h] = l, this.uint16[8 + h] = c, this.uint16[9 + h] = u, e;
          }
        }
        Pi.prototype.bytesPerElement = 20, r("StructArrayLayout10ui20", Pi);
        class Di extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r, n, i, o, a, s, l, c, u, h) {
            var d = this.length;
            return this.resize(d + 1), this.emplace(d, e, t, r, n, i, o, a, s, l, c, u, h);
          }
          emplace(e, t, r, n, i, o, a, s, l, c, u, h, d) {
            var p = 12 * e;
            return this.int16[0 + p] = t, this.int16[1 + p] = r, this.int16[2 + p] = n, this.int16[3 + p] = i, this.uint16[4 + p] = o, this.uint16[5 + p] = a, this.uint16[6 + p] = s, this.uint16[7 + p] = l, this.int16[8 + p] = c, this.int16[9 + p] = u, this.int16[10 + p] = h, this.int16[11 + p] = d, e;
          }
        }
        Di.prototype.bytesPerElement = 24, r("StructArrayLayout4i4ui4i24", Di);
        class Ri extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r) {
            var n = this.length;
            return this.resize(n + 1), this.emplace(n, e, t, r);
          }
          emplace(e, t, r, n) {
            var i = 3 * e;
            return this.float32[0 + i] = t, this.float32[1 + i] = r, this.float32[2 + i] = n, e;
          }
        }
        Ri.prototype.bytesPerElement = 12, r("StructArrayLayout3f12", Ri);
        class Oi extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            var t = this.length;
            return this.resize(t + 1), this.emplace(t, e);
          }
          emplace(e, t) {
            return this.uint32[0 + +e] = t, e;
          }
        }
        Oi.prototype.bytesPerElement = 4, r("StructArrayLayout1ul4", Oi);
        class Mi extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r, n, i, o, a, s, l) {
            var c = this.length;
            return this.resize(c + 1), this.emplace(c, e, t, r, n, i, o, a, s, l);
          }
          emplace(e, t, r, n, i, o, a, s, l, c) {
            var u = 10 * e,
              h = 5 * e;
            return this.int16[0 + u] = t, this.int16[1 + u] = r, this.int16[2 + u] = n, this.int16[3 + u] = i, this.int16[4 + u] = o, this.int16[5 + u] = a, this.uint32[3 + h] = s, this.uint16[8 + u] = l, this.uint16[9 + u] = c, e;
          }
        }
        Mi.prototype.bytesPerElement = 20, r("StructArrayLayout6i1ul2ui20", Mi);
        class ki extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r, n, i, o) {
            var a = this.length;
            return this.resize(a + 1), this.emplace(a, e, t, r, n, i, o);
          }
          emplace(e, t, r, n, i, o, a) {
            var s = 6 * e;
            return this.int16[0 + s] = t, this.int16[1 + s] = r, this.int16[2 + s] = n, this.int16[3 + s] = i, this.int16[4 + s] = o, this.int16[5 + s] = a, e;
          }
        }
        ki.prototype.bytesPerElement = 12, r("StructArrayLayout2i2i2i12", ki);
        class Li extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r, n, i) {
            var o = this.length;
            return this.resize(o + 1), this.emplace(o, e, t, r, n, i);
          }
          emplace(e, t, r, n, i, o) {
            var a = 4 * e,
              s = 8 * e;
            return this.float32[0 + a] = t, this.float32[1 + a] = r, this.float32[2 + a] = n, this.int16[6 + s] = i, this.int16[7 + s] = o, e;
          }
        }
        Li.prototype.bytesPerElement = 16, r("StructArrayLayout2f1f2i16", Li);
        class Ui extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r, n) {
            var i = this.length;
            return this.resize(i + 1), this.emplace(i, e, t, r, n);
          }
          emplace(e, t, r, n, i) {
            var o = 12 * e,
              a = 3 * e;
            return this.uint8[0 + o] = t, this.uint8[1 + o] = r, this.float32[1 + a] = n, this.float32[2 + a] = i, e;
          }
        }
        Ui.prototype.bytesPerElement = 12, r("StructArrayLayout2ub2f12", Ui);
        class Fi extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r) {
            var n = this.length;
            return this.resize(n + 1), this.emplace(n, e, t, r);
          }
          emplace(e, t, r, n) {
            var i = 3 * e;
            return this.uint16[0 + i] = t, this.uint16[1 + i] = r, this.uint16[2 + i] = n, e;
          }
        }
        Fi.prototype.bytesPerElement = 6, r("StructArrayLayout3ui6", Fi);
        class Bi extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r, n, i, o, a, s, l, c, u, h, d, p, f, _, m) {
            var g = this.length;
            return this.resize(g + 1), this.emplace(g, e, t, r, n, i, o, a, s, l, c, u, h, d, p, f, _, m);
          }
          emplace(e, t, r, n, i, o, a, s, l, c, u, h, d, p, f, _, m, g) {
            var y = 24 * e,
              v = 12 * e,
              E = 48 * e;
            return this.int16[0 + y] = t, this.int16[1 + y] = r, this.uint16[2 + y] = n, this.uint16[3 + y] = i, this.uint32[2 + v] = o, this.uint32[3 + v] = a, this.uint32[4 + v] = s, this.uint16[10 + y] = l, this.uint16[11 + y] = c, this.uint16[12 + y] = u, this.float32[7 + v] = h, this.float32[8 + v] = d, this.uint8[36 + E] = p, this.uint8[37 + E] = f, this.uint8[38 + E] = _, this.uint32[10 + v] = m, this.int16[22 + y] = g, e;
          }
        }
        Bi.prototype.bytesPerElement = 48, r("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Bi);
        class $i extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r, n, i, o, a, s, l, c, u, h, d, p, f, _, m, g, y, v, E, b, w, T, S, x, C, A) {
            var I = this.length;
            return this.resize(I + 1), this.emplace(I, e, t, r, n, i, o, a, s, l, c, u, h, d, p, f, _, m, g, y, v, E, b, w, T, S, x, C, A);
          }
          emplace(e, t, r, n, i, o, a, s, l, c, u, h, d, p, f, _, m, g, y, v, E, b, w, T, S, x, C, A, I) {
            var N = 32 * e,
              P = 16 * e;
            return this.int16[0 + N] = t, this.int16[1 + N] = r, this.int16[2 + N] = n, this.int16[3 + N] = i, this.int16[4 + N] = o, this.int16[5 + N] = a, this.int16[6 + N] = s, this.int16[7 + N] = l, this.uint16[8 + N] = c, this.uint16[9 + N] = u, this.uint16[10 + N] = h, this.uint16[11 + N] = d, this.uint16[12 + N] = p, this.uint16[13 + N] = f, this.uint16[14 + N] = _, this.uint16[15 + N] = m, this.uint16[16 + N] = g, this.uint16[17 + N] = y, this.uint16[18 + N] = v, this.uint16[19 + N] = E, this.uint16[20 + N] = b, this.uint16[21 + N] = w, this.uint16[22 + N] = T, this.uint32[12 + P] = S, this.float32[13 + P] = x, this.float32[14 + P] = C, this.uint16[30 + N] = A, this.uint16[31 + N] = I, e;
          }
        }
        $i.prototype.bytesPerElement = 64, r("StructArrayLayout8i15ui1ul2f2ui64", $i);
        class zi extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            var t = this.length;
            return this.resize(t + 1), this.emplace(t, e);
          }
          emplace(e, t) {
            return this.float32[0 + +e] = t, e;
          }
        }
        zi.prototype.bytesPerElement = 4, r("StructArrayLayout1f4", zi);
        class Yi extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r) {
            var n = this.length;
            return this.resize(n + 1), this.emplace(n, e, t, r);
          }
          emplace(e, t, r, n) {
            var i = 3 * e;
            return this.uint16[0 + 6 * e] = t, this.float32[1 + i] = r, this.float32[2 + i] = n, e;
          }
        }
        Yi.prototype.bytesPerElement = 12, r("StructArrayLayout1ui2f12", Yi);
        class Hi extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r) {
            var n = this.length;
            return this.resize(n + 1), this.emplace(n, e, t, r);
          }
          emplace(e, t, r, n) {
            var i = 4 * e;
            return this.uint32[0 + 2 * e] = t, this.uint16[2 + i] = r, this.uint16[3 + i] = n, e;
          }
        }
        Hi.prototype.bytesPerElement = 8, r("StructArrayLayout1ul2ui8", Hi);
        class ji extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, t) {
            var r = this.length;
            return this.resize(r + 1), this.emplace(r, e, t);
          }
          emplace(e, t, r) {
            var n = 2 * e;
            return this.uint16[0 + n] = t, this.uint16[1 + n] = r, e;
          }
        }
        ji.prototype.bytesPerElement = 4, r("StructArrayLayout2ui4", ji);
        class Gi extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            var t = this.length;
            return this.resize(t + 1), this.emplace(t, e);
          }
          emplace(e, t) {
            return this.uint16[0 + +e] = t, e;
          }
        }
        Gi.prototype.bytesPerElement = 2, r("StructArrayLayout1ui2", Gi);
        class qi extends c {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, t, r, n) {
            var i = this.length;
            return this.resize(i + 1), this.emplace(i, e, t, r, n);
          }
          emplace(e, t, r, n, i) {
            var o = 4 * e;
            return this.float32[0 + o] = t, this.float32[1 + o] = r, this.float32[2 + o] = n, this.float32[3 + o] = i, e;
          }
        }
        qi.prototype.bytesPerElement = 16, r("StructArrayLayout4f16", qi);
        class Vi extends wi {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new F(this.anchorPointX, this.anchorPointY);
          }
        }
        Vi.prototype.size = 20;
        class Ki extends Mi {
          get(e) {
            return new Vi(this, e);
          }
        }
        r("CollisionBoxArray", Ki);
        class Wi extends wi {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(e) {
            this._structArray.uint8[this._pos1 + 37] = e;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(e) {
            this._structArray.uint8[this._pos1 + 38] = e;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(e) {
            this._structArray.uint32[this._pos4 + 10] = e;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        Wi.prototype.size = 48;
        class Zi extends Bi {
          get(e) {
            return new Wi(this, e);
          }
        }
        r("PlacedSymbolArray", Zi);
        class Xi extends wi {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(e) {
            this._structArray.uint32[this._pos4 + 12] = e;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        Xi.prototype.size = 64;
        class Ji extends $i {
          get(e) {
            return new Xi(this, e);
          }
        }
        r("SymbolInstanceArray", Ji);
        class Qi extends zi {
          getoffsetX(e) {
            return this.float32[+e + 0];
          }
        }
        r("GlyphOffsetArray", Qi);
        class eo extends xi {
          getx(e) {
            return this.int16[3 * e + 0];
          }
          gety(e) {
            return this.int16[3 * e + 1];
          }
          gettileUnitDistanceFromAnchor(e) {
            return this.int16[3 * e + 2];
          }
        }
        r("SymbolLineVertexArray", eo);
        class to extends wi {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        to.prototype.size = 12;
        class ro extends Yi {
          get(e) {
            return new to(this, e);
          }
        }
        r("TextAnchorOffsetArray", ro);
        class no extends wi {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        no.prototype.size = 8;
        class io extends Hi {
          get(e) {
            return new no(this, e);
          }
        }
        r("FeatureIndexArray", io);
        class oo extends Si {}
        class ao extends Si {}
        class so extends Si {}
        class lo extends Ai {}
        class co extends Ii {}
        class uo extends Ni {}
        class ho extends Pi {}
        class po extends Di {}
        class fo extends Ri {}
        class _o extends Oi {}
        class mo extends ki {}
        class go extends Ui {}
        class yo extends Fi {}
        class vo extends ji {}
        const Eo = w([{
          name: "a_pos",
          components: 2,
          type: "Int16"
        }], 4)["members"];
        class T {
          constructor(e = []) {
            this.segments = e;
          }
          prepareSegment(e, t, r, n) {
            let i = this.segments[this.segments.length - 1];
            return e > T.MAX_VERTEX_ARRAY_LENGTH && he(`Max vertices per segment is ${T.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ` + e), (!i || i.vertexLength + e > T.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {
              vertexOffset: t.length,
              primitiveOffset: r.length,
              vertexLength: 0,
              primitiveLength: 0
            }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const e of this.segments) for (const t in e.vaos) e.vaos[t].destroy();
          }
          static simpleSegment(e, t, r, n) {
            return new T([{
              vertexOffset: e,
              primitiveOffset: t,
              vertexLength: r,
              primitiveLength: n,
              vaos: {},
              sortKey: 0
            }]);
          }
        }
        function bo(e, t) {
          return 256 * (e = H(Math.floor(e), 0, 255)) + (t = H(Math.floor(t), 0, 255));
        }
        T.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, r("SegmentVector", T);
        const wo = w([{
          name: "a_pattern_from",
          components: 4,
          type: "Uint16"
        }, {
          name: "a_pattern_to",
          components: 4,
          type: "Uint16"
        }, {
          name: "a_pixel_ratio_from",
          components: 1,
          type: "Uint16"
        }, {
          name: "a_pixel_ratio_to",
          components: 1,
          type: "Uint16"
        }]);
        e = {
          exports: {}
        }, Sr = {
          exports: {},
          exports: function (e, t) {
            for (var r, n, i = 3 & e.length, o = e.length - i, a = t, s = 3432918353, l = 461845907, c = 0; c < o;) n = 255 & e.charCodeAt(c) | (255 & e.charCodeAt(++c)) << 8 | (255 & e.charCodeAt(++c)) << 16 | (255 & e.charCodeAt(++c)) << 24, ++c, a = 27492 + (65535 & (r = 5 * (65535 & (a = (a ^= n = (65535 & (n = (n = (65535 & n) * s + (((n >>> 16) * s & 65535) << 16) & 4294967295) << 15 | n >>> 17)) * l + (((n >>> 16) * l & 65535) << 16) & 4294967295) << 13 | a >>> 19)) + ((5 * (a >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (r >>> 16) & 65535) << 16);
            switch (n = 0, i) {
              case 3:
                n ^= (255 & e.charCodeAt(c + 2)) << 16;
              case 2:
                n ^= (255 & e.charCodeAt(c + 1)) << 8;
              case 1:
                a ^= n = (65535 & (n = (n = (65535 & (n ^= 255 & e.charCodeAt(c))) * s + (((n >>> 16) * s & 65535) << 16) & 4294967295) << 15 | n >>> 17)) * l + (((n >>> 16) * l & 65535) << 16) & 4294967295;
            }
            return a = 2246822507 * (65535 & (a = (a ^= e.length) ^ a >>> 16)) + ((2246822507 * (a >>> 16) & 65535) << 16) & 4294967295, a = 3266489909 * (65535 & (a ^= a >>> 13)) + ((3266489909 * (a >>> 16) & 65535) << 16) & 4294967295, (a ^= a >>> 16) >>> 0;
          }
        }, Tr = {
          exports: {},
          exports: function (e, t) {
            for (var r, n = e.length, i = t ^ n, o = 0; 4 <= n;) r = 1540483477 * (65535 & (r = 255 & e.charCodeAt(o) | (255 & e.charCodeAt(++o)) << 8 | (255 & e.charCodeAt(++o)) << 16 | (255 & e.charCodeAt(++o)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), n -= 4, ++o;
            switch (n) {
              case 3:
                i ^= (255 & e.charCodeAt(o + 2)) << 16;
              case 2:
                i ^= (255 & e.charCodeAt(o + 1)) << 8;
              case 1:
                i = 1540483477 * (65535 & (i ^= 255 & e.charCodeAt(o))) + ((1540483477 * (i >>> 16) & 65535) << 16);
            }
            return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;
          }
        }, t = Sr.exports, xr = Tr.exports;
        e.exports = t, e.exports.murmur3 = t, e.exports.murmur2 = xr;
        var To = I(e.exports);
        class So {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1;
          }
          add(e, t, r, n) {
            this.ids.push(xo(e)), this.positions.push(t, r, n);
          }
          getPositions(e) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            var t = xo(e);
            let r = 0,
              n = this.ids.length - 1;
            for (; r < n;) {
              var i = r + n >> 1;
              this.ids[i] >= t ? n = i : r = 1 + i;
            }
            for (var o = []; this.ids[r] === t;) {
              var a = this.positions[3 * r],
                s = this.positions[3 * r + 1],
                l = this.positions[3 * r + 2];
              o.push({
                index: a,
                start: s,
                end: l
              }), r++;
            }
            return o;
          }
          static serialize(e, t) {
            var r = new Float64Array(e.ids),
              e = new Uint32Array(e.positions);
            return Co(r, e, 0, r.length - 1), t && t.push(r.buffer, e.buffer), {
              ids: r,
              positions: e
            };
          }
          static deserialize(e) {
            var t = new So();
            return t.ids = e.ids, t.positions = e.positions, t.indexed = !0, t;
          }
        }
        function xo(e) {
          var t = +e;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : To(String(e));
        }
        function Co(r, n, i, o) {
          for (; i < o;) {
            var a = r[i + o >> 1];
            let e = i - 1,
              t = o + 1;
            for (;;) {
              for (; r[++e] < a;);
              for (; r[--t] > a;);
              if (e >= t) break;
              Ao(r, e, t), Ao(n, 3 * e, 3 * t), Ao(n, 3 * e + 1, 3 * t + 1), Ao(n, 3 * e + 2, 3 * t + 2);
            }
            t - i < o - t ? (Co(r, n, i, t), i = t + 1) : (Co(r, n, t + 1, o), o = t);
          }
        }
        function Ao(e, t, r) {
          var n = e[t];
          e[t] = e[r], e[r] = n;
        }
        r("FeaturePositionMap", So);
        class Io {
          constructor(e, t) {
            this.gl = e.gl, this.location = t;
          }
        }
        class No extends Io {
          constructor(e, t) {
            super(e, t), this.current = 0;
          }
          set(e) {
            this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e));
          }
        }
        class Po extends Io {
          constructor(e, t) {
            super(e, t), this.current = [0, 0, 0, 0];
          }
          set(e) {
            e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2] && e[3] === this.current[3] || (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]));
          }
        }
        class Do extends Io {
          constructor(e, t) {
            super(e, t), this.current = g.transparent;
          }
          set(e) {
            e.r === this.current.r && e.g === this.current.g && e.b === this.current.b && e.a === this.current.a || (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a));
          }
        }
        const Ro = new Float32Array(16);
        function Oo(e) {
          return [bo(255 * e.r, 255 * e.g), bo(255 * e.b, 255 * e.a)];
        }
        class Mo {
          constructor(e, t, r) {
            this.value = e, this.uniformNames = t.map(e => "u_" + e), this.type = r;
          }
          setUniform(e, t, r) {
            e.set(r.constantOr(this.value));
          }
          getBinding(e, t, r) {
            return new ("color" === this.type ? Do : No)(e, t);
          }
        }
        class ko {
          constructor(e, t) {
            this.uniformNames = t.map(e => "u_" + e), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(e, t) {
            this.pixelRatioFrom = t.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = t.tlbr, this.patternTo = e.tlbr;
          }
          setUniform(e, t, r, n) {
            n = "u_pattern_to" === n ? this.patternTo : "u_pattern_from" === n ? this.patternFrom : "u_pixel_ratio_to" === n ? this.pixelRatioTo : "u_pixel_ratio_from" === n ? this.pixelRatioFrom : null;
            n && e.set(n);
          }
          getBinding(e, t, r) {
            return new ("u_pattern" === r.substr(0, 9) ? Po : No)(e, t);
          }
        }
        class Lo {
          constructor(e, t, r, n) {
            this.expression = e, this.type = r, this.maxValue = 0, this.paintVertexAttributes = t.map(e => ({
              name: "a_" + e,
              type: "Float32",
              components: "color" === r ? 2 : 1,
              offset: 0
            })), this.paintVertexArray = new n();
          }
          populatePaintArray(e, t, r, n, i) {
            var o = this.paintVertexArray.length,
              t = this.expression.evaluate(new N(0), t, {}, n, [], i);
            this.paintVertexArray.resize(e), this._setPaintValue(o, e, t);
          }
          updatePaintArray(e, t, r, n) {
            r = this.expression.evaluate({
              zoom: 0
            }, r, n);
            this._setPaintValue(e, t, r);
          }
          _setPaintValue(t, r, n) {
            if ("color" === this.type) {
              var i = Oo(n);
              for (let e = t; e < r; e++) this.paintVertexArray.emplace(e, i[0], i[1]);
            } else {
              for (let e = t; e < r; e++) this.paintVertexArray.emplace(e, n);
              this.maxValue = Math.max(this.maxValue, Math.abs(n));
            }
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Uo {
          constructor(e, t, r, n, i, o) {
            this.expression = e, this.uniformNames = t.map(e => `u_${e}_t`), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = t.map(e => ({
              name: "a_" + e,
              type: "Float32",
              components: "color" === r ? 4 : 2,
              offset: 0
            })), this.paintVertexArray = new o();
          }
          populatePaintArray(e, t, r, n, i) {
            var o = this.expression.evaluate(new N(this.zoom), t, {}, n, [], i),
              t = this.expression.evaluate(new N(this.zoom + 1), t, {}, n, [], i),
              n = this.paintVertexArray.length;
            this.paintVertexArray.resize(e), this._setPaintValue(n, e, o, t);
          }
          updatePaintArray(e, t, r, n) {
            var i = this.expression.evaluate({
                zoom: this.zoom
              }, r, n),
              r = this.expression.evaluate({
                zoom: this.zoom + 1
              }, r, n);
            this._setPaintValue(e, t, i, r);
          }
          _setPaintValue(t, r, n, i) {
            if ("color" === this.type) {
              var o = Oo(n),
                a = Oo(i);
              for (let e = t; e < r; e++) this.paintVertexArray.emplace(e, o[0], o[1], a[0], a[1]);
            } else {
              for (let e = t; e < r; e++) this.paintVertexArray.emplace(e, n, i);
              this.maxValue = Math.max(this.maxValue, Math.abs(n), Math.abs(i));
            }
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(e, t) {
            t = this.useIntegerZoom ? Math.floor(t.zoom) : t.zoom, t = H(this.expression.interpolationFactor(t, this.zoom, this.zoom + 1), 0, 1);
            e.set(t);
          }
          getBinding(e, t, r) {
            return new No(e, t);
          }
        }
        class Fo {
          constructor(e, t, r, n, i, o) {
            this.expression = e, this.type = t, this.useIntegerZoom = r, this.zoom = n, this.layerId = o, this.zoomInPaintVertexArray = new i(), this.zoomOutPaintVertexArray = new i();
          }
          populatePaintArray(e, t, r) {
            var n = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(n, e, t.patterns && t.patterns[this.layerId], r);
          }
          updatePaintArray(e, t, r, n, i) {
            this._setPaintValues(e, t, r.patterns && r.patterns[this.layerId], i);
          }
          _setPaintValues(t, r, e, n) {
            if (n && e) {
              var {
                  min: e,
                  mid: i,
                  max: o
                } = e,
                a = n[e],
                s = n[i],
                l = n[o];
              if (a && s && l) for (let e = t; e < r; e++) this.zoomInPaintVertexArray.emplace(e, s.tl[0], s.tl[1], s.br[0], s.br[1], a.tl[0], a.tl[1], a.br[0], a.br[1], s.pixelRatio, a.pixelRatio), this.zoomOutPaintVertexArray.emplace(e, s.tl[0], s.tl[1], s.br[0], s.br[1], l.tl[0], l.tl[1], l.br[0], l.br[1], s.pixelRatio, l.pixelRatio);
            }
          }
          upload(e) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, wo.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, wo.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Bo {
          constructor(e, t, r) {
            this.binders = {}, this._buffers = [];
            var n,
              i,
              o,
              a,
              s,
              l,
              c = [];
            for (const u in e.paint._values) r(u) && (l = e.paint.get(u)) instanceof fi && Or(l.property.specification) && (n = zo(u, e.type), i = l.value, o = l.property.specification.type, a = l.property.useIntegerZoom, l = "cross-faded" === (l = l.property.specification["property-type"]) || "cross-faded-data-driven" === l, "constant" === i.kind ? (this.binders[u] = l ? new ko(i.value, n) : new Mo(i.value, n, o), c.push("/u_" + u)) : "source" === i.kind || l ? (s = Yo(u, o, "source"), this.binders[u] = l ? new Fo(i, o, a, t, s, e.id) : new Lo(i, n, o, s), c.push("/a_" + u)) : (l = Yo(u, o, "composite"), this.binders[u] = new Uo(i, n, o, a, t, l), c.push("/z_" + u)));
            this.cacheKey = c.sort().join("");
          }
          getMaxValue(e) {
            e = this.binders[e];
            return e instanceof Lo || e instanceof Uo ? e.maxValue : 0;
          }
          populatePaintArrays(e, t, r, n, i) {
            for (const a in this.binders) {
              var o = this.binders[a];
              (o instanceof Lo || o instanceof Uo || o instanceof Fo) && o.populatePaintArray(e, t, r, n, i);
            }
          }
          setConstantPatternPositions(e, t) {
            for (const n in this.binders) {
              var r = this.binders[n];
              r instanceof ko && r.setConstantPatternPositions(e, t);
            }
          }
          updatePaintArrays(e, t, r, n, i) {
            let o = !1;
            for (const c in e) for (const u of t.getPositions(c)) {
              var a = r.feature(u.index);
              for (const h in this.binders) {
                var s,
                  l = this.binders[h];
                (l instanceof Lo || l instanceof Uo || l instanceof Fo) && !0 === l.expression.isStateDependent && (s = n.paint.get(h), l.expression = s.value, l.updatePaintArray(u.start, u.end, a, e[c], i), o = !0);
              }
            }
            return o;
          }
          defines() {
            var e = [];
            for (const r in this.binders) {
              var t = this.binders[r];
              (t instanceof Mo || t instanceof ko) && e.push(...t.uniformNames.map(e => "#define HAS_UNIFORM_" + e));
            }
            return e;
          }
          getBinderAttributes() {
            var t = [];
            for (const e in this.binders) {
              var r = this.binders[e];
              if (r instanceof Lo || r instanceof Uo) for (let e = 0; e < r.paintVertexAttributes.length; e++) t.push(r.paintVertexAttributes[e].name);else if (r instanceof Fo) for (let e = 0; e < wo.members.length; e++) t.push(wo.members[e].name);
            }
            return t;
          }
          getBinderUniforms() {
            var e = [];
            for (const r in this.binders) {
              var t = this.binders[r];
              if (t instanceof Mo || t instanceof ko || t instanceof Uo) for (const n of t.uniformNames) e.push(n);
            }
            return e;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(e, t) {
            var r = [];
            for (const o in this.binders) {
              var n,
                i = this.binders[o];
              if (i instanceof Mo || i instanceof ko || i instanceof Uo) for (const a of i.uniformNames) t[a] && (n = i.getBinding(e, t[a], a), r.push({
                name: a,
                property: o,
                binding: n
              }));
            }
            return r;
          }
          setUniforms(e, t, r, n) {
            for (var {
              name: i,
              property: o,
              binding: a
            } of t) this.binders[o].setUniform(a, n, r.get(o), i);
          }
          updatePaintBuffers(e) {
            this._buffers = [];
            for (const n in this.binders) {
              var t,
                r = this.binders[n];
              e && r instanceof Fo ? (t = 2 === e.fromScale ? r.zoomInPaintVertexBuffer : r.zoomOutPaintVertexBuffer) && this._buffers.push(t) : (r instanceof Lo || r instanceof Uo) && r.paintVertexBuffer && this._buffers.push(r.paintVertexBuffer);
            }
          }
          upload(e) {
            for (const r in this.binders) {
              var t = this.binders[r];
              (t instanceof Lo || t instanceof Uo || t instanceof Fo) && t.upload(e);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t in this.binders) {
              var e = this.binders[t];
              (e instanceof Lo || e instanceof Uo || e instanceof Fo) && e.destroy();
            }
          }
        }
        class $o {
          constructor(e, t, r = () => !0) {
            this.programConfigurations = {};
            for (const n of e) this.programConfigurations[n.id] = new Bo(n, t, r);
            this.needsUpload = !1, this._featureMap = new So(), this._bufferOffset = 0;
          }
          populatePaintArrays(e, t, r, n, i, o) {
            for (const a in this.programConfigurations) this.programConfigurations[a].populatePaintArrays(e, t, n, i, o);
            void 0 !== t.id && this._featureMap.add(t.id, r, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = !0;
          }
          updatePaintArrays(e, t, r, n) {
            for (const i of r) this.needsUpload = this.programConfigurations[i.id].updatePaintArrays(e, this._featureMap, t, i, n) || this.needsUpload;
          }
          get(e) {
            return this.programConfigurations[e];
          }
          upload(e) {
            if (this.needsUpload) {
              for (const t in this.programConfigurations) this.programConfigurations[t].upload(e);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (const e in this.programConfigurations) this.programConfigurations[e].destroy();
          }
        }
        function zo(e, t) {
          return {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
          }[e] || [e.replace(t + "-", "").replace(/-/g, "_")];
        }
        function Yo(e, t, r) {
          var n = {
              color: {
                source: Ni,
                composite: qi
              },
              number: {
                source: zi,
                composite: Ni
              }
            },
            e = (e = e, {
              "line-pattern": {
                source: ho,
                composite: ho
              },
              "fill-pattern": {
                source: ho,
                composite: ho
              },
              "fill-extrusion-pattern": {
                source: ho,
                composite: ho
              }
            }[e]);
          return e && e[r] || n[t][r];
        }
        r("ConstantBinder", Mo), r("CrossFadedConstantBinder", ko), r("SourceExpressionBinder", Lo), r("CrossFadedCompositeBinder", Fo), r("CompositeExpressionBinder", Uo), r("ProgramConfiguration", Bo, {
          omit: ["_buffers"]
        }), r("ProgramConfigurationSet", $o);
        const de = 8192;
        const Ho = Math.pow(2, 14) - 1,
          jo = -Ho - 1;
        function Go(e) {
          var t = de / e.extent,
            r = e.loadGeometry();
          for (let e = 0; e < r.length; e++) {
            var n = r[e];
            for (let e = 0; e < n.length; e++) {
              var i = n[e],
                o = Math.round(i.x * t),
                a = Math.round(i.y * t);
              i.x = H(o, jo, Ho), i.y = H(a, jo, Ho), (o < i.x || o > i.x + 1 || a < i.y || a > i.y + 1) && he("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return r;
        }
        function qo(e, t) {
          return {
            type: e.type,
            id: e.id,
            properties: e.properties,
            geometry: t ? Go(e) : []
          };
        }
        function Vo(e, t, r, n, i) {
          e.emplaceBack(2 * t + (n + 1) / 2, 2 * r + (i + 1) / 2);
        }
        class Ko {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.hasPattern = !1, this.layoutVertexArray = new ao(), this.indexArray = new yo(), this.segments = new T(), this.programConfigurations = new $o(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter(e => e.isStateDependent()).map(e => e.id);
          }
          populate(e, t, r) {
            var n,
              i,
              o,
              a,
              s = this.layers[0],
              l = [];
            let c = null,
              u = !1;
            "circle" === s.type && (c = s.layout.get("circle-sort-key"), u = !c.isConstant());
            for ({
              feature: n,
              id: i,
              index: o,
              sourceLayerIndex: a
            } of e) {
              var h,
                d = this.layers[0]._featureFilter.needGeometry,
                p = qo(n, d);
              this.layers[0]._featureFilter.filter(new N(this.zoom), p, r) && (h = u ? c.evaluate(p, {}, r) : void 0, d = {
                id: i,
                properties: n.properties,
                type: n.type,
                sourceLayerIndex: a,
                index: o,
                geometry: d ? p.geometry : Go(n),
                patterns: {},
                sortKey: h
              }, l.push(d));
            }
            u && l.sort((e, t) => e.sortKey - t.sortKey);
            for (const y of l) {
              var {
                  geometry: f,
                  index: _,
                  sourceLayerIndex: m
                } = y,
                g = e[_].feature;
              this.addFeature(y, f, _, r), t.featureIndex.insert(g, f, _, m, this.index);
            }
          }
          update(e, t, r) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, r);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Eo), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(e, t, r, n) {
            for (const s of t) for (const l of s) {
              var i = l.x,
                o = l.y;
              if (!(i < 0 || i >= de || o < 0 || o >= de)) {
                var a = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey);
                const r = a.vertexLength;
                Vo(this.layoutVertexArray, i, o, -1, -1), Vo(this.layoutVertexArray, i, o, 1, -1), Vo(this.layoutVertexArray, i, o, 1, 1), Vo(this.layoutVertexArray, i, o, -1, 1), this.indexArray.emplaceBack(r, r + 1, r + 2), this.indexArray.emplaceBack(r, r + 3, r + 2), a.vertexLength += 4, a.primitiveLength += 2;
              }
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, r, {}, n);
          }
        }
        function Wo(t, r) {
          for (let e = 0; e < t.length; e++) if (na(r, t[e])) return !0;
          for (let e = 0; e < r.length; e++) if (na(t, r[e])) return !0;
          return !!Qo(t, r);
        }
        function Zo(e, t, r) {
          return na(e, t) || !!ea(t, e, r);
        }
        function Xo(t, r) {
          if (1 === t.length) return ra(r, t[0]);
          for (let e = 0; e < r.length; e++) {
            var n = r[e];
            for (let e = 0; e < n.length; e++) if (na(t, n[e])) return !0;
          }
          for (let e = 0; e < t.length; e++) if (ra(r, t[e])) return !0;
          for (let e = 0; e < r.length; e++) if (Qo(t, r[e])) return !0;
          return !1;
        }
        function Jo(t, r, n) {
          for (let e = 0; e < r.length; e++) {
            var i = r[e];
            if (3 <= t.length) for (let e = 0; e < i.length; e++) if (na(t, i[e])) return !0;
            if (function (t, r, n) {
              if (1 < t.length) {
                if (Qo(t, r)) return 1;
                for (let e = 0; e < r.length; e++) if (ea(r[e], t, n)) return 1;
              }
              for (let e = 0; e < t.length; e++) if (ea(t[e], r, n)) return 1;
              return;
            }(t, i, n)) return !0;
          }
          return !1;
        }
        function Qo(t, r) {
          var n, i;
          if (0 !== t.length && 0 !== r.length) for (let e = 0; e < t.length - 1; e++) {
            var o = t[e],
              a = t[e + 1];
            for (let e = 0; e < r.length - 1; e++) {
              var s = r[e],
                l = r[e + 1];
              if (i = a, J(n = o, s = s, l = l) !== J(i, s, l) && J(n, i, s) !== J(n, i, l)) return 1;
            }
          }
        }
        function ea(t, r, e) {
          var n = e * e;
          if (1 === r.length) return t.distSqr(r[0]) < n;
          for (let e = 1; e < r.length; e++) if (ta(t, r[e - 1], r[e]) < n) return 1;
        }
        function ta(e, t, r) {
          var n = t.distSqr(r);
          return 0 === n || (n = ((e.x - t.x) * (r.x - t.x) + (e.y - t.y) * (r.y - t.y)) / n) < 0 ? e.distSqr(t) : 1 < n ? e.distSqr(r) : e.distSqr(r.sub(t)._mult(n)._add(t));
        }
        function ra(n, i) {
          let o = !1,
            a,
            s,
            l;
          for (let r = 0; r < n.length; r++) for (let e = 0, t = (a = n[r]).length - 1; e < a.length; t = e++) s = a[e], l = a[t], s.y > i.y != l.y > i.y && i.x < (l.x - s.x) * (i.y - s.y) / (l.y - s.y) + s.x && (o = !o);
          return o;
        }
        function na(r, n) {
          let i = !1;
          for (let e = 0, t = r.length - 1; e < r.length; t = e++) {
            var o = r[e],
              a = r[t];
            o.y > n.y != a.y > n.y && n.x < (a.x - o.x) * (n.y - o.y) / (a.y - o.y) + o.x && (i = !i);
          }
          return i;
        }
        function ia(t, e, r, n, i) {
          for (const a of t) if (e <= a.x && r <= a.y && n >= a.x && i >= a.y) return !0;
          var o = [new F(e, r), new F(e, i), new F(n, i), new F(n, r)];
          if (2 < t.length) for (const s of o) if (na(t, s)) return !0;
          for (let e = 0; e < t.length - 1; e++) if (function (e, t, r) {
            var n = r[0],
              i = r[2];
            if (e.x < n.x && t.x < n.x || e.x > i.x && t.x > i.x || e.y < n.y && t.y < n.y || e.y > i.y && t.y > i.y) return;
            n = J(e, t, r[0]);
            return n !== J(e, t, r[1]) || n !== J(e, t, r[2]) || n !== J(e, t, r[3]);
          }(t[e], t[e + 1], o)) return !0;
          return !1;
        }
        function oa(e, t, r) {
          var n = t.paint.get(e).value;
          return "constant" === n.kind ? n.value : r.programConfigurations.get(t.id).getMaxValue(e);
        }
        function aa(e) {
          return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
        }
        function sa(t, e, r, n, i) {
          if (!e[0] && !e[1]) return t;
          var o = F.convert(e)._mult(i),
            a = ("viewport" === r && o._rotate(-n), []);
          for (let e = 0; e < t.length; e++) {
            var s = t[e];
            a.push(s.sub(o));
          }
          return a;
        }
        function la(t, r) {
          var n = [];
          for (let e = 0; e < t.length; e++) {
            var i = t[e],
              o = [];
            for (let e = 0; e < i.length; e++) {
              var a = i[e - 1],
                s = i[e],
                l = i[e + 1],
                a = 0 === e ? new F(0, 0) : s.sub(a)._unit()._perp(),
                l = e === i.length - 1 ? new F(0, 0) : l.sub(s)._unit()._perp(),
                a = a._add(l)._unit(),
                l = a.x * l.x + a.y * l.y;
              0 != l && a._mult(1 / l), o.push(a._mult(r)._add(s));
            }
            n.push(o);
          }
          return n;
        }
        r("CircleBucket", Ko, {
          omit: ["layers"]
        });
        let ca;
        let ua;
        var ha = {
            get paint() {
              return ua = ua || new l({
                "circle-radius": new a(o.paint_circle["circle-radius"]),
                "circle-color": new a(o.paint_circle["circle-color"]),
                "circle-blur": new a(o.paint_circle["circle-blur"]),
                "circle-opacity": new a(o.paint_circle["circle-opacity"]),
                "circle-translate": new i(o.paint_circle["circle-translate"]),
                "circle-translate-anchor": new i(o.paint_circle["circle-translate-anchor"]),
                "circle-pitch-scale": new i(o.paint_circle["circle-pitch-scale"]),
                "circle-pitch-alignment": new i(o.paint_circle["circle-pitch-alignment"]),
                "circle-stroke-width": new a(o.paint_circle["circle-stroke-width"]),
                "circle-stroke-color": new a(o.paint_circle["circle-stroke-color"]),
                "circle-stroke-opacity": new a(o.paint_circle["circle-stroke-opacity"])
              });
            },
            get layout() {
              return ca = ca || new l({
                "circle-sort-key": new a(o.layout_circle["circle-sort-key"])
              });
            }
          },
          R = 1e-6,
          S = "undefined" != typeof Float32Array ? Float32Array : Array;
        function da() {
          var e = new S(9);
          return S != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e;
        }
        function pa(e) {
          return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
        }
        function fa(e, t, r) {
          var n = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = t[4],
            l = t[5],
            c = t[6],
            u = t[7],
            h = t[8],
            d = t[9],
            p = t[10],
            f = t[11],
            _ = t[12],
            m = t[13],
            g = t[14],
            t = t[15],
            y = r[0],
            v = r[1],
            E = r[2],
            b = r[3];
          return e[0] = y * n + v * s + E * h + b * _, e[1] = y * i + v * l + E * d + b * m, e[2] = y * o + v * c + E * p + b * g, e[3] = y * a + v * u + E * f + b * t, y = r[4], v = r[5], E = r[6], b = r[7], e[4] = y * n + v * s + E * h + b * _, e[5] = y * i + v * l + E * d + b * m, e[6] = y * o + v * c + E * p + b * g, e[7] = y * a + v * u + E * f + b * t, y = r[8], v = r[9], E = r[10], b = r[11], e[8] = y * n + v * s + E * h + b * _, e[9] = y * i + v * l + E * d + b * m, e[10] = y * o + v * c + E * p + b * g, e[11] = y * a + v * u + E * f + b * t, y = r[12], v = r[13], E = r[14], b = r[15], e[12] = y * n + v * s + E * h + b * _, e[13] = y * i + v * l + E * d + b * m, e[14] = y * o + v * c + E * p + b * g, e[15] = y * a + v * u + E * f + b * t, e;
        }
        Math.hypot || (Math.hypot = function () {
          for (var e = 0, t = arguments.length; t--;) e += arguments[t] * arguments[t];
          return Math.sqrt(e);
        });
        function _a(e, t, r, n, i) {
          return t = 1 / Math.tan(t / 2), e[0] = t / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, null != i && i !== 1 / 0 ? (e[10] = (i + n) * (r = 1 / (n - i)), e[14] = 2 * i * n * r) : (e[10] = -1, e[14] = -2 * n), e;
        }
        function ma(e, t, r, n, i, o, a) {
          var s = 1 / (t - r),
            l = 1 / (n - i),
            c = 1 / (o - a);
          return e[0] = -2 * s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * l, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * c, e[11] = 0, e[12] = (t + r) * s, e[13] = (i + n) * l, e[14] = (a + o) * c, e[15] = 1, e;
        }
        Sr = fa;
        function ga() {
          var e = new S(3);
          return S != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e;
        }
        function ya(e, t, r) {
          var n = new S(3);
          return n[0] = e, n[1] = t, n[2] = r, n;
        }
        function va(e, t) {
          var r = t[0],
            n = t[1],
            i = t[2],
            r = r * r + n * n + i * i;
          return 0 < r && (r = 1 / Math.sqrt(r)), e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e;
        }
        function Ea(e, t) {
          return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
        }
        function ba(e, t, r) {
          var n = t[0],
            i = t[1],
            t = t[2],
            o = r[0],
            a = r[1],
            r = r[2];
          return e[0] = i * r - t * a, e[1] = t * o - n * r, e[2] = n * a - i * o, e;
        }
        function wa(e, t, r) {
          return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e;
        }
        function Ta(e, t, r) {
          var n = t[0],
            i = t[1],
            o = t[2],
            t = t[3];
          return e[0] = r[0] * n + r[4] * i + r[8] * o + r[12] * t, e[1] = r[1] * n + r[5] * i + r[9] * o + r[13] * t, e[2] = r[2] * n + r[6] * i + r[10] * o + r[14] * t, e[3] = r[3] * n + r[7] * i + r[11] * o + r[15] * t, e;
        }
        ga();
        function Sa(e, t, r) {
          return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e[3] = t[3] * r[3], e;
        }
        function xa() {
          var e = new S(4);
          return S != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e[3] = 1, e;
        }
        Tr = new S(4), S != Float32Array && (Tr[0] = 0, Tr[1] = 0, Tr[2] = 0, Tr[3] = 0);
        ga(), ya(1, 0, 0), ya(0, 1, 0), xa(), xa(), da();
        function Ca(e) {
          var t = e[0],
            e = e[1];
          return t * t + e * e;
        }
        t = new S(2), S != Float32Array && (t[0] = 0, t[1] = 0);
        class Aa extends Ei {
          constructor(e) {
            super(e, ha);
          }
          createBucket(e) {
            return new Ko(e);
          }
          queryRadius(e) {
            return oa("circle-radius", this, e) + oa("circle-stroke-width", this, e) + aa(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(e, t, r, n, i, o, a, s) {
            var e = sa(e, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), o.angle, a),
              t = this.paint.get("circle-radius").evaluate(t, r) + this.paint.get("circle-stroke-width").evaluate(t, r),
              l = "map" === this.paint.get("circle-pitch-alignment"),
              c = l ? e : Na(e, s),
              u = l ? t * a : t;
            for (const p of n) for (const f of p) {
              var h = l ? f : Ia(f, s);
              let e = u;
              var d = Ta([], [f.x, f.y, 0, 1], s);
              if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? e *= d[3] / o.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (e *= o.cameraToCenterDistance / d[3]), Zo(c, h, e)) return !0;
            }
            return !1;
          }
        }
        function Ia(e, t) {
          e = Ta([], [e.x, e.y, 0, 1], t);
          return new F(e[0] / e[3], e[1] / e[3]);
        }
        function Na(e, t) {
          return e.map(e => Ia(e, t));
        }
        class Pa extends Ko {}
        r("HeatmapBucket", Pa, {
          omit: ["layers"]
        });
        let Da;
        var Ra = {
          get paint() {
            return Da = Da || new l({
              "heatmap-radius": new a(o.paint_heatmap["heatmap-radius"]),
              "heatmap-weight": new a(o.paint_heatmap["heatmap-weight"]),
              "heatmap-intensity": new i(o.paint_heatmap["heatmap-intensity"]),
              "heatmap-color": new yi(o.paint_heatmap["heatmap-color"]),
              "heatmap-opacity": new i(o.paint_heatmap["heatmap-opacity"])
            });
          }
        };
        function Oa(e, {
          width: t,
          height: r
        }, n, i) {
          if (i) {
            if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);else if (i.length !== t * r * n) throw new RangeError(`mismatched image size. expected: ${i.length} but got: ` + t * r * n);
          } else i = new Uint8Array(t * r * n);
          return e.width = t, e.height = r, e.data = i, e;
        }
        function Ma(e, {
          width: t,
          height: r
        }, n) {
          var i;
          t === e.width && r === e.height || (ka(e, i = Oa({}, {
            width: t,
            height: r
          }, n), {
            x: 0,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            width: Math.min(e.width, t),
            height: Math.min(e.height, r)
          }, n), e.width = t, e.height = r, e.data = i.data);
        }
        function ka(t, r, n, i, o, a) {
          if (0 !== o.width && 0 !== o.height) {
            if (o.width > t.width || o.height > t.height || n.x > t.width - o.width || n.y > t.height - o.height) throw new RangeError("out of range source coordinates for image copy");
            if (o.width > r.width || o.height > r.height || i.x > r.width - o.width || i.y > r.height - o.height) throw new RangeError("out of range destination coordinates for image copy");
            var s = t.data,
              l = r.data;
            if (s === l) throw new Error("srcData equals dstData, so image is already copied");
            for (let e = 0; e < o.height; e++) {
              var c = ((n.y + e) * t.width + n.x) * a,
                u = ((i.y + e) * r.width + i.x) * a;
              for (let e = 0; e < o.width * a; e++) l[u + e] = s[c + e];
            }
          }
        }
        class La {
          constructor(e, t) {
            Oa(this, e, 1, t);
          }
          resize(e) {
            Ma(this, e, 1);
          }
          clone() {
            return new La({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data));
          }
          static copy(e, t, r, n, i) {
            ka(e, t, r, n, i, 1);
          }
        }
        class Ua {
          constructor(e, t) {
            Oa(this, e, 4, t);
          }
          resize(e) {
            Ma(this, e, 4);
          }
          replace(e, t) {
            t ? this.data.set(e) : e instanceof Uint8ClampedArray ? this.data = new Uint8Array(e.buffer) : this.data = e;
          }
          clone() {
            return new Ua({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data));
          }
          static copy(e, t, r, n, i) {
            ka(e, t, r, n, i, 4);
          }
        }
        function Fa(i) {
          const n = {};
          var o = i.resolution || 256,
            e = i.clips ? i.clips.length : 1;
          const a = i.image || new Ua({
            width: o,
            height: e
          });
          if (Math.log(o) / Math.LN2 % 1 != 0) throw new Error("width is not a power of 2 - " + o);
          var s = (e, t, r) => {
            n[i.evaluationKey] = r;
            r = i.expression.evaluate(n);
            a.data[e + t + 0] = Math.floor(255 * r.r / r.a), a.data[e + t + 1] = Math.floor(255 * r.g / r.a), a.data[e + t + 2] = Math.floor(255 * r.b / r.a), a.data[e + t + 3] = Math.floor(255 * r.a);
          };
          if (i.clips) for (let r = 0, n = 0; r < e; ++r, n += 4 * o) for (let e = 0, t = 0; e < o; e++, t += 4) {
            var l = e / (o - 1),
              {
                start: c,
                end: u
              } = i.clips[r];
            s(n, t, c * (1 - l) + u * l);
          } else for (let e = 0, t = 0; e < o; e++, t += 4) {
            var r = e / (o - 1);
            s(0, t, r);
          }
          return a;
        }
        r("AlphaImage", La), r("RGBAImage", Ua);
        class Ba extends Ei {
          createBucket(e) {
            return new Pa(e);
          }
          constructor(e) {
            super(e, Ra), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(e) {
            "heatmap-color" === e && this._updateColorRamp();
          }
          _updateColorRamp() {
            var e = this._transitionablePaint._values["heatmap-color"].value.expression;
            this.colorRamp = Fa({
              expression: e,
              evaluationKey: "heatmapDensity",
              image: this.colorRamp
            }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return !1;
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
        }
        let $a;
        var za = {
          get paint() {
            return $a = $a || new l({
              "hillshade-illumination-direction": new i(o.paint_hillshade["hillshade-illumination-direction"]),
              "hillshade-illumination-anchor": new i(o.paint_hillshade["hillshade-illumination-anchor"]),
              "hillshade-exaggeration": new i(o.paint_hillshade["hillshade-exaggeration"]),
              "hillshade-shadow-color": new i(o.paint_hillshade["hillshade-shadow-color"]),
              "hillshade-highlight-color": new i(o.paint_hillshade["hillshade-highlight-color"]),
              "hillshade-accent-color": new i(o.paint_hillshade["hillshade-accent-color"])
            });
          }
        };
        class Ya extends Ei {
          constructor(e) {
            super(e, za);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
        }
        const Ha = w([{
          name: "a_pos",
          components: 2,
          type: "Int16"
        }], 4)["members"];
        xr = {
          exports: {}
        };
        function ja(e, t, r) {
          r = r || 2;
          var n,
            i,
            o,
            a,
            s,
            l = t && t.length,
            c = l ? t[0] * r : e.length,
            u = Ga(e, 0, c, r, !0),
            h = [];
          if (u && u.next !== u.prev) {
            if (l && (u = function (e, t, r, n) {
              var i,
                o,
                a,
                s,
                l = [];
              for (i = 0, o = t.length; i < o; i++) s = t[i] * n, a = i < o - 1 ? t[i + 1] * n : e.length, (s = Ga(e, s, a, n, !1)) === s.next && (s.steiner = !0), l.push(function (e) {
                var t = e,
                  r = e;
                for (; (t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next, t !== e;);
                return r;
              }(s));
              for (l.sort(Ka), i = 0; i < l.length; i++) r = function (e, t) {
                var r = function (e, t) {
                  var r,
                    n = t,
                    i = e.x,
                    o = e.y,
                    a = -1 / 0;
                  do {
                    if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
                      var s = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                      if (s <= i && a < s && (a = s, r = n.x < n.next.x ? n : n.next, s === i)) return r;
                    }
                  } while ((n = n.next, n !== t));
                  if (!r) return null;
                  var l,
                    c = r,
                    u = r.x,
                    h = r.y,
                    d = 1 / 0;
                  n = r;
                  for (; i >= n.x && n.x >= u && i !== n.x && Za(o < h ? i : a, o, u, h, o < h ? a : i, o, n.x, n.y) && (l = Math.abs(o - n.y) / (i - n.x), ts(n, e)) && (l < d || l === d && (n.x > r.x || n.x === r.x && function (e, t) {
                    return x(e.prev, e, t.prev) < 0 && x(t.next, e, e.next) < 0;
                  }(r, n))) && (r = n, d = l), n = n.next, n !== c;);
                  return r;
                }(e, t);
                return r ? (qa(e = rs(r, e), e.next), qa(r, r.next)) : t;
              }(l[i], r);
              return r;
            }(e, t, u, r)), e.length > 80 * r) {
              for (var d = n = e[0], p = i = e[1], f = r; f < c; f += r) (o = e[f]) < d && (d = o), (a = e[f + 1]) < p && (p = a), n < o && (n = o), i < a && (i = a);
              s = 0 !== (s = Math.max(n - d, i - p)) ? 32767 / s : 0;
            }
            Va(u, h, r, d, p, s, 0);
          }
          return h;
        }
        function Ga(e, t, r, n, i) {
          var o, a;
          if (i === 0 < as(e, t, r, n)) for (o = t; o < r; o += n) a = ns(o, e[o], e[o + 1], a);else for (o = r - n; t <= o; o -= n) a = ns(o, e[o], e[o + 1], a);
          return a && Xa(a, a.next) && (is(a), a = a.next), a;
        }
        function qa(e, t) {
          if (!e) return e;
          t = t || e;
          var r,
            n = e;
          do {
            if (r = !1, n.steiner || !Xa(n, n.next) && 0 !== x(n.prev, n, n.next)) n = n.next;else {
              if (is(n), (n = t = n.prev) === n.next) break;
              r = !0;
            }
          } while (r || n !== t);
          return t;
        }
        function Va(e, t, r, n, i, o, a) {
          if (e) {
            if (!a && o) {
              for (var s = e, l = n, c = i, u = o, h = s; 0 === h.z && (h.z = Wa(h.x, h.y, l, c, u)), h.prevZ = h.prev, h.nextZ = h.next, (h = h.next) !== s;);
              h.prevZ.nextZ = null, h.prevZ = null;
              var d,
                p,
                f,
                _,
                m,
                g,
                y,
                v,
                E = h,
                b = 1;
              do {
                for (p = E, m = E = null, g = 0; p;) {
                  for (g++, f = p, d = y = 0; d < b && (y++, f = f.nextZ); d++);
                  for (v = b; 0 < y || 0 < v && f;) 0 !== y && (0 === v || !f || p.z <= f.z) ? (p = (_ = p).nextZ, y--) : (f = (_ = f).nextZ, v--), m ? m.nextZ = _ : E = _, _.prevZ = m, m = _;
                  p = f;
                }
              } while ((m.nextZ = null, b *= 2, 1 < g));
            }
            for (var w, T, S = e; e.prev !== e.next;) if (w = e.prev, T = e.next, o ? function (e, t, r, n) {
              var i = e.prev,
                o = e,
                a = e.next;
              if (0 <= x(i, o, a)) return;
              var s = i.x,
                l = o.x,
                c = a.x,
                u = i.y,
                h = o.y,
                d = a.y,
                p = s < l ? s < c ? s : c : l < c ? l : c,
                f = u < h ? u < d ? u : d : h < d ? h : d,
                _ = l < s ? c < s ? s : c : c < l ? l : c,
                m = h < u ? d < u ? u : d : d < h ? h : d,
                g = Wa(p, f, t, r, n),
                y = Wa(_, m, t, r, n),
                v = e.prevZ,
                E = e.nextZ;
              for (; v && v.z >= g && E && E.z <= y;) {
                if (v.x >= p && v.x <= _ && v.y >= f && v.y <= m && v !== i && v !== a && Za(s, u, l, h, c, d, v.x, v.y) && 0 <= x(v.prev, v, v.next)) return;
                if (v = v.prevZ, E.x >= p && E.x <= _ && E.y >= f && E.y <= m && E !== i && E !== a && Za(s, u, l, h, c, d, E.x, E.y) && 0 <= x(E.prev, E, E.next)) return;
                E = E.nextZ;
              }
              for (; v && v.z >= g;) {
                if (v.x >= p && v.x <= _ && v.y >= f && v.y <= m && v !== i && v !== a && Za(s, u, l, h, c, d, v.x, v.y) && 0 <= x(v.prev, v, v.next)) return;
                v = v.prevZ;
              }
              for (; E && E.z <= y;) {
                if (E.x >= p && E.x <= _ && E.y >= f && E.y <= m && E !== i && E !== a && Za(s, u, l, h, c, d, E.x, E.y) && 0 <= x(E.prev, E, E.next)) return;
                E = E.nextZ;
              }
              return 1;
            }(e, n, i, o) : function (e) {
              var t = e.prev,
                r = e,
                e = e.next;
              if (0 <= x(t, r, e)) return;
              var n = t.x,
                i = r.x,
                o = e.x,
                a = t.y,
                s = r.y,
                l = e.y,
                c = n < i ? n < o ? n : o : i < o ? i : o,
                u = a < s ? a < l ? a : l : s < l ? s : l,
                h = i < n ? o < n ? n : o : o < i ? i : o,
                d = s < a ? l < a ? a : l : l < s ? s : l,
                p = e.next;
              for (; p !== t;) {
                if (p.x >= c && p.x <= h && p.y >= u && p.y <= d && Za(n, a, i, s, o, l, p.x, p.y) && 0 <= x(p.prev, p, p.next)) return;
                p = p.next;
              }
              return 1;
            }(e)) t.push(w.i / r | 0), t.push(e.i / r | 0), t.push(T.i / r | 0), is(e), e = T.next, S = T.next;else if ((e = T) === S) {
              a ? 1 === a ? Va(e = function (e, t, r) {
                var n = e;
                do {
                  var i = n.prev,
                    o = n.next.next;
                } while ((!Xa(i, o) && Ja(i, n, n.next, o) && ts(i, o) && ts(o, i) && (t.push(i.i / r | 0), t.push(n.i / r | 0), t.push(o.i / r | 0), is(n), is(n.next), n = e = o), n = n.next, n !== e));
                return qa(n);
              }(qa(e), t, r), t, r, n, i, o, 2) : 2 === a && function (e, t, r, n, i, o) {
                var a = e;
                do {
                  for (var s, l = a.next.next; l !== a.prev;) {
                    if (a.i !== l.i && function (e, t) {
                      return e.next.i !== t.i && e.prev.i !== t.i && !function (e, t) {
                        var r = e;
                        do {
                          if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && Ja(r, r.next, e, t)) return 1;
                        } while ((r = r.next, r !== e));
                        return;
                      }(e, t) && (ts(e, t) && ts(t, e) && function (e, t) {
                        var r = e,
                          n = !1,
                          i = (e.x + t.x) / 2,
                          o = (e.y + t.y) / 2;
                        for (; r.y > o != r.next.y > o && r.next.y !== r.y && i < (r.next.x - r.x) * (o - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next, r !== e;);
                        return n;
                      }(e, t) && (x(e.prev, e, t.prev) || x(e, t.prev, t)) || Xa(e, t) && 0 < x(e.prev, e, e.next) && 0 < x(t.prev, t, t.next));
                    }(a, l)) return s = rs(a, l), a = qa(a, a.next), s = qa(s, s.next), Va(a, t, r, n, i, o, 0), Va(s, t, r, n, i, o, 0);
                    l = l.next;
                  }
                } while ((a = a.next, a !== e));
              }(e, t, r, n, i, o) : Va(qa(e), t, r, n, i, o, 1);
              break;
            }
          }
        }
        function Ka(e, t) {
          return e.x - t.x;
        }
        function Wa(e, t, r, n, i) {
          return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - r) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
        }
        function Za(e, t, r, n, i, o, a, s) {
          return (e - a) * (o - s) <= (i - a) * (t - s) && (r - a) * (t - s) <= (e - a) * (n - s) && (i - a) * (n - s) <= (r - a) * (o - s);
        }
        function x(e, t, r) {
          return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y);
        }
        function Xa(e, t) {
          return e.x === t.x && e.y === t.y;
        }
        function Ja(e, t, r, n) {
          var i = es(x(e, t, r)),
            o = es(x(e, t, n)),
            a = es(x(r, n, e)),
            s = es(x(r, n, t));
          return i !== o && a !== s || 0 === i && Qa(e, r, t) || 0 === o && Qa(e, n, t) || 0 === a && Qa(r, e, n) || !(0 !== s || !Qa(r, t, n));
        }
        function Qa(e, t, r) {
          return t.x <= Math.max(e.x, r.x) && t.x >= Math.min(e.x, r.x) && t.y <= Math.max(e.y, r.y) && t.y >= Math.min(e.y, r.y);
        }
        function es(e) {
          return 0 < e ? 1 : e < 0 ? -1 : 0;
        }
        function ts(e, t) {
          return x(e.prev, e, e.next) < 0 ? 0 <= x(e, t, e.next) && 0 <= x(e, e.prev, t) : x(e, t, e.prev) < 0 || x(e, e.next, t) < 0;
        }
        function rs(e, t) {
          var r = new os(e.i, e.x, e.y),
            n = new os(t.i, t.x, t.y),
            i = e.next,
            o = t.prev;
          return (e.next = t).prev = e, (r.next = i).prev = r, (n.next = r).prev = n, (o.next = n).prev = o, n;
        }
        function ns(e, t, r, n) {
          e = new os(e, t, r);
          return n ? (e.next = n.next, (e.prev = n).next.prev = e, n.next = e) : (e.prev = e).next = e, e;
        }
        function is(e) {
          e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);
        }
        function os(e, t, r) {
          this.i = e, this.x = t, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
        }
        function as(e, t, r, n) {
          for (var i = 0, o = t, a = r - n; o < r; o += n) i += (e[a] - e[o]) * (e[o + 1] + e[a + 1]), a = o;
          return i;
        }
        xr.exports = ja, (xr.exports.default = ja).deviation = function (e, t, r, n) {
          var i = t && t.length,
            o = i ? t[0] * r : e.length,
            a = Math.abs(as(e, 0, o, r));
          if (i) for (var s = 0, l = t.length; s < l; s++) {
            var c = t[s] * r,
              u = s < l - 1 ? t[s + 1] * r : e.length;
            a -= Math.abs(as(e, c, u, r));
          }
          for (var h = 0, s = 0; s < n.length; s += 3) {
            var d = n[s] * r,
              p = n[s + 1] * r,
              f = n[s + 2] * r;
            h += Math.abs((e[d] - e[f]) * (e[1 + p] - e[1 + d]) - (e[d] - e[p]) * (e[1 + f] - e[1 + d]));
          }
          return 0 === a && 0 === h ? 0 : Math.abs((h - a) / a);
        }, ja.flatten = function (e) {
          for (var t = e[0][0].length, r = {
              vertices: [],
              holes: [],
              dimensions: t
            }, n = 0, i = 0; i < e.length; i++) {
            for (var o = 0; o < e[i].length; o++) for (var a = 0; a < t; a++) r.vertices.push(e[i][o][a]);
            0 < i && (n += e[i - 1].length, r.holes.push(n));
          }
          return r;
        };
        var ss = I(xr.exports);
        function ls(e, t, r, n, i) {
          !function e(t, r, n, i, o) {
            for (; n < i;) {
              600 < i - n && (a = i - n + 1, u = r - n + 1, l = Math.log(a), s = .5 * Math.exp(2 * l / 3), l = .5 * Math.sqrt(l * s * (a - s) / a) * (u - a / 2 < 0 ? -1 : 1), c = Math.max(n, Math.floor(r - u * s / a + l)), u = Math.min(i, Math.floor(r + (a - u) * s / a + l)), e(t, r, c, u, o));
              var a,
                s,
                l,
                c,
                u,
                h = t[r],
                d = n,
                p = i;
              for (cs(t, n, r), 0 < o(t[i], h) && cs(t, n, i); d < p;) {
                for (cs(t, d, p), d++, p--; o(t[d], h) < 0;) d++;
                for (; 0 < o(t[p], h);) p--;
              }
              0 === o(t[n], h) ? cs(t, n, p) : cs(t, ++p, i), p <= r && (n = p + 1), r <= p && (i = p - 1);
            }
          }(e, t, r , n || e.length - 1, i || us);
        }
        function cs(e, t, r) {
          var n = e[t];
          e[t] = e[r], e[r] = n;
        }
        function us(e, t) {
          return e < t ? -1 : t < e ? 1 : 0;
        }
        function hs(t, r) {
          var n = t.length;
          if (n <= 1) return [t];
          var i = [];
          let o, a;
          for (let e = 0; e < n; e++) {
            var s = function (o) {
              let a = 0;
              for (let e = 0, t = o.length, r = t - 1, n, i; e < t; r = e++) n = o[e], i = o[r], a += (i.x - n.x) * (n.y + i.y);
              return a;
            }(t[e]);
            0 !== s && (t[e].area = Math.abs(s), (a = void 0 === a ? s < 0 : a) === s < 0 ? (o && i.push(o), o = [t[e]]) : o.push(t[e]));
          }
          if (o && i.push(o), 1 < r) for (let e = 0; e < i.length; e++) i[e].length <= r || (ls(i[e], r, 1, i[e].length - 1, ds), i[e] = i[e].slice(0, r));
          return i;
        }
        function ds(e, t) {
          return t.area - e.area;
        }
        function ps(e, t, r) {
          var n = r.patternDependencies;
          let i = !1;
          for (const a of t) {
            var o = a.paint.get(e + "-pattern"),
              o = (o.isConstant() || (i = !0), o.constantOr(null));
            o && (i = !0, n[o.to] = !0, n[o.from] = !0);
          }
          return i;
        }
        function fs(e, t, r, n, i) {
          var o = i.patternDependencies;
          for (const c of t) {
            var a,
              s,
              l = c.paint.get(e + "-pattern").value;
            "constant" !== l.kind && (a = l.evaluate({
              zoom: n - 1
            }, r, {}, i.availableImages), s = l.evaluate({
              zoom: n
            }, r, {}, i.availableImages), l = l.evaluate({
              zoom: n + 1
            }, r, {}, i.availableImages), a = a && a.name ? a.name : a, s = s && s.name ? s.name : s, l = l && l.name ? l.name : l, o[a] = !0, o[s] = !0, o[l] = !0, r.patterns[c.id] = {
              min: a,
              mid: s,
              max: l
            });
          }
          return r;
        }
        class _s {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new so(), this.indexArray = new yo(), this.indexArray2 = new vo(), this.programConfigurations = new $o(e.layers, e.zoom), this.segments = new T(), this.segments2 = new T(), this.stateDependentLayerIds = this.layers.filter(e => e.isStateDependent()).map(e => e.id);
          }
          populate(e, t, r) {
            this.hasPattern = ps("fill", this.layers, t);
            var n,
              i,
              o,
              a,
              s = this.layers[0].layout.get("fill-sort-key"),
              l = !s.isConstant(),
              c = [];
            for ({
              feature: n,
              id: i,
              index: o,
              sourceLayerIndex: a
            } of e) {
              var u,
                h = this.layers[0]._featureFilter.needGeometry,
                d = qo(n, h);
              this.layers[0]._featureFilter.filter(new N(this.zoom), d, r) && (u = l ? s.evaluate(d, {}, r, t.availableImages) : void 0, h = {
                id: i,
                properties: n.properties,
                type: n.type,
                sourceLayerIndex: a,
                index: o,
                geometry: h ? d.geometry : Go(n),
                patterns: {},
                sortKey: u
              }, c.push(h));
            }
            l && c.sort((e, t) => e.sortKey - t.sortKey);
            for (const g of c) {
              var {
                  geometry: p,
                  index: f,
                  sourceLayerIndex: _
                } = g,
                m = (this.hasPattern ? (m = fs("fill", this.layers, g, this.zoom, t), this.patternFeatures.push(m)) : this.addFeature(g, p, f, r, {}), e[f].feature);
              t.featureIndex.insert(m, p, f, _, this.index);
            }
          }
          update(e, t, r) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, r);
          }
          addFeatures(e, t, r) {
            for (const n of this.patternFeatures) this.addFeature(n, n.geometry, n.index, t, r);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Ha), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(e, t, r, n, i) {
            for (const d of hs(t, 500)) {
              let e = 0;
              for (const p of d) e += p.length;
              var o = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray),
                a = o.vertexLength,
                s = [],
                l = [];
              for (const f of d) if (0 !== f.length) {
                f !== d[0] && l.push(s.length / 2);
                var c = this.segments2.prepareSegment(f.length, this.layoutVertexArray, this.indexArray2),
                  u = c.vertexLength;
                this.layoutVertexArray.emplaceBack(f[0].x, f[0].y), this.indexArray2.emplaceBack(u + f.length - 1, u), s.push(f[0].x), s.push(f[0].y);
                for (let e = 1; e < f.length; e++) this.layoutVertexArray.emplaceBack(f[e].x, f[e].y), this.indexArray2.emplaceBack(u + e - 1, u + e), s.push(f[e].x), s.push(f[e].y);
                c.vertexLength += f.length, c.primitiveLength += f.length;
              }
              var h = ss(s, l);
              for (let e = 0; e < h.length; e += 3) this.indexArray.emplaceBack(a + h[e], a + h[e + 1], a + h[e + 2]);
              o.vertexLength += e, o.primitiveLength += h.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, r, i, n);
          }
        }
        r("FillBucket", _s, {
          omit: ["layers", "patternFeatures"]
        });
        let ms;
        let gs;
        var ys = {
          get paint() {
            return gs = gs || new l({
              "fill-antialias": new i(o.paint_fill["fill-antialias"]),
              "fill-opacity": new a(o.paint_fill["fill-opacity"]),
              "fill-color": new a(o.paint_fill["fill-color"]),
              "fill-outline-color": new a(o.paint_fill["fill-outline-color"]),
              "fill-translate": new i(o.paint_fill["fill-translate"]),
              "fill-translate-anchor": new i(o.paint_fill["fill-translate-anchor"]),
              "fill-pattern": new mi(o.paint_fill["fill-pattern"])
            });
          },
          get layout() {
            return ms = ms || new l({
              "fill-sort-key": new a(o.layout_fill["fill-sort-key"])
            });
          }
        };
        class vs extends Ei {
          constructor(e) {
            super(e, ys);
          }
          recalculate(e, t) {
            super.recalculate(e, t);
            e = this.paint._values["fill-outline-color"];
            "constant" === e.value.kind && void 0 === e.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(e) {
            return new _s(e);
          }
          queryRadius() {
            return aa(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(e, t, r, n, i, o, a) {
            return Xo(sa(e, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), o.angle, a), n);
          }
          isTileClipped() {
            return !0;
          }
        }
        e = w([{
          name: "a_pos",
          components: 2,
          type: "Int16"
        }, {
          name: "a_normal_ed",
          components: 4,
          type: "Int16"
        }], 4);
        const Es = w([{
            name: "a_centroid",
            components: 2,
            type: "Int16"
          }], 4),
          bs = e["members"];
        var ws = {},
          Ts = P,
          Tr = Ss;
        function Ss(e, t, r, n, i) {
          this.properties = {}, this.extent = r, this.type = 0, this._pbf = e, this._geometry = -1, this._keys = n, this._values = i, e.readFields(xs, this, t);
        }
        function xs(e, t, r) {
          if (1 == e) t.id = r.readVarint();else if (2 == e) for (var n = r, i = t, o = n.readVarint() + n.pos; n.pos < o;) {
            var a = i._keys[n.readVarint()],
              s = i._values[n.readVarint()];
            i.properties[a] = s;
          } else 3 == e ? t.type = r.readVarint() : 4 == e && (t._geometry = r.pos);
        }
        Ss.types = ["Unknown", "Point", "LineString", "Polygon"], Ss.prototype.loadGeometry = function () {
          for (var e, t, r = this._pbf, n = (r.pos = this._geometry, r.readVarint() + r.pos), i = 1, o = 0, a = 0, s = 0, l = []; r.pos < n;) if (o <= 0 && (i = 7 & (t = r.readVarint()), o = t >> 3), o--, 1 === i || 2 === i) a += r.readSVarint(), s += r.readSVarint(), 1 === i && (e && l.push(e), e = []), e.push(new Ts(a, s));else {
            if (7 !== i) throw new Error("unknown command " + i);
            e && e.push(e[0].clone());
          }
          return e && l.push(e), l;
        }, Ss.prototype.bbox = function () {
          for (var e, t = this._pbf, r = (t.pos = this._geometry, t.readVarint() + t.pos), n = 1, i = 0, o = 0, a = 0, s = 1 / 0, l = -1 / 0, c = 1 / 0, u = -1 / 0; t.pos < r;) if (i <= 0 && (n = 7 & (e = t.readVarint()), i = e >> 3), i--, 1 === n || 2 === n) (o += t.readSVarint()) < s && (s = o), l < o && (l = o), (a += t.readSVarint()) < c && (c = a), u < a && (u = a);else if (7 !== n) throw new Error("unknown command " + n);
          return [s, c, l, u];
        }, Ss.prototype.toGeoJSON = function (e, t, r) {
          var n,
            i = this.extent * Math.pow(2, r),
            o = this.extent * e,
            a = this.extent * t,
            s = this.loadGeometry(),
            r = Ss.types[this.type];
          function l(e) {
            for (var t = 0; t < e.length; t++) {
              var r = e[t],
                n = 180 - 360 * (r.y + a) / i;
              e[t] = [360 * (r.x + o) / i - 180, 360 / Math.PI * Math.atan(Math.exp(n * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              for (var c = [], u = 0; u < s.length; u++) c[u] = s[u][0];
              l(s = c);
              break;
            case 2:
              for (u = 0; u < s.length; u++) l(s[u]);
              break;
            case 3:
              for (s = function (e) {
                var t = e.length;
                if (t <= 1) return [e];
                for (var r, n, i = [], o = 0; o < t; o++) {
                  var a = function (e) {
                    for (var t, r, n = 0, i = 0, o = e.length, a = o - 1; i < o; a = i++) t = e[i], r = e[a], n += (r.x - t.x) * (t.y + r.y);
                    return n;
                  }(e[o]);
                  0 !== a && ((n = void 0 === n ? a < 0 : n) === a < 0 ? (r && i.push(r), r = [e[o]]) : r.push(e[o]));
                }
                r && i.push(r);
                return i;
              }(s), u = 0; u < s.length; u++) for (n = 0; n < s[u].length; n++) l(s[u][n]);
          }
          1 === s.length ? s = s[0] : r = "Multi" + r;
          e = {
            type: "Feature",
            geometry: {
              type: r,
              coordinates: s
            },
            properties: this.properties
          };
          return "id" in this && (e.id = this.id), e;
        };
        var Cs = Tr,
          t = As;
        function As(e, t) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = e, this._keys = [], this._values = [], this._features = [], e.readFields(Is, this, t), this.length = this._features.length;
        }
        function Is(e, t, r) {
          15 === e ? t.version = r.readVarint() : 1 === e ? t.name = r.readString() : 5 === e ? t.extent = r.readVarint() : 2 === e ? t._features.push(r.pos) : 3 === e ? t._keys.push(r.readString()) : 4 === e && t._values.push(function (e) {
            var t = null,
              r = e.readVarint() + e.pos;
            for (; e.pos < r;) {
              var n = e.readVarint() >> 3;
              t = 1 == n ? e.readString() : 2 == n ? e.readFloat() : 3 == n ? e.readDouble() : 4 == n ? e.readVarint64() : 5 == n ? e.readVarint() : 6 == n ? e.readSVarint() : 7 == n ? e.readBoolean() : null;
            }
            return t;
          }(r));
        }
        As.prototype.feature = function (e) {
          if (e < 0 || e >= this._features.length) throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[e];
          e = this._pbf.readVarint() + this._pbf.pos;
          return new Cs(this._pbf, e, this.extent, this._keys, this._values);
        };
        var Ns = t;
        function Ps(e, t, r) {
          3 === e && (e = new Ns(r, r.readVarint() + r.pos)).length && (t[e.name] = e);
        }
        ws.VectorTile = function (e, t) {
          this.layers = e.readFields(Ps, {}, t);
        }, ws.VectorTileFeature = Tr, ws.VectorTileLayer = t;
        const Ds = ws.VectorTileFeature.types,
          Rs = Math.pow(2, 13);
        function Os(e, t, r, n, i, o, a, s) {
          e.emplaceBack(t, r, 2 * Math.floor(n * Rs) + a, i * Rs * 2, o * Rs * 2, Math.round(s));
        }
        class Ms {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.hasPattern = !1, this.layoutVertexArray = new lo(), this.centroidVertexArray = new oo(), this.indexArray = new yo(), this.programConfigurations = new $o(e.layers, e.zoom), this.segments = new T(), this.stateDependentLayerIds = this.layers.filter(e => e.isStateDependent()).map(e => e.id);
          }
          populate(e, t, r) {
            this.features = [], this.hasPattern = ps("fill-extrusion", this.layers, t);
            for (var {
              feature: n,
              id: i,
              index: o,
              sourceLayerIndex: a
            } of e) {
              var s = this.layers[0]._featureFilter.needGeometry,
                l = qo(n, s);
              this.layers[0]._featureFilter.filter(new N(this.zoom), l, r) && (i = {
                id: i,
                sourceLayerIndex: a,
                index: o,
                geometry: s ? l.geometry : Go(n),
                properties: n.properties,
                type: n.type,
                patterns: {}
              }, this.hasPattern ? this.features.push(fs("fill-extrusion", this.layers, i, this.zoom, t)) : this.addFeature(i, i.geometry, o, r, {}), t.featureIndex.insert(n, i.geometry, o, a, this.index, !0));
            }
          }
          addFeatures(e, t, r) {
            for (const i of this.features) {
              var n = i["geometry"];
              this.addFeature(i, n, i.index, t, r);
            }
          }
          update(e, t, r) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, r);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, bs), this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, Es.members, !0), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t, e, r, n, i) {
            var o = {
              x: 0,
              y: 0,
              vertexCount: 0
            };
            for (const _ of hs(e, 500)) {
              let e = 0;
              for (const m of _) e += m.length;
              let r = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
              for (const g of _) if (0 !== g.length && !Ls(g)) {
                let t = 0;
                for (let e = 0; e < g.length; e++) {
                  var a,
                    s,
                    l,
                    c = g[e];
                  1 <= e && (ks(c, a = g[e - 1]) || (r.vertexLength + 4 > T.MAX_VERTEX_ARRAY_LENGTH && (r = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)), s = c.sub(a)._perp()._unit(), l = a.dist(c), 32768 < t + l && (t = 0), Os(this.layoutVertexArray, c.x, c.y, s.x, s.y, 0, 0, t), Os(this.layoutVertexArray, c.x, c.y, s.x, s.y, 0, 1, t), o.x += 2 * c.x, o.y += 2 * c.y, o.vertexCount += 2, t += l, Os(this.layoutVertexArray, a.x, a.y, s.x, s.y, 0, 0, t), Os(this.layoutVertexArray, a.x, a.y, s.x, s.y, 0, 1, t), o.x += 2 * a.x, o.y += 2 * a.y, o.vertexCount += 2, c = r.vertexLength, this.indexArray.emplaceBack(c, c + 2, c + 1), this.indexArray.emplaceBack(c + 1, c + 2, c + 3), r.vertexLength += 4, r.primitiveLength += 2));
                }
              }
              if (r.vertexLength + e > T.MAX_VERTEX_ARRAY_LENGTH && (r = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray)), "Polygon" === Ds[t.type]) {
                var u = [],
                  h = [],
                  d = r.vertexLength;
                for (const y of _) if (0 !== y.length) {
                  y !== _[0] && h.push(u.length / 2);
                  for (let e = 0; e < y.length; e++) {
                    var p = y[e];
                    Os(this.layoutVertexArray, p.x, p.y, 0, 0, 1, 1, 0), o.x += p.x, o.y += p.y, o.vertexCount += 1, u.push(p.x), u.push(p.y);
                  }
                }
                var f = ss(u, h);
                for (let e = 0; e < f.length; e += 3) this.indexArray.emplaceBack(d + f[e], d + f[e + 2], d + f[e + 1]);
                r.primitiveLength += f.length / 3, r.vertexLength += e;
              }
            }
            for (let e = 0; e < o.vertexCount; e++) this.centroidVertexArray.emplaceBack(Math.floor(o.x / o.vertexCount), Math.floor(o.y / o.vertexCount));
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);
          }
        }
        function ks(e, t) {
          return e.x === t.x && (e.x < 0 || e.x > de) || e.y === t.y && (e.y < 0 || e.y > de);
        }
        function Ls(e) {
          return e.every(e => e.x < 0) || e.every(e => e.x > de) || e.every(e => e.y < 0) || e.every(e => e.y > de);
        }
        r("FillExtrusionBucket", Ms, {
          omit: ["layers", "features"]
        });
        let Us;
        var Fs = {
          get paint() {
            return Us = Us || new l({
              "fill-extrusion-opacity": new i(o["paint_fill-extrusion"]["fill-extrusion-opacity"]),
              "fill-extrusion-color": new a(o["paint_fill-extrusion"]["fill-extrusion-color"]),
              "fill-extrusion-translate": new i(o["paint_fill-extrusion"]["fill-extrusion-translate"]),
              "fill-extrusion-translate-anchor": new i(o["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
              "fill-extrusion-pattern": new mi(o["paint_fill-extrusion"]["fill-extrusion-pattern"]),
              "fill-extrusion-height": new a(o["paint_fill-extrusion"]["fill-extrusion-height"]),
              "fill-extrusion-base": new a(o["paint_fill-extrusion"]["fill-extrusion-base"]),
              "fill-extrusion-vertical-gradient": new i(o["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
            });
          }
        };
        class Bs extends Ei {
          constructor(e) {
            super(e, Fs);
          }
          createBucket(e) {
            return new Ms(e);
          }
          queryRadius() {
            return aa(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          queryIntersectsFeature(e, t, r, n, i, o, a, s) {
            e = sa(e, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o.angle, a), a = this.paint.get("fill-extrusion-height").evaluate(t, r), t = this.paint.get("fill-extrusion-base").evaluate(t, r), r = js(e, s, 0, 0), e = Hs(n, t, a, s);
            return Ys(e[0], e[1], r);
          }
        }
        function $s(e, t) {
          return e.x * t.x + e.y * t.y;
        }
        function zs(r, n) {
          if (1 === r.length) {
            let e = 0;
            var i = n[e++];
            let t;
            for (; !t || i.equals(t);) if (!(t = n[e++])) return 1 / 0;
            for (; e < n.length; e++) {
              var o = n[e],
                a = r[0],
                s = t.sub(i),
                l = o.sub(i),
                a = a.sub(i),
                c = $s(s, s),
                u = $s(s, l),
                h = $s(l, l),
                s = $s(a, s),
                a = $s(a, l),
                l = c * h - u * u,
                h = (h * s - u * a) / l,
                c = (c * a - u * s) / l,
                a = i.z * (1 - h - c) + t.z * h + o.z * c;
              if (isFinite(a)) return a;
            }
            return 1 / 0;
          }
          {
            let e = 1 / 0;
            for (const t of n) e = Math.min(e, t.z);
            return e;
          }
        }
        function Ys(t, r, n) {
          let i = 1 / 0;
          Xo(n, r) && (i = zs(n, r[0]));
          for (let e = 0; e < r.length; e++) {
            var o = r[e],
              a = t[e];
            for (let e = 0; e < o.length - 1; e++) {
              var s = o[e],
                l = o[e + 1],
                c = a[e],
                l = [s, l, a[e + 1], c, s];
              Wo(n, l) && (i = Math.min(i, zs(n, l)));
            }
          }
          return i !== 1 / 0 && i;
        }
        function Hs(e, t, r, n) {
          var i = [],
            o = [],
            a = n[8] * t,
            s = n[9] * t,
            l = n[10] * t,
            c = n[11] * t,
            u = n[8] * r,
            h = n[9] * r,
            d = n[10] * r,
            p = n[11] * r;
          for (const S of e) {
            var f = [],
              _ = [];
            for (const x of S) {
              var m = x.x,
                g = x.y,
                y = n[0] * m + n[4] * g + n[12],
                v = n[1] * m + n[5] * g + n[13],
                E = n[2] * m + n[6] * g + n[14],
                m = n[3] * m + n[7] * g + n[15],
                g = E + l,
                b = m + c,
                w = y + u,
                T = v + h,
                E = E + d,
                m = m + p,
                y = new F((y + a) / b, (v + s) / b),
                v = (y.z = g / b, f.push(y), new F(w / m, T / m));
              v.z = E / m, _.push(v);
            }
            i.push(f), o.push(_);
          }
          return [i, o];
        }
        function js(e, t, r, n) {
          var i = [];
          for (const a of e) {
            var o = [a.x, a.y, n, 1];
            Ta(o, o, t), i.push(new F(o[0] / o[3], o[1] / o[3]));
          }
          return i;
        }
        const Gs = w([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
          }], 4)["members"],
          qs = w([{
            name: "a_uv_x",
            components: 1,
            type: "Float32"
          }, {
            name: "a_split_index",
            components: 1,
            type: "Float32"
          }])["members"],
          Vs = ws.VectorTileFeature.types,
          Ks = Math.cos(Math.PI / 180 * 37.5);
        const Ws = Math.pow(2, 14) / .5;
        class Zs {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(e => {
              this.gradients[e.id] = {};
            }), this.layoutVertexArray = new co(), this.layoutVertexArray2 = new uo(), this.indexArray = new yo(), this.programConfigurations = new $o(e.layers, e.zoom), this.segments = new T(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(e => e.isStateDependent()).map(e => e.id);
          }
          populate(e, t, r) {
            this.hasPattern = ps("line", this.layers, t);
            var n,
              i,
              o,
              a,
              s = this.layers[0].layout.get("line-sort-key"),
              l = !s.isConstant(),
              c = [];
            for ({
              feature: n,
              id: i,
              index: o,
              sourceLayerIndex: a
            } of e) {
              var u,
                h = this.layers[0]._featureFilter.needGeometry,
                d = qo(n, h);
              this.layers[0]._featureFilter.filter(new N(this.zoom), d, r) && (u = l ? s.evaluate(d, {}, r) : void 0, h = {
                id: i,
                properties: n.properties,
                type: n.type,
                sourceLayerIndex: a,
                index: o,
                geometry: h ? d.geometry : Go(n),
                patterns: {},
                sortKey: u
              }, c.push(h));
            }
            l && c.sort((e, t) => e.sortKey - t.sortKey);
            for (const g of c) {
              var {
                  geometry: p,
                  index: f,
                  sourceLayerIndex: _
                } = g,
                m = (this.hasPattern ? (m = fs("line", this.layers, g, this.zoom, t), this.patternFeatures.push(m)) : this.addFeature(g, p, f, r, {}), e[f].feature);
              t.featureIndex.insert(m, p, f, _, this.index);
            }
          }
          update(e, t, r) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, r);
          }
          addFeatures(e, t, r) {
            for (const n of this.patternFeatures) this.addFeature(n, n.geometry, n.index, t, r);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, qs)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Gs), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(e) {
            if (e.properties && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_end")) return {
              start: +e.properties.mapbox_clip_start,
              end: +e.properties.mapbox_clip_end
            };
          }
          addFeature(e, t, r, n, i) {
            var o = this.layers[0].layout,
              a = o.get("line-join").evaluate(e, {}),
              s = o.get("line-cap"),
              l = o.get("line-miter-limit"),
              c = o.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(e);
            for (const u of t) this.addLine(u, e, a, s, l, c);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, r, i, n);
          }
          addLine(s, e, l, c, u, h) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e = 0; e < s.length - 1; e++) this.totalDistance += s[e].dist(s[e + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            var d = "Polygon" === Vs[e.type];
            let p = s.length;
            for (; 2 <= p && s[p - 1].equals(s[p - 2]);) p--;
            let f = 0;
            for (; f < p - 1 && s[f].equals(s[f + 1]);) f++;
            if (!(p < (d ? 3 : 2))) {
              "bevel" === l && (u = 1.05);
              var _,
                m = this.overscaling <= 16 ? 15 * de / (512 * this.overscaling) : 0,
                g = this.segments.prepareSegment(10 * p, this.layoutVertexArray, this.indexArray);
              let n, i, o, a;
              this.e1 = this.e2 = -1, d && (n = s[p - 2], a = s[f].sub(n)._unit()._perp());
              for (let r = f; r < p; r++) if (!(_ = r === p - 1 ? d ? s[f + 1] : void 0 : s[r + 1]) || !s[r].equals(_)) {
                a && (o = a), n && (i = n), n = s[r], a = _ ? _.sub(n)._unit()._perp() : o;
                let e = (o = o || a).add(a);
                0 === e.x && 0 === e.y || e._unit();
                var y = o.x * a.x + o.y * a.y,
                  v = e.x * a.x + e.y * a.y,
                  E = 0 != v ? 1 / v : 1 / 0,
                  b = 2 * Math.sqrt(2 - 2 * v),
                  v = v < Ks && i && _,
                  w = 0 < o.x * a.y - o.y * a.x,
                  T = (v && r > f && 2 * m < (T = n.dist(i)) && (T = n.sub(n.sub(i)._mult(m / T)._round()), this.updateDistance(i, T), this.addCurrentVertex(T, o, 0, 0, g), i = T), i && _);
                let t = T ? l : d ? "butt" : c;
                if (T && "round" === t && (E < h ? t = "miter" : E <= 2 && (t = "fakeround")), "bevel" === (t = "miter" === t && u < E ? "bevel" : t) && (2 < E && (t = "flipbevel"), E < u) && (t = "miter"), i && this.updateDistance(i, n), "miter" === t) e._mult(E), this.addCurrentVertex(n, e, 0, 0, g);else if ("flipbevel" === t) 100 < E ? e = a.mult(-1) : (S = E * o.add(a).mag() / o.sub(a).mag(), e._perp()._mult(S * (w ? -1 : 1))), this.addCurrentVertex(n, e, 0, 0, g), this.addCurrentVertex(n, e.mult(-1), 0, 0, g);else if ("bevel" === t || "fakeround" === t) {
                  var S = -Math.sqrt(E * E - 1),
                    E = w ? S : 0,
                    x = w ? 0 : S;
                  if (i && this.addCurrentVertex(n, o, E, x, g), "fakeround" === t) {
                    var C = Math.round(180 * b / Math.PI / 20);
                    for (let t = 1; t < C; t++) {
                      let e = t / C;
                      .5 !== e && (A = e - .5, e += e * A * (e - 1) * ((1.0904 + y * (y * (3.55645 - 1.43519 * y) - 3.2452)) * A * A + (.848013 + y * (.215638 * y - 1.06021))));
                      var A = a.sub(o)._mult(e)._add(o)._unit()._mult(w ? -1 : 1);
                      this.addHalfVertex(n, A.x, A.y, !1, w, 0, g);
                    }
                  }
                  _ && this.addCurrentVertex(n, a, -E, -x, g);
                } else "butt" === t ? this.addCurrentVertex(n, e, 0, 0, g) : "square" === t ? (b = i ? 1 : -1, this.addCurrentVertex(n, e, b, b, g)) : "round" === t && (i && (this.addCurrentVertex(n, o, 0, 0, g), this.addCurrentVertex(n, o, 1, 1, g, !0)), _) && (this.addCurrentVertex(n, a, -1, -1, g, !0), this.addCurrentVertex(n, a, 0, 0, g));
                v && r < p - 1 && 2 * m < (E = n.dist(_)) && (x = n.add(_.sub(n)._mult(m / E)._round()), this.updateDistance(n, x), this.addCurrentVertex(x, a, 0, 0, g), n = x);
              }
            }
          }
          addCurrentVertex(e, t, r, n, i, o = !1) {
            var a = t.x + t.y * r,
              s = t.y - t.x * r,
              l = -t.x + t.y * n,
              c = -t.y - t.x * n;
            this.addHalfVertex(e, a, s, o, !1, r, i), this.addHalfVertex(e, l, c, o, !0, -n, i), this.distance > Ws / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e, t, r, n, i, o));
          }
          addHalfVertex({
            x: e,
            y: t
          }, r, n, i, o, a, s) {
            var l = .5 * (this.lineClips ? this.scaledDistance * (Ws - 1) : this.scaledDistance),
              t = (this.layoutVertexArray.emplaceBack((e << 1) + (i ? 1 : 0), (t << 1) + (o ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1) | (63 & l) << 2, l >> 6), this.lineClips && (e = this.scaledDistance - this.lineClips.start, i = this.lineClips.end - this.lineClips.start, this.layoutVertexArray2.emplaceBack(e / i, this.lineClipsArray.length)), s.vertexLength++);
            0 <= this.e1 && 0 <= this.e2 && (this.indexArray.emplaceBack(this.e1, this.e2, t), s.primitiveLength++), o ? this.e2 = t : this.e1 = t;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(e, t) {
            this.distance += e.dist(t), this.updateScaledDistance();
          }
        }
        r("LineBucket", Zs, {
          omit: ["layers", "patternFeatures"]
        });
        let Xs;
        let Js;
        var Qs = {
          get paint() {
            return Js = Js || new l({
              "line-opacity": new a(o.paint_line["line-opacity"]),
              "line-color": new a(o.paint_line["line-color"]),
              "line-translate": new i(o.paint_line["line-translate"]),
              "line-translate-anchor": new i(o.paint_line["line-translate-anchor"]),
              "line-width": new a(o.paint_line["line-width"]),
              "line-gap-width": new a(o.paint_line["line-gap-width"]),
              "line-offset": new a(o.paint_line["line-offset"]),
              "line-blur": new a(o.paint_line["line-blur"]),
              "line-dasharray": new gi(o.paint_line["line-dasharray"]),
              "line-pattern": new mi(o.paint_line["line-pattern"]),
              "line-gradient": new yi(o.paint_line["line-gradient"])
            });
          },
          get layout() {
            return Xs = Xs || new l({
              "line-cap": new i(o.layout_line["line-cap"]),
              "line-join": new a(o.layout_line["line-join"]),
              "line-miter-limit": new i(o.layout_line["line-miter-limit"]),
              "line-round-limit": new i(o.layout_line["line-round-limit"]),
              "line-sort-key": new a(o.layout_line["line-sort-key"])
            });
          }
        };
        class el extends a {
          possiblyEvaluate(e, t) {
            return t = new N(Math.floor(t.zoom), {
              now: t.now,
              fadeDuration: t.fadeDuration,
              zoomHistory: t.zoomHistory,
              transition: t.transition
            }), super.possiblyEvaluate(e, t);
          }
          evaluate(e, t, r, n) {
            return t = G({}, t, {
              zoom: Math.floor(t.zoom)
            }), super.evaluate(e, t, r, n);
          }
        }
        let tl;
        class rl extends Ei {
          constructor(e) {
            super(e, Qs), this.gradientVersion = 0, tl || ((tl = new el(Qs.paint.properties["line-width"].specification)).useIntegerZoom = !0);
          }
          _handleSpecialPaintPropertyUpdate(e) {
            "line-gradient" === e && (Wr(e = this.gradientExpression()) ? this.stepInterpolant = e._styleExpression.expression instanceof dr : this.stepInterpolant = !1, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(e, t) {
            super.recalculate(e, t), this.paint._values["line-floorwidth"] = tl.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);
          }
          createBucket(e) {
            return new Zs(e);
          }
          queryRadius(e) {
            var t = nl(oa("line-width", this, e), oa("line-gap-width", this, e)),
              e = oa("line-offset", this, e);
            return t / 2 + Math.abs(e) + aa(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(e, t, r, n, i, o, a) {
            e = sa(e, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o.angle, a), o = a / 2 * nl(this.paint.get("line-width").evaluate(t, r), this.paint.get("line-gap-width").evaluate(t, r)), t = this.paint.get("line-offset").evaluate(t, r);
            return Jo(e, n = t ? la(n, t * a) : n, o);
          }
          isTileClipped() {
            return !0;
          }
        }
        function nl(e, t) {
          return 0 < t ? t + 2 * e : e;
        }
        const il = w([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
          }], 4),
          ol = w([{
            name: "a_projected_pos",
            components: 3,
            type: "Float32"
          }], 4),
          al = (w([{
            name: "a_fade_opacity",
            components: 1,
            type: "Uint32"
          }], 4), w([{
            name: "a_placed",
            components: 2,
            type: "Uint8"
          }, {
            name: "a_shift",
            components: 2,
            type: "Float32"
          }])),
          sl = (w([{
            type: "Int16",
            name: "anchorPointX"
          }, {
            type: "Int16",
            name: "anchorPointY"
          }, {
            type: "Int16",
            name: "x1"
          }, {
            type: "Int16",
            name: "y1"
          }, {
            type: "Int16",
            name: "x2"
          }, {
            type: "Int16",
            name: "y2"
          }, {
            type: "Uint32",
            name: "featureIndex"
          }, {
            type: "Uint16",
            name: "sourceLayerIndex"
          }, {
            type: "Uint16",
            name: "bucketIndex"
          }]), w([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
          }], 4));
        xr = w([{
          name: "a_pos",
          components: 2,
          type: "Float32"
        }, {
          name: "a_radius",
          components: 1,
          type: "Float32"
        }, {
          name: "a_flags",
          components: 2,
          type: "Int16"
        }], 4);
        function ll(e, n, i) {
          return e.sections.forEach(e => {
            var t, r;
            e.text = (e = e.text, r = i, "uppercase" === (t = (t = n).layout.get("text-transform").evaluate(r, {})) ? e = e.toLocaleUpperCase() : "lowercase" === t && (e = e.toLocaleLowerCase()), e = si.applyArabicShaping ? si.applyArabicShaping(e) : e);
          }), e;
        }
        function cl(t) {
          const i = {},
            o = {},
            a = [];
          let r = 0;
          function n(e) {
            a.push(t[e]), r++;
          }
          function s(e, t, r) {
            var n = o[e];
            return delete o[e], o[t] = n, a[n].geometry[0].pop(), a[n].geometry[0] = a[n].geometry[0].concat(r[0]), n;
          }
          function l(e, t, r) {
            var n = i[t];
            return delete i[t], i[e] = n, a[n].geometry[0].shift(), a[n].geometry[0] = r[0].concat(a[n].geometry[0]), n;
          }
          function c(e, t, r) {
            r = r ? t[0][t[0].length - 1] : t[0][0];
            return `${e}:${r.x}:` + r.y;
          }
          for (let e = 0; e < t.length; e++) {
            var u,
              h,
              d,
              p,
              f = t[e],
              _ = f.geometry,
              f = f.text ? f.text.toString() : null;
            f ? (u = c(f, _), h = c(f, _, !0), u in o && h in i && o[u] !== i[h] ? (d = l(u, h, _), p = s(u, h, a[d].geometry), delete i[u], delete o[h], o[c(f, a[p].geometry, !0)] = p, a[d].geometry = null) : u in o ? s(u, h, _) : h in i ? l(u, h, _) : (n(e), i[u] = r - 1, o[h] = r - 1)) : n(e);
          }
          return a.filter(e => e.geometry);
        }
        w([{
          name: "triangle",
          components: 3,
          type: "Uint16"
        }]), w([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Uint16",
          name: "glyphStartIndex"
        }, {
          type: "Uint16",
          name: "numGlyphs"
        }, {
          type: "Uint32",
          name: "vertexStartIndex"
        }, {
          type: "Uint32",
          name: "lineStartIndex"
        }, {
          type: "Uint32",
          name: "lineLength"
        }, {
          type: "Uint16",
          name: "segment"
        }, {
          type: "Uint16",
          name: "lowerSize"
        }, {
          type: "Uint16",
          name: "upperSize"
        }, {
          type: "Float32",
          name: "lineOffsetX"
        }, {
          type: "Float32",
          name: "lineOffsetY"
        }, {
          type: "Uint8",
          name: "writingMode"
        }, {
          type: "Uint8",
          name: "placedOrientation"
        }, {
          type: "Uint8",
          name: "hidden"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Int16",
          name: "associatedIconIndex"
        }]), w([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Int16",
          name: "rightJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "centerJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "leftJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "placedIconSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedIconSymbolIndex"
        }, {
          type: "Uint16",
          name: "key"
        }, {
          type: "Uint16",
          name: "textBoxStartIndex"
        }, {
          type: "Uint16",
          name: "textBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxEndIndex"
        }, {
          type: "Uint16",
          name: "iconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "iconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "numHorizontalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numVerticalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numIconVertices"
        }, {
          type: "Uint16",
          name: "numVerticalIconVertices"
        }, {
          type: "Uint16",
          name: "useRuntimeCollisionCircles"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Float32",
          name: "textBoxScale"
        }, {
          type: "Float32",
          name: "collisionCircleDiameter"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetStartIndex"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetEndIndex"
        }]), w([{
          type: "Float32",
          name: "offsetX"
        }]), w([{
          type: "Int16",
          name: "x"
        }, {
          type: "Int16",
          name: "y"
        }, {
          type: "Int16",
          name: "tileUnitDistanceFromAnchor"
        }]), w([{
          type: "Uint16",
          name: "textAnchor"
        }, {
          type: "Float32",
          components: 2,
          name: "textOffset"
        }]);
        const ul = {
          "!": "︕",
          "#": "＃",
          $: "＄",
          "%": "％",
          "&": "＆",
          "(": "︵",
          ")": "︶",
          "*": "＊",
          "+": "＋",
          ",": "︐",
          "-": "︲",
          ".": "・",
          "/": "／",
          ":": "︓",
          ";": "︔",
          "<": "︿",
          "=": "＝",
          ">": "﹀",
          "?": "︖",
          "@": "＠",
          "[": "﹇",
          "\\": "＼",
          "]": "﹈",
          "^": "＾",
          _: "︳",
          "`": "｀",
          "{": "︷",
          "|": "―",
          "}": "︸",
          "~": "～",
          "¢": "￠",
          "£": "￡",
          "¥": "￥",
          "¦": "￤",
          "¬": "￢",
          "¯": "￣",
          "–": "︲",
          "—": "︱",
          "‘": "﹃",
          "’": "﹄",
          "“": "﹁",
          "”": "﹂",
          "…": "︙",
          "‧": "・",
          "₩": "￦",
          "、": "︑",
          "。": "︒",
          "〈": "︿",
          "〉": "﹀",
          "《": "︽",
          "》": "︾",
          "「": "﹁",
          "」": "﹂",
          "『": "﹃",
          "』": "﹄",
          "【": "︻",
          "】": "︼",
          "〔": "︹",
          "〕": "︺",
          "〖": "︗",
          "〗": "︘",
          "！": "︕",
          "（": "︵",
          "）": "︶",
          "，": "︐",
          "－": "︲",
          "．": "・",
          "：": "︓",
          "；": "︔",
          "＜": "︿",
          "＞": "﹀",
          "？": "︖",
          "［": "﹇",
          "］": "﹈",
          "＿": "︳",
          "｛": "︷",
          "｜": "―",
          "｝": "︸",
          "｟": "︵",
          "｠": "︶",
          "｡": "︒",
          "｢": "﹁",
          "｣": "﹂"
        };
        function hl(t) {
          let r = "";
          for (let e = 0; e < t.length; e++) {
            var n = t.charCodeAt(e + 1) || null,
              i = t.charCodeAt(e - 1) || null;
            (!n || !Zn(n) || ul[t[e + 1]]) && (!i || !Zn(i) || ul[t[e - 1]]) && ul[t[e]] ? r += ul[t[e]] : r += t[e];
          }
          return r;
        }
        var pe = 24,
          e = {
            read: function (e, t, r, n, i) {
              var o,
                a,
                s = 8 * i - n - 1,
                l = (1 << s) - 1,
                c = l >> 1,
                u = -7,
                h = r ? i - 1 : 0,
                d = r ? -1 : 1,
                i = e[t + h];
              for (h += d, o = i & (1 << -u) - 1, i >>= -u, u += s; 0 < u; o = 256 * o + e[t + h], h += d, u -= 8);
              for (a = o & (1 << -u) - 1, o >>= -u, u += n; 0 < u; a = 256 * a + e[t + h], h += d, u -= 8);
              if (0 === o) o = 1 - c;else {
                if (o === l) return a ? NaN : 1 / 0 * (i ? -1 : 1);
                a += Math.pow(2, n), o -= c;
              }
              return (i ? -1 : 1) * a * Math.pow(2, o - n);
            },
            write: function (e, t, r, n, i, o) {
              var a,
                s,
                l = 8 * o - i - 1,
                c = (1 << l) - 1,
                u = c >> 1,
                h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                d = n ? 0 : o - 1,
                p = n ? 1 : -1,
                o = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
              for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, a = c) : (a = Math.floor(Math.log(t) / Math.LN2), t * (n = Math.pow(2, -a)) < 1 && (a--, n *= 2), 2 <= (t += 1 <= a + u ? h / n : h * Math.pow(2, 1 - u)) * n && (a++, n /= 2), c <= a + u ? (s = 0, a = c) : 1 <= a + u ? (s = (t * n - 1) * Math.pow(2, i), a += u) : (s = t * Math.pow(2, u - 1) * Math.pow(2, i), a = 0)); 8 <= i; e[r + d] = 255 & s, d += p, s /= 256, i -= 8);
              for (a = a << i | s, l += i; 0 < l; e[r + d] = 255 & a, d += p, a /= 256, l -= 8);
              e[r + d - p] |= 128 * o;
            }
          },
          Tr = C,
          dl = e;
        function C(e) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(e) ? e : new Uint8Array(e || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        C.Varint = 0, C.Fixed64 = 1, C.Bytes = 2, C.Fixed32 = 5;
        var pl = 4294967296,
          fl = 1 / pl,
          _l = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function ml(e) {
          return e.type === C.Bytes ? e.readVarint() + e.pos : e.pos + 1;
        }
        function gl(e, t, r) {
          return r ? 4294967296 * t + (e >>> 0) : 4294967296 * (t >>> 0) + (e >>> 0);
        }
        function yl(e, t, r) {
          var n = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          r.realloc(n);
          for (var i = r.pos - 1; e <= i; i--) r.buf[i + n] = r.buf[i];
        }
        function vl(e, t) {
          for (var r = 0; r < e.length; r++) t.writeVarint(e[r]);
        }
        function El(e, t) {
          for (var r = 0; r < e.length; r++) t.writeSVarint(e[r]);
        }
        function bl(e, t) {
          for (var r = 0; r < e.length; r++) t.writeFloat(e[r]);
        }
        function wl(e, t) {
          for (var r = 0; r < e.length; r++) t.writeDouble(e[r]);
        }
        function Tl(e, t) {
          for (var r = 0; r < e.length; r++) t.writeBoolean(e[r]);
        }
        function Sl(e, t) {
          for (var r = 0; r < e.length; r++) t.writeFixed32(e[r]);
        }
        function xl(e, t) {
          for (var r = 0; r < e.length; r++) t.writeSFixed32(e[r]);
        }
        function Cl(e, t) {
          for (var r = 0; r < e.length; r++) t.writeFixed64(e[r]);
        }
        function Al(e, t) {
          for (var r = 0; r < e.length; r++) t.writeSFixed64(e[r]);
        }
        function Il(e, t) {
          return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + 16777216 * e[t + 3];
        }
        function Nl(e, t, r) {
          e[r] = t, e[r + 1] = t >>> 8, e[r + 2] = t >>> 16, e[r + 3] = t >>> 24;
        }
        function Pl(e, t) {
          return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + (e[t + 3] << 24);
        }
        C.prototype = {
          destroy: function () {
            this.buf = null;
          },
          readFields: function (e, t, r) {
            for (r = r || this.length; this.pos < r;) {
              var n = this.readVarint(),
                i = n >> 3,
                o = this.pos;
              this.type = 7 & n, e(i, t, this), this.pos === o && this.skip(n);
            }
            return t;
          },
          readMessage: function (e, t) {
            return this.readFields(e, t, this.readVarint() + this.pos);
          },
          readFixed32: function () {
            var e = Il(this.buf, this.pos);
            return this.pos += 4, e;
          },
          readSFixed32: function () {
            var e = Pl(this.buf, this.pos);
            return this.pos += 4, e;
          },
          readFixed64: function () {
            var e = Il(this.buf, this.pos) + Il(this.buf, this.pos + 4) * pl;
            return this.pos += 8, e;
          },
          readSFixed64: function () {
            var e = Il(this.buf, this.pos) + Pl(this.buf, this.pos + 4) * pl;
            return this.pos += 8, e;
          },
          readFloat: function () {
            var e = dl.read(this.buf, this.pos, !0, 23, 4);
            return this.pos += 4, e;
          },
          readDouble: function () {
            var e = dl.read(this.buf, this.pos, !0, 52, 8);
            return this.pos += 8, e;
          },
          readVarint: function (e) {
            var t = this.buf,
              r = t[this.pos++],
              n = 127 & r;
            if (r < 128) return n;
            if (n |= (127 & (r = t[this.pos++])) << 7, r < 128) return n;
            if (n |= (127 & (r = t[this.pos++])) << 14, r < 128) return n;
            if (n |= (127 & (r = t[this.pos++])) << 21, r < 128) return n;
            var i,
              o,
              r = n |= (15 & t[this.pos]) << 28,
              t = e,
              n = this,
              e = n.buf;
            if (o = e[n.pos++], i = (112 & o) >> 4, o < 128) return gl(r, i, t);
            if (o = e[n.pos++], i |= (127 & o) << 3, o < 128) return gl(r, i, t);
            if (o = e[n.pos++], i |= (127 & o) << 10, o < 128) return gl(r, i, t);
            if (o = e[n.pos++], i |= (127 & o) << 17, o < 128) return gl(r, i, t);
            if (o = e[n.pos++], i |= (127 & o) << 24, o < 128) return gl(r, i, t);
            if (o = e[n.pos++], i |= (1 & o) << 31, o < 128) return gl(r, i, t);
            throw new Error("Expected varint not more than 10 bytes");
          },
          readVarint64: function () {
            return this.readVarint(!0);
          },
          readSVarint: function () {
            var e = this.readVarint();
            return e % 2 == 1 ? (e + 1) / -2 : e / 2;
          },
          readBoolean: function () {
            return Boolean(this.readVarint());
          },
          readString: function () {
            var e = this.readVarint() + this.pos,
              t = this.pos;
            if (12 <= (this.pos = e) - t && _l) return r = this.buf, _l.decode(r.subarray(t, e));
            for (var r, n, i, o, a = this.buf, s = e, l = "", c = t; c < s;) {
              var u = a[c],
                h = null,
                d = 239 < u ? 4 : 223 < u ? 3 : 191 < u ? 2 : 1;
              if (s < c + d) break;
              1 === d ? u < 128 && (h = u) : 2 === d ? 128 == (192 & (n = a[c + 1])) && (h = (31 & u) << 6 | 63 & n) <= 127 && (h = null) : 3 === d ? (n = a[c + 1], i = a[c + 2], 128 == (192 & n) && 128 == (192 & i) && ((h = (15 & u) << 12 | (63 & n) << 6 | 63 & i) <= 2047 || 55296 <= h && h <= 57343) && (h = null)) : 4 === d && (n = a[c + 1], i = a[c + 2], o = a[c + 3], 128 == (192 & n)) && 128 == (192 & i) && 128 == (192 & o) && ((h = (15 & u) << 18 | (63 & n) << 12 | (63 & i) << 6 | 63 & o) <= 65535 || 1114112 <= h) && (h = null), null === h ? (h = 65533, d = 1) : 65535 < h && (h -= 65536, l += String.fromCharCode(h >>> 10 & 1023 | 55296), h = 56320 | 1023 & h), l += String.fromCharCode(h), c += d;
            }
            return l;
          },
          readBytes: function () {
            var e = this.readVarint() + this.pos,
              t = this.buf.subarray(this.pos, e);
            return this.pos = e, t;
          },
          readPackedVarint: function (e, t) {
            if (this.type !== C.Bytes) return e.push(this.readVarint(t));
            var r = ml(this);
            for (e = e || []; this.pos < r;) e.push(this.readVarint(t));
            return e;
          },
          readPackedSVarint: function (e) {
            if (this.type !== C.Bytes) return e.push(this.readSVarint());
            var t = ml(this);
            for (e = e || []; this.pos < t;) e.push(this.readSVarint());
            return e;
          },
          readPackedBoolean: function (e) {
            if (this.type !== C.Bytes) return e.push(this.readBoolean());
            var t = ml(this);
            for (e = e || []; this.pos < t;) e.push(this.readBoolean());
            return e;
          },
          readPackedFloat: function (e) {
            if (this.type !== C.Bytes) return e.push(this.readFloat());
            var t = ml(this);
            for (e = e || []; this.pos < t;) e.push(this.readFloat());
            return e;
          },
          readPackedDouble: function (e) {
            if (this.type !== C.Bytes) return e.push(this.readDouble());
            var t = ml(this);
            for (e = e || []; this.pos < t;) e.push(this.readDouble());
            return e;
          },
          readPackedFixed32: function (e) {
            if (this.type !== C.Bytes) return e.push(this.readFixed32());
            var t = ml(this);
            for (e = e || []; this.pos < t;) e.push(this.readFixed32());
            return e;
          },
          readPackedSFixed32: function (e) {
            if (this.type !== C.Bytes) return e.push(this.readSFixed32());
            var t = ml(this);
            for (e = e || []; this.pos < t;) e.push(this.readSFixed32());
            return e;
          },
          readPackedFixed64: function (e) {
            if (this.type !== C.Bytes) return e.push(this.readFixed64());
            var t = ml(this);
            for (e = e || []; this.pos < t;) e.push(this.readFixed64());
            return e;
          },
          readPackedSFixed64: function (e) {
            if (this.type !== C.Bytes) return e.push(this.readSFixed64());
            var t = ml(this);
            for (e = e || []; this.pos < t;) e.push(this.readSFixed64());
            return e;
          },
          skip: function (e) {
            e &= 7;
            if (e === C.Varint) for (; 127 < this.buf[this.pos++];);else if (e === C.Bytes) this.pos = this.readVarint() + this.pos;else if (e === C.Fixed32) this.pos += 4;else {
              if (e !== C.Fixed64) throw new Error("Unimplemented type: " + e);
              this.pos += 8;
            }
          },
          writeTag: function (e, t) {
            this.writeVarint(e << 3 | t);
          },
          realloc: function (e) {
            for (var t, r = this.length || 16; r < this.pos + e;) r *= 2;
            r !== this.length && ((t = new Uint8Array(r)).set(this.buf), this.buf = t, this.length = r);
          },
          finish: function () {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          },
          writeFixed32: function (e) {
            this.realloc(4), Nl(this.buf, e, this.pos), this.pos += 4;
          },
          writeSFixed32: function (e) {
            this.realloc(4), Nl(this.buf, e, this.pos), this.pos += 4;
          },
          writeFixed64: function (e) {
            this.realloc(8), Nl(this.buf, -1 & e, this.pos), Nl(this.buf, Math.floor(e * fl), this.pos + 4), this.pos += 8;
          },
          writeSFixed64: function (e) {
            this.realloc(8), Nl(this.buf, -1 & e, this.pos), Nl(this.buf, Math.floor(e * fl), this.pos + 4), this.pos += 8;
          },
          writeVarint: function (e) {
            if (268435455 < (e = +e || 0) || e < 0) {
              var t = e,
                r = this;
              if (0 <= t ? (n = t % 4294967296 | 0, i = t / 4294967296 | 0) : (i = ~(-t / 4294967296), 4294967295 ^ (n = ~(-t % 4294967296)) ? n = n + 1 | 0 : i = i + 1 | (n = 0)), 0x10000000000000000 <= t || t < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");
              r.realloc(10);
              var t = n,
                n = r,
                t = (n.buf[n.pos++] = 127 & t | 128, t >>>= 7, n.buf[n.pos++] = 127 & t | 128, t >>>= 7, n.buf[n.pos++] = 127 & t | 128, t >>>= 7, n.buf[n.pos++] = 127 & t | 128, t >>>= 7, n.buf[n.pos] = 127 & t, i),
                i = r,
                r = (7 & t) << 4;
              i.buf[i.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (i.buf[i.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t) && (i.buf[i.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t) && (i.buf[i.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t) && (i.buf[i.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t) && (i.buf[i.pos++] = 127 & t);
            } else this.realloc(4), this.buf[this.pos++] = 127 & e | (127 < e ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (127 < e ? 128 : 0), e <= 127) || (this.buf[this.pos++] = 127 & (e >>>= 7) | (127 < e ? 128 : 0), e <= 127) || (this.buf[this.pos++] = e >>> 7 & 127);
          },
          writeSVarint: function (e) {
            this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e);
          },
          writeBoolean: function (e) {
            this.writeVarint(Boolean(e));
          },
          writeString: function (e) {
            e = String(e), this.realloc(4 * e.length), this.pos++;
            var t = this.pos,
              e = (this.pos = function (e, t, r) {
                for (var n, i, o = 0; o < t.length; o++) {
                  if (55295 < (n = t.charCodeAt(o)) && n < 57344) {
                    if (!i) {
                      56319 < n || o + 1 === t.length ? (e[r++] = 239, e[r++] = 191, e[r++] = 189) : i = n;
                      continue;
                    }
                    if (n < 56320) {
                      e[r++] = 239, e[r++] = 191, e[r++] = 189, i = n;
                      continue;
                    }
                    n = i - 55296 << 10 | n - 56320 | 65536, i = null;
                  } else i && (e[r++] = 239, e[r++] = 191, e[r++] = 189, i = null);
                  n < 128 ? e[r++] = n : (n < 2048 ? e[r++] = n >> 6 | 192 : (n < 65536 ? e[r++] = n >> 12 | 224 : (e[r++] = n >> 18 | 240, e[r++] = n >> 12 & 63 | 128), e[r++] = n >> 6 & 63 | 128), e[r++] = 63 & n | 128);
                }
                return r;
              }(this.buf, e, this.pos), this.pos - t);
            128 <= e && yl(t, e, this), this.pos = t - 1, this.writeVarint(e), this.pos += e;
          },
          writeFloat: function (e) {
            this.realloc(4), dl.write(this.buf, e, this.pos, !0, 23, 4), this.pos += 4;
          },
          writeDouble: function (e) {
            this.realloc(8), dl.write(this.buf, e, this.pos, !0, 52, 8), this.pos += 8;
          },
          writeBytes: function (e) {
            var t = e.length;
            this.writeVarint(t), this.realloc(t);
            for (var r = 0; r < t; r++) this.buf[this.pos++] = e[r];
          },
          writeRawMessage: function (e, t) {
            this.pos++;
            var r = this.pos,
              e = (e(t, this), this.pos - r);
            128 <= e && yl(r, e, this), this.pos = r - 1, this.writeVarint(e), this.pos += e;
          },
          writeMessage: function (e, t, r) {
            this.writeTag(e, C.Bytes), this.writeRawMessage(t, r);
          },
          writePackedVarint: function (e, t) {
            t.length && this.writeMessage(e, vl, t);
          },
          writePackedSVarint: function (e, t) {
            t.length && this.writeMessage(e, El, t);
          },
          writePackedBoolean: function (e, t) {
            t.length && this.writeMessage(e, Tl, t);
          },
          writePackedFloat: function (e, t) {
            t.length && this.writeMessage(e, bl, t);
          },
          writePackedDouble: function (e, t) {
            t.length && this.writeMessage(e, wl, t);
          },
          writePackedFixed32: function (e, t) {
            t.length && this.writeMessage(e, Sl, t);
          },
          writePackedSFixed32: function (e, t) {
            t.length && this.writeMessage(e, xl, t);
          },
          writePackedFixed64: function (e, t) {
            t.length && this.writeMessage(e, Cl, t);
          },
          writePackedSFixed64: function (e, t) {
            t.length && this.writeMessage(e, Al, t);
          },
          writeBytesField: function (e, t) {
            this.writeTag(e, C.Bytes), this.writeBytes(t);
          },
          writeFixed32Field: function (e, t) {
            this.writeTag(e, C.Fixed32), this.writeFixed32(t);
          },
          writeSFixed32Field: function (e, t) {
            this.writeTag(e, C.Fixed32), this.writeSFixed32(t);
          },
          writeFixed64Field: function (e, t) {
            this.writeTag(e, C.Fixed64), this.writeFixed64(t);
          },
          writeSFixed64Field: function (e, t) {
            this.writeTag(e, C.Fixed64), this.writeSFixed64(t);
          },
          writeVarintField: function (e, t) {
            this.writeTag(e, C.Varint), this.writeVarint(t);
          },
          writeSVarintField: function (e, t) {
            this.writeTag(e, C.Varint), this.writeSVarint(t);
          },
          writeStringField: function (e, t) {
            this.writeTag(e, C.Bytes), this.writeString(t);
          },
          writeFloatField: function (e, t) {
            this.writeTag(e, C.Fixed32), this.writeFloat(t);
          },
          writeDoubleField: function (e, t) {
            this.writeTag(e, C.Fixed64), this.writeDouble(t);
          },
          writeBooleanField: function (e, t) {
            this.writeVarintField(e, Boolean(t));
          }
        };
        var Dl,
          Rl = I(Tr);
        const Ol = 3;
        function Ml(e, t, r) {
          1 === e && r.readMessage(kl, t);
        }
        function kl(e, t, r) {
          var n, i, o, a, s;
          3 === e && (({
            id: e,
            bitmap: r,
            width: n,
            height: i,
            left: o,
            top: a,
            advance: s
          } = r.readMessage(Ll, {})), t.push({
            id: e,
            bitmap: new La({
              width: n + 2 * Ol,
              height: i + 2 * Ol
            }, r),
            metrics: {
              width: n,
              height: i,
              left: o,
              top: a,
              advance: s
            }
          }));
        }
        function Ll(e, t, r) {
          1 === e ? t.id = r.readVarint() : 2 === e ? t.bitmap = r.readBytes() : 3 === e ? t.width = r.readVarint() : 4 === e ? t.height = r.readVarint() : 5 === e ? t.left = r.readSVarint() : 6 === e ? t.top = r.readSVarint() : 7 === e && (t.advance = r.readVarint());
        }
        const Ul = Ol;
        function Fl(e) {
          let t = 0,
            r = 0;
          for (const l of e) t += l.w * l.h, r = Math.max(r, l.w);
          e.sort((e, t) => t.h - e.h);
          var n = [{
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(t / .95)), r),
            h: 1 / 0
          }];
          let i = 0,
            o = 0;
          for (const c of e) for (let e = n.length - 1; 0 <= e; e--) {
            var a,
              s = n[e];
            if (!(c.w > s.w || c.h > s.h)) {
              c.x = s.x, c.y = s.y, o = Math.max(o, c.y + c.h), i = Math.max(i, c.x + c.w), c.w === s.w && c.h === s.h ? (a = n.pop(), e < n.length && (n[e] = a)) : c.h === s.h ? (s.x += c.w, s.w -= c.w) : (c.w !== s.w && n.push({
                x: s.x + c.w,
                y: s.y,
                w: s.w - c.w,
                h: c.h
              }), s.y += c.h, s.h -= c.h);
              break;
            }
          }
          return {
            w: i,
            h: o,
            fill: t / (i * o) || 0
          };
        }
        (t = Dl = Dl || {}).none = "none", t.height = "height", t.width = "width";
        const ie = 1;
        class Bl {
          constructor(e, {
            pixelRatio: t,
            version: r,
            stretchX: n,
            stretchY: i,
            content: o,
            contentMatch: a
          }) {
            this.paddedRect = e, this.pixelRatio = t, this.stretchX = n, this.stretchY = i, this.content = o, this.version = r, this.contentMatch = a;
          }
          get tl() {
            return [this.paddedRect.x + ie, this.paddedRect.y + ie];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - ie, this.paddedRect.y + this.paddedRect.h - ie];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * ie) / this.pixelRatio, (this.paddedRect.h - 2 * ie) / this.pixelRatio];
          }
        }
        class $l {
          constructor(e, t) {
            var r = {},
              n = {},
              i = (this.haveRenderCallbacks = [], []);
            this.addImages(e, r, i), this.addImages(t, n, i);
            const {
              w: o,
              h: a
            } = Fl(i);
            var s = new Ua({
              width: o || 1,
              height: a || 1
            });
            for (const d in e) {
              var l = e[d],
                c = r[d].paddedRect;
              Ua.copy(l.data, s, {
                x: 0,
                y: 0
              }, {
                x: c.x + ie,
                y: c.y + ie
              }, l.data);
            }
            for (const p in t) {
              var u = t[p],
                h = n[p].paddedRect;
              const f = h.x + ie,
                _ = h.y + ie,
                o = u.data.width,
                a = u.data.height;
              Ua.copy(u.data, s, {
                x: 0,
                y: 0
              }, {
                x: f,
                y: _
              }, u.data), Ua.copy(u.data, s, {
                x: 0,
                y: a - 1
              }, {
                x: f,
                y: _ - 1
              }, {
                width: o,
                height: 1
              }), Ua.copy(u.data, s, {
                x: 0,
                y: 0
              }, {
                x: f,
                y: _ + a
              }, {
                width: o,
                height: 1
              }), Ua.copy(u.data, s, {
                x: o - 1,
                y: 0
              }, {
                x: f - 1,
                y: _
              }, {
                width: 1,
                height: a
              }), Ua.copy(u.data, s, {
                x: 0,
                y: 0
              }, {
                x: f + o,
                y: _
              }, {
                width: 1,
                height: a
              });
            }
            this.image = s, this.iconPositions = r, this.patternPositions = n;
          }
          addImages(e, t, r) {
            for (const o in e) {
              var n = e[o],
                i = {
                  x: 0,
                  y: 0,
                  w: n.data.width + 2 * ie,
                  h: n.data.height + 2 * ie
                };
              r.push(i), t[o] = new Bl(i, n), n.hasRenderCallback && this.haveRenderCallbacks.push(o);
            }
          }
          patchUpdatedImages(e, t) {
            e.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const r in e.updatedImages) this.patchUpdatedImage(this.iconPositions[r], e.getImage(r), t), this.patchUpdatedImage(this.patternPositions[r], e.getImage(r), t);
          }
          patchUpdatedImage(e, t, r) {
            var n;
            e && t && e.version !== t.version && (e.version = t.version, [e, n] = e.tl, r.update(t.data, void 0, {
              x: e,
              y: n
            }));
          }
        }
        r("ImagePosition", Bl), r("ImageAtlas", $l), ue.WritingMode = void 0, (e = ue.WritingMode || (ue.WritingMode = {}))[e.none = 0] = "none", e[e.horizontal = 1] = "horizontal", e[e.vertical = 2] = "vertical", e[e.horizontalOnly = 3] = "horizontalOnly";
        const zl = -17;
        class Yl {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(e, t) {
            var r = new Yl();
            return r.scale = e || 1, r.fontStack = t, r;
          }
          static forImage(e) {
            var t = new Yl();
            return t.imageName = e, t;
          }
        }
        class Hl {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t, r) {
            var n = new Hl();
            for (let e = 0; e < t.sections.length; e++) {
              var i = t.sections[e];
              i.image ? n.addImageSection(i) : n.addTextSection(i, r);
            }
            return n;
          }
          length() {
            return this.text.length;
          }
          getSection(e) {
            return this.sections[this.sectionIndex[e]];
          }
          getSectionIndex(e) {
            return this.sectionIndex[e];
          }
          getCharCode(e) {
            return this.text.charCodeAt(e);
          }
          verticalizePunctuation() {
            this.text = hl(this.text);
          }
          trim() {
            let t = 0;
            for (let e = 0; e < this.text.length && Gl[this.text.charCodeAt(e)]; e++) t++;
            let r = this.text.length;
            for (let e = this.text.length - 1; 0 <= e && e >= t && Gl[this.text.charCodeAt(e)]; e--) r--;
            this.text = this.text.substring(t, r), this.sectionIndex = this.sectionIndex.slice(t, r);
          }
          substring(e, t) {
            var r = new Hl();
            return r.text = this.text.substring(e, t), r.sectionIndex = this.sectionIndex.slice(e, t), r.sections = this.sections, r;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((e, t) => Math.max(e, this.sections[t].scale), 0);
          }
          addTextSection(t, e) {
            this.text += t.text, this.sections.push(Yl.forText(t.scale, t.fontStack || e));
            var r = this.sections.length - 1;
            for (let e = 0; e < t.text.length; ++e) this.sectionIndex.push(r);
          }
          addImageSection(e) {
            var t,
              e = e.image ? e.image.name : "";
            0 === e.length ? he("Can't add FormattedSection with an empty image.") : (t = this.getNextImageSectionCharCode()) ? (this.text += String.fromCharCode(t), this.sections.push(Yl.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : he("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? 63743 <= this.imageSectionID ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function jl(e, n, L, i, o, a, U, F, B, c, u, h, $, d, p, z) {
          var t = Hl.fromFeature(e, o);
          h === ue.WritingMode.vertical && t.verticalizePunctuation();
          let f;
          var {
            processBidirectionalText: e,
            processStyledBidirectionalText: o
          } = si;
          if (e && 1 === t.sections.length) {
            f = [];
            for (const l of e(t.toString(), Zl(t, c, a, n, i, d, p))) {
              var r = new Hl();
              r.text = l, r.sections = t.sections;
              for (let e = 0; e < l.length; e++) r.sectionIndex.push(0);
              f.push(r);
            }
          } else if (o) {
            f = [];
            for (const O of o(t.text, t.sectionIndex, Zl(t, c, a, n, i, d, p))) {
              var s = new Hl();
              s.text = O[0], s.sectionIndex = O[1], s.sections = t.sections, f.push(s);
            }
          } else f = function (e, t) {
            var r = [],
              n = e.text;
            let i = 0;
            for (const o of t) r.push(e.substring(i, o)), i = o;
            return i < n.length && r.push(e.substring(i, n.length)), r;
          }(t, Zl(t, c, a, n, i, d, p));
          e = [], o = {
            positionedLines: e,
            text: t.toString(),
            top: u[1],
            bottom: u[1],
            left: u[0],
            right: u[0],
            writingMode: h,
            iconsInText: !1,
            verticalizable: !1
          };
          {
            var _ = o,
              Y = n,
              H = L,
              j = i,
              m = (a = f, U),
              G = (d = F, p = B, h),
              g = c,
              y = $,
              q = z;
            let s = 0,
              l = zl,
              t = 0,
              r = 0;
            var v = "right" === p ? 1 : "left" === p ? 0 : .5;
            let e = 0;
            for (const M of a) {
              M.trim();
              var E = M.getMaxScale(),
                b = (E - 1) * pe,
                w = {
                  positionedGlyphs: [],
                  lineOffset: 0
                },
                T = (_.positionedLines[e] = w).positionedGlyphs;
              let a = 0;
              if (M.length()) {
                for (let o = 0; o < M.length(); o++) {
                  var S = M.getSection(o),
                    x = M.getSectionIndex(o),
                    C = M.getCharCode(o);
                  let e = 0,
                    t = null,
                    r = null,
                    n = null,
                    i = pe;
                  var A = !(G === ue.WritingMode.horizontal || !y && !Wn(C) || y && (Gl[C] || function (e) {
                    return ne.Arabic(e) || ne["Arabic Supplement"](e) || ne["Arabic Extended-A"](e) || ne["Arabic Presentation Forms-A"](e) || ne["Arabic Presentation Forms-B"](e);
                  }(C)));
                  if (S.imageName) {
                    var I = j[S.imageName];
                    if (!I) continue;
                    n = S.imageName, _.iconsInText = _.iconsInText || !0, r = I.paddedRect;
                    var I = I.displaySize,
                      N = (S.scale = S.scale * pe / q, t = {
                        width: I[0],
                        height: I[1],
                        left: ie,
                        top: -Ul,
                        advance: A ? I[1] : I[0]
                      }, pe - I[1] * S.scale),
                      N = (e = b + N, i = t.advance, A ? I[0] * S.scale - pe * E : I[1] * S.scale - pe * E);
                    0 < N && N > a && (a = N);
                  } else {
                    I = H[S.fontStack], N = I && I[C];
                    if (N && N.rect) r = N.rect, t = N.metrics;else {
                      var P = Y[S.fontStack],
                        P = P && P[C];
                      if (!P) continue;
                      t = P.metrics;
                    }
                    e = (E - S.scale) * pe;
                  }
                  A ? (_.verticalizable = !0, T.push({
                    glyph: C,
                    imageName: n,
                    x: s,
                    y: l + e,
                    vertical: A,
                    scale: S.scale,
                    fontStack: S.fontStack,
                    sectionIndex: x,
                    metrics: t,
                    rect: r
                  }), s += i * S.scale + g) : (T.push({
                    glyph: C,
                    imageName: n,
                    x: s,
                    y: l + e,
                    vertical: A,
                    scale: S.scale,
                    fontStack: S.fontStack,
                    sectionIndex: x,
                    metrics: t,
                    rect: r
                  }), s += t.advance * S.scale + g);
                }
                0 !== T.length && (D = s - g, t = Math.max(D, t), function (t, r, n, e, i) {
                  if (e || i) {
                    var o = t[n],
                      o = o.metrics.advance * o.scale,
                      a = (t[n].x + o) * e;
                    for (let e = r; e <= n; e++) t[e].x -= a, t[e].y += i;
                  }
                }(T, 0, T.length - 1, v, a)), s = 0;
                var D = m * E + a;
                w.lineOffset = Math.max(a, b), l += D, r = Math.max(D, r);
              } else l += m;
              ++e;
            }
            var p = l - zl,
              {
                horizontalAlign: d,
                verticalAlign: u
              } = Xl(d);
            {
              var V = _.positionedLines;
              var K = v;
              var W = d;
              var R = u;
              var Z = t;
              var X = r;
              var J = m;
              var Q = p;
              var ee = a.length;
              var te = (K - W) * Z;
              let e = 0;
              e = X !== J ? -Q * R - zl : (-R * ee + .5) * J;
              for (const re of V) for (const k of re.positionedGlyphs) k.x += te, k.y += e;
            }
            _.top += -u * p, _.bottom = _.top + p, _.left += -d * t, _.right = _.left + t;
          }
          return !function (e) {
            for (const t of e) if (0 !== t.positionedGlyphs.length) return;
            return 1;
          }(e) && o;
        }
        const Gl = {
            [9]: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
          },
          ql = {
            [10]: !0,
            32: !0,
            38: !0,
            40: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
          };
        function Vl(e, t, r, n, i, o) {
          return t.imageName ? (n = n[t.imageName]) ? n.displaySize[0] * t.scale * pe / o + i : 0 : (o = (n = r[t.fontStack]) && n[e]) ? o.metrics.advance * t.scale + i : 0;
        }
        function Kl(e, t, r, n) {
          var i = Math.pow(e - t, 2);
          return n ? e < t ? i / 2 : 2 * i : i + Math.abs(r) * r;
        }
        function Wl(e, t, r, n, i, o) {
          let a = null,
            s = Kl(t, r, i, o);
          for (const c of n) {
            var l = Kl(t - c.x, r, i, o) + c.badness;
            l <= s && (a = c, s = l);
          }
          return {
            index: e,
            x: t,
            priorBreak: a,
            badness: s
          };
        }
        function Zl(t, r, e, n, i, o, a) {
          if ("point" !== o) return [];
          if (!t) return [];
          var s = [],
            l = function (t, r, e, n, i, o) {
              let a = 0;
              for (let e = 0; e < t.length(); e++) {
                var s = t.getSection(e);
                a += Vl(t.getCharCode(e), s, n, i, r, o);
              }
              return e = Math.max(1, Math.ceil(a / e)), a / e;
            }(t, r, e, n, i, a),
            c = 0 <= t.text.indexOf("​");
          let u = 0;
          for (let e = 0; e < t.length(); e++) {
            var h,
              d = t.getSection(e),
              p = t.getCharCode(e);
            Gl[p] || (u += Vl(p, d, n, i, r, a)), e < t.length() - 1 && (h = !((h = p) < 11904 || !ne["Bopomofo Extended"](h) && !(ne.Bopomofo(h) || ne["CJK Compatibility Forms"](h) || ne["CJK Compatibility Ideographs"](h) || ne["CJK Compatibility"](h) || ne["CJK Radicals Supplement"](h) || ne["CJK Strokes"](h) || ne["CJK Symbols and Punctuation"](h) || ne["CJK Unified Ideographs Extension A"](h) || ne["CJK Unified Ideographs"](h) || ne["Enclosed CJK Letters and Months"](h) || ne["Halfwidth and Fullwidth Forms"](h) || ne.Hiragana(h) || ne["Ideographic Description Characters"](h) || ne["Kangxi Radicals"](h) || ne["Katakana Phonetic Extensions"](h) || ne.Katakana(h) || ne["Vertical Forms"](h) || ne["Yi Radicals"](h) || ne["Yi Syllables"](h))), ql[p] || h || d.imageName) && s.push(Wl(e + 1, u, l, s, function (e, t, r) {
              let n = 0;
              return 10 === e && (n -= 1e4), r && (n += 150), 40 !== e && 65288 !== e || (n += 50), 41 !== t && 65289 !== t || (n += 50), n;
            }(p, t.getCharCode(e + 1), h && c), !1));
          }
          return function e(t) {
            return t ? e(t.priorBreak).concat(t.index) : [];
          }(Wl(t.length(), u, l, s, 0, !0));
        }
        function Xl(e) {
          let t = .5,
            r = .5;
          switch (e) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0;
          }
          switch (e) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r = 0;
          }
          return {
            horizontalAlign: t,
            verticalAlign: r
          };
        }
        function Jl(e) {
          let t = e.left,
            r = e.top,
            n = e.right - t,
            i = e.bottom - r;
          var o = e.image.content[2] - e.image.content[0],
            a = e.image.content[3] - e.image.content[1];
          return 0 != a && 0 !== n && 0 !== i && (o = o / a, e.image.contentMatch === Dl.height ? n / i < o && (a = i * o, t *= a / n, n = a) : e.image.contentMatch === Dl.width && 0 != o && n / i > o && (a = n / o, r *= a / a, i = a)), {
            x1: t,
            y1: r,
            x2: t + n,
            y2: r + i
          };
        }
        function Ql(e, t, r, n, i, o) {
          e = e.image;
          let a;
          e.content && (s = e.content, l = e.pixelRatio || 1, a = [s[0] / l, s[1] / l, e.displaySize[0] - s[2] / l, e.displaySize[1] - s[3] / l]);
          var s = t.left * o,
            l = t.right * o;
          let c, u, h, d;
          u = "width" === r || "both" === r ? (d = i[0] + s - n[3], i[0] + l + n[1]) : (d = i[0] + (s + l - e.displaySize[0]) / 2) + e.displaySize[0];
          s = t.top * o, l = t.bottom * o;
          return h = "height" === r || "both" === r ? (c = i[1] + s - n[0], i[1] + l + n[2]) : (c = i[1] + (s + l - e.displaySize[1]) / 2) + e.displaySize[1], {
            image: e,
            top: c,
            right: u,
            bottom: h,
            left: d,
            collisionPadding: a
          };
        }
        const ec = 255,
          tc = 128,
          rc = ec * tc;
        function nc(r, n) {
          n = n.expression;
          if ("constant" === n.kind) return {
            kind: "constant",
            layoutSize: n.evaluate(new N(r + 1))
          };
          if ("source" === n.kind) return {
            kind: "source"
          };
          {
            var {
              zoomStops: i,
              interpolationType: o
            } = n;
            let e = 0;
            for (; e < i.length && i[e] <= r;) e++;
            let t = e = Math.max(0, e - 1);
            for (; t < i.length && i[t] < r + 1;) t++;
            t = Math.min(i.length - 1, t);
            var a = i[e],
              s = i[t];
            return "composite" === n.kind ? {
              kind: "composite",
              minZoom: a,
              maxZoom: s,
              interpolationType: o
            } : {
              kind: "camera",
              minZoom: a,
              maxZoom: s,
              minSize: n.evaluate(new N(a)),
              maxSize: n.evaluate(new N(s)),
              interpolationType: o
            };
          }
        }
        function ic(e, t, r) {
          let n = "never";
          t = e.get(t);
          return t ? n = t : e.get(r) && (n = "always"), n;
        }
        const oc = ws.VectorTileFeature.types,
          ac = [{
            name: "a_fade_opacity",
            components: 1,
            type: "Uint8",
            offset: 0
          }];
        function sc(e, t, r, n, i, o, a, s, l, c, u, h, d) {
          var p = s ? Math.min(rc, Math.round(s[0])) : 0,
            s = s ? Math.min(rc, Math.round(s[1])) : 0;
          e.emplaceBack(t, r, Math.round(32 * n), Math.round(32 * i), o, a, (p << 1) + (l ? 1 : 0), s, 16 * c, 16 * u, 256 * h, 256 * d);
        }
        function lc(e, t, r) {
          e.emplaceBack(t.x, t.y, r), e.emplaceBack(t.x, t.y, r), e.emplaceBack(t.x, t.y, r), e.emplaceBack(t.x, t.y, r);
        }
        function cc(e) {
          for (const t of e.sections) if (function (e) {
            for (const t of e) if (Xn(t.charCodeAt(0))) return 1;
          }(t.text)) return 1;
        }
        class uc {
          constructor(e) {
            this.layoutVertexArray = new po(), this.indexArray = new yo(), this.programConfigurations = e, this.segments = new T(), this.dynamicLayoutVertexArray = new fo(), this.opacityVertexArray = new _o(), this.hasVisibleVertices = !1, this.placedSymbolArray = new Zi();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
          }
          upload(e, t, r, n) {
            !this.isEmpty() && (r && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, il.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, t), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, ol.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, ac, !0), this.opacityVertexBuffer.itemSize = 1), r || n) && this.programConfigurations.upload(e);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        r("SymbolBuffers", uc);
        class hc {
          constructor(e, t, r) {
            this.layoutVertexArray = new e(), this.layoutAttributes = t, this.indexArray = new r(), this.segments = new T(), this.collisionVertexArray = new go();
          }
          upload(e) {
            this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, al.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        r("CollisionBuffers", hc);
        class dc {
          constructor(e) {
            this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = pa([]), this.placementViewportMatrix = pa([]);
            var t = this.layers[0]._unevaluatedLayout._values,
              t = (this.textSizeData = nc(this.zoom, t["text-size"]), this.iconSizeData = nc(this.zoom, t["icon-size"]), this.layers[0].layout),
              r = t.get("symbol-sort-key"),
              n = t.get("symbol-z-order"),
              r = (this.canOverlap = "never" !== ic(t, "text-overlap", "text-allow-overlap") || "never" !== ic(t, "icon-overlap", "icon-allow-overlap") || t.get("text-ignore-placement") || t.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== n && !r.isConstant(), "viewport-y" === n || "auto" === n && !this.sortFeaturesByKey);
            this.sortFeaturesByY = r && this.canOverlap, "point" === t.get("symbol-placement") && (this.writingModes = t.get("text-writing-mode").map(e => ue.WritingMode[e])), this.stateDependentLayerIds = this.layers.filter(e => e.isStateDependent()).map(e => e.id), this.sourceID = e.sourceID;
          }
          createArrays() {
            this.text = new uc(new $o(this.layers, this.zoom, e => /^text/.test(e))), this.icon = new uc(new $o(this.layers, this.zoom, e => /^icon/.test(e))), this.glyphOffsetArray = new Qi(), this.lineVertexArray = new eo(), this.symbolInstances = new Ji(), this.textAnchorOffsets = new ro();
          }
          calculateGlyphDependencies(t, r, n, i, o) {
            for (let e = 0; e < t.length; e++) {
              var a;
              r[t.charCodeAt(e)] = !0, (n || i) && o && (a = ul[t.charAt(e)]) && (r[a.charCodeAt(0)] = !0);
            }
          }
          populate(e, t, r) {
            var n = this.layers[0],
              i = n.layout,
              o = i.get("text-font"),
              a = i.get("text-field"),
              s = i.get("icon-image"),
              l = ("constant" !== a.value.kind || a.value.value instanceof xt && !a.value.value.isEmpty() || 0 < a.value.value.toString().length) && ("constant" !== o.value.kind || 0 < o.value.value.length),
              c = "constant" !== s.value.kind || !!s.value.value || 0 < Object.keys(s.parameters).length,
              u = i.get("symbol-sort-key");
            if (this.features = [], l || c) {
              var h,
                d,
                p,
                f,
                _ = t.iconDependencies,
                m = t.glyphDependencies,
                g = t.availableImages,
                y = new N(this.zoom);
              for ({
                feature: h,
                id: d,
                index: p,
                sourceLayerIndex: f
              } of e) {
                var v = n._featureFilter.needGeometry,
                  E = qo(h, v);
                if (n._featureFilter.filter(y, E, r)) {
                  v || (E.geometry = Go(h));
                  let e;
                  l && (v = n.getValueAndResolveTokens("text-field", E, r, g), cc(v = xt.factory(v)) && (this.hasRTLText = !0), !this.hasRTLText || "unavailable" === ii() || this.hasRTLText && si.isParsed()) && (e = ll(v, n, E));
                  let t;
                  if (c && (v = n.getValueAndResolveTokens("icon-image", E, r, g), t = v instanceof Nt ? v : Nt.fromString(v)), e || t) {
                    v = this.sortFeaturesByKey ? u.evaluate(E, {}, r) : void 0, v = {
                      id: d,
                      text: e,
                      icon: t,
                      index: p,
                      sourceLayerIndex: f,
                      geometry: E.geometry,
                      properties: h.properties,
                      type: oc[h.type],
                      sortKey: v
                    };
                    if (this.features.push(v), t && (_[t.name] = !0), e) {
                      var b,
                        w,
                        T = o.evaluate(E, {}, r).join(","),
                        S = "viewport" !== i.get("text-rotation-alignment") && "point" !== i.get("symbol-placement");
                      this.allowVerticalPlacement = this.writingModes && 0 <= this.writingModes.indexOf(ue.WritingMode.vertical);
                      for (const x of e.sections) x.image ? _[x.image.name] = !0 : (b = Vn(e.toString()), w = m[w = x.fontStack || T] = m[w] || {}, this.calculateGlyphDependencies(x.text, w, S, this.allowVerticalPlacement, b));
                    }
                  }
                }
              }
              "line" === i.get("symbol-placement") && (this.features = cl(this.features)), this.sortFeaturesByKey && this.features.sort((e, t) => e.sortKey - t.sortKey);
            }
          }
          update(e, t, r) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, t, this.layers, r), this.icon.programConfigurations.updatePaintArrays(e, t, this.layers, r));
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(e) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(n, i) {
            var e = this.lineVertexArray.length;
            if (void 0 !== n.segment) {
              let t = n.dist(i[n.segment + 1]),
                r = n.dist(i[n.segment]);
              var o = {};
              for (let e = n.segment + 1; e < i.length; e++) o[e] = {
                x: i[e].x,
                y: i[e].y,
                tileUnitDistanceFromAnchor: t
              }, e < i.length - 1 && (t += i[e + 1].dist(i[e]));
              for (let e = n.segment || 0; 0 <= e; e--) o[e] = {
                x: i[e].x,
                y: i[e].y,
                tileUnitDistanceFromAnchor: r
              }, 0 < e && (r += i[e - 1].dist(i[e]));
              for (let e = 0; e < i.length; e++) {
                var a = o[e];
                this.lineVertexArray.emplaceBack(a.x, a.y, a.tileUnitDistanceFromAnchor);
              }
            }
            return {
              lineStartIndex: e,
              lineLength: this.lineVertexArray.length - e
            };
          }
          addSymbols(t, r, n, e, i, o, a, s, l, c, u, h) {
            var d = t.indexArray,
              p = t.layoutVertexArray,
              f = t.segments.prepareSegment(4 * r.length, p, d, this.canOverlap ? o.sortKey : void 0),
              _ = this.glyphOffsetArray.length,
              m = f.vertexLength,
              g = this.allowVerticalPlacement && a === ue.WritingMode.vertical ? Math.PI / 2 : 0,
              y = o.text && o.text.sections;
            for (let e = 0; e < r.length; e++) {
              var {
                  tl: v,
                  tr: E,
                  bl: b,
                  br: w,
                  tex: T,
                  pixelOffsetTL: S,
                  pixelOffsetBR: x,
                  minFontScaleX: C,
                  minFontScaleY: A,
                  glyphOffset: I,
                  isSDF: N,
                  sectionIndex: P
                } = r[e],
                D = f.vertexLength,
                R = I[1];
              sc(p, s.x, s.y, v.x, R + v.y, T.x, T.y, n, N, S.x, S.y, C, A), sc(p, s.x, s.y, E.x, R + E.y, T.x + T.w, T.y, n, N, x.x, S.y, C, A), sc(p, s.x, s.y, b.x, R + b.y, T.x, T.y + T.h, n, N, S.x, x.y, C, A), sc(p, s.x, s.y, w.x, R + w.y, T.x + T.w, T.y + T.h, n, N, x.x, x.y, C, A), lc(t.dynamicLayoutVertexArray, s, g), d.emplaceBack(D, D + 1, D + 2), d.emplaceBack(D + 1, D + 2, D + 3), f.vertexLength += 4, f.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(I[0]), e !== r.length - 1 && P === r[e + 1].sectionIndex || t.programConfigurations.populatePaintArrays(p.length, o, o.index, {}, h, y && y[P]);
            }
            t.placedSymbolArray.emplaceBack(s.x, s.y, _, this.glyphOffsetArray.length - _, m, l, c, s.segment, n ? n[0] : 0, n ? n[1] : 0, e[0], e[1], a, 0, !1, 0, u);
          }
          _addCollisionDebugVertex(e, t, r, n, i, o) {
            return t.emplaceBack(0, 0), e.emplaceBack(r.x, r.y, n, i, Math.round(o.x), Math.round(o.y));
          }
          addCollisionDebugVertices(e, t, r, n, i, o, a) {
            var s = i.segments.prepareSegment(4, i.layoutVertexArray, i.indexArray),
              l = s.vertexLength,
              c = i.layoutVertexArray,
              u = i.collisionVertexArray,
              h = a.anchorX,
              a = a.anchorY,
              t = (this._addCollisionDebugVertex(c, u, o, h, a, new F(e, t)), this._addCollisionDebugVertex(c, u, o, h, a, new F(r, t)), this._addCollisionDebugVertex(c, u, o, h, a, new F(r, n)), this._addCollisionDebugVertex(c, u, o, h, a, new F(e, n)), s.vertexLength += 4, i.indexArray);
            t.emplaceBack(l, l + 1), t.emplaceBack(l + 1, l + 2), t.emplaceBack(l + 2, l + 3), t.emplaceBack(l + 3, l), s.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t, r, n, i) {
            for (let e = t; e < r; e++) {
              var o = this.collisionBoxArray.get(e),
                a = o.x1,
                s = o.y1,
                l = o.x2,
                c = o.y2;
              this.addCollisionDebugVertices(a, s, l, c, i ? this.textCollisionBox : this.iconCollisionBox, o.anchorPoint, n);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new hc(mo, sl.members, vo), this.iconCollisionBox = new hc(mo, sl.members, vo);
            for (let e = 0; e < this.symbolInstances.length; e++) {
              var t = this.symbolInstances.get(e);
              this.addDebugCollisionBoxes(t.textBoxStartIndex, t.textBoxEndIndex, t, !0), this.addDebugCollisionBoxes(t.verticalTextBoxStartIndex, t.verticalTextBoxEndIndex, t, !0), this.addDebugCollisionBoxes(t.iconBoxStartIndex, t.iconBoxEndIndex, t, !1), this.addDebugCollisionBoxes(t.verticalIconBoxStartIndex, t.verticalIconBoxEndIndex, t, !1);
            }
          }
          _deserializeCollisionBoxesForSymbol(t, r, n, i, o, a, s, l, c) {
            var u = {};
            for (let e = r; e < n; e++) {
              var h = t.get(e);
              u.textBox = {
                x1: h.x1,
                y1: h.y1,
                x2: h.x2,
                y2: h.y2,
                anchorPointX: h.anchorPointX,
                anchorPointY: h.anchorPointY
              }, u.textFeatureIndex = h.featureIndex;
              break;
            }
            for (let e = i; e < o; e++) {
              var d = t.get(e);
              u.verticalTextBox = {
                x1: d.x1,
                y1: d.y1,
                x2: d.x2,
                y2: d.y2,
                anchorPointX: d.anchorPointX,
                anchorPointY: d.anchorPointY
              }, u.verticalTextFeatureIndex = d.featureIndex;
              break;
            }
            for (let e = a; e < s; e++) {
              var p = t.get(e);
              u.iconBox = {
                x1: p.x1,
                y1: p.y1,
                x2: p.x2,
                y2: p.y2,
                anchorPointX: p.anchorPointX,
                anchorPointY: p.anchorPointY
              }, u.iconFeatureIndex = p.featureIndex;
              break;
            }
            for (let e = l; e < c; e++) {
              var f = t.get(e);
              u.verticalIconBox = {
                x1: f.x1,
                y1: f.y1,
                x2: f.x2,
                y2: f.y2,
                anchorPointX: f.anchorPointX,
                anchorPointY: f.anchorPointY
              }, u.verticalIconFeatureIndex = f.featureIndex;
              break;
            }
            return u;
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let e = 0; e < this.symbolInstances.length; e++) {
              var r = this.symbolInstances.get(e);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return 0 < this.text.segments.get().length;
          }
          hasIconData() {
            return 0 < this.icon.segments.get().length;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && 0 < this.textCollisionBox.segments.get().length;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && 0 < this.iconCollisionBox.segments.get().length;
          }
          addIndicesForPlacedSymbol(t, r) {
            var r = t.placedSymbolArray.get(r),
              n = r.vertexStartIndex + 4 * r.numGlyphs;
            for (let e = r.vertexStartIndex; e < n; e += 4) t.indexArray.emplaceBack(e, e + 1, e + 2), t.indexArray.emplaceBack(e + 1, e + 2, e + 3);
          }
          getSortedSymbolIndexes(e) {
            if (this.sortedAngle === e && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
            var t = Math.sin(e),
              r = Math.cos(e);
            const n = [],
              i = [];
            var o = [];
            for (let e = 0; e < this.symbolInstances.length; ++e) {
              o.push(e);
              var a = this.symbolInstances.get(e);
              n.push(0 | Math.round(t * a.anchorX + r * a.anchorY)), i.push(a.featureIndex);
            }
            return o.sort((e, t) => n[e] - n[t] || i[t] - i[e]), o;
          }
          addToSortKeyRanges(e, t) {
            var r = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r && r.sortKey === t ? r.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({
              sortKey: t,
              symbolInstanceStart: e,
              symbolInstanceEnd: e + 1
            });
          }
          sortFeatures(e) {
            if (this.sortFeaturesByY && this.sortedAngle !== e && !(1 < this.text.segments.get().length || 1 < this.icon.segments.get().length)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const r of this.symbolInstanceIndexes) {
                var t = this.symbolInstances.get(r);
                this.featureSortOrder.push(t.featureIndex), [t.rightJustifiedTextSymbolIndex, t.centerJustifiedTextSymbolIndex, t.leftJustifiedTextSymbolIndex].forEach((e, t, r) => {
                  0 <= e && r.indexOf(e) === t && this.addIndicesForPlacedSymbol(this.text, e);
                }), 0 <= t.verticalPlacedTextSymbolIndex && this.addIndicesForPlacedSymbol(this.text, t.verticalPlacedTextSymbolIndex), 0 <= t.placedIconSymbolIndex && this.addIndicesForPlacedSymbol(this.icon, t.placedIconSymbolIndex), 0 <= t.verticalPlacedIconSymbolIndex && this.addIndicesForPlacedSymbol(this.icon, t.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        function pc(r, e) {
          return e.replace(/{([^{}]+)}/g, (e, t) => r && t in r ? String(r[t]) : "");
        }
        r("SymbolBucket", dc, {
          omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }), dc.MAX_GLYPHS = 65535, dc.addDynamicAttributes = lc;
        let fc;
        let _c;
        var mc = {
          get paint() {
            return _c = _c || new l({
              "icon-opacity": new a(o.paint_symbol["icon-opacity"]),
              "icon-color": new a(o.paint_symbol["icon-color"]),
              "icon-halo-color": new a(o.paint_symbol["icon-halo-color"]),
              "icon-halo-width": new a(o.paint_symbol["icon-halo-width"]),
              "icon-halo-blur": new a(o.paint_symbol["icon-halo-blur"]),
              "icon-translate": new i(o.paint_symbol["icon-translate"]),
              "icon-translate-anchor": new i(o.paint_symbol["icon-translate-anchor"]),
              "text-opacity": new a(o.paint_symbol["text-opacity"]),
              "text-color": new a(o.paint_symbol["text-color"], {
                runtimeType: ze,
                getOverride: e => e.textColor,
                hasOverride: e => !!e.textColor
              }),
              "text-halo-color": new a(o.paint_symbol["text-halo-color"]),
              "text-halo-width": new a(o.paint_symbol["text-halo-width"]),
              "text-halo-blur": new a(o.paint_symbol["text-halo-blur"]),
              "text-translate": new i(o.paint_symbol["text-translate"]),
              "text-translate-anchor": new i(o.paint_symbol["text-translate-anchor"])
            });
          },
          get layout() {
            return fc = fc || new l({
              "symbol-placement": new i(o.layout_symbol["symbol-placement"]),
              "symbol-spacing": new i(o.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new i(o.layout_symbol["symbol-avoid-edges"]),
              "symbol-sort-key": new a(o.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new i(o.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new i(o.layout_symbol["icon-allow-overlap"]),
              "icon-overlap": new i(o.layout_symbol["icon-overlap"]),
              "icon-ignore-placement": new i(o.layout_symbol["icon-ignore-placement"]),
              "icon-optional": new i(o.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new i(o.layout_symbol["icon-rotation-alignment"]),
              "icon-size": new a(o.layout_symbol["icon-size"]),
              "icon-text-fit": new i(o.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new i(o.layout_symbol["icon-text-fit-padding"]),
              "icon-image": new a(o.layout_symbol["icon-image"]),
              "icon-rotate": new a(o.layout_symbol["icon-rotate"]),
              "icon-padding": new a(o.layout_symbol["icon-padding"]),
              "icon-keep-upright": new i(o.layout_symbol["icon-keep-upright"]),
              "icon-offset": new a(o.layout_symbol["icon-offset"]),
              "icon-anchor": new a(o.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new i(o.layout_symbol["icon-pitch-alignment"]),
              "text-pitch-alignment": new i(o.layout_symbol["text-pitch-alignment"]),
              "text-rotation-alignment": new i(o.layout_symbol["text-rotation-alignment"]),
              "text-field": new a(o.layout_symbol["text-field"]),
              "text-font": new a(o.layout_symbol["text-font"]),
              "text-size": new a(o.layout_symbol["text-size"]),
              "text-max-width": new a(o.layout_symbol["text-max-width"]),
              "text-line-height": new i(o.layout_symbol["text-line-height"]),
              "text-letter-spacing": new a(o.layout_symbol["text-letter-spacing"]),
              "text-justify": new a(o.layout_symbol["text-justify"]),
              "text-radial-offset": new a(o.layout_symbol["text-radial-offset"]),
              "text-variable-anchor": new i(o.layout_symbol["text-variable-anchor"]),
              "text-variable-anchor-offset": new a(o.layout_symbol["text-variable-anchor-offset"]),
              "text-anchor": new a(o.layout_symbol["text-anchor"]),
              "text-max-angle": new i(o.layout_symbol["text-max-angle"]),
              "text-writing-mode": new i(o.layout_symbol["text-writing-mode"]),
              "text-rotate": new a(o.layout_symbol["text-rotate"]),
              "text-padding": new i(o.layout_symbol["text-padding"]),
              "text-keep-upright": new i(o.layout_symbol["text-keep-upright"]),
              "text-transform": new a(o.layout_symbol["text-transform"]),
              "text-offset": new a(o.layout_symbol["text-offset"]),
              "text-allow-overlap": new i(o.layout_symbol["text-allow-overlap"]),
              "text-overlap": new i(o.layout_symbol["text-overlap"]),
              "text-ignore-placement": new i(o.layout_symbol["text-ignore-placement"]),
              "text-optional": new i(o.layout_symbol["text-optional"])
            });
          }
        };
        class gc {
          constructor(e) {
            if (void 0 === e.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = e.property.overrides ? e.property.overrides.runtimeType : $e, this.defaultValue = e;
          }
          evaluate(e) {
            if (e.formattedSection) {
              var t = this.defaultValue.property.overrides;
              if (t && t.hasOverride(e.formattedSection)) return t.getOverride(e.formattedSection);
            }
            return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(e) {
            this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        r("FormatSectionOverride", gc, {
          omit: ["defaultValue"]
        });
        class yc extends Ei {
          constructor(e) {
            super(e, mc);
          }
          recalculate(e, t) {
            if (super.recalculate(e, t), "auto" === this.layout.get("icon-rotation-alignment") && ("point" !== this.layout.get("symbol-placement") ? this.layout._values["icon-rotation-alignment"] = "map" : this.layout._values["icon-rotation-alignment"] = "viewport"), "auto" === this.layout.get("text-rotation-alignment") && ("point" !== this.layout.get("symbol-placement") ? this.layout._values["text-rotation-alignment"] = "map" : this.layout._values["text-rotation-alignment"] = "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
              e = this.layout.get("text-writing-mode");
              if (e) {
                var r = [];
                for (const n of e) r.indexOf(n) < 0 && r.push(n);
                this.layout._values["text-writing-mode"] = r;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(e, t, r, n) {
            r = this.layout.get(e).evaluate(t, {}, r, n), n = this._unevaluatedLayout._values[e];
            return n.isDataDriven() || Gr(n.value) || !r ? r : pc(t.properties, r);
          }
          createBucket(e) {
            return new dc(e);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const n of mc.paint.overridableProperties) if (yc.hasPaintOverride(this.layout, n)) {
              var t = this.paint.get(n),
                r = new gc(t),
                r = new jr(r, t.property.specification);
              let e = null;
              e = "constant" === t.value.kind || "source" === t.value.kind ? new Vr("source", r) : new Kr("composite", r, t.value.zoomStops), this.paint._values[n] = new fi(t.property, e, t.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(e, t, r) {
            return !(!this.layout || t.isDataDriven() || r.isDataDriven()) && yc.hasPaintOverride(this.layout, e);
          }
          static hasPaintOverride(e, t) {
            e = e.get("text-field");
            const r = mc.paint.properties[t];
            let n = !1;
            const i = e => {
              for (const t of e) if (r.overrides && r.overrides.hasOverride(t)) return void (n = !0);
            };
            if ("constant" === e.value.kind && e.value.value instanceof xt) i(e.value.value.sections);else if ("source" === e.value.kind) {
              const o = e => {
                var t;
                n || (e instanceof Ot && d(e.value) === je ? (t = e.value, i(t.sections)) : e instanceof Cr ? i(e.sections) : e.eachChild(o));
              };
              t = e.value;
              t._styleExpression && o(t._styleExpression.expression);
            }
            return n;
          }
        }
        let vc;
        var Ec = {
          get paint() {
            return vc = vc || new l({
              "background-color": new i(o.paint_background["background-color"]),
              "background-pattern": new gi(o.paint_background["background-pattern"]),
              "background-opacity": new i(o.paint_background["background-opacity"])
            });
          }
        };
        class bc extends Ei {
          constructor(e) {
            super(e, Ec);
          }
        }
        let wc;
        var Tc = {
          get paint() {
            return wc = wc || new l({
              "raster-opacity": new i(o.paint_raster["raster-opacity"]),
              "raster-hue-rotate": new i(o.paint_raster["raster-hue-rotate"]),
              "raster-brightness-min": new i(o.paint_raster["raster-brightness-min"]),
              "raster-brightness-max": new i(o.paint_raster["raster-brightness-max"]),
              "raster-saturation": new i(o.paint_raster["raster-saturation"]),
              "raster-contrast": new i(o.paint_raster["raster-contrast"]),
              "raster-resampling": new i(o.paint_raster["raster-resampling"]),
              "raster-fade-duration": new i(o.paint_raster["raster-fade-duration"])
            });
          }
        };
        class Sc extends Ei {
          constructor(e) {
            super(e, Tc);
          }
        }
        class xc extends Ei {
          constructor(e) {
            super(e, {}), this.onAdd = e => {
              this.implementation.onAdd && this.implementation.onAdd(e, e.painter.context.gl);
            }, this.onRemove = e => {
              this.implementation.onRemove && this.implementation.onRemove(e, e.painter.context.gl);
            }, this.implementation = e;
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          recalculate() {}
          updateTransitions() {}
          hasTransition() {
            return !1;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class Cc {
          constructor(e) {
            this._callback = e, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
              this._triggered = !1, this._callback();
            }, 0));
          }
          remove() {
            delete this._channel, this._callback = () => {};
          }
        }
        const Ac = 6371008.8;
        class Ic {
          constructor(e, t) {
            if (isNaN(e) || isNaN(t)) throw new Error(`Invalid LngLat object: (${e}, ${t})`);
            if (this.lng = +e, this.lat = +t, 90 < this.lat || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Ic(j(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(e) {
            var t = Math.PI / 180,
              r = this.lat * t,
              n = e.lat * t,
              r = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((e.lng - this.lng) * t);
            return Ac * Math.acos(Math.min(r, 1));
          }
          static convert(e) {
            if (e instanceof Ic) return e;
            if (Array.isArray(e) && (2 === e.length || 3 === e.length)) return new Ic(Number(e[0]), Number(e[1]));
            if (Array.isArray(e) || "object" != typeof e || null === e) throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            return new Ic(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
          }
        }
        const Nc = 2 * Math.PI * Ac;
        function Pc(e) {
          return Nc * Math.cos(e * Math.PI / 180);
        }
        function Dc(e) {
          return (180 + e) / 360;
        }
        function Rc(e) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e * Math.PI / 360))) / 360;
        }
        function Oc(e, t) {
          return e / Pc(t);
        }
        function Mc(e) {
          return 360 * e - 180;
        }
        function kc(e) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * e) * Math.PI / 180)) - 90;
        }
        function Lc(e, t) {
          return e * Pc(kc(t));
        }
        function Uc(e) {
          return 1 / Math.cos(e * Math.PI / 180);
        }
        class Fc {
          constructor(e, t, r = 0) {
            this.x = +e, this.y = +t, this.z = +r;
          }
          static fromLngLat(e, t = 0) {
            e = Ic.convert(e);
            return new Fc(Dc(e.lng), Rc(e.lat), Oc(t, e.lat));
          }
          toLngLat() {
            return new Ic(Mc(this.x), kc(this.y));
          }
          toAltitude() {
            return Lc(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Nc * Uc(kc(this.y));
          }
        }
        function Bc(e, t, r) {
          var n = $c(256 * e, 256 * (t = Math.pow(2, r) - t - 1), r),
            e = $c(256 * (e + 1), 256 * (t + 1), r);
          return n[0] + "," + n[1] + "," + e[0] + "," + e[1];
        }
        function $c(e, t, r) {
          r = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
          return [e * r - 2 * Math.PI * 6378137 / 2, t * r - 2 * Math.PI * 6378137 / 2];
        }
        class zc {
          constructor(e, t, r) {
            if (e < 0 || 25 < e || r < 0 || r >= Math.pow(2, e) || t < 0 || t >= Math.pow(2, e)) throw new Error(`x=${t}, y=${r}, z=${e} outside of bounds. 0<=x<${Math.pow(2, e)}, 0<=y<${Math.pow(2, e)} 0<=z<=25 `);
            this.z = e, this.x = t, this.y = r, this.key = jc(0, e, e, t, r);
          }
          equals(e) {
            return this.z === e.z && this.x === e.x && this.y === e.y;
          }
          url(e, t, r) {
            var n = Bc(this.x, this.y, this.z),
              i = Gc(this.z, this.x, this.y);
            return e[(this.x + this.y) % e.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, 1 < t ? "@2x" : "").replace(/{quadkey}/g, i).replace(/{bbox-epsg-3857}/g, n);
          }
          isChildOf(e) {
            var t = this.z - e.z;
            return 0 < t && e.x === this.x >> t && e.y === this.y >> t;
          }
          getTilePoint(e) {
            var t = Math.pow(2, this.z);
            return new F((e.x * t - this.x) * de, (e.y * t - this.y) * de);
          }
          toString() {
            return `${this.z}/${this.x}/` + this.y;
          }
        }
        class Yc {
          constructor(e, t) {
            this.wrap = e, this.canonical = t, this.key = jc(e, t.z, t.z, t.x, t.y);
          }
        }
        class Hc {
          constructor(e, t, r, n, i) {
            if (e < r) throw new Error(`overscaledZ should be >= z; overscaledZ = ${e}; z = ` + r);
            this.overscaledZ = e, this.wrap = t, this.canonical = new zc(r, +n, +i), this.key = jc(t, e, r, n, i);
          }
          clone() {
            return new Hc(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(e) {
            return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
          }
          scaledTo(e) {
            if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ` + this.overscaledZ);
            var t = this.canonical.z - e;
            return e > this.canonical.z ? new Hc(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Hc(e, this.wrap, e, this.canonical.x >> t, this.canonical.y >> t);
          }
          calculateScaledKey(e, t) {
            if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ` + this.overscaledZ);
            var r = this.canonical.z - e;
            return e > this.canonical.z ? jc(this.wrap * +t, e, this.canonical.z, this.canonical.x, this.canonical.y) : jc(this.wrap * +t, e, e, this.canonical.x >> r, this.canonical.y >> r);
          }
          isChildOf(e) {
            var t;
            return e.wrap === this.wrap && (t = this.canonical.z - e.canonical.z, 0 === e.overscaledZ || e.overscaledZ < this.overscaledZ && e.canonical.x === this.canonical.x >> t && e.canonical.y === this.canonical.y >> t);
          }
          children(e) {
            var t, r;
            return this.overscaledZ >= e ? [new Hc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)] : (e = this.canonical.z + 1, t = 2 * this.canonical.x, r = 2 * this.canonical.y, [new Hc(e, this.wrap, e, t, r), new Hc(e, this.wrap, e, 1 + t, r), new Hc(e, this.wrap, e, t, 1 + r), new Hc(e, this.wrap, e, 1 + t, 1 + r)]);
          }
          isLessThan(e) {
            return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y));
          }
          wrapped() {
            return new Hc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(e) {
            return new Hc(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new Yc(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/` + this.canonical.y;
          }
          getTilePoint(e) {
            return this.canonical.getTilePoint(new Fc(e.x - this.wrap, e.y));
          }
        }
        function jc(e, t, r, n, i) {
          var o = 1 << r;
          return (o * o * (e = (e *= 2) < 0 ? -1 * e - 1 : e) + o * i + n).toString(36) + r.toString(36) + t.toString(36);
        }
        function Gc(t, r, n) {
          let i = "",
            o;
          for (let e = t; 0 < e; e--) o = 1 << e - 1, i += (r & o ? 1 : 0) + (n & o ? 2 : 0);
          return i;
        }
        r("CanonicalTileID", zc), r("OverscaledTileID", Hc, {
          omit: ["posMatrix"]
        });
        class qc {
          constructor(e, t, r, n = 1, i = 1, o = 1, a = 0) {
            if (this.uid = e, t.height !== t.width) throw new RangeError("DEM tiles must be square");
            if (r && !["mapbox", "terrarium", "custom"].includes(r)) he(`"${r}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);else {
              this.stride = t.height;
              var s = this.dim = t.height - 2;
              switch (this.data = new Uint32Array(t.data.buffer), r) {
                case "terrarium":
                  this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                  break;
                case "custom":
                  this.redFactor = n, this.greenFactor = i, this.blueFactor = o, this.baseShift = a;
                  break;
                default:
                  this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4;
              }
              for (let e = 0; e < s; e++) this.data[this._idx(-1, e)] = this.data[this._idx(0, e)], this.data[this._idx(s, e)] = this.data[this._idx(s - 1, e)], this.data[this._idx(e, -1)] = this.data[this._idx(e, 0)], this.data[this._idx(e, s)] = this.data[this._idx(e, s - 1)];
              this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(s, -1)] = this.data[this._idx(s - 1, 0)], this.data[this._idx(-1, s)] = this.data[this._idx(0, s - 1)], this.data[this._idx(s, s)] = this.data[this._idx(s - 1, s - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
              for (let t = 0; t < s; t++) for (let e = 0; e < s; e++) {
                var l = this.get(t, e);
                l > this.max && (this.max = l), l < this.min && (this.min = l);
              }
            }
          }
          get(e, t) {
            var r = new Uint8Array(this.data.buffer),
              e = 4 * this._idx(e, t);
            return this.unpack(r[e], r[1 + e], r[2 + e]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(e, t) {
            if (e < -1 || e >= this.dim + 1 || t < -1 || t >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (t + 1) * this.stride + (e + 1);
          }
          unpack(e, t, r) {
            return e * this.redFactor + t * this.greenFactor + r * this.blueFactor - this.baseShift;
          }
          getPixels() {
            return new Ua({
              width: this.stride,
              height: this.stride
            }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(r, e, t) {
            if (this.dim !== r.dim) throw new Error("dem dimension mismatch");
            let n = e * this.dim,
              i = e * this.dim + this.dim,
              o = t * this.dim,
              a = t * this.dim + this.dim;
            switch (e) {
              case -1:
                n = i - 1;
                break;
              case 1:
                i = n + 1;
            }
            switch (t) {
              case -1:
                o = a - 1;
                break;
              case 1:
                a = o + 1;
            }
            var s = -e * this.dim,
              l = -t * this.dim;
            for (let t = o; t < a; t++) for (let e = n; e < i; e++) this.data[this._idx(e, t)] = r.data[this._idx(e + s, t + l)];
          }
        }
        r("DEMData", qc);
        class Vc {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e = 0; e < t.length; e++) {
              var r = t[e];
              this._stringToNumber[r] = e, this._numberToString[e] = r;
            }
          }
          encode(e) {
            return this._stringToNumber[e];
          }
          decode(e) {
            if (e >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${e} can't be >= this._numberToString.length ` + this._numberToString.length);
            return this._numberToString[e];
          }
        }
        class Kc {
          constructor(e, t, r, n, i) {
            this.type = "Feature", (this._vectorTileFeature = e)._z = t, e._x = r, e._y = n, this.properties = e.properties, this.id = i;
          }
          get geometry() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(e) {
            this._geometry = e;
          }
          toJSON() {
            var e = {
              geometry: this.geometry
            };
            for (const t in this) "_geometry" !== t && "_vectorTileFeature" !== t && (e[t] = this[t]);
            return e;
          }
        }
        class Wc {
          constructor(e, t) {
            this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new zn(de, 16, 0), this.grid3D = new zn(de, 16, 0), this.featureIndexArray = new io(), this.promoteId = t;
          }
          insert(e, t, r, n, i, o) {
            var a = this.featureIndexArray.length,
              s = (this.featureIndexArray.emplaceBack(r, n, i), o ? this.grid3D : this.grid);
            for (let e = 0; e < t.length; e++) {
              var l = t[e],
                c = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let e = 0; e < l.length; e++) {
                var u = l[e];
                c[0] = Math.min(c[0], u.x), c[1] = Math.min(c[1], u.y), c[2] = Math.max(c[2], u.x), c[3] = Math.max(c[3], u.y);
              }
              c[0] < de && c[1] < de && 0 <= c[2] && 0 <= c[3] && s.insert(a, c[0], c[1], c[2], c[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new ws.VectorTile(new Rl(this.rawTileData)).layers, this.sourceLayerCoder = new Vc(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(i, t, r, o) {
            this.loadVTLayers();
            const a = i.params || {},
              s = de / i.tileSize / i.scale,
              l = rn(a.filter),
              c = i.queryGeometry,
              u = i.queryPadding * s;
            var e = Xc(c),
              n = this.grid.query(e.minX - u, e.minY - u, e.maxX + u, e.maxY + u),
              e = Xc(i.cameraQueryGeometry);
            for (const f of this.grid3D.query(e.minX - u, e.minY - u, e.maxX + u, e.maxY + u, (e, t, r, n) => ia(i.cameraQueryGeometry, e - u, t - u, r + u, n + u))) n.push(f);
            n.sort(Jc);
            var h = {};
            let d;
            for (let e = 0; e < n.length; e++) {
              var p = n[e];
              if (p !== d) {
                d = p;
                p = this.featureIndexArray.get(p);
                let n = null;
                this.loadMatchingFeature(h, p.bucketIndex, p.sourceLayerIndex, p.featureIndex, l, a.layers, a.availableImages, t, r, o, (e, t, r) => (n = n || Go(e), t.queryIntersectsFeature(c, e, r, n, this.z, i.transform, s, i.pixelPosMatrix)));
              }
            }
            return h;
          }
          loadMatchingFeature(t, e, r, n, i, o, a, s, l, c, u) {
            var h = this.bucketLayerIDs[e];
            if (!o || Z(o, h)) {
              var e = this.sourceLayerCoder.decode(r),
                d = this.vtLayers[e].feature(n);
              if (i.needGeometry) {
                r = qo(d, !0);
                if (!i.filter(new N(this.tileID.overscaledZ), r, this.tileID.canonical)) return;
              } else if (!i.filter(new N(this.tileID.overscaledZ), d)) return;
              var p = this.getId(d, e);
              for (let e = 0; e < h.length; e++) {
                var f = h[e];
                if (!(o && o.indexOf(f) < 0)) {
                  var _ = s[f];
                  if (_) {
                    let e = {};
                    p && c && (e = c.getState(_.sourceLayer || "_geojsonTileLayer", p));
                    var m = G({}, l[f]),
                      _ = (m.paint = Zc(m.paint, _.paint, d, e, a), m.layout = Zc(m.layout, _.layout, d, e, a), !u || u(d, _, e));
                    if (_) {
                      var g = new Kc(d, this.z, this.x, this.y, p);
                      g.layer = m;
                      let e = t[f];
                      (e = void 0 === e ? t[f] = [] : e).push({
                        featureIndex: n,
                        feature: g,
                        intersectionZ: _
                      });
                    }
                  }
                }
              }
            }
          }
          lookupSymbolFeatures(e, t, r, n, i, o, a, s) {
            var l = {},
              c = (this.loadVTLayers(), rn(i));
            for (const u of e) this.loadMatchingFeature(l, r, n, u, c, o, a, s, t);
            return l;
          }
          hasLayer(e) {
            for (const t of this.bucketLayerIDs) for (const r of t) if (e === r) return !0;
            return !1;
          }
          getId(e, t) {
            let r = e.id;
            return r = this.promoteId && (t = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[t], "boolean" == typeof (r = e.properties[t])) ? Number(r) : r;
          }
        }
        function Zc(e, r, n, i, o) {
          return V(e, (e, t) => {
            t = r instanceof _i ? r.get(t) : null;
            return t && t.evaluate ? t.evaluate(n, i, o) : t;
          });
        }
        function Xc(e) {
          let t = 1 / 0,
            r = 1 / 0,
            n = -1 / 0,
            i = -1 / 0;
          for (const o of e) t = Math.min(t, o.x), r = Math.min(r, o.y), n = Math.max(n, o.x), i = Math.max(i, o.y);
          return {
            minX: t,
            minY: r,
            maxX: n,
            maxY: i
          };
        }
        function Jc(e, t) {
          return t - e;
        }
        function Qc(t, i, o, a, s) {
          var l = [];
          for (let e = 0; e < t.length; e++) {
            var c = t[e];
            let n;
            for (let r = 0; r < c.length - 1; r++) {
              let e = c[r],
                t = c[r + 1];
              e.x < i && t.x < i || (e.x < i ? e = new F(i, e.y + (t.y - e.y) * ((i - e.x) / (t.x - e.x)))._round() : t.x < i && (t = new F(i, e.y + (t.y - e.y) * ((i - e.x) / (t.x - e.x)))._round()), e.y < o && t.y < o) || (e.y < o ? e = new F(e.x + (t.x - e.x) * ((o - e.y) / (t.y - e.y)), o)._round() : t.y < o && (t = new F(e.x + (t.x - e.x) * ((o - e.y) / (t.y - e.y)), o)._round()), e.x >= a && t.x >= a) || (e.x >= a ? e = new F(a, e.y + (t.y - e.y) * ((a - e.x) / (t.x - e.x)))._round() : t.x >= a && (t = new F(a, e.y + (t.y - e.y) * ((a - e.x) / (t.x - e.x)))._round()), e.y >= s && t.y >= s) || (e.y >= s ? e = new F(e.x + (t.x - e.x) * ((s - e.y) / (t.y - e.y)), s)._round() : t.y >= s && (t = new F(e.x + (t.x - e.x) * ((s - e.y) / (t.y - e.y)), s)._round()), n && e.equals(n[n.length - 1]) || (n = [e], l.push(n)), n.push(t));
            }
          }
          return l;
        }
        r("FeatureIndex", Wc, {
          omit: ["rawTileData", "sourceLayerCoder"]
        });
        class eu extends F {
          constructor(e, t, r, n) {
            super(e, t), this.angle = r, void 0 !== n && (this.segment = n);
          }
          clone() {
            return new eu(this.x, this.y, this.angle, this.segment);
          }
        }
        function tu(i, o, a, s, l) {
          if (void 0 !== o.segment && 0 !== a) {
            let e = o,
              t = o.segment + 1,
              r = 0;
            for (; r > -a / 2;) {
              if (--t < 0) return;
              r -= i[t].dist(e), e = i[t];
            }
            r += i[t].dist(i[t + 1]), t++;
            var c = [];
            let n = 0;
            for (; r < a / 2;) {
              var u = i[t - 1],
                h = i[t],
                d = i[t + 1];
              if (!d) return;
              u = u.angleTo(h) - h.angleTo(d), u = Math.abs((u + 3 * Math.PI) % (2 * Math.PI) - Math.PI);
              for (c.push({
                distance: r,
                angleDelta: u
              }), n += u; r - c[0].distance > s;) n -= c.shift().angleDelta;
              if (n > l) return;
              t++, r += h.dist(d);
            }
          }
          return 1;
        }
        function ru(t) {
          let r = 0;
          for (let e = 0; e < t.length - 1; e++) r += t[e].dist(t[e + 1]);
          return r;
        }
        function nu(e, t, r) {
          return e ? .6 * t * r : 0;
        }
        function iu(e, t) {
          return Math.max(e ? e.right - e.left : 0, t ? t.right - t.left : 0);
        }
        function ou(e, t, r, n, i, o, a, s, l) {
          var c = nu(n, o, a),
            n = iu(n, i),
            i = n * a,
            u = 0 === e[0].x || e[0].x === l || 0 === e[0].y || e[0].y === l,
            o = (t - i < t / 4 && (t = i + t / 4), 2 * o);
          return function e(t, r, n, i, o, a, s, l, c) {
            const u = a / 2;
            const h = ru(t);
            let d = 0,
              p = r - n;
            let f = [];
            for (let e = 0; e < t.length - 1; e++) {
              const _ = t[e],
                m = t[e + 1],
                g = _.dist(m),
                y = m.angleTo(_);
              for (; p + n < d + g;) {
                const v = ((p += n) - d) / g,
                  E = _r.number(_.x, m.x, v),
                  b = _r.number(_.y, m.y, v);
                if (0 <= E && E < c && 0 <= b && b < c && 0 <= p - u && p + u <= h) {
                  const w = new eu(E, b, y, e);
                  w._round(), i && !tu(t, w, a, i, o) || f.push(w);
                }
              }
              d += g;
            }
            l || f.length || s || (f = e(t, d / 2, n, i, o, a, s, !0, c));
            return f;
          }(e, u ? t / 2 * s % t : (n / 2 + o) * a * s % t, t, c, r, i, u, !1, l);
        }
        r("Anchor", eu);
        const au = ie;
        function su(e, p, f, t) {
          var r = [];
          const _ = e.image,
            m = _.pixelRatio;
          var n = _.paddedRect.w - 2 * au,
            i = _.paddedRect.h - 2 * au;
          let o = {
            x1: e.left,
            y1: e.top,
            x2: e.right,
            y2: e.bottom
          };
          var a = _.stretchX || [[0, n]],
            s = _.stretchY || [[0, i]],
            l = (e, t) => e + t[1] - t[0];
          const g = a.reduce(l, 0),
            y = s.reduce(l, 0);
          var c,
            u,
            h,
            l = n - g,
            d = i - y;
          let v = 0,
            E = g,
            b = 0,
            w = y,
            T = 0,
            S = l,
            x = 0,
            C = d;
          _.content && t && (u = (c = _.content)[2] - c[0], h = c[3] - c[1], _.contentMatch && _.content && (o = Jl(e)), v = lu(a, 0, c[0]), b = lu(s, 0, c[1]), E = lu(a, c[0], c[2]), w = lu(s, c[1], c[3]), T = c[0] - v, x = c[1] - b, S = u - E, C = h - w);
          const A = o.x1,
            I = o.y1,
            N = o.x2 - A,
            P = o.y2 - I;
          var D = (e, t, r, n) => {
            var i = (e.stretch - v) / E * N + A,
              o = e.fixed - T - S * e.stretch / g,
              a = (t.stretch - b) / w * P + I,
              s = t.fixed - x - C * t.stretch / y,
              l = (r.stretch - v) / E * N + A,
              c = r.fixed - T - S * r.stretch / g,
              u = (n.stretch - b) / w * P + I,
              h = n.fixed - x - C * n.stretch / y,
              d = new F(i, a),
              a = new F(l, a),
              l = new F(l, u),
              i = new F(i, u),
              u = new F(o / m, s / m),
              o = new F(c / m, h / m),
              s = p * Math.PI / 180,
              c = (s && (c = Math.sin(s), h = Math.cos(s), d._matMult(s = [h, -c, c, h]), a._matMult(s), i._matMult(s), l._matMult(s)), e.stretch + e.fixed),
              h = r.stretch + r.fixed,
              s = t.stretch + t.fixed,
              e = n.stretch + n.fixed;
            return {
              tl: d,
              tr: a,
              bl: i,
              br: l,
              tex: {
                x: _.paddedRect.x + au + c,
                y: _.paddedRect.y + au + s,
                w: h - c,
                h: e - s
              },
              writingMode: void 0,
              glyphOffset: [0, 0],
              sectionIndex: 0,
              pixelOffsetTL: u,
              pixelOffsetBR: o,
              minFontScaleX: S / m / N,
              minFontScaleY: C / m / P,
              isSDF: f
            };
          };
          if (t && (_.stretchX || _.stretchY)) {
            var R = cu(a, l, g),
              O = cu(s, d, y);
            for (let e = 0; e < R.length - 1; e++) {
              var M = R[e],
                k = R[e + 1];
              for (let e = 0; e < O.length - 1; e++) {
                var L = O[e],
                  U = O[e + 1];
                r.push(D(M, L, k, U));
              }
            }
          } else r.push(D({
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: 1 + n
          }, {
            fixed: 0,
            stretch: 1 + i
          }));
          return r;
        }
        function lu(e, t, r) {
          let n = 0;
          for (const i of e) n += Math.max(t, Math.min(r, i[1])) - Math.max(t, Math.min(r, i[0]));
          return n;
        }
        function cu(e, t, r) {
          var n,
            i,
            o = [{
              fixed: -au,
              stretch: 0
            }];
          for ([n, i] of e) {
            var a = o[o.length - 1];
            o.push({
              fixed: n - a.stretch,
              stretch: a.stretch
            }), o.push({
              fixed: n - a.stretch,
              stretch: a.stretch + (i - n)
            });
          }
          return o.push({
            fixed: t + au,
            stretch: r
          }), o;
        }
        function uu(e, a, s, t, l, r, c, u) {
          var h = t.layout.get("text-rotate").evaluate(r, {}) * Math.PI / 180,
            d = [];
          for (const S of a.positionedLines) for (const x of S.positionedGlyphs) if (x.rect) {
            var p = x.rect || {};
            let e = Ul + 1,
              t = !0,
              r = 1,
              n = 0;
            var f,
              _ = (l || u) && x.vertical,
              m = x.metrics.advance * x.scale / 2,
              g = (u && a.verticalizable && (g = (x.scale - 1) * pe, f = (pe - x.metrics.width * x.scale) / 2, n = S.lineOffset / 2 - (x.imageName ? -f : g)), x.imageName && (f = c[x.imageName], t = f.sdf, r = f.pixelRatio, e = ie / r), l ? [x.x + m, x.y] : [0, 0]);
            let i = l ? [0, 0] : [x.x + m + s[0], x.y + s[1] - n],
              o = [0, 0];
            _ && (o = i, i = [0, 0]);
            var y = x.metrics.isDoubleResolution ? 2 : 1,
              v = (x.metrics.left - e) * x.scale - m + i[0],
              E = (-x.metrics.top - e) * x.scale + i[1],
              b = v + p.w / y * x.scale / r,
              y = E + p.h / y * x.scale / r,
              w = new F(v, E),
              E = new F(b, E),
              v = new F(v, y),
              b = new F(b, y),
              T = (_ && (y = new F(-m, m - zl), _ = -Math.PI / 2, m = pe / 2 - m, T = x.imageName ? m : 0, m = new F(5 - zl - m, -T), T = new F(...o), w._rotateAround(_, y)._add(m)._add(T), E._rotateAround(_, y)._add(m)._add(T), v._rotateAround(_, y)._add(m)._add(T), b._rotateAround(_, y)._add(m)._add(T)), h && (_ = Math.sin(h), y = Math.cos(h), w._matMult(m = [y, -_, _, y]), E._matMult(m), v._matMult(m), b._matMult(m)), new F(0, 0)),
              _ = new F(0, 0);
            d.push({
              tl: w,
              tr: E,
              bl: v,
              br: b,
              tex: p,
              writingMode: a.writingMode,
              glyphOffset: g,
              sectionIndex: x.sectionIndex,
              isSDF: t,
              pixelOffsetTL: T,
              pixelOffsetBR: _,
              minFontScaleX: 0,
              minFontScaleY: 0
            });
          }
          return d;
        }
        class hu {
          constructor(e, t, r, n, i, o, a, s, l, c) {
            if (this.boxStartIndex = e.length, l) {
              let e = o.top,
                t = o.bottom;
              var l = o.collisionPadding,
                l = (l && (e -= l[1], t += l[3]), t - e);
              0 < l && (l = Math.max(10, l), this.circleDiameter = l);
            } else {
              var u,
                l = null != (l = o.image) && l.contentMatch && o.image.content ? Jl(o) : {
                  x1: o.left,
                  y1: o.top,
                  x2: o.right,
                  y2: o.bottom
                },
                s = (l.y1 = l.y1 * a - s[0], l.x2 = l.x2 * a + s[1], l.y2 = l.y2 * a + s[2], l.x1 = l.x1 * a - s[3], o.collisionPadding);
              s && (l.x1 -= s[0] * a, l.y1 -= s[1] * a, l.x2 += s[2] * a, l.y2 += s[3] * a), c && (o = new F(l.x1, l.y1), s = new F(l.x2, l.y1), a = new F(l.x1, l.y2), u = new F(l.x2, l.y2), c = c * Math.PI / 180, o._rotate(c), s._rotate(c), a._rotate(c), u._rotate(c), l.x1 = Math.min(o.x, s.x, a.x, u.x), l.x2 = Math.max(o.x, s.x, a.x, u.x), l.y1 = Math.min(o.y, s.y, a.y, u.y), l.y2 = Math.max(o.y, s.y, a.y, u.y)), e.emplaceBack(t.x, t.y, l.x1, l.y1, l.x2, l.y2, r, n, i);
            }
            this.boxEndIndex = e.length;
          }
        }
        class du {
          constructor(e = [], t = pu) {
            if (this.data = e, this.length = this.data.length, this.compare = t, 0 < this.length) for (let e = (this.length >> 1) - 1; 0 <= e; e--) this._down(e);
          }
          push(e) {
            this.data.push(e), this.length++, this._up(this.length - 1);
          }
          pop() {
            var e, t;
            if (0 !== this.length) return e = this.data[0], t = this.data.pop(), this.length--, 0 < this.length && (this.data[0] = t, this._down(0)), e;
          }
          peek() {
            return this.data[0];
          }
          _up(e) {
            for (var {
                data: t,
                compare: r
              } = this, n = t[e]; 0 < e;) {
              var i = e - 1 >> 1,
                o = t[i];
              if (0 <= r(n, o)) break;
              t[e] = o, e = i;
            }
            t[e] = n;
          }
          _down(r) {
            for (var {
                data: n,
                compare: i
              } = this, e = this.length >> 1, o = n[r]; r < e;) {
              let e = 1 + (r << 1),
                t = n[e];
              var a = e + 1;
              if (a < this.length && i(n[a], t) < 0 && (e = a, t = n[a]), 0 <= i(t, o)) break;
              n[r] = t, r = e;
            }
            n[r] = o;
          }
        }
        function pu(e, t) {
          return e < t ? -1 : t < e ? 1 : 0;
        }
        function fu(r, e = 1, t = !1) {
          let n = 1 / 0,
            i = 1 / 0,
            o = -1 / 0,
            a = -1 / 0;
          var s = r[0];
          for (let e = 0; e < s.length; e++) {
            var l = s[e];
            (!e || l.x < n) && (n = l.x), (!e || l.y < i) && (i = l.y), (!e || l.x > o) && (o = l.x), (!e || l.y > a) && (a = l.y);
          }
          var c = o - n,
            u = a - i,
            h = Math.min(c, u);
          let d = h / 2;
          var p = new du([], _u);
          if (0 === h) return new F(n, i);
          for (let t = n; t < o; t += h) for (let e = i; e < a; e += h) p.push(new mu(t + d, e + d, d, r));
          let f = function (e) {
              let n = 0,
                i = 0,
                o = 0;
              var a = e[0];
              for (let e = 0, t = a.length, r = t - 1; e < t; r = e++) {
                var s = a[e],
                  l = a[r],
                  c = s.x * l.y - l.x * s.y;
                i += (s.x + l.x) * c, o += (s.y + l.y) * c, n += 3 * c;
              }
              return new mu(i / n, o / n, 0, e);
            }(r),
            _ = p.length;
          for (; p.length;) {
            var m = p.pop();
            (m.d > f.d || !f.d) && (f = m, t) && console.log("found best %d after %d probes", Math.round(1e4 * m.d) / 1e4, _), m.max - f.d <= e || (d = m.h / 2, p.push(new mu(m.p.x - d, m.p.y - d, d, r)), p.push(new mu(m.p.x + d, m.p.y - d, d, r)), p.push(new mu(m.p.x - d, m.p.y + d, d, r)), p.push(new mu(m.p.x + d, m.p.y + d, d, r)), _ += 4);
          }
          return t && (console.log("num probes: " + _), console.log("best distance: " + f.d)), f.p;
        }
        function _u(e, t) {
          return t.max - e.max;
        }
        function mu(e, t, r, n) {
          this.p = new F(e, t), this.h = r, this.d = function (n, t) {
            let i = !1,
              o = 1 / 0;
            for (let e = 0; e < t.length; e++) {
              var a = t[e];
              for (let e = 0, t = a.length, r = t - 1; e < t; r = e++) {
                var s = a[e],
                  l = a[r];
                s.y > n.y != l.y > n.y && n.x < (l.x - s.x) * (n.y - s.y) / (l.y - s.y) + s.x && (i = !i), o = Math.min(o, ta(n, s, l));
              }
            }
            return (i ? 1 : -1) * Math.sqrt(o);
          }(this.p, n), this.max = this.d + this.h * Math.SQRT2;
        }
        ue.TextAnchorEnum = void 0, (t = ue.TextAnchorEnum || (ue.TextAnchorEnum = {}))[t.center = 1] = "center", t[t.left = 2] = "left", t[t.right = 3] = "right", t[t.top = 4] = "top", t[t.bottom = 5] = "bottom", t[t["top-left"] = 6] = "top-left", t[t["top-right"] = 7] = "top-right", t[t["bottom-left"] = 8] = "bottom-left", t[t["bottom-right"] = 9] = "bottom-right";
        const gu = 7,
          yu = Number.POSITIVE_INFINITY;
        function vu(r, n) {
          if (n[1] !== yu) {
            var i = r,
              o = n[0],
              a = n[1];
            let e = 0,
              t = 0;
            switch (o = Math.abs(o), a = Math.abs(a), i) {
              case "top-right":
              case "top-left":
              case "top":
                t = a - gu;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                t = -a + gu;
            }
            switch (i) {
              case "top-right":
              case "bottom-right":
              case "right":
                e = -o;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                e = o;
            }
            return [e, t];
          }
          {
            var i = r,
              s = n[0];
            let e = 0,
              t = 0;
            var l = (s = s < 0 ? 0 : s) / Math.SQRT2;
            switch (i) {
              case "top-right":
              case "top-left":
                t = l - gu;
                break;
              case "bottom-right":
              case "bottom-left":
                t = -l + gu;
                break;
              case "bottom":
                t = -s + gu;
                break;
              case "top":
                t = s - gu;
            }
            switch (i) {
              case "top-right":
              case "bottom-right":
                e = -l;
                break;
              case "top-left":
              case "bottom-left":
                e = l;
                break;
              case "left":
                e = s;
                break;
              case "right":
                e = -s;
            }
            return [e, t];
          }
        }
        function Eu(t, r, n) {
          var i = t.layout,
            o = null == (o = i.get("text-variable-anchor-offset")) ? void 0 : o.evaluate(r, {}, n);
          if (o) {
            var a = o.values,
              s = [];
            for (let e = 0; e < a.length; e += 2) {
              var l = s[e] = a[e],
                c = a[e + 1].map(e => e * pe);
              l.startsWith("top") ? c[1] -= gu : l.startsWith("bottom") && (c[1] += gu), s[e + 1] = c;
            }
            return new It(s);
          }
          o = i.get("text-variable-anchor");
          if (o) {
            let e;
            var t = t._unevaluatedLayout,
              u = (e = void 0 !== t.getValue("text-radial-offset") ? [i.get("text-radial-offset").evaluate(r, {}, n) * pe, yu] : i.get("text-offset").evaluate(r, {}, n).map(e => e * pe), []);
            for (const h of o) u.push(h, vu(h, e));
            return new It(u);
          }
          return null;
        }
        function bu(e) {
          switch (e) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function wu(e, t, r, n, i, o, a, s, l, c, u, h, d, p, f) {
          r = uu(0, r, s, i, o, a, n, e.allowVerticalPlacement), n = e.textSizeData;
          let _ = null;
          "source" === n.kind ? (_ = [tc * i.layout.get("text-size").evaluate(a, {})])[0] > rc && he(`${e.layerIds[0]}: Value for "text-size" is >= ${ec}. Reduce your "text-size".`) : "composite" === n.kind && ((_ = [tc * p.compositeTextSizes[0].evaluate(a, {}, f), tc * p.compositeTextSizes[1].evaluate(a, {}, f)])[0] > rc || _[1] > rc) && he(`${e.layerIds[0]}: Value for "text-size" is >= ${ec}. Reduce your "text-size".`), e.addSymbols(e.text, r, _, s, o, a, c, t, l.lineStartIndex, l.lineLength, d, f);
          for (const m of u) h[m] = e.text.placedSymbolArray.length - 1;
          return 4 * r.length;
        }
        function Tu(e) {
          for (const t in e) return e[t];
          return null;
        }
        const Su = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        function xu(e, t, r, n, i, o) {
          var a;
          i - n <= r || (function r(n, i, o, a, s, l) {
            for (; a < s;) {
              if (600 < s - a) {
                const u = s - a + 1,
                  h = o - a + 1,
                  d = Math.log(u),
                  p = .5 * Math.exp(2 * d / 3),
                  f = .5 * Math.sqrt(d * p * (u - p) / u) * (h - u / 2 < 0 ? -1 : 1),
                  _ = Math.max(a, Math.floor(o - h * p / u + f)),
                  m = Math.min(s, Math.floor(o + (u - h) * p / u + f));
                r(n, i, o, _, m, l);
              }
              const c = i[2 * o + l];
              let e = a,
                t = s;
              for (Cu(n, i, a, o), i[2 * s + l] > c && Cu(n, i, a, s); e < t;) {
                for (Cu(n, i, e, t), e++, t--; i[2 * e + l] < c;) e++;
                for (; i[2 * t + l] > c;) t--;
              }
              i[2 * a + l] === c ? Cu(n, i, a, t) : (t++, Cu(n, i, t, s)), t <= o && (a = t + 1), o <= t && (s = t - 1);
            }
          }(e, t, a = n + i >> 1, n, i, o), xu(e, t, r, n, a - 1, 1 - o), xu(e, t, r, 1 + a, i, 1 - o));
        }
        function Cu(e, t, r, n) {
          Au(e, r, n), Au(t, 2 * r, 2 * n), Au(t, 2 * r + 1, 2 * n + 1);
        }
        function Au(e, t, r) {
          var n = e[t];
          e[t] = e[r], e[r] = n;
        }
        function Iu(e, t, r, n) {
          e -= r, r = t - n;
          return e * e + r * r;
        }
        ue.PerformanceMarkers = void 0, (e = ue.PerformanceMarkers || (ue.PerformanceMarkers = {})).create = "create", e.load = "load", e.fullLoad = "fullLoad";
        let Nu = null,
          Pu = [];
        const Du = 1e3 / 60,
          Ru = "loadTime",
          Ou = "fullLoadTime";
        t = {
          mark(e) {
            performance.mark(e);
          },
          frame(e) {
            var t;
            null != Nu && (t = e - Nu, Pu.push(t)), Nu = e;
          },
          clearMetrics() {
            Nu = null, Pu = [], performance.clearMeasures(Ru), performance.clearMeasures(Ou);
            for (const e in ue.PerformanceMarkers) performance.clearMarks(ue.PerformanceMarkers[e]);
          },
          getPerformanceMetrics() {
            performance.measure(Ru, ue.PerformanceMarkers.create, ue.PerformanceMarkers.load), performance.measure(Ou, ue.PerformanceMarkers.create, ue.PerformanceMarkers.fullLoad);
            var e = performance.getEntriesByName(Ru)[0].duration,
              t = performance.getEntriesByName(Ou)[0].duration,
              r = Pu.length,
              n = 1 / (Pu.reduce((e, t) => e + t, 0) / r / 1e3),
              i = Pu.filter(e => e > Du).reduce((e, t) => e + (t - Du) / Du, 0);
            return {
              loadTime: e,
              fullLoadTime: t,
              fps: n,
              percentDroppedFrames: i / (r + i) * 100,
              totalFrames: r
            };
          }
        };
        ue.AJAXError = ge, ue.Actor = class {
          constructor(e, t, r) {
            this.receive = e => {
              var t,
                e = e.data,
                r = e.id;
              !r || e.targetMapId && this.mapId !== e.targetMapId || ("<cancel>" === e.type ? (delete this.tasks[r], t = this.cancelCallbacks[r], delete this.cancelCallbacks[r], t && t()) : Q() || e.mustQueue ? (this.tasks[r] = e, this.taskQueue.push(r), this.invoker.trigger()) : this.processTask(r, e));
            }, this.process = () => {
              var e, t;
              this.taskQueue.length && (e = this.taskQueue.shift(), t = this.tasks[e], delete this.tasks[e], this.taskQueue.length && this.invoker.trigger(), t) && this.processTask(e, t);
            }, this.target = e, this.parent = t, this.mapId = r, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, this.invoker = new Cc(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = Q() ? e : window;
          }
          send(e, t, r, n, i = !1) {
            const o = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            r && (this.callbacks[o] = r);
            var a = [],
              e = {
                id: o,
                type: e,
                hasCallback: !!r,
                targetMapId: n,
                mustQueue: i,
                sourceMapId: this.mapId,
                data: jn(t, a)
              };
            return this.target.postMessage(e, {
              transfer: a
            }), {
              cancel: () => {
                r && delete this.callbacks[o];
                var e = {
                  id: o,
                  type: "<cancel>",
                  targetMapId: n,
                  sourceMapId: this.mapId
                };
                this.target.postMessage(e);
              }
            };
          }
          processTask(n, t) {
            if ("<response>" === t.type) {
              var i = this.callbacks[n];
              delete this.callbacks[n], i && (t.error ? i(Gn(t.error)) : i(null, Gn(t.data)));
            } else {
              let r = !1;
              const l = [];
              i = t.hasCallback ? (e, t) => {
                r = !0, delete this.cancelCallbacks[n];
                e = {
                  id: n,
                  type: "<response>",
                  sourceMapId: this.mapId,
                  error: e ? jn(e) : null,
                  data: jn(t, l)
                };
                this.target.postMessage(e, {
                  transfer: l
                });
              } : e => {
                r = !0;
              };
              let e = null;
              var o,
                a,
                s = Gn(t.data);
              this.parent[t.type] ? e = this.parent[t.type](t.sourceMapId, s, i) : "getWorkerSource" in this.parent ? (o = t.type.split("."), a = this.parent.getWorkerSource(t.sourceMapId, o[0], s.source), e = a[o[1]](s, i)) : i(new Error("Could not find function " + t.type)), !r && e && e.cancel && (this.cancelCallbacks[n] = e.cancel);
            }
          }
          remove() {
            this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1);
          }
        }, ue.AlphaImage = La, ue.CanonicalTileID = zc, ue.CollisionBoxArray = Ki, ue.CollisionCircleLayoutArray = class extends Li {}, ue.Color = g, ue.DEMData = qc, ue.DataConstantProperty = i, ue.DictionaryCoder = Vc, ue.EXTENT = de, ue.ErrorEvent = Ie, ue.EvaluationParameters = N, ue.Event = Ae, ue.Evented = Ne, ue.FeatureIndex = Wc, ue.FillBucket = _s, ue.FillExtrusionBucket = Ms, ue.GeoJSONFeature = Kc, ue.ImageAtlas = $l, ue.ImagePosition = Bl, ue.KDBush = class ju {
          static from(e) {
            if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            var t,
              [r, n] = new Uint8Array(e, 0, 2);
            if (219 !== r) throw new Error("Data does not appear to be in a KDBush format.");
            if (1 != (r = n >> 4)) throw new Error(`Got v${r} data when expected v1.`);
            if (r = Su[15 & n]) return [n] = new Uint16Array(e, 2, 1), [t] = new Uint32Array(e, 4, 1), new ju(t, n, r, e);
            throw new Error("Unrecognized array type.");
          }
          constructor(e, t = 64, r = Float64Array, n) {
            if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`);
            this.numItems = +e, this.nodeSize = Math.min(Math.max(+t, 2), 65535), this.ArrayType = r, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
            var i = Su.indexOf(this.ArrayType),
              o = 2 * e * this.ArrayType.BYTES_PER_ELEMENT,
              a = e * this.IndexArrayType.BYTES_PER_ELEMENT,
              s = (8 - a % 8) % 8;
            if (i < 0) throw new Error(`Unexpected typed array class: ${r}.`);
            n && n instanceof ArrayBuffer ? (this.data = n, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + a + s, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + o + a + s), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + a + s, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + i]), new Uint16Array(this.data, 2, 1)[0] = t, new Uint32Array(this.data, 4, 1)[0] = e);
          }
          add(e, t) {
            var r = this._pos >> 1;
            return this.ids[r] = r, this.coords[this._pos++] = e, this.coords[this._pos++] = t, r;
          }
          finish() {
            var e = this._pos >> 1;
            if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`);
            return xu(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
          }
          range(t, r, n, i) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            for (var {
                ids: o,
                coords: a,
                nodeSize: e
              } = this, s = [0, o.length - 1, 0], l = []; s.length;) {
              var c = s.pop() || 0,
                u = s.pop() || 0,
                h = s.pop() || 0;
              if (u - h <= e) for (let e = h; e <= u; e++) {
                var d = a[2 * e],
                  p = a[2 * e + 1];
                t <= d && d <= n && r <= p && p <= i && l.push(o[e]);
              } else {
                var f = h + u >> 1,
                  _ = a[2 * f],
                  m = a[2 * f + 1];
                t <= _ && _ <= n && r <= m && m <= i && l.push(o[f]), (0 === c ? t <= _ : r <= m) && (s.push(h), s.push(f - 1), s.push(1 - c)), (0 === c ? _ <= n : m <= i) && (s.push(1 + f), s.push(u), s.push(1 - c));
              }
            }
            return l;
          }
          within(t, r, e) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            for (var {
                ids: n,
                coords: i,
                nodeSize: o
              } = this, a = [0, n.length - 1, 0], s = [], l = e * e; a.length;) {
              var c = a.pop() || 0,
                u = a.pop() || 0,
                h = a.pop() || 0;
              if (u - h <= o) for (let e = h; e <= u; e++) Iu(i[2 * e], i[2 * e + 1], t, r) <= l && s.push(n[e]);else {
                var d = h + u >> 1,
                  p = i[2 * d],
                  f = i[2 * d + 1];
                Iu(p, f, t, r) <= l && s.push(n[d]), (0 === c ? t - e <= p : r - e <= f) && (a.push(h), a.push(d - 1), a.push(1 - c)), (0 === c ? p <= t + e : f <= r + e) && (a.push(1 + d), a.push(u), a.push(1 - c));
              }
            }
            return s;
          }
        }, ue.LineBucket = Zs, ue.LineStripIndexArray = class extends Gi {}, ue.LngLat = Ic, ue.MercatorCoordinate = Fc, ue.ONE_EM = pe, ue.OverscaledTileID = Hc, ue.PerformanceUtils = t, ue.Point = F, ue.Pos3dArray = class extends xi {}, ue.PosArray = oo, ue.Properties = l, ue.Protobuf = Rl, ue.QuadTriangleArray = class extends Fi {}, ue.RGBAImage = Ua, ue.RasterBoundsArray = class extends Ci {}, ue.RequestPerformance = class {
          constructor(e) {
            this._marks = {
              start: [e.url, "start"].join("#"),
              end: [e.url, "end"].join("#"),
              measure: e.url.toString()
            }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let e = performance.getEntriesByName(this._marks.measure);
            return 0 === e.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), e = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), e;
          }
        }, ue.SegmentVector = T, ue.SymbolBucket = dc, ue.Transitionable = ui, ue.TriangleIndexArray = yo, ue.Uniform1f = No, ue.Uniform1i = class extends Io {
          constructor(e, t) {
            super(e, t), this.current = 0;
          }
          set(e) {
            this.current !== e && (this.current = e, this.gl.uniform1i(this.location, e));
          }
        }, ue.Uniform2f = class extends Io {
          constructor(e, t) {
            super(e, t), this.current = [0, 0];
          }
          set(e) {
            e[0] === this.current[0] && e[1] === this.current[1] || (this.current = e, this.gl.uniform2f(this.location, e[0], e[1]));
          }
        }, ue.Uniform3f = class extends Io {
          constructor(e, t) {
            super(e, t), this.current = [0, 0, 0];
          }
          set(e) {
            e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2] || (this.current = e, this.gl.uniform3f(this.location, e[0], e[1], e[2]));
          }
        }, ue.Uniform4f = Po, ue.UniformColor = Do, ue.UniformMatrix4f = class extends Io {
          constructor(e, t) {
            super(e, t), this.current = Ro;
          }
          set(t) {
            if (t[12] !== this.current[12] || t[0] !== this.current[0]) this.current = t, this.gl.uniformMatrix4fv(this.location, !1, t);else for (let e = 1; e < 16; e++) if (t[e] !== this.current[e]) {
              this.current = t, this.gl.uniformMatrix4fv(this.location, !1, t);
              break;
            }
          }
        }, ue.UnwrappedTileID = Yc, ue.ValidationError = p, ue.ZoomHistory = qn, ue.__awaiter = A, ue.add = function (e, t, r) {
          return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e;
        }, ue.addDynamicAttributes = lc, ue.arrayBufferToImage = function (e, t) {
          const r = new Image();
          r.onload = () => {
            t(null, r), URL.revokeObjectURL(r.src), r.onload = null, window.requestAnimationFrame(() => {
              r.src = re;
            });
          }, r.onerror = () => t(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          var n = new Blob([new Uint8Array(e)], {
            type: "image/png"
          });
          r.src = e.byteLength ? URL.createObjectURL(n) : re;
        }, ue.arrayBufferToImageBitmap = function (e, t) {
          e = new Blob([new Uint8Array(e)], {
            type: "image/png"
          }), createImageBitmap(e).then(e => {
            t(null, e);
          }).catch(e => {
            t(new Error(`Could not load image because of ${e.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
          });
        }, ue.asyncAll = function (e, t, n) {
          if (!e.length) return n(null, []);
          let i = e.length;
          const o = new Array(e.length);
          let a = null;
          e.forEach((e, r) => {
            t(e, (e, t) => {
              e && (a = e), o[r] = t, 0 == --i && n(a, o);
            });
          });
        }, ue.bezier = Y, ue.browser = _e, ue.clamp = H, ue.clipLine = Qc, ue.clone = function (e) {
          var t = new S(16);
          return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
        }, ue.clone$1 = W, ue.clone$2 = function (e) {
          var t = new S(3);
          return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;
        }, ue.collisionCircleLayout = xr, ue.config = me, ue.copy = function (e, t) {
          return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
        }, ue.create = function () {
          var e = new S(16);
          return S != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0), e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e;
        }, ue.create$1 = da, ue.create$2 = function () {
          var e = new S(4);
          return S != Float32Array && (e[1] = 0, e[2] = 0), e[0] = 1, e[3] = 1, e;
        }, ue.createExpression = qr, ue.createFilter = rn, ue.createLayout = w, ue.createStyleLayer = function (e) {
          if ("custom" === e.type) return new xc(e);
          switch (e.type) {
            case "background":
              return new bc(e);
            case "circle":
              return new Aa(e);
            case "fill":
              return new vs(e);
            case "fill-extrusion":
              return new Bs(e);
            case "heatmap":
              return new Ba(e);
            case "hillshade":
              return new Ya(e);
            case "line":
              return new rl(e);
            case "raster":
              return new Sc(e);
            case "symbol":
              return new yc(e);
          }
        }, ue.cross = ba, ue.deepEqual = function t(r, n) {
          if (Array.isArray(r)) {
            if (!Array.isArray(n) || r.length !== n.length) return !1;
            for (let e = 0; e < r.length; e++) if (!t(r[e], n[e])) return !1;
          } else {
            if ("object" != typeof r || null === r || null === n) return r === n;
            if ("object" != typeof n) return !1;
            if (Object.keys(r).length !== Object.keys(n).length) return !1;
            for (const e in r) if (!t(r[e], n[e])) return !1;
          }
          return !0;
        }, ue.defaultEasing = O, ue.derefLayers = function (t) {
          t = t.slice();
          var r = Object.create(null);
          for (let e = 0; e < t.length; e++) r[t[e].id] = t[e];
          for (let e = 0; e < t.length; e++) "ref" in t[e] && (t[e] = function (e, t) {
            const r = {};
            for (const n in e) "ref" !== n && (r[n] = e[n]);
            return Pe.forEach(e => {
              e in t && (r[e] = t[e]);
            }), r;
          }(t[e], r[t[e].ref]));
          return t;
        }, ue.diffStyles = function (e, s) {
          if (!e) return [{
            command: E.setStyle,
            args: [s]
          }];
          let l = [];
          try {
            if (!v(e.version, s.version)) return [{
              command: E.setStyle,
              args: [s]
            }];
            v(e.center, s.center) || l.push({
              command: E.setCenter,
              args: [s.center]
            }), v(e.zoom, s.zoom) || l.push({
              command: E.setZoom,
              args: [s.zoom]
            }), v(e.bearing, s.bearing) || l.push({
              command: E.setBearing,
              args: [s.bearing]
            }), v(e.pitch, s.pitch) || l.push({
              command: E.setPitch,
              args: [s.pitch]
            }), v(e.sprite, s.sprite) || l.push({
              command: E.setSprite,
              args: [s.sprite]
            }), v(e.glyphs, s.glyphs) || l.push({
              command: E.setGlyphs,
              args: [s.glyphs]
            }), v(e.transition, s.transition) || l.push({
              command: E.setTransition,
              args: [s.transition]
            }), v(e.light, s.light) || l.push({
              command: E.setLight,
              args: [s.light]
            });
            const r = {};
            var t = [];
            Oe(e.sources, s.sources, t, r);
            const y = [];
            e.layers && e.layers.forEach(e => {
              r[e.source] ? l.push({
                command: E.removeLayer,
                args: [e.id]
              }) : y.push(e);
            }), l = l.concat(t);
            {
              var c = y;
              var u = s.layers;
              var h = l;
              u = u || [];
              var d = (c = c || []).map(ke),
                p = u.map(ke),
                f = c.reduce(Le, {}),
                _ = u.reduce(Le, {}),
                m = d.slice(),
                g = Object.create(null);
              let e, t, r, n, i, o, a;
              for (e = 0, t = 0; e < d.length; e++) r = d[e], Object.prototype.hasOwnProperty.call(_, r) ? t++ : (h.push({
                command: E.removeLayer,
                args: [r]
              }), m.splice(m.indexOf(r, t), 1));
              for (e = 0, t = 0; e < p.length; e++) r = p[p.length - 1 - e], m[m.length - 1 - e] !== r && (Object.prototype.hasOwnProperty.call(f, r) ? (h.push({
                command: E.removeLayer,
                args: [r]
              }), m.splice(m.lastIndexOf(r, m.length - t), 1)) : t++, o = m[m.length - e], h.push({
                command: E.addLayer,
                args: [_[r], o]
              }), m.splice(m.length - e, 0, r), g[r] = !0);
              for (e = 0; e < p.length; e++) if (n = f[r = p[e]], i = _[r], !g[r] && !v(n, i)) if (v(n.source, i.source) && v(n["source-layer"], i["source-layer"]) && v(n.type, i.type)) {
                for (a in Me(n.layout, i.layout, h, r, null, E.setLayoutProperty), Me(n.paint, i.paint, h, r, null, E.setPaintProperty), v(n.filter, i.filter) || h.push({
                  command: E.setFilter,
                  args: [r, i.filter]
                }), v(n.minzoom, i.minzoom) && v(n.maxzoom, i.maxzoom) || h.push({
                  command: E.setLayerZoomRange,
                  args: [r, i.minzoom, i.maxzoom]
                }), n) Object.prototype.hasOwnProperty.call(n, a) && "layout" !== a && "paint" !== a && "filter" !== a && "metadata" !== a && "minzoom" !== a && "maxzoom" !== a && (0 === a.indexOf("paint.") ? Me(n[a], i[a], h, r, a.slice(6), E.setPaintProperty) : v(n[a], i[a]) || h.push({
                  command: E.setLayerProperty,
                  args: [r, a, i[a]]
                }));
                for (a in i) Object.prototype.hasOwnProperty.call(i, a) && !Object.prototype.hasOwnProperty.call(n, a) && "layout" !== a && "paint" !== a && "filter" !== a && "metadata" !== a && "minzoom" !== a && "maxzoom" !== a && (0 === a.indexOf("paint.") ? Me(n[a], i[a], h, r, a.slice(6), E.setPaintProperty) : v(n[a], i[a]) || h.push({
                  command: E.setLayerProperty,
                  args: [r, a, i[a]]
                }));
              } else h.push({
                command: E.removeLayer,
                args: [r]
              }), o = m[m.lastIndexOf(r) + 1], h.push({
                command: E.addLayer,
                args: [i, o]
              });
            }
          } catch (e) {
            console.warn("Unable to compute style diff:", e), l = [{
              command: E.setStyle,
              args: [s]
            }];
          }
          return l;
        }, ue.dot = Ea, ue.dot$1 = function (e, t) {
          return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];
        }, ue.earthRadius = Ac, ue.emitValidationErrors = $n, ue.emptyStyle = function () {
          var t = {},
            r = o.$version;
          for (const i in o.$root) {
            var n = o.$root[i];
            if (n.required) {
              let e = null;
              null != (e = "version" === i ? r : "array" === n.type ? [] : {}) && (t[i] = e);
            }
          }
          return t;
        }, ue.equals = function (e, t) {
          var r = e[0],
            n = e[1],
            i = e[2],
            o = e[3],
            a = e[4],
            s = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            h = e[9],
            d = e[10],
            p = e[11],
            f = e[12],
            _ = e[13],
            m = e[14],
            e = e[15],
            g = t[0],
            y = t[1],
            v = t[2],
            E = t[3],
            b = t[4],
            w = t[5],
            T = t[6],
            S = t[7],
            x = t[8],
            C = t[9],
            A = t[10],
            I = t[11],
            N = t[12],
            P = t[13],
            D = t[14],
            t = t[15];
          return Math.abs(r - g) <= R * Math.max(1, Math.abs(r), Math.abs(g)) && Math.abs(n - y) <= R * Math.max(1, Math.abs(n), Math.abs(y)) && Math.abs(i - v) <= R * Math.max(1, Math.abs(i), Math.abs(v)) && Math.abs(o - E) <= R * Math.max(1, Math.abs(o), Math.abs(E)) && Math.abs(a - b) <= R * Math.max(1, Math.abs(a), Math.abs(b)) && Math.abs(s - w) <= R * Math.max(1, Math.abs(s), Math.abs(w)) && Math.abs(l - T) <= R * Math.max(1, Math.abs(l), Math.abs(T)) && Math.abs(c - S) <= R * Math.max(1, Math.abs(c), Math.abs(S)) && Math.abs(u - x) <= R * Math.max(1, Math.abs(u), Math.abs(x)) && Math.abs(h - C) <= R * Math.max(1, Math.abs(h), Math.abs(C)) && Math.abs(d - A) <= R * Math.max(1, Math.abs(d), Math.abs(A)) && Math.abs(p - I) <= R * Math.max(1, Math.abs(p), Math.abs(I)) && Math.abs(f - N) <= R * Math.max(1, Math.abs(f), Math.abs(N)) && Math.abs(_ - P) <= R * Math.max(1, Math.abs(_), Math.abs(P)) && Math.abs(m - D) <= R * Math.max(1, Math.abs(m), Math.abs(D)) && Math.abs(e - t) <= R * Math.max(1, Math.abs(e), Math.abs(t));
        }, ue.evaluateSizeForFeature = function (e, {
          uSize: t,
          uSizeT: r
        }, {
          lowerSize: n,
          upperSize: i
        }) {
          return "source" === e.kind ? n / tc : "composite" === e.kind ? _r.number(n / tc, i / tc, r) : t;
        }, ue.evaluateSizeForZoom = function (e, t) {
          let r = 0,
            n = 0;
          var i, o, a;
          return "constant" === e.kind ? n = e.layoutSize : "source" !== e.kind && (({
            interpolationType: a,
            minZoom: i,
            maxZoom: o
          } = e), a = a ? H(mr.interpolationFactor(a, t, i, o), 0, 1) : 0, "camera" === e.kind ? n = _r.number(e.minSize, e.maxSize, a) : r = a), {
            uSizeT: r,
            uSize: n
          };
        }, ue.evented = oi, ue.extend = G, ue.filterObject = K, ue.findLineIntersection = function (e, t, r, n) {
          var i = t.y - e.y,
            t = t.x - e.x,
            o = n.y - r.y,
            n = n.x - r.x,
            a = o * t - n * i;
          return 0 == a ? null : (n = (n * (e.y - r.y) - o * (e.x - r.x)) / a, new F(e.x + n * t, e.y + n * i));
        }, ue.fromRotation = function (e, t) {
          var r = Math.sin(t),
            t = Math.cos(t);
          return e[0] = t, e[1] = r, e[2] = 0, e[3] = -r, e[4] = t, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;
        }, ue.fromScaling = function (e, t) {
          return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
        }, ue.getAnchorAlignment = Xl, ue.getAnchorJustification = bu, ue.getArrayBuffer = Te, ue.getDefaultExportFromCjs = I, ue.getImageData = function (s, l, c, u, h) {
          return A(this, void 0, void 0, function* () {
            if ($()) try {
              return yield oe(s, l, c, u, h);
            } catch (e) {}
            return t = l, r = c, n = u, i = h, o = (e = s).width, a = e.height, ae && se || (ae = new OffscreenCanvas(o, a), se = ae.getContext("2d", {
              willReadFrequently: !0
            })), ae.width = o, ae.height = a, se.drawImage(e, 0, 0, o, a), e = se.getImageData(t, r, n, i), se.clearRect(0, 0, o, a), e.data;
            var e, t, r, n, i, o, a;
          });
        }, ue.getJSON = function (e, t) {
          return we(G(e, {
            type: "json"
          }), t);
        }, ue.getOverlapMode = ic, ue.getProtocolAction = ve, ue.getRTLTextPluginStatus = ii, ue.getReferrer = ye, ue.getVideo = function (t, e) {
          const r = window.document.createElement("video");
          r.muted = !0, r.onloadstart = function () {
            e(null, r);
          };
          for (let e = 0; e < t.length; e++) {
            var n = window.document.createElement("source");
            Se(t[e]) || (r.crossOrigin = "Anonymous"), n.src = t[e], r.appendChild(n);
          }
          return {
            cancel: () => {}
          };
        }, ue.groupByLayout = function (r, n) {
          var i = {};
          for (let t = 0; t < r.length; t++) {
            var o = n && n[r[t].id] || un(r[t]);
            n && (n[r[t].id] = o);
            let e = i[o];
            (e = e || (i[o] = [])).push(r[t]);
          }
          var e = [];
          for (const t in i) e.push(i[t]);
          return e;
        }, ue.identity = pa, ue.interpolate = _r, ue.invert = function (e, t) {
          var r = t[0],
            n = t[1],
            i = t[2],
            o = t[3],
            a = t[4],
            s = t[5],
            l = t[6],
            c = t[7],
            u = t[8],
            h = t[9],
            d = t[10],
            p = t[11],
            f = t[12],
            _ = t[13],
            m = t[14],
            t = t[15],
            g = r * s - n * a,
            y = r * l - i * a,
            v = r * c - o * a,
            E = n * l - i * s,
            b = n * c - o * s,
            w = i * c - o * l,
            T = u * _ - h * f,
            S = u * m - d * f,
            x = u * t - p * f,
            C = h * m - d * _,
            A = h * t - p * _,
            I = d * t - p * m,
            N = g * I - y * A + v * C + E * x - b * S + w * T;
          return N ? (e[0] = (s * I - l * A + c * C) * (N = 1 / N), e[1] = (i * A - n * I - o * C) * N, e[2] = (_ * w - m * b + t * E) * N, e[3] = (d * b - h * w - p * E) * N, e[4] = (l * x - a * I - c * S) * N, e[5] = (r * I - i * x + o * S) * N, e[6] = (m * v - f * w - t * y) * N, e[7] = (u * w - d * v + p * y) * N, e[8] = (a * A - s * x + c * T) * N, e[9] = (n * x - r * A - o * T) * N, e[10] = (f * b - _ * v + t * g) * N, e[11] = (h * v - u * b - p * g) * N, e[12] = (s * S - a * C - l * T) * N, e[13] = (r * C - n * S + i * T) * N, e[14] = (_ * y - f * E - m * g) * N, e[15] = (u * E - h * y + d * g) * N, e) : null;
        }, ue.isImageBitmap = te, ue.isOffscreenCanvasDistorted = $, ue.isSafari = function (e) {
          var t;
          return null == ee && (t = e.navigator ? e.navigator.userAgent : null, ee = !!e.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))), ee;
        }, ue.isWorker = Q, ue.keysDifference = function (e, t) {
          var r = [];
          for (const n in e) n in t || r.push(n);
          return r;
        }, ue.lazyLoadRTLTextPlugin = function () {
          si.isLoading() || si.isLoaded() || "deferred" !== n || ai();
        }, ue.makeRequest = we, ue.mapObject = V, ue.mercatorXfromLng = Dc, ue.mercatorYfromLat = Rc, ue.mercatorZfromAltitude = Oc, ue.mul = Sr, ue.mul$1 = Sa, ue.multiply = fa, ue.nextPowerOfTwo = function (e) {
          return e <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
        }, ue.normalize = va, ue.offscreenCanvasSupported = U, ue.operations = E, ue.ortho = ma, ue.parseCacheControl = function (e) {
          const i = {};
          return e.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (e, t, r, n) => {
            r = r || n;
            return i[t] = !r || r.toLowerCase(), "";
          }), i["max-age"] && (e = parseInt(i["max-age"], 10), isNaN(e) ? delete i["max-age"] : i["max-age"] = e), i;
        }, ue.parseGlyphPbf = function (e) {
          return new Rl(e).readFields(Ml, []);
        }, ue.pbf = Tr, ue.performSymbolLayout = function (n) {
          n.bucket.createArrays();
          var e,
            t,
            r = 512 * n.bucket.overscaling,
            i = (n.bucket.tilePixelRatio = de / r, n.bucket.compareText = {}, n.bucket.iconsNeedLinear = !1, n.bucket.layers[0]),
            o = i.layout,
            a = {
              layoutIconSize: (r = i._unevaluatedLayout._values)["icon-size"].possiblyEvaluate(new N(n.bucket.zoom + 1), n.canonical),
              layoutTextSize: r["text-size"].possiblyEvaluate(new N(n.bucket.zoom + 1), n.canonical),
              textMaxSize: r["text-size"].possiblyEvaluate(new N(18))
            };
          "composite" === n.bucket.textSizeData.kind && (({
            minZoom: e,
            maxZoom: t
          } = n.bucket.textSizeData), a.compositeTextSizes = [r["text-size"].possiblyEvaluate(new N(e), n.canonical), r["text-size"].possiblyEvaluate(new N(t), n.canonical)]), "composite" === n.bucket.iconSizeData.kind && (({
            minZoom: e,
            maxZoom: t
          } = n.bucket.iconSizeData), a.compositeIconSizes = [r["icon-size"].possiblyEvaluate(new N(e), n.canonical), r["icon-size"].possiblyEvaluate(new N(t), n.canonical)]);
          const s = o.get("text-line-height") * pe;
          var l = "viewport" !== o.get("text-rotation-alignment") && "point" !== o.get("symbol-placement"),
            c = o.get("text-keep-upright"),
            u = o.get("text-size");
          for (const g of n.bucket.features) {
            const y = o.get("text-font").evaluate(g, {}, n.canonical).join(","),
              v = u.evaluate(g, {}, n.canonical),
              E = a.layoutTextSize.evaluate(g, {}, n.canonical);
            var h = a.layoutIconSize.evaluate(g, {}, n.canonical);
            const b = {
                horizontal: {},
                vertical: void 0
              },
              w = g.text;
            let r = [0, 0];
            if (w) {
              const T = w.toString();
              var d = o.get("text-letter-spacing").evaluate(g, {}, n.canonical) * pe;
              const S = Kn(T) ? d : 0,
                x = o.get("text-anchor").evaluate(g, {}, n.canonical);
              var p = Eu(i, g, n.canonical);
              p || (d = o.get("text-radial-offset").evaluate(g, {}, n.canonical), r = d ? vu(x, [d * pe, yu]) : o.get("text-offset").evaluate(g, {}, n.canonical).map(e => e * pe));
              let t = l ? "center" : o.get("text-justify").evaluate(g, {}, n.canonical);
              const C = o.get("symbol-placement"),
                A = "point" === C ? o.get("text-max-width").evaluate(g, {}, n.canonical) * pe : 0;
              d = () => {
                n.bucket.allowVerticalPlacement && Vn(T) && (b.vertical = jl(w, n.glyphMap, n.glyphPositions, n.imagePositions, y, A, s, x, "left", S, r, ue.WritingMode.vertical, !0, C, E, v));
              };
              if (!l && p) {
                var f,
                  _ = new Set();
                if ("auto" === t) for (let e = 0; e < p.values.length; e += 2) _.add(bu(p.values[e]));else _.add(t);
                let e = !1;
                for (const I of _) b.horizontal[I] || (e ? b.horizontal[I] = b.horizontal[0] : (f = jl(w, n.glyphMap, n.glyphPositions, n.imagePositions, y, A, s, "center", I, S, r, ue.WritingMode.horizontal, !1, C, E, v)) && (b.horizontal[I] = f, e = 1 === f.positionedLines.length));
                d();
              } else {
                "auto" === t && (t = bu(x));
                var m = jl(w, n.glyphMap, n.glyphPositions, n.imagePositions, y, A, s, x, t, S, r, ue.WritingMode.horizontal, !1, C, E, v);
                m && (b.horizontal[t] = m), d(), Vn(T) && l && c && (b.vertical = jl(w, n.glyphMap, n.glyphPositions, n.imagePositions, y, A, s, x, t, S, r, ue.WritingMode.vertical, !1, C, E, v));
              }
            }
            let e,
              t = !1;
            g.icon && g.icon.name && (m = n.imageMap[g.icon.name]) && (e = function (e, t, r) {
              var {
                  horizontalAlign: r,
                  verticalAlign: n
                } = Xl(r),
                i = t[0],
                t = t[1],
                r = (i = i - e.displaySize[0] * r) + e.displaySize[0],
                t = t - e.displaySize[1] * n;
              return {
                image: e,
                top: t,
                bottom: t + e.displaySize[1],
                left: i,
                right: r
              };
            }(n.imagePositions[g.icon.name], o.get("icon-offset").evaluate(g, {}, n.canonical), o.get("icon-anchor").evaluate(g, {}, n.canonical)), t = !!m.sdf, void 0 === n.bucket.sdfIcons ? n.bucket.sdfIcons = t : n.bucket.sdfIcons !== t && he("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), m.pixelRatio !== n.bucket.pixelRatio || 0 !== o.get("icon-rotate").constantOr(1)) && (n.bucket.iconsNeedLinear = !0);
            d = Tu(b.horizontal) || b.vertical;
            n.bucket.iconsInText = !!d && d.iconsInText, (d || e) && !function (q, V, K, W, Z, X, J, e, Q, ee, te) {
              let t = X.textMaxSize.evaluate(V, {});
              void 0 === t && (t = J);
              const r = q.layers[0].layout,
                re = r.get("icon-offset").evaluate(V, {}, te),
                n = Tu(K.horizontal),
                i = J / 24,
                ne = q.tilePixelRatio * i,
                o = q.tilePixelRatio * t / 24,
                ie = q.tilePixelRatio * e,
                a = q.tilePixelRatio * r.get("symbol-spacing"),
                oe = r.get("text-padding") * q.tilePixelRatio,
                ae = function (e, t, r, n = 1) {
                  return e = e.get("icon-padding").evaluate(t, {}, r), [(t = e && e.values)[0] * n, t[1] * n, t[2] * n, t[3] * n];
                }(r, V, te, q.tilePixelRatio),
                s = r.get("text-max-angle") / 180 * Math.PI,
                le = "viewport" !== r.get("text-rotation-alignment") && "point" !== r.get("symbol-placement"),
                ce = "map" === r.get("icon-rotation-alignment") && "point" !== r.get("symbol-placement"),
                l = r.get("symbol-placement"),
                E = a / 2,
                c = r.get("icon-text-fit");
              let se;
              W && "none" !== c && (q.allowVerticalPlacement && K.vertical && (se = Ql(W, K.vertical, c, r.get("icon-text-fit-padding"), re, i)), n) && (W = Ql(W, n, c, r.get("icon-text-fit-padding"), re, i));
              var u = (d, p) => {
                if (!(p.x < 0 || p.x >= de || p.y < 0 || p.y >= de)) {
                  var f = q;
                  var _ = p;
                  p = d;
                  var m = K;
                  d = W;
                  var g = Z;
                  var y = se;
                  var v = q.layers[0];
                  var E = q.collisionBoxArray;
                  var b = V.index;
                  var w = V.sourceLayerIndex;
                  var T = q.index;
                  var S = ne;
                  var x = [oe, oe, oe, oe];
                  var C = le;
                  var A = Q;
                  var I = ie;
                  var N = ae;
                  var P = ce;
                  var D = re;
                  var R = V;
                  var O = X;
                  var M = ee;
                  var k = te;
                  var L = J;
                  var U = f.addToLineVertexArray(_, p);
                  let e,
                    t,
                    r,
                    n,
                    i = 0,
                    o = 0,
                    a = 0,
                    s = 0,
                    l = -1,
                    c = -1;
                  var F = {};
                  let u = To("");
                  f.allowVerticalPlacement && m.vertical && (p = v.layout.get("text-rotate").evaluate(R, {}, k) + 90, B = m.vertical, r = new hu(E, _, b, w, T, B, S, x, C, p), y) && (n = new hu(E, _, b, w, T, y, I, N, C, p));
                  if (d) {
                    var B = v.layout.get("icon-rotate").evaluate(R, {}),
                      p = "none" !== v.layout.get("icon-text-fit"),
                      $ = su(d, B, M, p),
                      y = y ? su(y, B, M, p) : void 0,
                      M = (t = new hu(E, _, b, w, T, d, I, N, !1, B), i = 4 * $.length, f.iconSizeData);
                    let e = null;
                    "source" === M.kind ? (e = [tc * v.layout.get("icon-size").evaluate(R, {})])[0] > rc && he(`${f.layerIds[0]}: Value for "icon-size" is >= ${ec}. Reduce your "icon-size".`) : "composite" === M.kind && ((e = [tc * O.compositeIconSizes[0].evaluate(R, {}, k), tc * O.compositeIconSizes[1].evaluate(R, {}, k)])[0] > rc || e[1] > rc) && he(`${f.layerIds[0]}: Value for "icon-size" is >= ${ec}. Reduce your "icon-size".`), f.addSymbols(f.icon, $, e, D, P, R, ue.WritingMode.none, _, U.lineStartIndex, U.lineLength, -1, k), l = f.icon.placedSymbolArray.length - 1, y && (o = 4 * y.length, f.addSymbols(f.icon, y, e, D, P, R, ue.WritingMode.vertical, _, U.lineStartIndex, U.lineLength, -1, k), c = f.icon.placedSymbolArray.length - 1);
                  }
                  var z = Object.keys(m.horizontal);
                  for (const G of z) {
                    var Y = m.horizontal[G],
                      H = (e || (u = To(Y.text), H = v.layout.get("text-rotate").evaluate(R, {}, k), e = new hu(E, _, b, w, T, Y, S, x, C, H)), 1 === Y.positionedLines.length);
                    if (a += wu(f, _, Y, g, v, C, R, A, U, m.vertical ? ue.WritingMode.horizontal : ue.WritingMode.horizontalOnly, H ? z : [G], F, l, O, k), H) break;
                  }
                  m.vertical && (s += wu(f, _, m.vertical, g, v, C, R, A, U, ue.WritingMode.vertical, ["vertical"], F, c, O, k));
                  p = e ? e.boxStartIndex : f.collisionBoxArray.length, d = e ? e.boxEndIndex : f.collisionBoxArray.length, I = r ? r.boxStartIndex : f.collisionBoxArray.length, N = r ? r.boxEndIndex : f.collisionBoxArray.length, M = t ? t.boxStartIndex : f.collisionBoxArray.length, $ = t ? t.boxEndIndex : f.collisionBoxArray.length, y = n ? n.boxStartIndex : f.collisionBoxArray.length, D = n ? n.boxEndIndex : f.collisionBoxArray.length;
                  let h = -1;
                  P = (e, t) => e && e.circleDiameter ? Math.max(e.circleDiameter, t) : t, h = P(e, h), h = P(r, h), h = P(t, h), P = -1 < (h = P(n, h)) ? 1 : 0;
                  P && (h *= L / pe);
                  f.glyphOffsetArray.length >= dc.MAX_GLYPHS && he("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907");
                  void 0 !== R.sortKey && f.addToSortKeyRanges(f.symbolInstances.length, R.sortKey);
                  var L = Eu(v, R, k),
                    [L, j] = function (t, e) {
                      var r = t.length,
                        n = null == e ? void 0 : e.values;
                      if (0 < (null == n ? void 0 : n.length)) for (let e = 0; e < n.length; e += 2) {
                        var i = ue.TextAnchorEnum[n[e]],
                          o = n[e + 1];
                        t.emplaceBack(i, o[0], o[1]);
                      }
                      return [r, t.length];
                    }(f.textAnchorOffsets, L);
                  f.symbolInstances.emplaceBack(_.x, _.y, 0 <= F.right ? F.right : -1, 0 <= F.center ? F.center : -1, 0 <= F.left ? F.left : -1, F.vertical || -1, l, c, u, p, d, I, N, M, $, y, D, b, a, s, i, o, P, 0, S, h, L, j);
                }
              };
              if ("line" === l) for (const p of Qc(V.geometry, 0, 0, de, de)) for (const f of ou(p, a, s, K.vertical || n, W, 24, o, q.overscaling, de)) n && function (e, t, r, n) {
                e = e.compareText;
                if (t in e) {
                  var i = e[t];
                  for (let e = i.length - 1; 0 <= e; e--) if (n.dist(i[e]) < r) return 1;
                } else e[t] = [];
                return e[t].push(n), 0;
              }(q, n.text, E, f) || u(p, f);else if ("line-center" === l) for (const _ of V.geometry) {
                var h;
                1 < _.length && (h = function (t, r, e, n, i, o) {
                  var a = nu(e, i, o),
                    s = iu(e, n) * o;
                  let l = 0;
                  var c = ru(t) / 2;
                  for (let e = 0; e < t.length - 1; e++) {
                    var u,
                      h,
                      d = t[e],
                      p = t[e + 1],
                      f = d.dist(p);
                    if (l + f > c) return u = (c - l) / f, h = _r.number(d.x, p.x, u), u = _r.number(d.y, p.y, u), (h = new eu(h, u, p.angleTo(d), e))._round(), !a || tu(t, h, s, a, r) ? h : void 0;
                    l += f;
                  }
                }(_, s, K.vertical || n, W, 24, o)) && u(_, h);
              } else if ("Polygon" === V.type) for (const m of hs(V.geometry, 0)) {
                var d = fu(m, 16);
                u(m[0], new eu(d.x, d.y, 0));
              } else if ("LineString" === V.type) for (const g of V.geometry) u(g, new eu(g[0].x, g[0].y, 0));else if ("Point" === V.type) for (const y of V.geometry) for (const v of y) u([v], new eu(v.x, v.y, 0));
            }(n.bucket, g, b, e, n.imageMap, a, E, h, r, t, n.canonical);
          }
          n.showCollisionBoxes && n.bucket.generateCollisionDebugBuffers();
        }, ue.perspective = _a, ue.pick = function (t, r) {
          var n = {};
          for (let e = 0; e < r.length; e++) {
            var i = r[e];
            i in t && (n[i] = t[i]);
          }
          return n;
        }, ue.plugin = si, ue.pointGeometry = P, ue.polygonIntersectsPolygon = Wo, ue.potpack = Fl, ue.readImageUsingVideoFrame = oe, ue.register = r, ue.registerForPluginStateChange = function (e) {
          return e({
            pluginStatus: n,
            pluginURL: ti
          }), oi.on("pluginStateChange", e), e;
        }, ue.renderColorRamp = Fa, ue.renderStyleImage = function (e) {
          var t = e["userImage"];
          return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0);
        }, ue.rotate = function (e, t, r) {
          var n = t[0],
            i = t[1],
            o = t[2],
            t = t[3],
            a = Math.sin(r),
            r = Math.cos(r);
          return e[0] = n * r + o * a, e[1] = i * r + t * a, e[2] = n * -a + o * r, e[3] = i * -a + t * r, e;
        }, ue.rotateX = function (e, t, r) {
          var n = Math.sin(r),
            r = Math.cos(r),
            i = t[4],
            o = t[5],
            a = t[6],
            s = t[7],
            l = t[8],
            c = t[9],
            u = t[10],
            h = t[11];
          return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = i * r + l * n, e[5] = o * r + c * n, e[6] = a * r + u * n, e[7] = s * r + h * n, e[8] = l * r - i * n, e[9] = c * r - o * n, e[10] = u * r - a * n, e[11] = h * r - s * n, e;
        }, ue.rotateZ = function (e, t, r) {
          var n = Math.sin(r),
            r = Math.cos(r),
            i = t[0],
            o = t[1],
            a = t[2],
            s = t[3],
            l = t[4],
            c = t[5],
            u = t[6],
            h = t[7];
          return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * r + l * n, e[1] = o * r + c * n, e[2] = a * r + u * n, e[3] = s * r + h * n, e[4] = l * r - i * n, e[5] = c * r - o * n, e[6] = u * r - a * n, e[7] = h * r - s * n, e;
        }, ue.sameOrigin = Se, ue.scale = function (e, t, r) {
          var n = r[0],
            i = r[1],
            r = r[2];
          return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * i, e[5] = t[5] * i, e[6] = t[6] * i, e[7] = t[7] * i, e[8] = t[8] * r, e[9] = t[9] * r, e[10] = t[10] * r, e[11] = t[11] * r, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
        }, ue.scale$1 = function (e, t, r) {
          return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e;
        }, ue.setRTLTextPlugin = function (e, t, r = !1) {
          if (n === Qn.deferred || n === Qn.loading || n === Qn.loaded) throw new Error("setRTLTextPlugin cannot be called multiple times.");
          ti = _e.resolveURL(e), n = Qn.deferred, ei = t, ni(), r || ai();
        }, ue.sphericalToCartesian = function ([e, t, r]) {
          return t = (t += 90) * (Math.PI / 180), r *= Math.PI / 180, {
            x: e * Math.cos(t) * Math.sin(r),
            y: e * Math.sin(t) * Math.sin(r),
            z: e * Math.cos(r)
          };
        }, ue.sqrLen = Ca, ue.sub = wa, ue.toEvaluationFeature = qo, ue.transformMat3 = function (e, t, r) {
          var n = t[0],
            i = t[1],
            t = t[2];
          return e[0] = n * r[0] + i * r[3] + t * r[6], e[1] = n * r[1] + i * r[4] + t * r[7], e[2] = n * r[2] + i * r[5] + t * r[8], e;
        }, ue.transformMat4 = Ta, ue.transformMat4$1 = function (e, t, r) {
          var n = t[0],
            t = t[1];
          return e[0] = r[0] * n + r[4] * t + r[12], e[1] = r[1] * n + r[5] * t + r[13], e;
        }, ue.translate = function (e, t, r) {
          var n,
            i,
            o,
            a,
            s,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            _ = r[0],
            m = r[1],
            r = r[2];
          return t === e ? (e[12] = t[0] * _ + t[4] * m + t[8] * r + t[12], e[13] = t[1] * _ + t[5] * m + t[9] * r + t[13], e[14] = t[2] * _ + t[6] * m + t[10] * r + t[14], e[15] = t[3] * _ + t[7] * m + t[11] * r + t[15]) : (n = t[0], i = t[1], o = t[2], a = t[3], s = t[4], l = t[5], c = t[6], u = t[7], h = t[8], d = t[9], p = t[10], f = t[11], e[0] = n, e[1] = i, e[2] = o, e[3] = a, e[4] = s, e[5] = l, e[6] = c, e[7] = u, e[8] = h, e[9] = d, e[10] = p, e[11] = f, e[12] = n * _ + s * m + h * r + t[12], e[13] = i * _ + l * m + d * r + t[13], e[14] = o * _ + c * m + p * r + t[14], e[15] = a * _ + u * m + f * r + t[15]), e;
        }, ue.triggerPluginCompletionEvent = ri, ue.unicodeBlockLookup = ne, ue.uniqueId = function () {
          return q++;
        }, ue.v8Spec = o, ue.validateCustomStyleLayer = function (e) {
          var t = [],
            r = e.id;
          return void 0 === r && t.push({
            message: `layers.${r}: missing required property "id"`
          }), void 0 === e.render && t.push({
            message: `layers.${r}: missing required method "render"`
          }), e.renderingMode && "2d" !== e.renderingMode && "3d" !== e.renderingMode && t.push({
            message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
          }), t;
        }, ue.validateLight = le, ue.validateStyle = Un, ue.vectorTile = ws, ue.warnOnce = he, ue.wrap = j;
      }), e(0, function (S) {
        class L {
          constructor(e) {
            this.keyCache = {}, e && this.replace(e);
          }
          replace(e) {
            this._layerConfigs = {}, this._layers = {}, this.update(e, []);
          }
          update(e, t) {
            for (const a of e) {
              this._layerConfigs[a.id] = a;
              var r = this._layers[a.id] = S.createStyleLayer(a);
              r._featureFilter = S.createFilter(r.filter), this.keyCache[a.id] && delete this.keyCache[a.id];
            }
            for (const s of t) delete this.keyCache[s], delete this._layerConfigs[s], delete this._layers[s];
            this.familiesBySource = {};
            for (const e of S.groupByLayout(Object.values(this._layerConfigs), this.keyCache)) {
              var n = e.map(e => this._layers[e.id]),
                i = n[0];
              if ("none" !== i.visibility) {
                var o = i.source || "";
                let e = this.familiesBySource[o];
                e = e || (this.familiesBySource[o] = {});
                o = i.sourceLayer || "_geojsonTileLayer";
                let t = e[o];
                (t = t || (e[o] = [])).push(n);
              }
            }
          }
        }
        class x {
          constructor(e) {
            var t = {},
              r = [];
            for (const p in e) {
              var n = e[p],
                i = t[p] = {};
              for (const f in n) {
                var o,
                  a = n[+f];
                a && 0 !== a.bitmap.width && 0 !== a.bitmap.height && (o = {
                  x: 0,
                  y: 0,
                  w: a.bitmap.width + 2,
                  h: a.bitmap.height + 2
                }, r.push(o), i[f] = {
                  rect: o,
                  metrics: a.metrics
                });
              }
            }
            var {
                w: s,
                h: l
              } = S.potpack(r),
              c = new S.AlphaImage({
                width: s || 1,
                height: l || 1
              });
            for (const _ in e) {
              var u = e[_];
              for (const m in u) {
                var h,
                  d = u[+m];
                d && 0 !== d.bitmap.width && 0 !== d.bitmap.height && (h = t[_][m].rect, S.AlphaImage.copy(d.bitmap, c, {
                  x: 0,
                  y: 0
                }, {
                  x: h.x + 1,
                  y: h.y + 1
                }, d.bitmap));
              }
            }
            this.image = c, this.positions = t;
          }
        }
        S.register("GlyphAtlas", x);
        class U {
          constructor(e) {
            this.tileID = new S.OverscaledTileID(e.tileID.overscaledZ, e.tileID.wrap, e.tileID.canonical.z, e.tileID.canonical.x, e.tileID.canonical.y), this.uid = e.uid, this.zoom = e.zoom, this.pixelRatio = e.pixelRatio, this.tileSize = e.tileSize, this.source = e.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = e.showCollisionBoxes, this.collectResourceTiming = !!e.collectResourceTiming, this.returnDependencies = !!e.returnDependencies, this.promoteId = e.promoteId, this.inFlightDependencies = [], this.dependencySentinel = -1;
          }
          parse(e, t, i, r, o) {
            this.status = "parsing", this.data = e, this.collisionBoxArray = new S.CollisionBoxArray();
            var n = new S.DictionaryCoder(Object.keys(e.layers).sort());
            const a = new S.FeatureIndex(this.tileID, this.promoteId),
              s = (a.bucketLayerIDs = [], {}),
              l = {
                featureIndex: a,
                iconDependencies: {},
                patternDependencies: {},
                glyphDependencies: {},
                availableImages: i
              };
            var c = t.familiesBySource[this.source];
            for (const w in c) {
              var u = e.layers[w];
              if (u) {
                1 === u.version && S.warnOnce(`Vector tile source "${this.source}" layer "${w}" ` + "does not use vector tile spec v2 and therefore may have some rendering errors.");
                var h = n.encode(w),
                  d = [];
                for (let e = 0; e < u.length; e++) {
                  var p = u.feature(e),
                    f = a.getId(p, w);
                  d.push({
                    feature: p,
                    id: f,
                    index: e,
                    sourceLayerIndex: h
                  });
                }
                for (const T of c[w]) {
                  var _ = T[0];
                  _.source !== this.source && S.warnOnce(`layer.source = ${_.source} does not equal this.source = ` + this.source), _.minzoom && this.zoom < Math.floor(_.minzoom) || _.maxzoom && this.zoom >= _.maxzoom || "none" !== _.visibility && (C(T, this.zoom, i), (s[_.id] = _.createBucket({
                    index: a.bucketLayerIDs.length,
                    layers: T,
                    zoom: this.zoom,
                    pixelRatio: this.pixelRatio,
                    overscaling: this.overscaling,
                    collisionBoxArray: this.collisionBoxArray,
                    sourceLayerIndex: h,
                    sourceID: this.source
                  })).populate(d, l, this.tileID.canonical), a.bucketLayerIDs.push(T.map(e => e.id)));
                }
              }
            }
            let m, g, y, v;
            t = S.mapObject(l.glyphDependencies, e => Object.keys(e).map(Number));
            this.inFlightDependencies.forEach(e => null == e ? void 0 : e.cancel()), this.inFlightDependencies = [];
            const E = ++this.dependencySentinel;
            Object.keys(t).length ? this.inFlightDependencies.push(r.send("getGlyphs", {
              uid: this.uid,
              stacks: t,
              source: this.source,
              tileID: this.tileID,
              type: "glyphs"
            }, (e, t) => {
              E !== this.dependencySentinel || m || (m = e, g = t, b.call(this));
            })) : g = {};
            t = Object.keys(l.iconDependencies), t.length ? this.inFlightDependencies.push(r.send("getImages", {
              icons: t,
              source: this.source,
              tileID: this.tileID,
              type: "icons"
            }, (e, t) => {
              E !== this.dependencySentinel || m || (m = e, y = t, b.call(this));
            })) : y = {}, t = Object.keys(l.patternDependencies);
            function b() {
              if (m) return o(m);
              if (g && y && v) {
                var e = new x(g),
                  t = new S.ImageAtlas(y, v);
                for (const n in s) {
                  var r = s[n];
                  r instanceof S.SymbolBucket ? (C(r.layers, this.zoom, i), S.performSymbolLayout({
                    bucket: r,
                    glyphMap: g,
                    glyphPositions: e.positions,
                    imageMap: y,
                    imagePositions: t.iconPositions,
                    showCollisionBoxes: this.showCollisionBoxes,
                    canonical: this.tileID.canonical
                  })) : r.hasPattern && (r instanceof S.LineBucket || r instanceof S.FillBucket || r instanceof S.FillExtrusionBucket) && (C(r.layers, this.zoom, i), r.addFeatures(l, this.tileID.canonical, t.patternPositions));
                }
                this.status = "done", o(null, {
                  buckets: Object.values(s).filter(e => !e.isEmpty()),
                  featureIndex: a,
                  collisionBoxArray: this.collisionBoxArray,
                  glyphAtlasImage: e.image,
                  imageAtlas: t,
                  glyphMap: this.returnDependencies ? g : null,
                  iconMap: this.returnDependencies ? y : null,
                  glyphPositions: this.returnDependencies ? e.positions : null
                });
              }
            }
            t.length ? this.inFlightDependencies.push(r.send("getImages", {
              icons: t,
              source: this.source,
              tileID: this.tileID,
              type: "patterns"
            }, (e, t) => {
              E !== this.dependencySentinel || m || (m = e, v = t, b.call(this));
            })) : v = {}, b.call(this);
          }
        }
        function C(e, t, r) {
          var n = new S.EvaluationParameters(t);
          for (const i of e) i.recalculate(n, r);
        }
        function F(o, a) {
          const e = S.getArrayBuffer(o.request, (r, n, e, t) => {
            if (r) a(r);else if (n) try {
              var i = new S.vectorTile.VectorTile(new S.Protobuf(n));
              a(null, {
                vectorTile: i,
                rawData: n,
                cacheControl: e,
                expires: t
              });
            } catch (e) {
              r = new Uint8Array(n), i = 31 === r[0] && 139 === r[1];
              let t = `Unable to parse the tile at ${o.request.url}, `;
              t += i ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : "got error: " + e.messge, a(new Error(t));
            }
          });
          return () => {
            e.cancel(), a();
          };
        }
        class t {
          constructor(e, t, r, n) {
            this.actor = e, this.layerIndex = t, this.availableImages = r, this.loadVectorData = n || F, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadTile(e, o) {
            const a = e.uid,
              s = (this.loading || (this.loading = {}), !!(e && e.request && e.request.collectResourceTiming) && new S.RequestPerformance(e.request)),
              l = this.loading[a] = new U(e);
            l.abort = this.loadVectorData(e, (e, t) => {
              if (delete this.loading[a], e || !t) return l.status = "done", this.loaded[a] = l, o(e);
              const r = t.rawData,
                n = {},
                i = (t.expires && (n.expires = t.expires), t.cacheControl && (n.cacheControl = t.cacheControl), {});
              s && (e = s.finish()) && (i.resourceTiming = JSON.parse(JSON.stringify(e))), l.vectorTile = t.vectorTile, l.parse(t.vectorTile, this.layerIndex, this.availableImages, this.actor, (e, t) => {
                if (delete this.fetching[a], e || !t) return o(e);
                o(null, S.extend({
                  rawTileData: r.slice(0)
                }, t, n, i));
              }), this.loaded = this.loaded || {}, this.loaded[a] = l, this.fetching[a] = {
                rawTileData: r,
                cacheControl: n,
                resourceTiming: i
              };
            });
          }
          reloadTile(e, o) {
            var t = this.loaded;
            const a = e.uid;
            t && t[a] && ((t = t[a]).showCollisionBoxes = e.showCollisionBoxes, "parsing" === t.status ? t.parse(t.vectorTile, this.layerIndex, this.availableImages, this.actor, (e, t) => {
              if (e || !t) return o(e, t);
              let r;
              var n, i;
              r = this.fetching[a] ? (({
                rawTileData: e,
                cacheControl: n,
                resourceTiming: i
              } = this.fetching[a]), delete this.fetching[a], S.extend({
                rawTileData: e.slice(0)
              }, t, n, i)) : t, o(null, r);
            }) : "done" === t.status && (t.vectorTile ? t.parse(t.vectorTile, this.layerIndex, this.availableImages, this.actor, o) : o()));
          }
          abortTile(e, t) {
            var r = this.loading,
              e = e.uid;
            r && r[e] && r[e].abort && (r[e].abort(), delete r[e]), t();
          }
          removeTile(e, t) {
            var r = this.loaded,
              e = e.uid;
            r && r[e] && delete r[e], t();
          }
        }
        class B {
          constructor() {
            this.loaded = {};
          }
          loadTile(c, u) {
            return S.__awaiter(this, void 0, void 0, function* () {
              var {
                  uid: e,
                  encoding: t,
                  rawImageData: r,
                  redFactor: n,
                  greenFactor: i,
                  blueFactor: o,
                  baseShift: a
                } = c,
                s = r.width + 2,
                l = r.height + 2,
                s = S.isImageBitmap(r) ? new S.RGBAImage({
                  width: s,
                  height: l
                }, yield S.getImageData(r, -1, -1, s, l)) : r,
                l = new S.DEMData(e, s, t, n, i, o, a);
              this.loaded = this.loaded || {}, this.loaded[e] = l, u(null, l);
            });
          }
          removeTile(e) {
            var t = this.loaded,
              e = e.uid;
            t && t[e] && delete t[e];
          }
        }
        function o(e, t) {
          if (0 !== e.length) {
            n(e[0], t);
            for (var r = 1; r < e.length; r++) n(e[r], !t);
          }
        }
        function n(e, t) {
          for (var r = 0, n = 0, i = 0, o = e.length, a = o - 1; i < o; a = i++) {
            var s = (e[i][0] - e[a][0]) * (e[a][1] + e[i][1]),
              l = r + s;
            n += Math.abs(r) >= Math.abs(s) ? r - l + s : s - l + r, r = l;
          }
          0 <= r + n != !!t && e.reverse();
        }
        var $ = S.getDefaultExportFromCjs(function e(t, r) {
          var n,
            i = t && t.type;
          if ("FeatureCollection" === i) for (n = 0; n < t.features.length; n++) e(t.features[n], r);else if ("GeometryCollection" === i) for (n = 0; n < t.geometries.length; n++) e(t.geometries[n], r);else if ("Feature" === i) e(t.geometry, r);else if ("Polygon" === i) o(t.coordinates, r);else if ("MultiPolygon" === i) for (n = 0; n < t.coordinates.length; n++) o(t.coordinates[n], r);
          return t;
        });
        const z = S.vectorTile.VectorTileFeature.prototype.toGeoJSON;
        let Y = class {
            constructor(e) {
              this._feature = e, this.extent = S.EXTENT, this.type = e.type, this.properties = e.tags, "id" in e && !isNaN(e.id) && (this.id = parseInt(e.id, 10));
            }
            loadGeometry() {
              if (1 === this._feature.type) {
                var e = [];
                for (const n of this._feature.geometry) e.push([new S.Point(n[0], n[1])]);
                return e;
              }
              var t = [];
              for (const i of this._feature.geometry) {
                var r = [];
                for (const o of i) r.push(new S.Point(o[0], o[1]));
                t.push(r);
              }
              return t;
            }
            toGeoJSON(e, t, r) {
              return z.call(this, e, t, r);
            }
          },
          H = class {
            constructor(e) {
              this.layers = {
                _geojsonTileLayer: this
              }, this.name = "_geojsonTileLayer", this.extent = S.EXTENT, this.length = e.length, this._features = e;
            }
            feature(e) {
              return new Y(this._features[e]);
            }
          };
        var e = {
            exports: {}
          },
          j = S.pointGeometry,
          G = S.vectorTile.VectorTileFeature,
          q = r;
        function r(e, t) {
          this.options = t || {}, this.features = e, this.length = e.length;
        }
        function i(e, t) {
          this.id = "number" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096;
        }
        r.prototype.feature = function (e) {
          return new i(this.features[e], this.options.extent);
        }, i.prototype.loadGeometry = function () {
          var e = this.rawGeometry;
          this.geometry = [];
          for (var t = 0; t < e.length; t++) {
            for (var r = e[t], n = [], i = 0; i < r.length; i++) n.push(new j(r[i][0], r[i][1]));
            this.geometry.push(n);
          }
          return this.geometry;
        }, i.prototype.bbox = function () {
          this.geometry || this.loadGeometry();
          for (var e = this.geometry, t = 1 / 0, r = -1 / 0, n = 1 / 0, i = -1 / 0, o = 0; o < e.length; o++) for (var a = e[o], s = 0; s < a.length; s++) var l = a[s], t = Math.min(t, l.x), r = Math.max(r, l.x), n = Math.min(n, l.y), i = Math.max(i, l.y);
          return [t, n, r, i];
        }, i.prototype.toGeoJSON = G.prototype.toGeoJSON;
        var V = S.pbf,
          a = q;
        function s(e) {
          var t,
            r = new V(),
            n = e,
            i = r;
          for (t in n.layers) i.writeMessage(3, K, n.layers[t]);
          return r.finish();
        }
        function K(e, t) {
          t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || ""), t.writeVarintField(5, e.extent || 4096);
          for (var r = {
              keys: [],
              values: [],
              keycache: {},
              valuecache: {}
            }, n = 0; n < e.length; n++) r.feature = e.feature(n), t.writeMessage(2, W, r);
          var i = r.keys;
          for (n = 0; n < i.length; n++) t.writeStringField(3, i[n]);
          var o = r.values;
          for (n = 0; n < o.length; n++) t.writeMessage(4, J, o[n]);
        }
        function W(e, t) {
          var r = e.feature;
          void 0 !== r.id && t.writeVarintField(1, r.id), t.writeMessage(2, Z, e), t.writeVarintField(3, r.type), t.writeMessage(4, X, r);
        }
        function Z(e, t) {
          var r,
            n = e.feature,
            i = e.keys,
            o = e.values,
            a = e.keycache,
            s = e.valuecache;
          for (r in n.properties) {
            var l,
              c = n.properties[r],
              u = a[r];
            null !== c && (void 0 === u && (i.push(r), u = i.length - 1, a[r] = u), t.writeVarint(u), void 0 === (l = s[u = (u = typeof c) + ":" + (c = "string" != u && "boolean" != u && "number" != u ? JSON.stringify(c) : c)]) && (o.push(c), l = o.length - 1, s[u] = l), t.writeVarint(l));
          }
        }
        function f(e, t) {
          return (t << 3) + (7 & e);
        }
        function _(e) {
          return e << 1 ^ e >> 31;
        }
        function X(e, t) {
          for (var r = e.loadGeometry(), n = e.type, i = 0, o = 0, a = r.length, s = 0; s < a; s++) {
            for (var l = r[s], c = 1, u = (1 === n && (c = l.length), t.writeVarint(f(1, c)), 3 === n ? l.length - 1 : l.length), h = 0; h < u; h++) {
              1 === h && 1 !== n && t.writeVarint(f(2, u - 1));
              var d = l[h].x - i,
                p = l[h].y - o;
              t.writeVarint(_(d)), t.writeVarint(_(p)), i += d, o += p;
            }
            3 === n && t.writeVarint(15);
          }
        }
        function J(e, t) {
          var r = typeof e;
          "string" == r ? t.writeStringField(1, e) : "boolean" == r ? t.writeBooleanField(7, e) : "number" == r && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));
        }
        e.exports = s, e.exports.fromVectorTileJs = s, e.exports.fromGeojsonVt = function (e, t) {
          t = t || {};
          var r,
            n = {};
          for (r in e) n[r] = new a(e[r].features, t), n[r].name = r, n[r].version = t.version, n[r].extent = t.extent;
          return s({
            layers: n
          });
        }, e.exports.GeoJSONWrapper = a;
        var l,
          Q = S.getDefaultExportFromCjs(e.exports);
        const ee = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: e => e
          },
          u = Math.fround || (l = new Float32Array(1), e => (l[0] = +e, l[0])),
          m = 3,
          A = 5,
          c = 6;
        class te {
          constructor(e) {
            this.options = Object.assign(Object.create(ee), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(t) {
            var {
                log: r,
                minZoom: n,
                maxZoom: i
              } = this.options,
              e = (r && console.time("total time"), `prepare ${t.length} points`),
              o = (r && console.time(e), this.points = t, []);
            for (let e = 0; e < t.length; e++) {
              var a,
                s = t[e];
              s.geometry && ([s, a] = s.geometry.coordinates, s = u(y(s)), a = u(v(a)), o.push(s, a, 1 / 0, e, -1, 1), this.options.reduce) && o.push(0);
            }
            let l = this.trees[i + 1] = this._createTree(o);
            r && console.timeEnd(e);
            for (let e = i; e >= n; e--) {
              var c = +Date.now();
              l = this.trees[e] = this._createTree(this._cluster(l, e)), r && console.log("z%d: %d clusters in %dms", e, l.numItems, +Date.now() - c);
            }
            return r && console.timeEnd("total time"), this;
          }
          getClusters(e, t) {
            let r = ((e[0] + 180) % 360 + 360) % 360 - 180;
            var n = Math.max(-90, Math.min(90, e[1]));
            let i = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;
            var o = Math.max(-90, Math.min(90, e[3]));
            if (360 <= e[2] - e[0]) r = -180, i = 180;else if (r > i) return e = this.getClusters([r, n, 180, o], t), a = this.getClusters([-180, n, i, o], t), e.concat(a);
            var e = this.trees[this._limitZoom(t)],
              a = e.range(y(r), v(o), y(i), v(n)),
              s = e.data,
              l = [];
            for (const u of a) {
              var c = this.stride * u;
              l.push(1 < s[c + A] ? h(s, c, this.clusterProps) : this.points[s[c + m]]);
            }
            return l;
          }
          getChildren(e) {
            var t = this._getOriginId(e),
              r = this._getOriginZoom(e),
              n = "No cluster with the specified id.",
              i = this.trees[r];
            if (!i) throw new Error(n);
            var o = i.data;
            if (t * this.stride >= o.length) throw new Error(n);
            var r = this.options.radius / (this.options.extent * Math.pow(2, r - 1)),
              a = o[t * this.stride],
              t = o[t * this.stride + 1],
              s = [];
            for (const c of i.within(a, t, r)) {
              var l = c * this.stride;
              o[4 + l] === e && s.push(1 < o[l + A] ? h(o, l, this.clusterProps) : this.points[o[l + m]]);
            }
            if (0 === s.length) throw new Error(n);
            return s;
          }
          getLeaves(e, t, r) {
            var n = [];
            return this._appendLeaves(n, e, t = t || 10, r = r || 0, 0), n;
          }
          getTile(e, t, r) {
            var n = this.trees[this._limitZoom(e)],
              e = Math.pow(2, e),
              {
                extent: i,
                radius: o
              } = this.options,
              o = o / i,
              i = (r - o) / e,
              a = (r + 1 + o) / e,
              s = {
                features: []
              };
            return this._addTileFeatures(n.range((t - o) / e, i, (t + 1 + o) / e, a), n.data, t, r, e, s), 0 === t && this._addTileFeatures(n.range(1 - o / e, i, 1, a), n.data, e, r, e, s), t === e - 1 && this._addTileFeatures(n.range(0, i, o / e, a), n.data, -1, r, e, s), s.features.length ? s : null;
          }
          getClusterExpansionZoom(e) {
            let t = this._getOriginZoom(e) - 1;
            for (; t <= this.options.maxZoom;) {
              var r = this.getChildren(e);
              if (t++, 1 !== r.length) break;
              e = r[0].properties.cluster_id;
            }
            return t;
          }
          _appendLeaves(e, t, r, n, i) {
            for (const a of this.getChildren(t)) {
              var o = a.properties;
              if (o && o.cluster ? i + o.point_count <= n ? i += o.point_count : i = this._appendLeaves(e, o.cluster_id, r, n, i) : i < n ? i++ : e.push(a), e.length === r) break;
            }
            return i;
          }
          _createTree(t) {
            var r = new S.KDBush(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let e = 0; e < t.length; e += this.stride) r.add(t[e], t[e + 1]);
            return r.finish(), r.data = t, r;
          }
          _addTileFeatures(e, i, o, a, s, l) {
            for (const p of e) {
              var c,
                u = p * this.stride,
                h = 1 < i[u + A];
              let e, t, r;
              r = h ? (e = g(i, u, this.clusterProps), t = i[u], i[1 + u]) : (d = this.points[i[u + m]], [d, c] = (e = d.properties, d.geometry.coordinates), t = y(d), v(c));
              var d = {
                type: 1,
                geometry: [[Math.round(this.options.extent * (t * s - o)), Math.round(this.options.extent * (r * s - a))]],
                tags: e
              };
              let n;
              void 0 !== (n = h || this.options.generateId ? i[u + m] : this.points[i[u + m]].id) && (d.id = n), l.features.push(d);
            }
          }
          _limitZoom(e) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
          }
          _cluster(e, a) {
            var {
                radius: t,
                extent: r,
                reduce: s,
                minPoints: n
              } = this.options,
              l = t / (r * Math.pow(2, a)),
              c = e.data,
              u = [],
              h = this.stride;
            for (let o = 0; o < c.length; o += h) if (!(c[o + 2] <= a)) {
              c[o + 2] = a;
              var d = c[o],
                p = c[o + 1],
                f = e.within(c[o], c[o + 1], l),
                _ = c[o + A];
              let i = _;
              for (const b of f) {
                var m = b * h;
                c[2 + m] > a && (i += c[m + A]);
              }
              if (i > _ && i >= n) {
                let e = d * _,
                  t = p * _,
                  r,
                  n = -1;
                var g = ((o / h | 0) << 5) + (a + 1) + this.points.length;
                for (const w of f) {
                  var y,
                    v = w * h;
                  c[2 + v] <= a || (c[2 + v] = a, y = c[v + A], e += c[v] * y, t += c[1 + v] * y, c[4 + v] = g, s && (r || (r = this._map(c, o, !0), n = this.clusterProps.length, this.clusterProps.push(r)), s(r, this._map(c, v))));
                }
                c[o + 4] = g, u.push(e / i, t / i, 1 / 0, g, -1, i), s && u.push(n);
              } else {
                for (let e = 0; e < h; e++) u.push(c[o + e]);
                if (1 < i) for (const T of f) {
                  var E = T * h;
                  if (!(c[2 + E] <= a)) {
                    c[2 + E] = a;
                    for (let e = 0; e < h; e++) u.push(c[E + e]);
                  }
                }
              }
            }
            return u;
          }
          _getOriginId(e) {
            return e - this.points.length >> 5;
          }
          _getOriginZoom(e) {
            return (e - this.points.length) % 32;
          }
          _map(e, t, r) {
            var n;
            return 1 < e[t + A] ? (n = this.clusterProps[e[t + c]], r ? Object.assign({}, n) : n) : (n = this.points[e[t + m]].properties, e = this.options.map(n), r && e === n ? Object.assign({}, e) : e);
          }
        }
        function h(e, t, r) {
          return {
            type: "Feature",
            id: e[t + m],
            properties: g(e, t, r),
            geometry: {
              type: "Point",
              coordinates: [360 * (e[t] - .5), function (e) {
                e = (180 - 360 * e) * Math.PI / 180;
                return 360 * Math.atan(Math.exp(e)) / Math.PI - 90;
              }(e[t + 1])]
            }
          };
        }
        function g(e, t, r) {
          var n = e[t + A],
            i = 1e4 <= n ? Math.round(n / 1e3) + "k" : 1e3 <= n ? Math.round(n / 100) / 10 + "k" : n,
            o = e[t + c],
            r = -1 === o ? {} : Object.assign({}, r[o]);
          return Object.assign(r, {
            cluster: !0,
            cluster_id: e[t + m],
            point_count: n,
            point_count_abbreviated: i
          });
        }
        function y(e) {
          return e / 360 + .5;
        }
        function v(e) {
          e = Math.sin(e * Math.PI / 180), e = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI;
          return e < 0 ? 0 : 1 < e ? 1 : e;
        }
        function E(e, t, r, n) {
          for (var i, o = n, a = r - t >> 1, s = r - t, l = e[t], c = e[t + 1], u = e[r], h = e[r + 1], d = t + 3; d < r; d += 3) {
            var p = function (e, t, r, n, i, o) {
              var a = i - r,
                s = o - n;
              {
                var l;
                0 == a && 0 == s || (1 < (l = ((e - r) * a + (t - n) * s) / (a * a + s * s)) ? (r = i, n = o) : 0 < l && (r += a * l, n += s * l));
              }
              return (a = e - r) * a + (s = t - n) * s;
            }(e[d], e[d + 1], l, c, u, h);
            o < p ? (i = d, o = p) : p === o && (p = Math.abs(d - a)) < s && (i = d, s = p);
          }
          n < o && (3 < i - t && E(e, t, i, n), e[i + 2] = o, 3 < r - i) && E(e, i, r, n);
        }
        function I(e, t, r, n) {
          var e = {
              id: void 0 === e ? null : e,
              type: t,
              geometry: r,
              tags: n,
              minX: 1 / 0,
              minY: 1 / 0,
              maxX: -1 / 0,
              maxY: -1 / 0
            },
            i = e,
            o = i.geometry,
            t = i.type;
          if ("Point" === t || "MultiPoint" === t || "LineString" === t) d(i, o);else if ("Polygon" === t || "MultiLineString" === t) for (var a = 0; a < o.length; a++) d(i, o[a]);else if ("MultiPolygon" === t) for (a = 0; a < o.length; a++) for (var s = 0; s < o[a].length; s++) d(i, o[a][s]);
          return e;
        }
        function d(e, t) {
          for (var r = 0; r < t.length; r += 3) e.minX = Math.min(e.minX, t[r]), e.minY = Math.min(e.minY, t[r + 1]), e.maxX = Math.max(e.maxX, t[r]), e.maxY = Math.max(e.maxY, t[r + 1]);
        }
        function p(e, t, r, n) {
          if (t.geometry) {
            var i = t.geometry.coordinates,
              o = t.geometry.type,
              a = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2),
              s = [],
              l = t.id;
            if (r.promoteId ? l = t.properties[r.promoteId] : r.generateId && (l = n || 0), "Point" === o) re(i, s);else if ("MultiPoint" === o) for (var c = 0; c < i.length; c++) re(i[c], s);else if ("LineString" === o) b(i, s, a, !1);else if ("MultiLineString" === o) {
              if (r.lineMetrics) {
                for (c = 0; c < i.length; c++) b(i[c], s = [], a, !1), e.push(I(l, "LineString", s, t.properties));
                return;
              }
              w(i, s, a, !1);
            } else if ("Polygon" === o) w(i, s, a, !0);else {
              if ("MultiPolygon" !== o) {
                if ("GeometryCollection" !== o) throw new Error("Input data is not a valid GeoJSON object.");
                for (c = 0; c < t.geometry.geometries.length; c++) p(e, {
                  id: l,
                  geometry: t.geometry.geometries[c],
                  properties: t.properties
                }, r, n);
                return;
              }
              for (c = 0; c < i.length; c++) {
                var u = [];
                w(i[c], u, a, !0), s.push(u);
              }
            }
            e.push(I(l, o, s, t.properties));
          }
        }
        function re(e, t) {
          t.push(ne(e[0])), t.push(ie(e[1])), t.push(0);
        }
        function b(e, t, r, n) {
          for (var i, o, a = 0, s = 0; s < e.length; s++) {
            var l = ne(e[s][0]),
              c = ie(e[s][1]);
            t.push(l), t.push(c), t.push(0), 0 < s && (a += n ? (i * c - l * o) / 2 : Math.sqrt(Math.pow(l - i, 2) + Math.pow(c - o, 2))), i = l, o = c;
          }
          var u = t.length - 3;
          t[2] = 1, E(t, 0, u, r), t[2 + u] = 1, t.size = Math.abs(a), t.start = 0, t.end = t.size;
        }
        function w(e, t, r, n) {
          for (var i = 0; i < e.length; i++) {
            var o = [];
            b(e[i], o, r, n), t.push(o);
          }
        }
        function ne(e) {
          return e / 360 + .5;
        }
        function ie(e) {
          e = Math.sin(e * Math.PI / 180), e = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI;
          return e < 0 ? 0 : 1 < e ? 1 : e;
        }
        function T(e, t, r, n, i, o, a, s) {
          if (n /= t, (r /= t) <= o && a < n) return e;
          if (a < r || n <= o) return null;
          for (var l = [], c = 0; c < e.length; c++) {
            var u = e[c],
              h = u.geometry,
              d = u.type,
              p = 0 === i ? u.minX : u.minY,
              f = 0 === i ? u.maxX : u.maxY;
            if (r <= p && f < n) l.push(u);else if (!(f < r || n <= p)) {
              var _ = [];
              if ("Point" === d || "MultiPoint" === d) {
                w = b = E = v = y = g = m = void 0;
                for (var m = h, g = _, y = r, v = n, E = i, b = 0; b < m.length; b += 3) {
                  var w = m[b + E];
                  y <= w && w <= v && (g.push(m[b]), g.push(m[b + 1]), g.push(m[b + 2]));
                }
              } else if ("LineString" === d) oe(h, _, r, n, i, !1, s.lineMetrics);else if ("MultiLineString" === d) N(h, _, r, n, i, !1);else if ("Polygon" === d) N(h, _, r, n, i, !0);else if ("MultiPolygon" === d) for (var T = 0; T < h.length; T++) {
                var S = [];
                N(h[T], S, r, n, i, !0), S.length && _.push(S);
              }
              if (_.length) if (s.lineMetrics && "LineString" === d) for (T = 0; T < _.length; T++) l.push(I(u.id, d, _[T], u.tags));else "LineString" !== d && "MultiLineString" !== d || (1 === _.length ? (d = "LineString", _ = _[0]) : d = "MultiLineString"), "Point" !== d && "MultiPoint" !== d || (d = 3 === _.length ? "Point" : "MultiPoint"), l.push(I(u.id, d, _, u.tags));
            }
          }
          return l.length ? l : null;
        }
        function oe(e, t, r, n, i, o, a) {
          for (var s, l, c = ae(e), u = 0 === i ? se : le, h = e.start, d = 0; d < e.length - 3; d += 3) {
            var p = e[d],
              f = e[d + 1],
              _ = e[d + 2],
              m = e[d + 3],
              g = e[d + 4],
              y = 0 === i ? p : f,
              v = 0 === i ? m : g,
              E = !1;
            a && (s = Math.sqrt(Math.pow(p - m, 2) + Math.pow(f - g, 2))), y < r ? r < v && (l = u(c, p, f, m, g, r), a) && (c.start = h + s * l) : n < y ? v < n && (l = u(c, p, f, m, g, n), a) && (c.start = h + s * l) : P(c, p, f, _), v < r && r <= y && (l = u(c, p, f, m, g, r), E = !0), n < v && y <= n && (l = u(c, p, f, m, g, n), E = !0), !o && E && (a && (c.end = h + s * l), t.push(c), c = ae(e)), a && (h += s);
          }
          var b = e.length - 3,
            p = e[b],
            f = e[1 + b],
            _ = e[2 + b];
          r <= (y = 0 === i ? p : f) && y <= n && P(c, p, f, _), b = c.length - 3, o && 3 <= b && (c[b] !== c[0] || c[1 + b] !== c[1]) && P(c, c[0], c[1], c[2]), c.length && t.push(c);
        }
        function ae(e) {
          var t = [];
          return t.size = e.size, t.start = e.start, t.end = e.end, t;
        }
        function N(e, t, r, n, i, o) {
          for (var a = 0; a < e.length; a++) oe(e[a], t, r, n, i, o, !1);
        }
        function P(e, t, r, n) {
          e.push(t), e.push(r), e.push(n);
        }
        function se(e, t, r, n, i, o) {
          n = (o - t) / (n - t);
          return e.push(o), e.push(r + (i - r) * n), e.push(1), n;
        }
        function le(e, t, r, n, i, o) {
          i = (o - r) / (i - r);
          return e.push(t + (n - t) * i), e.push(o), e.push(1), i;
        }
        function ce(e, t) {
          for (var r = [], n = 0; n < e.length; n++) {
            var i = e[n],
              o = i.type;
            if ("Point" === o || "MultiPoint" === o || "LineString" === o) a = D(i.geometry, t);else if ("MultiLineString" === o || "Polygon" === o) for (var a = [], s = 0; s < i.geometry.length; s++) a.push(D(i.geometry[s], t));else if ("MultiPolygon" === o) for (a = [], s = 0; s < i.geometry.length; s++) {
              for (var l = [], c = 0; c < i.geometry[s].length; c++) l.push(D(i.geometry[s][c], t));
              a.push(l);
            }
            r.push(I(i.id, o, a, i.tags));
          }
          return r;
        }
        function D(e, t) {
          var r = [];
          r.size = e.size, void 0 !== e.start && (r.start = e.start, r.end = e.end);
          for (var n = 0; n < e.length; n += 3) r.push(e[n] + t, e[n + 1], e[n + 2]);
          return r;
        }
        function ue(e, t) {
          if (!e.transformed) {
            for (var r, n = 1 << e.z, i = e.x, o = e.y, a = 0; a < e.features.length; a++) {
              var s = e.features[a],
                l = s.geometry,
                c = s.type;
              if (s.geometry = [], 1 === c) for (r = 0; r < l.length; r += 2) s.geometry.push(he(l[r], l[r + 1], t, n, i, o));else for (r = 0; r < l.length; r++) {
                for (var u = [], h = 0; h < l[r].length; h += 2) u.push(he(l[r][h], l[r][h + 1], t, n, i, o));
                s.geometry.push(u);
              }
            }
            e.transformed = !0;
          }
          return e;
        }
        function he(e, t, r, n, i, o) {
          return [Math.round(r * (e * n - i)), Math.round(r * (t * n - o))];
        }
        function de(e, t, r, n, i) {
          for (var o = t === i.maxZoom ? 0 : i.tolerance / ((1 << t) * i.extent), a = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: 0,
              source: null,
              x: r,
              y: n,
              z: t,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0
            }, s = 0; s < e.length; s++) {
            a.numFeatures++, v = y = g = m = _ = f = p = d = h = u = c = l = void 0;
            var l = a,
              c = e[s],
              u = o,
              h = i,
              d = c.geometry,
              p = c.type,
              f = [];
            if ("Point" === p || "MultiPoint" === p) for (var _ = 0; _ < d.length; _ += 3) f.push(d[_]), f.push(d[_ + 1]), l.numPoints++, l.numSimplified++;else if ("LineString" === p) R(f, d, l, u, !1, !1);else if ("MultiLineString" === p || "Polygon" === p) for (_ = 0; _ < d.length; _++) R(f, d[_], l, u, "Polygon" === p, 0 === _);else if ("MultiPolygon" === p) for (var m = 0; m < d.length; m++) {
              var g = d[m];
              for (_ = 0; _ < g.length; _++) R(f, g[_], l, u, !0, 0 === _);
            }
            if (f.length) {
              var y = c.tags || null;
              if ("LineString" === p && h.lineMetrics) {
                for (var v in y = {}, c.tags) y[v] = c.tags[v];
                y.mapbox_clip_start = d.start / d.size, y.mapbox_clip_end = d.end / d.size;
              }
              h = {
                geometry: f,
                type: "Polygon" === p || "MultiPolygon" === p ? 3 : "LineString" === p || "MultiLineString" === p ? 2 : 1,
                tags: y
              };
              null !== c.id && (h.id = c.id), l.features.push(h);
            }
            var h = e[s].minX,
              E = e[s].minY,
              b = e[s].maxX,
              w = e[s].maxY;
            h < a.minX && (a.minX = h), E < a.minY && (a.minY = E), a.maxX < b && (a.maxX = b), a.maxY < w && (a.maxY = w);
          }
          return a;
        }
        function R(e, t, r, n, i, o) {
          var a = n * n;
          if (0 < n && t.size < (i ? a : n)) r.numPoints += t.length / 3;else {
            for (var s = [], l = 0; l < t.length; l += 3) (0 === n || t[l + 2] > a) && (r.numSimplified++, s.push(t[l]), s.push(t[l + 1])), r.numPoints++;
            if (i) {
              for (var c = s, i = o, u = 0, h = 0, d = c.length, p = d - 2; h < d; p = h, h += 2) u += (c[h] - c[p]) * (c[h + 1] + c[p + 1]);
              if (0 < u === i) for (h = 0, d = c.length; h < d / 2; h += 2) {
                var f = c[h],
                  _ = c[h + 1];
                c[h] = c[d - 2 - h], c[h + 1] = c[d - 1 - h], c[d - 2 - h] = f, c[d - 1 - h] = _;
              }
            }
            e.push(s);
          }
        }
        function pe(e, t) {
          return new O(e, t);
        }
        function O(e, t) {
          var r = (t = this.options = function (e, t) {
            for (var r in t) e[r] = t[r];
            return e;
          }(Object.create(this.options), t)).debug;
          if (r && console.time("preprocess data"), t.maxZoom < 0 || 24 < t.maxZoom) throw new Error("maxZoom should be in the 0-24 range");
          if (t.promoteId && t.generateId) throw new Error("promoteId and generateId cannot be used together.");
          var n,
            i,
            o,
            a,
            s,
            e = function (e, t) {
              var r = [];
              if ("FeatureCollection" === e.type) for (var n = 0; n < e.features.length; n++) p(r, e.features[n], t, n);else "Feature" === e.type ? p(r, e, t) : p(r, {
                geometry: e
              }, t);
              return r;
            }(e, t);
          this.tiles = {}, this.tileCoords = [], r && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t.indexMaxZoom, t.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), n = e, i = (t = t).buffer / t.extent, a = T(o = n, 1, -1 - i, i, 0, -1, 2, t), s = T(n, 1, 1 - i, 2 + i, 0, -1, 2, t), (e = o = (a || s) && (o = T(n, 1, -i, 1 + i, 0, -1, 2, t) || [], a && (o = ce(a, 1).concat(o)), s) ? o.concat(ce(s, -1)) : o).length && this.splitTile(e, 0, 0, 0), r && (e.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function M(e, t, r) {
          return 32 * ((1 << e) * r + t) + e;
        }
        function k(e, t) {
          return t ? e.properties[t] : e.id;
        }
        function fe(e, t) {
          if (null == e) return 1;
          if ("Feature" === e.type) return null != k(e, t);
          if ("FeatureCollection" === e.type) {
            var r = new Set();
            for (const i of e.features) {
              var n = k(i, t);
              if (null == n) return;
              if (r.has(n)) return;
              r.add(n);
            }
            return 1;
          }
        }
        function _e(e, t) {
          var r = new Map();
          if (null != e) if ("Feature" === e.type) r.set(k(e, t), e);else for (const n of e.features) r.set(k(n, t), n);
          return r;
        }
        function me(t, e, r) {
          if (e.removeAll && t.clear(), e.remove) for (const l of e.remove) t.delete(l);
          if (e.add) for (const c of e.add) {
            var n = k(c, r);
            null != n && t.set(n, c);
          }
          if (e.update) for (const u of e.update) {
            let e = t.get(u.id);
            if (null != e) {
              var i = u.newGeometry || u.removeAllProperties,
                o = !u.removeAllProperties && (0 < (null == (o = u.removeProperties) ? void 0 : o.length) || 0 < (null == (o = u.addOrUpdateProperties) ? void 0 : o.length));
              if ((i || o) && (e = Object.assign({}, e), t.set(u.id, e), o) && (e.properties = Object.assign({}, e.properties)), u.newGeometry && (e.geometry = u.newGeometry), u.removeAllProperties) e.properties = {};else if (0 < (null == (i = u.removeProperties) ? void 0 : i.length)) for (const h of u.removeProperties) Object.prototype.hasOwnProperty.call(e.properties, h) && delete e.properties[h];
              if (0 < (null == (i = u.addOrUpdateProperties) ? void 0 : i.length)) for (var {
                key: a,
                value: s
              } of u.addOrUpdateProperties) e.properties[a] = s;
            }
          }
        }
        O.prototype.options = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0
        }, O.prototype.splitTile = function (e, t, r, n, i, o, a) {
          for (var s = [e, t, r, n], l = this.options, c = l.debug; s.length;) {
            n = s.pop(), r = s.pop(), t = s.pop(), e = s.pop();
            var u,
              h,
              d,
              p,
              f,
              _,
              m,
              g,
              y,
              v = 1 << t,
              E = M(t, r, n),
              b = this.tiles[E];
            if (b || (1 < c && console.time("creation"), b = this.tiles[E] = de(e, t, r, n, l), this.tileCoords.push({
              z: t,
              x: r,
              y: n
            }), c && (1 < c && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t, r, n, b.numFeatures, b.numPoints, b.numSimplified), console.timeEnd("creation")), this.stats[E = "z" + t] = (this.stats[E] || 0) + 1, this.total++)), b.source = e, i) {
              if (t === l.maxZoom || t === i) continue;
              var E = 1 << i - t;
              if (r !== Math.floor(o / E) || n !== Math.floor(a / E)) continue;
            } else if (t === l.indexMaxZoom || b.numPoints <= l.indexMaxPoints) continue;
            b.source = null, 0 !== e.length && (1 < c && console.time("clipping"), u = .5 - (E = .5 * l.buffer / l.extent), d = 1 + E, m = p = f = _ = null, g = T(e, v, r - E, r + (h = .5 + E), 0, b.minX, b.maxX, l), y = T(e, v, r + u, r + d, 0, b.minX, b.maxX, l), e = null, g && (m = T(g, v, n - E, n + h, 1, b.minY, b.maxY, l), p = T(g, v, n + u, n + d, 1, b.minY, b.maxY, l), g = null), y && (f = T(y, v, n - E, n + h, 1, b.minY, b.maxY, l), _ = T(y, v, n + u, n + d, 1, b.minY, b.maxY, l), y = null), 1 < c && console.timeEnd("clipping"), s.push(m || [], t + 1, 2 * r, 2 * n), s.push(p || [], t + 1, 2 * r, 2 * n + 1), s.push(f || [], t + 1, 2 * r + 1, 2 * n), s.push(_ || [], t + 1, 2 * r + 1, 2 * n + 1));
          }
        }, O.prototype.getTile = function (e, t, r) {
          var n = this.options,
            i = n.extent,
            n = n.debug;
          if (e < 0 || 24 < e) return null;
          var o = 1 << e,
            o = M(e, t = (t % o + o) % o, r);
          if (this.tiles[o]) return ue(this.tiles[o], i);
          1 < n && console.log("drilling down to z%d-%d-%d", e, t, r);
          for (var a, s = e, l = t, c = r; !a && 0 < s;) s--, l = Math.floor(l / 2), c = Math.floor(c / 2), a = this.tiles[M(s, l, c)];
          return a && a.source && (1 < n && console.log("found parent tile z%d-%d-%d", s, l, c), 1 < n && console.time("drilling down"), this.splitTile(a.source, s, l, c, e, t, r), 1 < n && console.timeEnd("drilling down"), this.tiles[o]) ? ue(this.tiles[o], i) : null;
        };
        class ge extends t {
          constructor(e, t, r, n) {
            super(e, t, r), this._dataUpdateable = new Map(), this.loadGeoJSON = (t, i) => {
              const o = t["promoteId"];
              if (t.request) return S.getJSON(t.request, (e, t, r, n) => {
                this._dataUpdateable = fe(t, o) ? _e(t, o) : void 0, i(e, t, r, n);
              });
              if ("string" == typeof t.data) try {
                var e = JSON.parse(t.data);
                this._dataUpdateable = fe(e, o) ? _e(e, o) : void 0, i(null, e);
              } catch (e) {
                i(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
              } else t.dataDiff ? this._dataUpdateable ? (me(this._dataUpdateable, t.dataDiff, o), i(null, {
                type: "FeatureCollection",
                features: Array.from(this._dataUpdateable.values())
              })) : i(new Error("Cannot update existing geojson data in " + t.source)) : i(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
              return {
                cancel: () => {}
              };
            }, this.loadVectorData = this.loadGeoJSONTile, n && (this.loadGeoJSON = n);
          }
          loadGeoJSONTile(e, t) {
            e = e.tileID.canonical;
            if (!this._geoJSONIndex) return t(null, null);
            e = this._geoJSONIndex.getTile(e.z, e.x, e.y);
            if (!e) return t(null, null);
            e = new H(e.features);
            let r = Q(e);
            t(null, {
              vectorTile: e,
              rawData: (r = 0 === r.byteOffset && r.byteLength === r.buffer.byteLength ? r : new Uint8Array(r)).buffer
            });
          }
          loadData(i, o) {
            var e;
            null != (e = this._pendingRequest) && e.cancel(), this._pendingCallback && this._pendingCallback(null, {
              abandoned: !0
            });
            const a = !!(i && i.request && i.request.collectResourceTiming) && new S.RequestPerformance(i.request);
            this._pendingCallback = o, this._pendingRequest = this.loadGeoJSON(i, (e, t) => {
              if (delete this._pendingCallback, delete this._pendingRequest, e || !t) return o(e);
              if ("object" != typeof t) return o(new Error(`Input data given to '${i.source}' is not a valid GeoJSON object.`));
              $(t, !0);
              try {
                if (i.filter) {
                  const n = S.createExpression(i.filter, {
                    type: "boolean",
                    "property-type": "data-driven",
                    overridable: !1,
                    transition: !1
                  });
                  if ("error" === n.result) throw new Error(n.value.map(e => e.key + ": " + e.message).join(", "));
                  t = {
                    type: "FeatureCollection",
                    features: t.features.filter(e => n.value.evaluate({
                      zoom: 0
                    }, e))
                  };
                }
                this._geoJSONIndex = i.cluster ? new te(ye(i)).load(t.features) : pe(t, i.geojsonVtOptions);
              } catch (e) {
                return o(e);
              }
              this.loaded = {};
              var r,
                t = {};
              a && (r = a.finish()) && (t.resourceTiming = {}, t.resourceTiming[i.source] = JSON.parse(JSON.stringify(r))), o(null, t);
            });
          }
          reloadTile(e, t) {
            var r = this.loaded,
              n = e.uid;
            return r && r[n] ? super.reloadTile(e, t) : this.loadTile(e, t);
          }
          removeSource(e, t) {
            this._pendingCallback && this._pendingCallback(null, {
              abandoned: !0
            }), t();
          }
          getClusterExpansionZoom(e, t) {
            try {
              t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));
            } catch (e) {
              t(e);
            }
          }
          getClusterChildren(e, t) {
            try {
              t(null, this._geoJSONIndex.getChildren(e.clusterId));
            } catch (e) {
              t(e);
            }
          }
          getClusterLeaves(e, t) {
            try {
              t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));
            } catch (e) {
              t(e);
            }
          }
        }
        function ye({
          superclusterOptions: e,
          clusterProperties: t
        }) {
          if (t && e) {
            const i = {},
              o = {},
              a = {
                accumulated: null,
                zoom: 0
              },
              s = {
                properties: null
              },
              l = Object.keys(t);
            for (const c of l) {
              var [r, n] = t[c],
                n = S.createExpression(n),
                r = S.createExpression("string" == typeof r ? [r, ["accumulated"], ["get", c]] : r);
              i[c] = n.value, o[c] = r.value;
            }
            e.map = e => {
              s.properties = e;
              var t = {};
              for (const r of l) t[r] = i[r].evaluate(a, s);
              return t;
            }, e.reduce = (e, t) => {
              s.properties = t;
              for (const r of l) a.accumulated = e[r], e[r] = o[r].evaluate(a, s);
            };
          }
          return e;
        }
        class ve {
          constructor(e) {
            this.self = e, this.actor = new S.Actor(e, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = {
              vector: t,
              geojson: ge
            }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e, t) => {
              if (this.workerSourceTypes[e]) throw new Error(`Worker source with name "${e}" already registered.`);
              this.workerSourceTypes[e] = t;
            }, this.self.registerRTLTextPlugin = e => {
              if (S.plugin.isParsed()) throw new Error("RTL text plugin already registered.");
              S.plugin.applyArabicShaping = e.applyArabicShaping, S.plugin.processBidirectionalText = e.processBidirectionalText, S.plugin.processStyledBidirectionalText = e.processStyledBidirectionalText;
            };
          }
          setReferrer(e, t) {
            this.referrer = t;
          }
          setImages(e, t, r) {
            this.availableImages[e] = t;
            for (const i in this.workerSources[e]) {
              var n = this.workerSources[e][i];
              for (const o in n) n[o].availableImages = t;
            }
            r();
          }
          setLayers(e, t, r) {
            this.getLayerIndex(e).replace(t), r();
          }
          updateLayers(e, t, r) {
            this.getLayerIndex(e).update(t.layers, t.removedIds), r();
          }
          loadTile(e, t, r) {
            this.getWorkerSource(e, t.type, t.source).loadTile(t, r);
          }
          loadDEMTile(e, t, r) {
            this.getDEMWorkerSource(e, t.source).loadTile(t, r);
          }
          reloadTile(e, t, r) {
            this.getWorkerSource(e, t.type, t.source).reloadTile(t, r);
          }
          abortTile(e, t, r) {
            this.getWorkerSource(e, t.type, t.source).abortTile(t, r);
          }
          removeTile(e, t, r) {
            this.getWorkerSource(e, t.type, t.source).removeTile(t, r);
          }
          removeDEMTile(e, t) {
            this.getDEMWorkerSource(e, t.source).removeTile(t);
          }
          removeSource(e, t, r) {
            var n;
            this.workerSources[e] && this.workerSources[e][t.type] && this.workerSources[e][t.type][t.source] && (n = this.workerSources[e][t.type][t.source], delete this.workerSources[e][t.type][t.source], void 0 !== n.removeSource ? n.removeSource(t, r) : r());
          }
          loadWorkerSource(e, t, r) {
            try {
              this.self.importScripts(t.url), r();
            } catch (e) {
              r(e.toString());
            }
          }
          syncRTLPluginState(e, t, r) {
            try {
              S.plugin.setState(t);
              var n,
                i = S.plugin.getPluginURL();
              S.plugin.isLoaded() && !S.plugin.isParsed() && null != i && (this.self.importScripts(i), r((n = S.plugin.isParsed()) ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + i), n));
            } catch (e) {
              r(e.toString());
            }
          }
          getAvailableImages(e) {
            let t = this.availableImages[e];
            return t = t || [];
          }
          getLayerIndex(e) {
            let t = this.layerIndexes[e];
            return t = t || (this.layerIndexes[e] = new L());
          }
          getWorkerSource(n, e, t) {
            return this.workerSources[n] || (this.workerSources[n] = {}), this.workerSources[n][e] || (this.workerSources[n][e] = {}), this.workerSources[n][e][t] || (this.workerSources[n][e][t] = new this.workerSourceTypes[e]({
              send: (e, t, r) => {
                this.actor.send(e, t, r, n);
              }
            }, this.getLayerIndex(n), this.getAvailableImages(n))), this.workerSources[n][e][t];
          }
          getDEMWorkerSource(e, t) {
            return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new B()), this.demWorkerSources[e][t];
          }
        }
        return S.isWorker() && (self.worker = new ve(self)), ve;
      }), e(0, function (de) {
        var f,
          _,
          A = "3.6.1";
        class m {
          static testProp(t) {
            if (m.docStyle) for (let e = 0; e < t.length; e++) if (t[e] in m.docStyle) return t[e];
            return t[0];
          }
          static create(e, t, r) {
            e = window.document.createElement(e);
            return void 0 !== t && (e.className = t), r && r.appendChild(e), e;
          }
          static createNS(e, t) {
            return window.document.createElementNS(e, t);
          }
          static disableDrag() {
            m.docStyle && m.selectProp && (m.userSelect = m.docStyle[m.selectProp], m.docStyle[m.selectProp] = "none");
          }
          static enableDrag() {
            m.docStyle && m.selectProp && (m.docStyle[m.selectProp] = m.userSelect);
          }
          static setTransform(e, t) {
            e.style[m.transformProp] = t;
          }
          static addEventListener(e, t, r, n = {}) {
            "passive" in n ? e.addEventListener(t, r, n) : e.addEventListener(t, r, n.capture);
          }
          static removeEventListener(e, t, r, n = {}) {
            "passive" in n ? e.removeEventListener(t, r, n) : e.removeEventListener(t, r, n.capture);
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", m.suppressClickInternal, !0);
          }
          static suppressClick() {
            window.addEventListener("click", m.suppressClickInternal, !0), window.setTimeout(() => {
              window.removeEventListener("click", m.suppressClickInternal, !0);
            }, 0);
          }
          static getScale(e) {
            var t = e.getBoundingClientRect();
            return {
              x: t.width / e.offsetWidth || 1,
              y: t.height / e.offsetHeight || 1,
              boundingClientRect: t
            };
          }
          static mousePos(e, t) {
            var r, n;
            return e ? (n = (r = m.getScale(e)).boundingClientRect, new de.Point((t.clientX - n.left) / r.x - e.clientLeft, (t.clientY - n.top) / r.y - e.clientTop)) : new de.Point(t.clientX, t.clientY);
          }
          static touchPos(t, r) {
            var n = t.getBoundingClientRect(),
              i = [];
            for (let e = 0; e < r.length; e++) i.push(new de.Point(r[e].clientX - n.left - t.clientLeft, r[e].clientY - n.top - t.clientTop));
            return i;
          }
          static mouseButton(e) {
            return e.button;
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e);
          }
        }
        m.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, m.selectProp = m.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), m.transformProp = m.testProp(["transform", "WebkitTransform"]);
        const I = {
          supported: !1,
          testSupport: function (e) {
            !P && r && (D ? O(e) : t = e);
          }
        };
        let t,
          P = !1,
          r,
          D = !1;
        function O(e) {
          var t = e.createTexture();
          e.bindTexture(e.TEXTURE_2D, t);
          try {
            if (e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, r), e.isContextLost()) return;
            I.supported = !0;
          } catch (e) {}
          e.deleteTexture(t), P = !0;
        }
        "undefined" != typeof document && ((r = document.createElement("img")).onload = function () {
          t && O(t), t = null, D = !0;
        }, r.onerror = function () {
          P = !0, t = null;
        }, r.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        {
          var e = f = f || {};
          let i, a, r, o;
          e.resetRequestQueue = () => {
            i = [], a = 0, r = 0, o = {};
          }, e.addThrottleControl = e => {
            var t = r++;
            return o[t] = e, t;
          }, e.removeThrottleControl = e => {
            delete o[e], S();
          }, e.getImage = (e, t, r = !0) => {
            I.supported && (e.headers || (e.headers = {}), e.headers.accept = "image/webp,*/*");
            const n = {
              requestParameters: e,
              supportImageRefresh: r,
              callback: t,
              cancelled: !1,
              completed: !1,
              cancel: () => {
                n.completed || n.cancelled || (n.cancelled = !0, n.innerRequest && (n.innerRequest.cancel(), a--), S());
              }
            };
            return i.push(n), S(), n;
          };
          const Ji = (e, r, t, n, i, o) => {
              t ? r(t) : n instanceof HTMLImageElement || de.isImageBitmap(n) ? r(null, n) : n && (t = n, n = (e, t) => {
                null != e ? r(e) : null != t && r(null, t, {
                  cacheControl: i,
                  expires: o
                });
              }, "function" == typeof createImageBitmap ? de.arrayBufferToImageBitmap(t, n) : de.arrayBufferToImage(t, n)), e.cancelled || (e.completed = !0, a--, S());
            },
            S = () => {
              var t = (() => {
                var e = Object.keys(o);
                let t = !1;
                if (0 < e.length) for (const r of e) if (t = o[r]()) break;
                return t;
              })() ? de.config.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : de.config.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let e = a; e < t && 0 < i.length; e++) {
                var r,
                  n = i.shift();
                n.cancelled ? e-- : (r = (i => {
                  const {
                    requestParameters: e,
                    supportImageRefresh: t,
                    callback: o
                  } = i;
                  return de.extend(e, {
                    type: "image"
                  }), (!1 === t && !de.isWorker() && !de.getProtocolAction(e.url) && (!e.headers || Object.keys(e.headers).reduce((e, t) => e && "accept" === t, !0)) ? Qi : de.makeRequest)(e, (e, t, r, n) => {
                    Ji(i, o, e, t, r, n);
                  });
                })(n), a++, n.innerRequest = r);
              }
            },
            Qi = (e, t) => {
              const r = new Image();
              var n = e.url;
              let i = !1;
              e = e.credentials;
              return e && "include" === e ? r.crossOrigin = "use-credentials" : (e && "same-origin" === e || !de.sameOrigin(n)) && (r.crossOrigin = "anonymous"), r.fetchPriority = "high", r.onload = () => {
                t(null, r), r.onerror = r.onload = null;
              }, r.onerror = () => {
                i || t(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")), r.onerror = r.onload = null;
              }, r.src = n, {
                cancel: () => {
                  i = !0, r.src = "";
                }
              };
            };
        }
        f.resetRequestQueue(), (e = _ = _ || {}).Glyphs = "Glyphs", e.Image = "Image", e.Source = "Source", e.SpriteImage = "SpriteImage", e.SpriteJSON = "SpriteJSON", e.Style = "Style", e.Tile = "Tile", e.Unknown = "Unknown";
        class M {
          constructor(e) {
            this._transformRequestFn = e;
          }
          transformRequest(e, t) {
            return this._transformRequestFn && this._transformRequestFn(e, t) || {
              url: e
            };
          }
          normalizeSpriteURL(e, t, r) {
            e = L(e);
            return e.path += "" + t + r, B(e);
          }
          setTransformRequest(e) {
            this._transformRequestFn = e;
          }
        }
        const k = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function L(e) {
          var t = e.match(k);
          if (t) return {
            protocol: t[1],
            authority: t[2],
            path: t[3] || "/",
            params: t[4] ? t[4].split("&") : []
          };
          throw new Error(`Unable to parse URL "${e}"`);
        }
        function B(e) {
          var t = e.params.length ? "?" + e.params.join("&") : "";
          return e.protocol + "://" + e.authority + e.path + t;
        }
        function $(e) {
          var t = [];
          if ("string" == typeof e) t.push({
            id: "default",
            url: e
          });else if (e && 0 < e.length) {
            var r,
              n,
              i = [];
            for ({
              id: r,
              url: n
            } of e) {
              var o = "" + r + n;
              -1 === i.indexOf(o) && (i.push(o), t.push({
                id: r,
                url: n
              }));
            }
          }
          return t;
        }
        function z(e, t, r, n) {
          e = $(e);
          const i = e.length;
          var o = 1 < r ? "@2x" : "";
          const a = {},
            s = {},
            l = {};
          for (const {
            id: u,
            url: h
          } of e) {
            var c = t.transformRequest(t.normalizeSpriteURL(h, o, ".json"), _.SpriteJSON);
            const d = u + "_" + c.url;
            a[d] = de.getJSON(c, (e, t) => {
              delete a[d], s[u] = t, Y(n, s, l, e, i);
            });
            c = t.transformRequest(t.normalizeSpriteURL(h, o, ".png"), _.SpriteImage);
            const p = u + "_" + c.url;
            a[p] = f.getImage(c, (e, t) => {
              delete a[p], l[u] = t, Y(n, s, l, e, i);
            });
          }
          return {
            cancel() {
              for (const e of Object.values(a)) e.cancel();
            }
          };
        }
        function Y(e, t, r, n, i) {
          if (n) e(n);else if (i === Object.values(t).length && i === Object.values(r).length) {
            var o = {};
            for (const y in t) {
              o[y] = {};
              var a = de.browser.getImageCanvasContext(r[y]),
                s = t[y];
              for (const v in s) {
                var {
                  width: l,
                  height: c,
                  x: u,
                  y: h,
                  sdf: d,
                  pixelRatio: p,
                  stretchX: f,
                  stretchY: _,
                  content: m,
                  contentMatch: g
                } = s[v];
                o[y][v] = {
                  data: null,
                  pixelRatio: p,
                  sdf: d,
                  stretchX: f,
                  stretchY: _,
                  content: m,
                  spriteData: {
                    width: l,
                    height: c,
                    x: u,
                    y: h,
                    context: a
                  },
                  contentMatch: g
                };
              }
            }
            e(null, o);
          }
        }
        class U {
          constructor(e, t, r, n) {
            this.context = e, this.format = r, this.texture = e.gl.createTexture(), this.update(t, n);
          }
          update(e, t, r) {
            var {
                width: n,
                height: i
              } = e,
              o = !(this.size && this.size[0] === n && this.size[1] === i || r),
              a = this["context"],
              s = a["gl"];
            this.useMipmap = Boolean(t && t.useMipmap), s.bindTexture(s.TEXTURE_2D, this.texture), a.pixelStoreUnpackFlipY.set(!1), a.pixelStoreUnpack.set(1), a.pixelStoreUnpackPremultiplyAlpha.set(this.format === s.RGBA && (!t || !1 !== t.premultiply)), o ? (this.size = [n, i], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || de.isImageBitmap(e) ? s.texImage2D(s.TEXTURE_2D, 0, this.format, this.format, s.UNSIGNED_BYTE, e) : s.texImage2D(s.TEXTURE_2D, 0, this.format, n, i, 0, this.format, s.UNSIGNED_BYTE, e.data)) : (({
              x: a,
              y: t
            } = r || {
              x: 0,
              y: 0
            }), e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || de.isImageBitmap(e) ? s.texSubImage2D(s.TEXTURE_2D, 0, a, t, s.RGBA, s.UNSIGNED_BYTE, e) : s.texSubImage2D(s.TEXTURE_2D, 0, a, t, n, i, s.RGBA, s.UNSIGNED_BYTE, e.data)), this.useMipmap && this.isSizePowerOfTwo() && s.generateMipmap(s.TEXTURE_2D);
          }
          bind(e, t, r) {
            var n = this["context"],
              n = n["gl"];
            n.bindTexture(n.TEXTURE_2D, this.texture), r !== n.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r = n.LINEAR), e !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, r || e), this.filter = e), t !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, t), this.wrap = t);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            var e = this.context["gl"];
            e.deleteTexture(this.texture), this.texture = null;
          }
        }
        class H extends de.Evented {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new de.RGBAImage({
              width: 1,
              height: 1
            }), this.dirty = !0;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e)) {
              for (var {
                ids: t,
                callback: r
              } of this.requestors) this._notify(t, r);
              this.requestors = [];
            }
          }
          getImage(e) {
            var t,
              e = this.images[e];
            return e && !e.data && e.spriteData && (t = e.spriteData, e.data = new de.RGBAImage({
              width: t.width,
              height: t.height
            }, t.context.getImageData(t.x, t.y, t.width, t.height).data), e.spriteData = null), e;
          }
          addImage(e, t) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, t) && (this.images[e] = t);
          }
          _validate(e, t) {
            let r = !0;
            var n = t.data || t.spriteData;
            return this._validateStretch(t.stretchX, n && n.width) || (this.fire(new de.ErrorEvent(new Error(`Image "${e}" has invalid "stretchX" value`))), r = !1), this._validateStretch(t.stretchY, n && n.height) || (this.fire(new de.ErrorEvent(new Error(`Image "${e}" has invalid "stretchY" value`))), r = !1), this._validateContent(t.content, t) || (this.fire(new de.ErrorEvent(new Error(`Image "${e}" has invalid "content" value`))), r = !1), r;
          }
          _validateStretch(t, r) {
            if (t) {
              let e = 0;
              for (const n of t) {
                if (n[0] < e || n[1] < n[0] || r < n[1]) return !1;
                e = n[1];
              }
            }
            return !0;
          }
          _validateContent(e, t) {
            var r, n;
            return !e || 4 === e.length && (r = (n = t.spriteData) && n.width || t.data.width, n = n && n.height || t.data.height, !(e[0] < 0 || r < e[0] || e[1] < 0 || n < e[1] || e[2] < 0 || r < e[2] || e[3] < 0 || n < e[3] || e[2] < e[0] || e[3] < e[1]));
          }
          updateImage(e, t, r = !0) {
            var n = this.getImage(e);
            if (r && (n.data.width !== t.data.width || n.data.height !== t.data.height)) throw new Error(`size mismatch between old image (${n.data.width}x${n.data.height}) and new image (${t.data.width}x${t.data.height}).`);
            t.version = n.version + 1, this.images[e] = t, this.updatedImages[e] = !0;
          }
          removeImage(e) {
            var t = this.images[e];
            delete this.images[e], delete this.patterns[e], t.userImage && t.userImage.onRemove && t.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e, t) {
            let r = !0;
            if (!this.isLoaded()) for (const n of e) this.images[n] || (r = !1);
            this.isLoaded() || r ? this._notify(e, t) : this.requestors.push({
              ids: e,
              callback: t
            });
          }
          _notify(e, t) {
            var r = {};
            for (const n of e) {
              let e = this.getImage(n);
              e || (this.fire(new de.Event("styleimagemissing", {
                id: n
              })), e = this.getImage(n)), e ? r[n] = {
                data: e.data.clone(),
                pixelRatio: e.pixelRatio,
                sdf: e.sdf,
                version: e.version,
                stretchX: e.stretchX,
                stretchY: e.stretchY,
                content: e.content,
                contentMatch: e.contentMatch,
                hasRenderCallback: Boolean(e.userImage && e.userImage.render)
              } : de.warnOnce(`Image "${n}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            t(null, r);
          }
          getPixelSize() {
            var {
              width: e,
              height: t
            } = this.atlasImage;
            return {
              width: e,
              height: t
            };
          }
          getPattern(e) {
            var t = this.patterns[e],
              r = this.getImage(e);
            return r ? (t && t.position.version === r.version ? t : (t ? t.position.version = r.version : (t = {
              w: r.data.width + 2,
              h: r.data.height + 2,
              x: 0,
              y: 0
            }, r = new de.ImagePosition(t, r), this.patterns[e] = {
              bin: t,
              position: r
            }), this._updatePatternAtlas(), this.patterns[e])).position : null;
          }
          bind(e) {
            var t = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new U(e, this.atlasImage, t.RGBA), this.atlasTexture.bind(t.LINEAR, t.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            var e = [];
            for (const s in this.patterns) e.push(this.patterns[s].bin);
            const {
              w: t,
              h: r
            } = de.potpack(e);
            var n = this.atlasImage;
            n.resize({
              width: t || 1,
              height: r || 1
            });
            for (const l in this.patterns) {
              var i = this.patterns[l]["bin"],
                o = i.x + 1,
                i = i.y + 1,
                a = this.getImage(l).data;
              const t = a.width,
                r = a.height;
              de.RGBAImage.copy(a, n, {
                x: 0,
                y: 0
              }, {
                x: o,
                y: i
              }, {
                width: t,
                height: r
              }), de.RGBAImage.copy(a, n, {
                x: 0,
                y: r - 1
              }, {
                x: o,
                y: i - 1
              }, {
                width: t,
                height: 1
              }), de.RGBAImage.copy(a, n, {
                x: 0,
                y: 0
              }, {
                x: o,
                y: i + r
              }, {
                width: t,
                height: 1
              }), de.RGBAImage.copy(a, n, {
                x: t - 1,
                y: 0
              }, {
                x: o - 1,
                y: i
              }, {
                width: 1,
                height: r
              }), de.RGBAImage.copy(a, n, {
                x: 0,
                y: 0
              }, {
                x: o + t,
                y: i
              }, {
                width: 1,
                height: r
              });
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e) {
            for (const r of e) {
              var t;
              this.callbackDispatchedThisFrame[r] || (this.callbackDispatchedThisFrame[r] = !0, (t = this.getImage(r)) || de.warnOnce(`Image with ID: "${r}" was not found`), de.renderStyleImage(t) && this.updateImage(r, t));
            }
          }
        }
        const y = 1e20;
        function j(t, r, n, i, o, a, s, l, c) {
          for (let e = r; e < r + i; e++) G(t, n * a + e, a, o, s, l, c);
          for (let e = n; e < n + o; e++) G(t, e * a + r, 1, i, s, l, c);
        }
        function G(n, i, o, a, s, l, c) {
          c[l[0] = 0] = -y, c[1] = y, s[0] = n[i];
          for (let e = 1, t = 0, r = 0; e < a; e++) {
            s[e] = n[i + e * o];
            var u = e * e;
            do {
              var h = l[t];
              r = (s[e] - s[h] + u - h * h) / (e - h) / 2;
            } while (r <= c[t] && -1 < --t);
            l[++t] = e, c[t] = r, c[t + 1] = y;
          }
          for (let e = 0, t = 0; e < a; e++) {
            for (; c[t + 1] < e;) t++;
            var r = l[t],
              d = e - r;
            n[i + e * o] = s[r] + d * d;
          }
        }
        class l {
          constructor(e, t) {
            this.requestManager = e, this.localIdeographFontFamily = t, this.entries = {};
          }
          setURL(e) {
            this.url = e;
          }
          getGlyphs(e, a) {
            var t = [];
            for (const r in e) for (const n of e[r]) t.push({
              stack: r,
              id: n
            });
            de.asyncAll(t, ({
              stack: r,
              id: n
            }, o) => {
              let a = this.entries[r];
              var e = (a = a || (this.entries[r] = {
                glyphs: {},
                requests: {},
                ranges: {}
              })).glyphs[n];
              if (void 0 !== e) o(null, {
                stack: r,
                id: n,
                glyph: e
              });else if (e = this._tinySDF(a, r, n)) a.glyphs[n] = e, o(null, {
                stack: r,
                id: n,
                glyph: e
              });else {
                const s = Math.floor(n / 256);
                if (65535 < 256 * s) o(new Error("glyphs > 65535 not supported"));else if (a.ranges[s]) o(null, {
                  stack: r,
                  id: n,
                  glyph: e
                });else if (this.url) {
                  let i = a.requests[s];
                  i || (i = a.requests[s] = [], l.loadGlyphRange(r, s, this.url, this.requestManager, (e, t) => {
                    if (t) {
                      for (const r in t) this._doesCharSupportLocalGlyph(+r) || (a.glyphs[+r] = t[+r]);
                      a.ranges[s] = !0;
                    }
                    for (const n of i) n(e, t);
                    delete a.requests[s];
                  })), i.push((e, t) => {
                    e ? o(e) : t && o(null, {
                      stack: r,
                      id: n,
                      glyph: t[n] || null
                    });
                  });
                } else o(new Error("glyphsUrl is not set"));
              }
            }, (e, t) => {
              if (e) a(e);else if (t) {
                var r,
                  n,
                  i,
                  o = {};
                for ({
                  stack: r,
                  id: n,
                  glyph: i
                } of t) (o[r] || (o[r] = {}))[n] = i && {
                  id: i.id,
                  bitmap: i.bitmap.clone(),
                  metrics: i.metrics
                };
                a(null, o);
              }
            });
          }
          _doesCharSupportLocalGlyph(e) {
            return !!this.localIdeographFontFamily && (de.unicodeBlockLookup["CJK Unified Ideographs"](e) || de.unicodeBlockLookup["Hangul Syllables"](e) || de.unicodeBlockLookup.Hiragana(e) || de.unicodeBlockLookup.Katakana(e));
          }
          _tinySDF(r, n, e) {
            var i = this.localIdeographFontFamily;
            if (i && this._doesCharSupportLocalGlyph(e)) {
              let t = r.tinySDF;
              if (!t) {
                let e = "400";
                /bold/i.test(n) ? e = "900" : /medium/i.test(n) ? e = "500" : /light/i.test(n) && (e = "200"), t = r.tinySDF = new l.TinySDF({
                  fontSize: 48,
                  buffer: 6,
                  radius: 16,
                  cutoff: .25,
                  fontFamily: i,
                  fontWeight: e
                });
              }
              n = t.draw(String.fromCharCode(e));
              return {
                id: e,
                bitmap: new de.AlphaImage({
                  width: n.width || 60,
                  height: n.height || 60
                }, n.data),
                metrics: {
                  width: n.glyphWidth / 2 || 24,
                  height: n.glyphHeight / 2 || 24,
                  left: n.glyphLeft / 2 + .5 || 0,
                  top: n.glyphTop / 2 - 27.5 || -8,
                  advance: n.glyphAdvance / 2 || 24,
                  isDoubleResolution: !0
                }
              };
            }
          }
        }
        l.loadGlyphRange = function (e, t, r, n, i) {
          var o = 255 + (t = 256 * t),
            n = n.transformRequest(r.replace("{fontstack}", e).replace("{range}", t + "-" + o), _.Glyphs);
          de.getArrayBuffer(n, (e, t) => {
            if (e) i(e);else if (t) {
              var r = {};
              for (const n of de.parseGlyphPbf(t)) r[n.id] = n;
              i(null, r);
            }
          });
        }, l.TinySDF = class {
          constructor({
            fontSize: e = 24,
            buffer: t = 3,
            radius: r = 8,
            cutoff: n = .25,
            fontFamily: i = "sans-serif",
            fontWeight: o = "normal",
            fontStyle: a = "normal"
          } = {}) {
            this.buffer = t, this.cutoff = n, this.radius = r;
            n = this.size = e + 4 * t, r = this._createCanvas(n), t = this.ctx = r.getContext("2d", {
              willReadFrequently: !0
            });
            t.font = a + ` ${o} ${e}px ` + i, t.textBaseline = "alphabetic", t.textAlign = "left", t.fillStyle = "black", this.gridOuter = new Float64Array(n * n), this.gridInner = new Float64Array(n * n), this.f = new Float64Array(n), this.z = new Float64Array(n + 1), this.v = new Uint16Array(n);
          }
          _createCanvas(e) {
            var t = document.createElement("canvas");
            return t.width = t.height = e, t;
          }
          draw(e) {
            var {
                width: t,
                actualBoundingBoxAscent: r,
                actualBoundingBoxDescent: n,
                actualBoundingBoxLeft: i,
                actualBoundingBoxRight: o
              } = this.ctx.measureText(e),
              r = Math.ceil(r),
              a = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o - i))),
              s = Math.min(this.size - this.buffer, r + Math.ceil(n)),
              l = a + 2 * this.buffer,
              o = s + 2 * this.buffer,
              c = Math.max(l * o, 0),
              u = new Uint8ClampedArray(c),
              i = {
                data: u,
                width: l,
                height: o,
                glyphWidth: a,
                glyphHeight: s,
                glyphTop: r,
                glyphLeft: 0,
                glyphAdvance: t
              };
            if (0 !== a && 0 !== s) {
              var {
                  ctx: n,
                  buffer: h,
                  gridInner: d,
                  gridOuter: p
                } = this,
                f = (n.clearRect(h, h, a, s), n.fillText(e, h, h + r), n.getImageData(h, h, a, s));
              p.fill(y, 0, c), d.fill(0, 0, c);
              for (let t = 0; t < s; t++) for (let e = 0; e < a; e++) {
                var _,
                  m = f.data[4 * (t * a + e) + 3] / 255;
                0 != m && (_ = (t + h) * l + e + h, 1 == m ? (p[_] = 0, d[_] = y) : (p[_] = 0 < (m = .5 - m) ? m * m : 0, d[_] = m < 0 ? m * m : 0));
              }
              j(p, 0, 0, l, o, l, this.f, this.v, this.z), j(d, h, h, a, s, l, this.f, this.v, this.z);
              for (let e = 0; e < c; e++) {
                var g = Math.sqrt(p[e]) - Math.sqrt(d[e]);
                u[e] = Math.round(255 - 255 * (g / this.radius + this.cutoff));
              }
            }
            return i;
          }
        };
        class q {
          constructor() {
            this.specification = de.v8Spec.light.position;
          }
          possiblyEvaluate(e, t) {
            return de.sphericalToCartesian(e.expression.evaluate(t));
          }
          interpolate(e, t, r) {
            return {
              x: de.interpolate.number(e.x, t.x, r),
              y: de.interpolate.number(e.y, t.y, r),
              z: de.interpolate.number(e.z, t.z, r)
            };
          }
        }
        const V = "-transition";
        let K;
        class W extends de.Evented {
          constructor(e) {
            super(), K = K || new de.Properties({
              anchor: new de.DataConstantProperty(de.v8Spec.light.anchor),
              position: new q(),
              color: new de.DataConstantProperty(de.v8Spec.light.color),
              intensity: new de.DataConstantProperty(de.v8Spec.light.intensity)
            }), this._transitionable = new de.Transitionable(K), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e, t = {}) {
            if (!this._validate(de.validateLight, e, t)) for (const n in e) {
              var r = e[n];
              n.endsWith(V) ? this._transitionable.setTransition(n.slice(0, -V.length), r) : this._transitionable.setValue(n, r);
            }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, t, r) {
            return (!r || !1 !== r.validate) && de.emitValidationErrors(this, e.call(de.validateStyle, de.extend({
              value: t,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: de.v8Spec
            })));
          }
        }
        class Z {
          constructor(e, t) {
            this.width = e, this.height = t, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(e, t) {
            var r = e.join(",") + String(t);
            return this.dashEntry[r] || (this.dashEntry[r] = this.addDash(e, t)), this.dashEntry[r];
          }
          getDashRanges(t, e, r) {
            var n = [],
              i = t.length % 2 == 1 ? -t[t.length - 1] * r : 0,
              o = t[0] * r;
            let a = !0,
              s = (n.push({
                left: i,
                right: o,
                isDash: a,
                zeroLength: 0 === t[0]
              }), t[0]);
            for (let e = 1; e < t.length; e++) {
              a = !a;
              var l = t[e],
                i = s * r,
                o = (s += l) * r;
              n.push({
                left: i,
                right: o,
                isDash: a,
                zeroLength: 0 === l
              });
            }
            return n;
          }
          addRoundDash(o, e, a) {
            var s = e / 2;
            for (let i = -a; i <= a; i++) {
              var t = this.nextRow + a + i,
                l = this.width * t;
              let r = 0,
                n = o[r];
              for (let t = 0; t < this.width; t++) {
                1 < t / n.right && (n = o[++r]);
                var c = Math.abs(t - n.left),
                  u = Math.abs(t - n.right),
                  c = Math.min(c, u);
                let e;
                var h,
                  u = i / a * (1 + s);
                e = n.isDash ? (h = s - Math.abs(u), Math.sqrt(c * c + h * h)) : s - Math.sqrt(c * c + u * u), this.data[l + t] = Math.max(0, Math.min(255, e + 128));
              }
            }
          }
          addRegularDash(t) {
            for (let e = t.length - 1; 0 <= e; --e) {
              var r = t[e],
                n = t[e + 1];
              r.zeroLength ? t.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left, t.splice(e, 1));
            }
            var e = t[0],
              i = t[t.length - 1],
              o = (e.isDash === i.isDash && (e.left = i.left - this.width, i.right = e.right + this.width), this.width * this.nextRow);
            let a = 0,
              s = t[a];
            for (let e = 0; e < this.width; e++) {
              1 < e / s.right && (s = t[++a]);
              var l = Math.abs(e - s.left),
                c = Math.abs(e - s.right),
                l = Math.min(l, c),
                c = s.isDash ? l : -l;
              this.data[o + e] = Math.max(0, Math.min(255, c + 128));
            }
          }
          addDash(t, e) {
            var r,
              n,
              i = e ? 7 : 0,
              o = 2 * i + 1;
            if (this.nextRow + o > this.height) return de.warnOnce("LineAtlas out of space"), null;
            let a = 0;
            for (let e = 0; e < t.length; e++) a += t[e];
            0 !== a && (r = this.width / a, n = this.getDashRanges(t, this.width, r), e ? this.addRoundDash(n, r, i) : this.addRegularDash(n));
            e = {
              y: (this.nextRow + i + .5) / this.height,
              height: 2 * i / this.height,
              width: a
            };
            return this.nextRow += o, this.dirty = !0, e;
          }
          bind(e) {
            e = e.gl;
            this.texture ? (e.bindTexture(e.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, this.width, this.height, e.ALPHA, e.UNSIGNED_BYTE, this.data))) : (this.texture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, this.texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, this.width, this.height, 0, e.ALPHA, e.UNSIGNED_BYTE, this.data));
          }
        }
        class X {
          constructor(e, t, r) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = r;
            var n = this.workerPool.acquire(r);
            for (let e = 0; e < n.length; e++) {
              var i = n[e],
                i = new de.Actor(i, t, r);
              i.name = "Worker " + e, this.actors.push(i);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(r, n, e) {
            de.asyncAll(this.actors, (e, t) => {
              e.send(r, n, t);
            }, e = e || function () {});
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(e = !0) {
            this.actors.forEach(e => {
              e.remove();
            }), this.actors = [], e && this.workerPool.release(this.id);
          }
        }
        function J(r, e, n) {
          function t(e, t) {
            if (e) return n(e);
            t && (e = de.pick(de.extend(t, r), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]), t.vector_layers && (e.vectorLayers = t.vector_layers, e.vectorLayerIds = e.vectorLayers.map(e => e.id)), n(null, e));
          }
          return r.url ? de.getJSON(e.transformRequest(r.url, _.Source), t) : de.browser.frame(() => t(null, r));
        }
        class a {
          constructor(e, t) {
            e && (t ? this.setSouthWest(e).setNorthEast(t) : Array.isArray(e) && (4 === e.length ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
          }
          setNorthEast(e) {
            return this._ne = e instanceof de.LngLat ? new de.LngLat(e.lng, e.lat) : de.LngLat.convert(e), this;
          }
          setSouthWest(e) {
            return this._sw = e instanceof de.LngLat ? new de.LngLat(e.lng, e.lat) : de.LngLat.convert(e), this;
          }
          extend(e) {
            var t,
              r = this._sw,
              n = this._ne;
            let i, o;
            if (e instanceof de.LngLat) i = e, o = e;else {
              if (!(e instanceof a)) return Array.isArray(e) ? 4 === e.length || e.every(Array.isArray) ? (t = e, this.extend(a.convert(t))) : this.extend(de.LngLat.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(de.LngLat.convert(e)) : this;
              if (i = e._sw, o = e._ne, !i || !o) return this;
            }
            return r || n ? (r.lng = Math.min(i.lng, r.lng), r.lat = Math.min(i.lat, r.lat), n.lng = Math.max(o.lng, n.lng), n.lat = Math.max(o.lat, n.lat)) : (this._sw = new de.LngLat(i.lng, i.lat), this._ne = new de.LngLat(o.lng, o.lat)), this;
          }
          getCenter() {
            return new de.LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new de.LngLat(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new de.LngLat(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e) {
            var {
                lng: e,
                lat: t
              } = de.LngLat.convert(e),
              t = this._sw.lat <= t && t <= this._ne.lat;
            let r = this._sw.lng <= e && e <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (r = this._sw.lng >= e && e >= this._ne.lng), t && r;
          }
          static convert(e) {
            return e instanceof a ? e : e && new a(e);
          }
          static fromLngLat(e, t = 0) {
            var t = 360 * t / 40075017,
              r = t / Math.cos(Math.PI / 180 * e.lat);
            return new a(new de.LngLat(e.lng - r, e.lat - t), new de.LngLat(e.lng + r, e.lat + t));
          }
        }
        class Q {
          constructor(e, t, r) {
            this.bounds = a.convert(this.validateBounds(e)), this.minzoom = t || 0, this.maxzoom = r || 24;
          }
          validateBounds(e) {
            return Array.isArray(e) && 4 === e.length ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
          }
          contains(e) {
            var t = Math.pow(2, e.z);
            const r = Math.floor(de.mercatorXfromLng(this.bounds.getWest()) * t),
              n = Math.floor(de.mercatorYfromLat(this.bounds.getNorth()) * t),
              i = Math.ceil(de.mercatorXfromLng(this.bounds.getEast()) * t),
              o = Math.ceil(de.mercatorYfromLat(this.bounds.getSouth()) * t);
            return e.x >= r && e.x < i && e.y >= n && e.y < o;
          }
        }
        class ee extends de.Evented {
          constructor(e, t, r, n) {
            if (super(), this.load = () => {
              this._loaded = !1, this.fire(new de.Event("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = J(this._options, this.map._requestManager, (e, t) => {
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e ? this.fire(new de.ErrorEvent(e)) : t && (de.extend(this, t), t.bounds && (this.tileBounds = new Q(t.bounds, this.minzoom, this.maxzoom)), this.fire(new de.Event("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new de.Event("data", {
                  dataType: "source",
                  sourceDataType: "content"
                })));
              });
            }, this.serialize = () => de.extend({}, this._options), this.id = e, this.dispatcher = r, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, de.extend(this, de.pick(t, ["url", "scheme", "tileSize", "promoteId"])), this._options = de.extend({
              type: "vector"
            }, t), this._collectResourceTiming = t.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(n);
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.cancel(), e(), this.load();
          }
          setTiles(e) {
            return this.setSourceProperty(() => {
              this._options.tiles = e;
            }), this;
          }
          setUrl(e) {
            return this.setSourceProperty(() => {
              this.url = e, this._options.url = e;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          loadTile(r, n) {
            var e = r.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
              e = {
                request: this.map._requestManager.transformRequest(e, _.Tile),
                uid: r.uid,
                tileID: r.tileID,
                zoom: r.tileID.overscaledZ,
                tileSize: this.tileSize * r.tileID.overscaleFactor(),
                type: this.type,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId
              };
            function t(e, t) {
              return delete r.request, r.aborted ? n(null) : e && 404 !== e.status ? n(e) : (t && t.resourceTiming && (r.resourceTiming = t.resourceTiming), this.map._refreshExpiredTiles && t && r.setExpiryData(t), r.loadVectorData(t, this.map.painter), n(null), void (r.reloadCallback && (this.loadTile(r, r.reloadCallback), r.reloadCallback = null)));
            }
            e.request.collectResourceTiming = this._collectResourceTiming, r.actor && "expired" !== r.state ? "loading" === r.state ? r.reloadCallback = n : r.request = r.actor.send("reloadTile", e, t.bind(this)) : (r.actor = this.dispatcher.getActor(), r.request = r.actor.send("loadTile", e, t.bind(this)));
          }
          abortTile(e) {
            e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send("abortTile", {
              uid: e.uid,
              type: this.type,
              source: this.id
            }, void 0);
          }
          unloadTile(e) {
            e.unloadVectorData(), e.actor && e.actor.send("removeTile", {
              uid: e.uid,
              type: this.type,
              source: this.id
            }, void 0);
          }
          hasTransition() {
            return !1;
          }
        }
        class te extends de.Evented {
          constructor(e, t, r, n) {
            super(), this.id = e, this.dispatcher = r, this.setEventedParent(n), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = de.extend({
              type: "raster"
            }, t), de.extend(this, de.pick(t, ["url", "scheme", "tileSize"]));
          }
          load() {
            this._loaded = !1, this.fire(new de.Event("dataloading", {
              dataType: "source"
            })), this._tileJSONRequest = J(this._options, this.map._requestManager, (e, t) => {
              this._tileJSONRequest = null, this._loaded = !0, e ? this.fire(new de.ErrorEvent(e)) : t && (de.extend(this, t), t.bounds && (this.tileBounds = new Q(t.bounds, this.minzoom, this.maxzoom)), this.fire(new de.Event("data", {
                dataType: "source",
                sourceDataType: "metadata"
              })), this.fire(new de.Event("data", {
                dataType: "source",
                sourceDataType: "content"
              })));
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.cancel(), e(), this.load();
          }
          setTiles(e) {
            return this.setSourceProperty(() => {
              this._options.tiles = e;
            }), this;
          }
          serialize() {
            return de.extend({}, this._options);
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(n, i) {
            var e = n.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            n.request = f.getImage(this.map._requestManager.transformRequest(e, _.Tile), (e, t, r) => {
              delete n.request, n.aborted ? (n.state = "unloaded", i(null)) : e ? (n.state = "errored", i(e)) : t && (this.map._refreshExpiredTiles && r && n.setExpiryData(r), r = (e = this.map.painter.context).gl, n.texture = this.map.painter.getTileTexture(t.width), n.texture ? n.texture.update(t, {
                useMipmap: !0
              }) : (n.texture = new U(e, t, r.RGBA, {
                useMipmap: !0
              }), n.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE, r.LINEAR_MIPMAP_NEAREST), e.extTextureFilterAnisotropic && r.texParameterf(r.TEXTURE_2D, e.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e.extTextureFilterAnisotropicMax)), n.state = "loaded", i(null));
            }, this.map._refreshExpiredTiles);
          }
          abortTile(e, t) {
            e.request && (e.request.cancel(), delete e.request), t();
          }
          unloadTile(e, t) {
            e.texture && this.map.painter.saveTileTexture(e.texture), t();
          }
          hasTransition() {
            return !1;
          }
        }
        class re extends te {
          constructor(e, t, r, n) {
            super(e, t, r, n), this.type = "raster-dem", this.maxzoom = 22, this._options = de.extend({
              type: "raster-dem"
            }, t), this.encoding = t.encoding || "mapbox", this.redFactor = t.redFactor, this.greenFactor = t.greenFactor, this.blueFactor = t.blueFactor, this.baseShift = t.baseShift;
          }
          loadTile(i, o) {
            var e = i.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
              e = this.map._requestManager.transformRequest(e, _.Tile);
            function a(e, t) {
              e && (i.state = "errored", o(e)), t && (i.dem = t, i.needsHillshadePrepare = !0, i.needsTerrainPrepare = !0, i.state = "loaded", o(null));
            }
            i.neighboringTiles = this._getNeighboringTiles(i.tileID), i.request = f.getImage(e, (t, r, n) => de.__awaiter(this, void 0, void 0, function* () {
              var e;
              delete i.request, i.aborted ? (i.state = "unloaded", o(null)) : t ? (i.state = "errored", o(t)) : r && (this.map._refreshExpiredTiles && i.setExpiryData(n), e = de.isImageBitmap(r) && de.offscreenCanvasSupported() ? r : yield function (r) {
                return de.__awaiter(this, void 0, void 0, function* () {
                  if ("undefined" != typeof VideoFrame && de.isOffscreenCanvasDistorted()) {
                    var e = r.width + 2,
                      t = r.height + 2;
                    try {
                      return new de.RGBAImage({
                        width: e,
                        height: t
                      }, yield de.readImageUsingVideoFrame(r, -1, -1, e, t));
                    } catch (e) {}
                  }
                  return de.browser.getImageData(r, 1);
                });
              }(r), e = {
                uid: i.uid,
                coord: i.tileID,
                source: this.id,
                rawImageData: e,
                encoding: this.encoding,
                redFactor: this.redFactor,
                greenFactor: this.greenFactor,
                blueFactor: this.blueFactor,
                baseShift: this.baseShift
              }, i.actor && "expired" !== i.state || (i.actor = this.dispatcher.getActor(), i.actor.send("loadDEMTile", e, a)));
            }), this.map._refreshExpiredTiles);
          }
          _getNeighboringTiles(e) {
            var t = e.canonical,
              r = Math.pow(2, t.z),
              n = (t.x - 1 + r) % r,
              i = 0 === t.x ? e.wrap - 1 : e.wrap,
              o = (t.x + 1 + r) % r,
              a = t.x + 1 === r ? e.wrap + 1 : e.wrap,
              s = {};
            return s[new de.OverscaledTileID(e.overscaledZ, i, t.z, n, t.y).key] = {
              backfilled: !1
            }, s[new de.OverscaledTileID(e.overscaledZ, a, t.z, o, t.y).key] = {
              backfilled: !1
            }, 0 < t.y && (s[new de.OverscaledTileID(e.overscaledZ, i, t.z, n, t.y - 1).key] = {
              backfilled: !1
            }, s[new de.OverscaledTileID(e.overscaledZ, e.wrap, t.z, t.x, t.y - 1).key] = {
              backfilled: !1
            }, s[new de.OverscaledTileID(e.overscaledZ, a, t.z, o, t.y - 1).key] = {
              backfilled: !1
            }), t.y + 1 < r && (s[new de.OverscaledTileID(e.overscaledZ, i, t.z, n, t.y + 1).key] = {
              backfilled: !1
            }, s[new de.OverscaledTileID(e.overscaledZ, e.wrap, t.z, t.x, t.y + 1).key] = {
              backfilled: !1
            }, s[new de.OverscaledTileID(e.overscaledZ, a, t.z, o, t.y + 1).key] = {
              backfilled: !1
            }), s;
          }
          unloadTile(e) {
            e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && e.actor.send("removeDEMTile", {
              uid: e.uid,
              source: this.id
            });
          }
        }
        class ne extends de.Evented {
          constructor(e, t, r, n) {
            super(), this.load = () => {
              this._updateWorkerData();
            }, this.serialize = () => de.extend({}, this._options, {
              type: this.type,
              data: this._data
            }), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = r.getActor(), this.setEventedParent(n), this._data = t.data, this._options = de.extend({}, t), this._collectResourceTiming = t.collectResourceTiming, void 0 !== t.maxzoom && (this.maxzoom = t.maxzoom), t.type && (this.type = t.type), t.attribution && (this.attribution = t.attribution), this.promoteId = t.promoteId;
            e = de.EXTENT / this.tileSize;
            this.workerOptions = de.extend({
              source: this.id,
              cluster: t.cluster || !1,
              geojsonVtOptions: {
                buffer: (void 0 !== t.buffer ? t.buffer : 128) * e,
                tolerance: (void 0 !== t.tolerance ? t.tolerance : .375) * e,
                extent: de.EXTENT,
                maxZoom: this.maxzoom,
                lineMetrics: t.lineMetrics || !1,
                generateId: t.generateId || !1
              },
              superclusterOptions: {
                maxZoom: void 0 !== t.clusterMaxZoom ? t.clusterMaxZoom : this.maxzoom - 1,
                minPoints: Math.max(2, t.clusterMinPoints || 2),
                extent: de.EXTENT,
                radius: (t.clusterRadius || 50) * e,
                log: !1,
                generateId: t.generateId || !1
              },
              clusterProperties: t.clusterProperties,
              filter: t.filter
            }, t.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setData(e) {
            return this._data = e, this._updateWorkerData(), this;
          }
          updateData(e) {
            return this._updateWorkerData(e), this;
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e && (void 0 !== e.clusterRadius && (this.workerOptions.superclusterOptions.radius = e.clusterRadius), void 0 !== e.clusterMaxZoom) && (this.workerOptions.superclusterOptions.maxZoom = e.clusterMaxZoom), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e, t) {
            return this.actor.send("geojson.getClusterExpansionZoom", {
              clusterId: e,
              source: this.id
            }, t), this;
          }
          getClusterChildren(e, t) {
            return this.actor.send("geojson.getClusterChildren", {
              clusterId: e,
              source: this.id
            }, t), this;
          }
          getClusterLeaves(e, t, r, n) {
            return this.actor.send("geojson.getClusterLeaves", {
              source: this.id,
              clusterId: e,
              limit: t,
              offset: r
            }, n), this;
          }
          _updateWorkerData(e) {
            var t = de.extend({}, this.workerOptions);
            e ? t.dataDiff = e : "string" == typeof this._data ? (t.request = this.map._requestManager.transformRequest(de.browser.resolveURL(this._data), _.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new de.Event("dataloading", {
              dataType: "source"
            })), this.actor.send(this.type + ".loadData", t, (t, r) => {
              if (this._pendingLoads--, this._removed || r && r.abandoned) this.fire(new de.Event("dataabort", {
                dataType: "source"
              }));else {
                let e = null;
                r && r.resourceTiming && r.resourceTiming[this.id] && (e = r.resourceTiming[this.id].slice(0)), t ? this.fire(new de.ErrorEvent(t)) : (r = {
                  dataType: "source"
                }, this._collectResourceTiming && e && 0 < e.length && de.extend(r, {
                  resourceTiming: e
                }), this.fire(new de.Event("data", Object.assign(Object.assign({}, r), {
                  sourceDataType: "metadata"
                }))), this.fire(new de.Event("data", Object.assign(Object.assign({}, r), {
                  sourceDataType: "content"
                }))));
              }
            });
          }
          loaded() {
            return 0 === this._pendingLoads;
          }
          loadTile(r, n) {
            const i = r.actor ? "reloadTile" : "loadTile";
            r.actor = this.actor;
            var e = {
              type: this.type,
              uid: r.uid,
              tileID: r.tileID,
              zoom: r.tileID.overscaledZ,
              maxZoom: this.maxzoom,
              tileSize: this.tileSize,
              source: this.id,
              pixelRatio: this.map.getPixelRatio(),
              showCollisionBoxes: this.map.showCollisionBoxes,
              promoteId: this.promoteId
            };
            r.request = this.actor.send(i, e, (e, t) => {
              if (delete r.request, r.unloadVectorData(), !r.aborted) {
                if (e) return n(e);
                r.loadVectorData(t, this.map.painter, "reloadTile" == i);
              }
              return n(null);
            });
          }
          abortTile(e) {
            e.request && (e.request.cancel(), delete e.request), e.aborted = !0;
          }
          unloadTile(e) {
            e.unloadVectorData(), this.actor.send("removeTile", {
              uid: e.uid,
              type: this.type,
              source: this.id
            });
          }
          onRemove() {
            this._removed = !0, this.actor.send("removeSource", {
              type: this.type,
              source: this.id
            });
          }
          hasTransition() {
            return !1;
          }
        }
        var ie = de.createLayout([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }, {
          name: "a_texture_pos",
          type: "Int16",
          components: 2
        }]);
        class v extends de.Evented {
          constructor(e, t, r, n) {
            super(), this.load = (r, n) => {
              this._loaded = !1, this.fire(new de.Event("dataloading", {
                dataType: "source"
              })), this.url = this.options.url, this._request = f.getImage(this.map._requestManager.transformRequest(this.url, _.Image), (e, t) => {
                this._request = null, this._loaded = !0, e ? this.fire(new de.ErrorEvent(e)) : t && (this.image = t, r && (this.coordinates = r), n && n(), this._finishLoading());
              });
            }, this.prepare = () => {
              if (0 !== Object.keys(this.tiles).length && this.image) {
                var t = this.map.painter.context,
                  r = t.gl;
                this.boundsBuffer || (this.boundsBuffer = t.createVertexBuffer(this._boundsArray, ie.members)), this.boundsSegments || (this.boundsSegments = de.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new U(t, this.image, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
                let e = !1;
                for (const i in this.tiles) {
                  var n = this.tiles[i];
                  "loaded" !== n.state && (n.state = "loaded", n.texture = this.texture, e = !0);
                }
                e && this.fire(new de.Event("data", {
                  dataType: "source",
                  sourceDataType: "idle",
                  sourceId: this.id
                }));
              }
            }, this.serialize = () => ({
              type: "image",
              url: this.options.url,
              coordinates: this.coordinates
            }), this.id = e, this.dispatcher = r, this.coordinates = t.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(n), this.options = t;
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e) {
            return e.url && (this._request && (this._request.cancel(), this._request = null), this.options.url = e.url, this.load(e.coordinates, () => {
              this.texture = null;
            })), this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new de.Event("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._request && (this._request.cancel(), this._request = null);
          }
          setCoordinates(e) {
            e = (this.coordinates = e).map(de.MercatorCoordinate.fromLngLat), this.tileID = oe(e), this.minzoom = this.maxzoom = this.tileID.z, e = e.map(e => this.tileID.getTilePoint(e)._round());
            return this._boundsArray = new de.RasterBoundsArray(), this._boundsArray.emplaceBack(e[0].x, e[0].y, 0, 0), this._boundsArray.emplaceBack(e[1].x, e[1].y, de.EXTENT, 0), this._boundsArray.emplaceBack(e[3].x, e[3].y, 0, de.EXTENT), this._boundsArray.emplaceBack(e[2].x, e[2].y, de.EXTENT, de.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new de.Event("data", {
              dataType: "source",
              sourceDataType: "content"
            })), this;
          }
          loadTile(e, t) {
            this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e).buckets = {} : e.state = "errored", t(null);
          }
          hasTransition() {
            return !1;
          }
        }
        function oe(e) {
          let t = 1 / 0,
            r = 1 / 0,
            n = -1 / 0,
            i = -1 / 0;
          for (const a of e) t = Math.min(t, a.x), r = Math.min(r, a.y), n = Math.max(n, a.x), i = Math.max(i, a.y);
          var e = n - t,
            o = i - r,
            e = Math.max(e, o),
            o = Math.max(0, Math.floor(-Math.log(e) / Math.LN2)),
            e = Math.pow(2, o);
          return new de.CanonicalTileID(o, Math.floor((t + n) / 2 * e), Math.floor((r + i) / 2 * e));
        }
        class ae extends v {
          constructor(e, t, r, n) {
            super(e, t, r, n), this.load = () => {
              this._loaded = !1;
              var e = this.options;
              this.urls = [];
              for (const t of e.urls) this.urls.push(this.map._requestManager.transformRequest(t, _.Source).url);
              de.getVideo(this.urls, (e, t) => {
                this._loaded = !0, e ? this.fire(new de.ErrorEvent(e)) : t && (this.video = t, this.video.loop = !0, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading());
              });
            }, this.prepare = () => {
              if (!(0 === Object.keys(this.tiles).length || this.video.readyState < 2)) {
                var t = this.map.painter.context,
                  r = t.gl;
                this.boundsBuffer || (this.boundsBuffer = t.createVertexBuffer(this._boundsArray, ie.members)), this.boundsSegments || (this.boundsSegments = de.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE), r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, r.RGBA, r.UNSIGNED_BYTE, this.video)) : (this.texture = new U(t, this.video, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
                let e = !1;
                for (const i in this.tiles) {
                  var n = this.tiles[i];
                  "loaded" !== n.state && (n.state = "loaded", n.texture = this.texture, e = !0);
                }
                e && this.fire(new de.Event("data", {
                  dataType: "source",
                  sourceDataType: "idle",
                  sourceId: this.id
                }));
              }
            }, this.serialize = () => ({
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates
            }), this.roundZoom = !0, this.type = "video", this.options = t;
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e) {
            var t;
            this.video && (e < (t = this.video.seekable).start(0) || e > t.end(0) ? this.fire(new de.ErrorEvent(new de.ValidationError("sources." + this.id, null, `Playback for this video can be set only between the ${t.start(0)} and ${t.end(0)}-second mark.`))) : this.video.currentTime = e);
          }
          getVideo() {
            return this.video;
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class se extends v {
          constructor(e, t, r, n) {
            super(e, t, r, n), this.load = () => {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new de.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () {
                this._playing = !0, this.map.triggerRepaint();
              }, this.pause = function () {
                this._playing && (this.prepare(), this._playing = !1);
              }, this._finishLoading());
            }, this.prepare = () => {
              let t = !1;
              if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), !this._hasInvalidDimensions() && 0 !== Object.keys(this.tiles).length) {
                var r = this.map.painter.context,
                  n = r.gl;
                this.boundsBuffer || (this.boundsBuffer = r.createVertexBuffer(this._boundsArray, ie.members)), this.boundsSegments || (this.boundsSegments = de.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (t || this._playing) && this.texture.update(this.canvas, {
                  premultiply: !0
                }) : this.texture = new U(r, this.canvas, n.RGBA, {
                  premultiply: !0
                });
                let e = !1;
                for (const o in this.tiles) {
                  var i = this.tiles[o];
                  "loaded" !== i.state && (i.state = "loaded", i.texture = this.texture, e = !0);
                }
                e && this.fire(new de.Event("data", {
                  dataType: "source",
                  sourceDataType: "idle",
                  sourceId: this.id
                }));
              }
            }, this.serialize = () => ({
              type: "canvas",
              coordinates: this.coordinates
            }), t.coordinates ? Array.isArray(t.coordinates) && 4 === t.coordinates.length && !t.coordinates.some(e => !Array.isArray(e) || 2 !== e.length || e.some(e => "number" != typeof e)) || this.fire(new de.ErrorEvent(new de.ValidationError("sources." + e, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new de.ErrorEvent(new de.ValidationError("sources." + e, null, 'missing required property "coordinates"'))), t.animate && "boolean" != typeof t.animate && this.fire(new de.ErrorEvent(new de.ValidationError("sources." + e, null, 'optional "animate" property must be a boolean value'))), t.canvas ? "string" == typeof t.canvas || t.canvas instanceof HTMLCanvasElement || this.fire(new de.ErrorEvent(new de.ValidationError("sources." + e, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new de.ErrorEvent(new de.ValidationError("sources." + e, null, 'missing required property "canvas"'))), this.options = t, this.animate = void 0 === t.animate || t.animate;
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;
            return !1;
          }
        }
        const le = {},
          ce = (e, t, r, n) => {
            t = new (ue(t.type))(e, t, r, n);
            if (t.id !== e) throw new Error(`Expected Source id to be ${e} instead of ` + t.id);
            return t;
          },
          ue = e => {
            switch (e) {
              case "geojson":
                return ne;
              case "image":
                return v;
              case "raster":
                return te;
              case "raster-dem":
                return re;
              case "vector":
                return ee;
              case "video":
                return ae;
              case "canvas":
                return se;
            }
            return le[e];
          },
          he = (e, t) => {
            le[e] = t;
          };
        function ge(r, e, t, n, i, o) {
          var a,
            s,
            l,
            c = function (e, t, r) {
              if (e) for (const o of e) {
                var n = t[o];
                if (n && n.source === r && "fill-extrusion" === n.type) return !0;
              } else for (const a in t) {
                var i = t[a];
                if (i.source === r && "fill-extrusion" === i.type) return !0;
              }
              return !1;
            }(i && i.layers, e, r.id),
            u = o.maxPitchScaleFactor(),
            n = r.tilesIn(n, u, c),
            h = (n.sort(Ee), []);
          for (const p of n) h.push({
            wrappedTileID: p.tileID.wrapped().key,
            queryResults: p.tile.queryRenderedFeatures(e, t, r._state, p.queryGeometry, p.cameraQueryGeometry, p.scale, i, o, u, (a = r.transform, s = p.tileID, l = void 0, l = de.create(), de.translate(l, l, [1, 1, 0]), de.scale(l, l, [.5 * a.width, .5 * a.height, 1]), de.multiply(l, l, a.calculatePosMatrix(s.toUnwrapped()))))
          });
          var d = function (e) {
            var t = {},
              r = {};
            for (const c of e) {
              var n = c.queryResults,
                i = c.wrappedTileID,
                o = r[i] = r[i] || {};
              for (const u in n) {
                var a = n[u],
                  s = o[u] = o[u] || {},
                  l = t[u] = t[u] || [];
                for (const h of a) s[h.featureIndex] || (s[h.featureIndex] = !0, l.push(h));
              }
            }
            return t;
          }(h);
          for (const f in d) d[f].forEach(e => {
            var e = e.feature,
              t = r.getFeatureState(e.layer["source-layer"], e.id);
            e.source = e.layer.source, e.layer["source-layer"] && (e.sourceLayer = e.layer["source-layer"]), e.state = t;
          });
          return d;
        }
        function ye(r, e, n, t, i, o, a) {
          var s = {},
            l = o.queryRenderedSymbols(t),
            c = [];
          for (const p of Object.keys(l).map(Number)) c.push(a[p]);
          c.sort(Ee);
          for (const f of c) {
            var u = f.featureIndex.lookupSymbolFeatures(l[f.bucketInstanceId], e, f.bucketIndex, f.sourceLayerIndex, i.filter, i.layers, i.availableImages, r);
            for (const _ in u) {
              var h = s[_] = s[_] || [],
                d = u[_];
              d.sort((e, t) => {
                var r,
                  n = f.featureSortOrder;
                return n ? (r = n.indexOf(e.featureIndex), n.indexOf(t.featureIndex) - r) : t.featureIndex - e.featureIndex;
              });
              for (const m of d) h.push(m);
            }
          }
          for (const g in s) s[g].forEach(e => {
            var e = e.feature,
              t = r[g],
              t = n[t.source].getFeatureState(e.layer["source-layer"], e.id);
            e.source = e.layer.source, e.layer["source-layer"] && (e.sourceLayer = e.layer["source-layer"]), e.state = t;
          });
          return s;
        }
        function ve(t, r) {
          var n = t.getRenderableIds().map(e => t.getTileByID(e)),
            i = [],
            o = {};
          for (let e = 0; e < n.length; e++) {
            var a = n[e],
              s = a.tileID.canonical.key;
            o[s] || (o[s] = !0, a.querySourceFeatures(i, r));
          }
          return i;
        }
        function Ee(e, t) {
          e = e.tileID, t = t.tileID;
          return e.overscaledZ - t.overscaledZ || e.canonical.y - t.canonical.y || e.wrap - t.wrap || e.canonical.x - t.canonical.x;
        }
        function be(e, t) {
          var r = {};
          if (t) for (const n of e) {
            const i = n.layerIds.map(e => t.getLayer(e)).filter(Boolean);
            if (0 !== i.length) {
              n.layers = i, n.stateDependentLayerIds && (n.stateDependentLayers = n.stateDependentLayerIds.map(t => i.filter(e => e.id === t)[0]));
              for (const o of i) r[o.id] = n;
            }
          }
          return r;
        }
        class we {
          constructor(e, t) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = de.uniqueId(), this.uses = 0, this.tileSize = t, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(e) {
            e += this.timeAdded;
            e < this.fadeEndTime || (this.fadeEndTime = e);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e, t, r) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = be(e.buckets, t.style), this.hasSymbolBuckets = !1;
              for (const a in this.buckets) {
                var n = this.buckets[a];
                if (n instanceof de.SymbolBucket) {
                  if (this.hasSymbolBuckets = !0, !r) break;
                  n.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const s in this.buckets) {
                var i = this.buckets[s];
                if (i instanceof de.SymbolBucket && i.hasRTLText) {
                  this.hasRTLText = !0, de.lazyLoadRTLTextPlugin();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const l in this.buckets) {
                var o = this.buckets[l];
                this.queryPadding = Math.max(this.queryPadding, t.style.getLayer(l).queryRadius(o));
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
            } else this.collisionBoxArray = new de.CollisionBoxArray();
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(e) {
            return this.buckets[e.id];
          }
          upload(e) {
            for (const n in this.buckets) {
              var t = this.buckets[n];
              t.uploadPending() && t.upload(e);
            }
            var r = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new U(e, this.imageAtlas.image, r.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new U(e, this.glyphAtlasImage, r.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
          }
          queryRenderedFeatures(e, t, r, n, i, o, a, s, l, c) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
              queryGeometry: n,
              cameraQueryGeometry: i,
              scale: o,
              tileSize: this.tileSize,
              pixelPosMatrix: c,
              transform: s,
              params: a,
              queryPadding: this.queryPadding * l
            }, e, t, r) : {};
          }
          querySourceFeatures(t, e) {
            var r = this.latestFeatureIndex;
            if (r && r.rawTileData) {
              var n = r.loadVTLayers(),
                i = e && e.sourceLayer ? e.sourceLayer : "",
                o = n._geojsonTileLayer || n[i];
              if (o) {
                var a = de.createFilter(e && e.filter),
                  {
                    z: s,
                    x: l,
                    y: c
                  } = this.tileID.canonical,
                  u = {
                    z: s,
                    x: l,
                    y: c
                  };
                for (let e = 0; e < o.length; e++) {
                  var h = o.feature(e);
                  if (a.needGeometry) {
                    var d = de.toEvaluationFeature(h, !0);
                    if (!a.filter(new de.EvaluationParameters(this.tileID.overscaledZ), d, this.tileID.canonical)) continue;
                  } else if (!a.filter(new de.EvaluationParameters(this.tileID.overscaledZ), h)) continue;
                  d = r.getId(h, i), h = new de.GeoJSONFeature(h, s, l, c, d);
                  h.tile = u, t.push(h);
                }
              }
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t) {
            var r = this.expirationTime;
            if (t.cacheControl ? (n = de.parseCacheControl(t.cacheControl))["max-age"] && (this.expirationTime = Date.now() + 1e3 * n["max-age"]) : t.expires && (this.expirationTime = new Date(t.expires).getTime()), this.expirationTime) {
              var n = Date.now();
              let e = !1;
              this.expirationTime > n ? e = !1 : r && !(this.expirationTime < r) && (t = this.expirationTime - r) ? this.expirationTime = n + Math.max(t, 3e4) : e = !0, e ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e, t) {
            if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(e).length) {
              var r,
                n,
                i,
                o = this.latestFeatureIndex.loadVTLayers();
              for (const a in this.buckets) t.style.hasLayer(a) && (n = o[i = (r = this.buckets[a]).layers[0].sourceLayer || "_geojsonTileLayer"], i = e[i], n) && i && 0 !== Object.keys(i).length && (r.update(i, n, this.imageAtlas && this.imageAtlas.patternPositions || {}), i = t && t.style && t.style.getLayer(a)) && (this.queryPadding = Math.max(this.queryPadding, i.queryRadius(r)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < de.browser.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e) {
            this.symbolFadeHoldUntil = de.browser.now() + e;
          }
          setDependencies(e, t) {
            var r = {};
            for (const n of t) r[n] = !0;
            this.dependencies[e] = r;
          }
          hasDependency(e, t) {
            for (const n of e) {
              var r = this.dependencies[n];
              if (r) for (const i of t) if (r[i]) return !0;
            }
            return !1;
          }
        }
        class Te {
          constructor(e, t) {
            this.max = e, this.onRemove = t, this.reset();
          }
          reset() {
            for (const e in this.data) for (const t of this.data[e]) t.timeout && clearTimeout(t.timeout), this.onRemove(t.value);
            return this.data = {}, this.order = [], this;
          }
          add(e, t, r) {
            var n = e.wrapped().key;
            void 0 === this.data[n] && (this.data[n] = []);
            const i = {
              value: t,
              timeout: void 0
            };
            return void 0 !== r && (i.timeout = setTimeout(() => {
              this.remove(e, i);
            }, r)), this.data[n].push(i), this.order.push(n), this.order.length > this.max && (t = this._getAndRemoveByKey(this.order[0])) && this.onRemove(t), this;
          }
          has(e) {
            return e.wrapped().key in this.data;
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
          }
          _getAndRemoveByKey(e) {
            var t = this.data[e].shift();
            return t.timeout && clearTimeout(t.timeout), 0 === this.data[e].length && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t.value;
          }
          getByKey(e) {
            e = this.data[e];
            return e ? e[0].value : null;
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null;
          }
          remove(e, t) {
            var r;
            return this.has(e) && (e = e.wrapped().key, t = void 0 === t ? 0 : this.data[e].indexOf(t), r = this.data[e][t], this.data[e].splice(t, 1), r.timeout && clearTimeout(r.timeout), 0 === this.data[e].length && delete this.data[e], this.onRemove(r.value), this.order.splice(this.order.indexOf(e), 1)), this;
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max;) {
              var t = this._getAndRemoveByKey(this.order[0]);
              t && this.onRemove(t);
            }
            return this;
          }
          filter(e) {
            var t = [];
            for (const r in this.data) for (const n of this.data[r]) e(n.value) || t.push(n);
            for (const i of t) this.remove(i.value.tileID, i);
          }
        }
        class Se {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e, t, r) {
            var n = String(t);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][n] = this.stateChanges[e][n] || {}, de.extend(this.stateChanges[e][n], r), null === this.deletedStates[e]) {
              this.deletedStates[e] = {};
              for (const i in this.state[e]) i !== n && (this.deletedStates[e][i] = null);
            } else if (this.deletedStates[e] && null === this.deletedStates[e][n]) {
              this.deletedStates[e][n] = {};
              for (const o in this.state[e][n]) r[o] || (this.deletedStates[e][n][o] = null);
            } else for (const a in r) this.deletedStates[e] && this.deletedStates[e][n] && null === this.deletedStates[e][n][a] && delete this.deletedStates[e][n][a];
          }
          removeFeatureState(e, t, r) {
            var n = null === this.deletedStates[e];
            if (!n) {
              var i = String(t);
              if (this.deletedStates[e] = this.deletedStates[e] || {}, r && void 0 !== t) null !== this.deletedStates[e][i] && (this.deletedStates[e][i] = this.deletedStates[e][i] || {}, this.deletedStates[e][i][r] = null);else if (void 0 !== t) {
                if (this.stateChanges[e] && this.stateChanges[e][i]) for (r in this.deletedStates[e][i] = {}, this.stateChanges[e][i]) this.deletedStates[e][i][r] = null;else this.deletedStates[e][i] = null;
              } else this.deletedStates[e] = null;
            }
          }
          getState(e, t) {
            var r = String(t),
              n = this.state[e] || {},
              i = this.stateChanges[e] || {},
              o = de.extend({}, n[r], i[r]);
            if (null === this.deletedStates[e]) return {};
            if (this.deletedStates[e]) {
              n = this.deletedStates[e][t];
              if (null === n) return {};
              for (const a in n) delete o[a];
            }
            return o;
          }
          initializeTileState(e, t) {
            e.setFeatureState(this.state, t);
          }
          coalesceChanges(e, t) {
            var r = {};
            for (const o in this.stateChanges) {
              this.state[o] = this.state[o] || {};
              var n = {};
              for (const a in this.stateChanges[o]) this.state[o][a] || (this.state[o][a] = {}), de.extend(this.state[o][a], this.stateChanges[o][a]), n[a] = this.state[o][a];
              r[o] = n;
            }
            for (const s in this.deletedStates) {
              this.state[s] = this.state[s] || {};
              var i = {};
              if (null === this.deletedStates[s]) for (const l in this.state[s]) i[l] = {}, this.state[s][l] = {};else for (const c in this.deletedStates[s]) {
                if (null === this.deletedStates[s][c]) this.state[s][c] = {};else for (const u of Object.keys(this.deletedStates[s][c])) delete this.state[s][c][u];
                i[c] = this.state[s][c];
              }
              r[s] = r[s] || {}, de.extend(r[s], i);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for (const h in e) e[h].setFeatureState(r, t);
          }
        }
        class N extends de.Evented {
          constructor(e, t, r) {
            super(), this.id = e, this.dispatcher = r, this.on("data", e => {
              "source" === e.dataType && "metadata" === e.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === e.dataType && "content" === e.sourceDataType && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
            }), this.on("dataloading", () => {
              this._sourceErrored = !1;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = ce(e, t, r, this), this._tiles = {}, this._cache = new Te(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Se(), this._didEmitContent = !1, this._updated = !1;
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
          }
          loaded() {
            if (!this._sourceErrored) {
              if (!this._sourceLoaded) return !1;
              if (!this._source.loaded()) return !1;
              if (void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain) {
                if (!this._updated) return !1;
                for (const t in this._tiles) {
                  var e = this._tiles[t];
                  if ("loaded" !== e.state && "errored" !== e.state) return !1;
                }
              }
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            var e;
            this._paused && (e = this._shouldReloadOnResume, this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform) && this.update(this.transform, this.terrain);
          }
          _loadTile(e, t) {
            return this._source.loadTile(e, t);
          }
          _unloadTile(e) {
            if (this._source.unloadTile) return this._source.unloadTile(e, () => {});
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e, () => {}), this._source.fire(new de.Event("dataabort", {
              tile: e,
              coord: e.tileID,
              dataType: "source"
            }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const r in this._tiles) {
              var t = this._tiles[r];
              t.upload(e), t.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map(e => e.tileID).sort(xe).map(e => e.key);
          }
          getRenderableIds(e) {
            var t = [];
            for (const r in this._tiles) this._isIdRenderable(r, e) && t.push(this._tiles[r]);
            return e ? t.sort((e, t) => {
              var e = e.tileID,
                t = t.tileID,
                r = new de.Point(e.canonical.x, e.canonical.y)._rotate(this.transform.angle),
                n = new de.Point(t.canonical.x, t.canonical.y)._rotate(this.transform.angle);
              return e.overscaledZ - t.overscaledZ || n.y - r.y || n.x - r.x;
            }).map(e => e.tileID.key) : t.map(e => e.tileID).sort(xe).map(e => e.key);
          }
          hasRenderableParent(e) {
            e = this.findLoadedParent(e, 0);
            return !!e && this._isIdRenderable(e.tileID.key);
          }
          _isIdRenderable(e, t) {
            return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (t || !this._tiles[e].holdingForFade());
          }
          reload() {
            if (this._paused) this._shouldReloadOnResume = !0;else {
              this._cache.reset();
              for (const e in this._tiles) "errored" !== this._tiles[e].state && this._reloadTile(e, "reloading");
            }
          }
          _reloadTile(e, t) {
            var r = this._tiles[e];
            r && ("loading" !== r.state && (r.state = t), this._loadTile(r, this._tileLoaded.bind(this, r, e, t)));
          }
          _tileLoaded(e, t, r, n) {
            n ? (e.state = "errored", 404 !== n.status ? this._source.fire(new de.ErrorEvent(n, {
              tile: e
            })) : this.update(this.transform, this.terrain)) : (e.timeAdded = de.browser.now(), "expired" === r && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(t, e), "raster-dem" === this.getSource().type && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new de.Event("data", {
              dataType: "source",
              tile: e,
              coord: e.tileID
            })));
          }
          _backfillDEM(t) {
            var r = this.getRenderableIds();
            for (let e = 0; e < r.length; e++) {
              var n = r[e];
              t.neighboringTiles && t.neighboringTiles[n] && (i(t, n = this.getTileByID(n)), i(n, t));
            }
            function i(e, t) {
              e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0;
              let r = t.tileID.canonical.x - e.tileID.canonical.x;
              var n = t.tileID.canonical.y - e.tileID.canonical.y,
                i = Math.pow(2, e.tileID.canonical.z),
                o = t.tileID.key;
              0 === r && 0 == n || 1 < Math.abs(n) || (1 < Math.abs(r) && (1 === Math.abs(r + i) ? r += i : 1 === Math.abs(r - i) && (r -= i)), t.dem && e.dem && (e.dem.backfillBorder(t.dem, r, n), e.neighboringTiles) && e.neighboringTiles[o] && (e.neighboringTiles[o].backfilled = !0));
            }
          }
          getTile(e) {
            return this.getTileByID(e.key);
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          _retainLoadedChildren(n, i, e, o) {
            for (const t in this._tiles) {
              let r = this._tiles[t];
              if (!(o[t] || !r.hasData() || r.tileID.overscaledZ <= i || r.tileID.overscaledZ > e)) {
                let e = r.tileID;
                for (; r && r.tileID.overscaledZ > i + 1;) {
                  var a = r.tileID.scaledTo(r.tileID.overscaledZ - 1);
                  (r = this._tiles[a.key]) && r.hasData() && (e = a);
                }
                let t = e;
                for (; t.overscaledZ > i;) if (n[(t = t.scaledTo(t.overscaledZ - 1)).key]) {
                  o[e.key] = e;
                  break;
                }
              }
            }
          }
          findLoadedParent(t, r) {
            var e;
            if (t.key in this._loadedParentTiles) return (e = this._loadedParentTiles[t.key]) && e.tileID.overscaledZ >= r ? e : null;
            for (let e = t.overscaledZ - 1; e >= r; e--) {
              var n = t.scaledTo(e),
                n = this._getLoadedTile(n);
              if (n) return n;
            }
          }
          _getLoadedTile(e) {
            var t = this._tiles[e.key];
            return t && t.hasData() ? t : this._cache.getByKey(e.wrapped().key);
          }
          updateCacheSize(e) {
            var t = Math.ceil(e.width / this._source.tileSize) + 1,
              e = Math.ceil(e.height / this._source.tileSize) + 1,
              r = null === this._maxTileCacheZoomLevels ? de.config.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels,
              t = Math.floor(t * e * r),
              e = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, t) : t;
            this._cache.setMaxSize(e);
          }
          handleWrapJump(e) {
            var t = void 0 === this._prevLng ? e : this._prevLng,
              r = Math.round((e - t) / 360);
            if (this._prevLng = e, r) {
              var n = {};
              for (const a in this._tiles) {
                var i = this._tiles[a];
                i.tileID = i.tileID.unwrapTo(i.tileID.wrap + r), n[i.tileID.key] = i;
              }
              this._tiles = n;
              for (const s in this._timers) clearTimeout(this._timers[s]), delete this._timers[s];
              for (const l in this._tiles) {
                var o = this._tiles[l];
                this._setTileReloadTimer(l, o);
              }
            }
          }
          update(t, r) {
            if (this.transform = t, this.terrain = r, this._sourceLoaded && !this._paused) {
              this.updateCacheSize(t), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {};
              let e;
              this.used || this.usedForTerrain ? this._source.tileID ? e = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(e => new de.OverscaledTileID(e.canonical.z, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y)) : (e = t.coveringTiles({
                tileSize: (this.usedForTerrain ? this : this._source).tileSize,
                minzoom: this._source.minzoom,
                maxzoom: this._source.maxzoom,
                roundZoom: !this.usedForTerrain && this._source.roundZoom,
                reparseOverscaled: this._source.reparseOverscaled,
                terrain: r
              }), this._source.hasTile && (e = e.filter(e => this._source.hasTile(e)))) : e = [];
              var t = t.coveringZoomLevel(this._source),
                n = Math.max(t - N.maxOverzooming, this._source.minzoom),
                i = Math.max(t + N.maxUnderzooming, this._source.minzoom);
              if (this.usedForTerrain) {
                var o,
                  a = {};
                for (const v of e) v.canonical.z > this._source.minzoom && (a[(o = v.scaledTo(v.canonical.z - 1)).key] = o, a[(o = v.scaledTo(Math.max(this._source.minzoom, Math.min(v.canonical.z, 5)))).key] = o);
                e = e.concat(Object.values(a));
              }
              var s = 0 === e.length && !this._updated && this._didEmitContent,
                l = (this._updated = !0, s && this.fire(new de.Event("data", {
                  sourceDataType: "idle",
                  dataType: "source",
                  sourceId: this.id
                })), this._updateRetainedTiles(e, t));
              if (Ce(this._source.type)) {
                var c = {},
                  u = {},
                  s = Object.keys(l),
                  h = de.browser.now();
                for (const E of s) {
                  var d = l[E],
                    p = this._tiles[E];
                  !p || 0 !== p.fadeEndTime && p.fadeEndTime <= h || ((p = this.findLoadedParent(d, n)) && (this._addTile(p.tileID), c[p.tileID.key] = p.tileID), u[E] = d);
                }
                this._retainLoadedChildren(u, t, i, l);
                for (const b in c) l[b] || (this._coveredTiles[b] = !0, l[b] = c[b]);
                if (r) {
                  var f = {},
                    _ = {};
                  for (const w of e) this._tiles[w.key].hasData() ? f[w.key] = w : _[w.key] = w;
                  for (const T in _) {
                    var m = _[T].children(this._source.maxzoom);
                    this._tiles[m[0].key] && this._tiles[m[1].key] && this._tiles[m[2].key] && this._tiles[m[3].key] && (f[m[0].key] = l[m[0].key] = m[0], f[m[1].key] = l[m[1].key] = m[1], f[m[2].key] = l[m[2].key] = m[2], f[m[3].key] = l[m[3].key] = m[3], delete _[T]);
                  }
                  for (const S in _) {
                    var g = this.findLoadedParent(_[S], this._source.minzoom);
                    if (g) {
                      f[g.tileID.key] = l[g.tileID.key] = g.tileID;
                      for (const x in f) f[x].isChildOf(g.tileID) && delete f[x];
                    }
                  }
                  for (const C in this._tiles) f[C] || (this._coveredTiles[C] = !0);
                }
              }
              for (const A in l) this._tiles[A].clearFadeHold();
              for (const I of de.keysDifference(this._tiles, l)) {
                var y = this._tiles[I];
                y.hasSymbolBuckets && !y.holdingForFade() ? y.setHoldDuration(this.map._fadeDuration) : y.hasSymbolBuckets && !y.symbolFadeFinished() || this._removeTile(I);
              }
              this._updateLoadedParentTileCache();
            }
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
          }
          _updateRetainedTiles(e, n) {
            var i = {},
              o = {},
              a = Math.max(n - N.maxOverzooming, this._source.minzoom),
              t = Math.max(n + N.maxUnderzooming, this._source.minzoom),
              r = {};
            for (const d of e) {
              var s = this._addTile(d);
              i[d.key] = d, s.hasData() || n < this._source.maxzoom && (r[d.key] = d);
            }
            this._retainLoadedChildren(r, n, t, i);
            for (const p of e) {
              let r = this._tiles[p.key];
              if (!r.hasData()) {
                if (n + 1 > this._source.maxzoom) {
                  var l = p.children(this._source.maxzoom)[0],
                    c = this.getTile(l);
                  if (c && c.hasData()) {
                    i[l.key] = l;
                    continue;
                  }
                } else {
                  c = p.children(this._source.maxzoom);
                  if (i[c[0].key] && i[c[1].key] && i[c[2].key] && i[c[3].key]) continue;
                }
                let t = r.wasRequested();
                for (let e = p.overscaledZ - 1; e >= a; --e) {
                  var u = p.scaledTo(e);
                  if (o[u.key]) break;
                  if (o[u.key] = !0, r = !(r = this.getTile(u)) && t ? this._addTile(u) : r) {
                    var h = r.hasData();
                    if ((t || h) && (i[u.key] = u), t = r.wasRequested(), h) break;
                  }
                }
              }
            }
            return i;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const i in this._tiles) {
              var r = [];
              let e,
                t = this._tiles[i].tileID;
              for (; 0 < t.overscaledZ;) {
                if (t.key in this._loadedParentTiles) {
                  e = this._loadedParentTiles[t.key];
                  break;
                }
                r.push(t.key);
                var n = t.scaledTo(t.overscaledZ - 1);
                if (e = this._getLoadedTile(n)) break;
                t = n;
              }
              for (const o of r) this._loadedParentTiles[o] = e;
            }
          }
          _addTile(e) {
            let t = this._tiles[e.key];
            var r;
            return t || ((t = this._cache.getAndRemove(e)) && (this._setTileReloadTimer(e.key, t), t.tileID = e, this._state.initializeTileState(t, this.map ? this.map.painter : null), this._cacheTimers[e.key]) && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, t)), (r = t) || (t = new we(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(t, this._tileLoaded.bind(this, t, e.key, t.state))), t.uses++, this._tiles[e.key] = t, r) || this._source.fire(new de.Event("dataloading", {
              tile: t,
              coord: t.tileID,
              dataType: "source"
            })), t;
          }
          _setTileReloadTimer(e, t) {
            e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
            t = t.getExpiryTimeout();
            t && (this._timers[e] = setTimeout(() => {
              this._reloadTile(e, "expired"), delete this._timers[e];
            }, t));
          }
          _removeTile(e) {
            var t = this._tiles[e];
            t && (t.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), 0 < t.uses || (t.hasData() && "reloading" !== t.state ? this._cache.add(t.tileID, t, t.getExpiryTimeout()) : (t.aborted = !0, this._abortTile(t), this._unloadTile(t))));
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset();
          }
          tilesIn(e, o, a) {
            var s = [];
            const l = this.transform;
            if (l) {
              var a = a ? l.getCameraQueryGeometry(e) : e,
                c = e.map(e => l.pointCoordinate(e, this.terrain)),
                u = a.map(e => l.pointCoordinate(e, this.terrain)),
                h = this.getIds();
              let t = 1 / 0,
                r = 1 / 0,
                n = -1 / 0,
                i = -1 / 0;
              for (const m of u) t = Math.min(t, m.x), r = Math.min(r, m.y), n = Math.max(n, m.x), i = Math.max(i, m.y);
              for (let e = 0; e < h.length; e++) {
                var d = this._tiles[h[e]];
                if (!d.holdingForFade()) {
                  const g = d.tileID;
                  var p = Math.pow(2, l.zoom - d.tileID.overscaledZ),
                    f = o * d.queryPadding * de.EXTENT / d.tileSize / p,
                    _ = [g.getTilePoint(new de.MercatorCoordinate(t, r)), g.getTilePoint(new de.MercatorCoordinate(n, i))];
                  _[0].x - f < de.EXTENT && _[0].y - f < de.EXTENT && 0 <= _[1].x + f && 0 <= _[1].y + f && (_ = c.map(e => g.getTilePoint(e)), f = u.map(e => g.getTilePoint(e)), s.push({
                    tile: d,
                    tileID: g,
                    queryGeometry: _,
                    cameraQueryGeometry: f,
                    scale: p
                  }));
                }
              }
            }
            return s;
          }
          getVisibleCoordinates(e) {
            e = this.getRenderableIds(e).map(e => this._tiles[e].tileID);
            for (const t of e) t.posMatrix = this.transform.calculatePosMatrix(t.toUnwrapped());
            return e;
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (Ce(this._source.type)) {
              var e = de.browser.now();
              for (const t in this._tiles) if (this._tiles[t].fadeEndTime >= e) return !0;
            }
            return !1;
          }
          setFeatureState(e, t, r) {
            this._state.updateState(e = e || "_geojsonTileLayer", t, r);
          }
          removeFeatureState(e, t, r) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", t, r);
          }
          getFeatureState(e, t) {
            return this._state.getState(e = e || "_geojsonTileLayer", t);
          }
          setDependencies(e, t, r) {
            e = this._tiles[e];
            e && e.setDependencies(t, r);
          }
          reloadTilesForDependencies(t, r) {
            for (const e in this._tiles) this._tiles[e].hasDependency(t, r) && this._reloadTile(e, "reloading");
            this._cache.filter(e => !e.hasDependency(t, r));
          }
        }
        function xe(e, t) {
          var r = Math.abs(2 * e.wrap) - (e.wrap < 0),
            n = Math.abs(2 * t.wrap) - (t.wrap < 0);
          return e.overscaledZ - t.overscaledZ || n - r || t.canonical.y - e.canonical.y || t.canonical.x - e.canonical.x;
        }
        function Ce(e) {
          return "raster" === e || "image" === e || "video" === e;
        }
        function Ae() {
          return new Worker(de.config.WORKER_URL);
        }
        N.maxOverzooming = 10, N.maxUnderzooming = 3;
        const Ie = "mapboxgl_preloaded_worker_pool";
        class n {
          constructor() {
            this.active = {};
          }
          acquire(e) {
            if (!this.workers) for (this.workers = []; this.workers.length < n.workerCount;) this.workers.push(Ae());
            return this.active[e] = !0, this.workers.slice();
          }
          release(e) {
            delete this.active[e], 0 === this.numActive() && (this.workers.forEach(e => {
              e.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[Ie];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        e = Math.floor(de.browser.hardwareConcurrency / 2);
        n.workerCount = de.isSafari(globalThis) ? Math.max(Math.min(e, 3), 1) : 1;
        let Ne;
        function Pe() {
          return Ne = Ne || new n();
        }
        class De {
          constructor(e, t) {
            this.reset(e, t);
          }
          reset(e, t) {
            this.points = e || [], this._distances = [0];
            for (let e = 1; e < this.points.length; e++) this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e) {
            if (1 === this.points.length) return this.points[0];
            e = de.clamp(e, 0, 1);
            let t = 1,
              r = this._distances[t];
            for (var n = e * this.paddedLength + this.padding; r < n && t < this._distances.length;) r = this._distances[++t];
            var e = t - 1,
              i = this._distances[e],
              o = r - i,
              i = 0 < o ? (n - i) / o : 0;
            return this.points[e].mult(1 - i).add(this.points[t].mult(i));
          }
        }
        function Re(e, t) {
          let r = "always" === e || "never" !== e && "never" !== t ? !0 : !1;
          return r;
        }
        class Oe {
          constructor(e, t, r) {
            var n = this.boxCells = [],
              i = this.circleCells = [];
            this.xCellCount = Math.ceil(e / r), this.yCellCount = Math.ceil(t / r);
            for (let e = 0; e < this.xCellCount * this.yCellCount; e++) n.push([]), i.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e, t, r, n, i) {
            this._forEachCell(t, r, n, i, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);
          }
          insertCircle(e, t, r, n) {
            this._forEachCell(t - n, r - n, t + n, r + n, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(r), this.circles.push(n);
          }
          _insertBoxCell(e, t, r, n, i, o) {
            this.boxCells[i].push(o);
          }
          _insertCircleCell(e, t, r, n, i, o) {
            this.circleCells[i].push(o);
          }
          _query(e, t, r, n, i, o, a) {
            if (r < 0 || e > this.width || n < 0 || t > this.height) return [];
            var s = [];
            if (e <= 0 && t <= 0 && this.width <= r && this.height <= n) {
              if (i) return [{
                key: null,
                x1: e,
                y1: t,
                x2: r,
                y2: n
              }];
              for (let e = 0; e < this.boxKeys.length; e++) s.push({
                key: this.boxKeys[e],
                x1: this.bboxes[4 * e],
                y1: this.bboxes[4 * e + 1],
                x2: this.bboxes[4 * e + 2],
                y2: this.bboxes[4 * e + 3]
              });
              for (let e = 0; e < this.circleKeys.length; e++) {
                var l = this.circles[3 * e],
                  c = this.circles[3 * e + 1],
                  u = this.circles[3 * e + 2];
                s.push({
                  key: this.circleKeys[e],
                  x1: l - u,
                  y1: c - u,
                  x2: l + u,
                  y2: c + u
                });
              }
            } else this._forEachCell(e, t, r, n, this._queryCell, s, {
              hitTest: i,
              overlapMode: o,
              seenUids: {
                box: {},
                circle: {}
              }
            }, a);
            return s;
          }
          query(e, t, r, n) {
            return this._query(e, t, r, n, !1, null);
          }
          hitTest(e, t, r, n, i, o) {
            return 0 < this._query(e, t, r, n, !0, i, o).length;
          }
          hitTestCircle(e, t, r, n, i) {
            var o = e - r,
              a = e + r,
              s = t - r,
              l = t + r;
            return !(a < 0 || o > this.width || l < 0 || s > this.height) && (this._forEachCell(o, s, a, l, this._queryCellCircle, o = [], {
              hitTest: !0,
              overlapMode: n,
              circle: {
                x: e,
                y: t,
                radius: r
              },
              seenUids: {
                box: {},
                circle: {}
              }
            }, i), 0 < o.length);
          }
          _queryCell(e, t, r, n, i, o, a, s) {
            var {
                seenUids: l,
                hitTest: c,
                overlapMode: u
              } = a,
              a = this.boxCells[i];
            if (null !== a) {
              var h = this.bboxes;
              for (const v of a) if (!l.box[v]) {
                l.box[v] = !0;
                var d = 4 * v,
                  p = this.boxKeys[v];
                if (e <= h[2 + d] && t <= h[3 + d] && r >= h[0 + d] && n >= h[1 + d] && (!s || s(p)) && (!c || !Re(u, p.overlapMode)) && (o.push({
                  key: p,
                  x1: h[d],
                  y1: h[1 + d],
                  x2: h[2 + d],
                  y2: h[3 + d]
                }), c)) return !0;
              }
            }
            a = this.circleCells[i];
            if (null !== a) {
              var f = this.circles;
              for (const E of a) if (!l.circle[E]) {
                l.circle[E] = !0;
                var _ = 3 * E,
                  m = this.circleKeys[E];
                if (this._circleAndRectCollide(f[_], f[1 + _], f[2 + _], e, t, r, n) && (!s || s(m)) && (!c || !Re(u, m.overlapMode))) {
                  var g = f[_],
                    y = f[1 + _],
                    _ = f[2 + _];
                  if (o.push({
                    key: m,
                    x1: g - _,
                    y1: y - _,
                    x2: g + _,
                    y2: y + _
                  }), c) return !0;
                }
              }
            }
            return !1;
          }
          _queryCellCircle(e, t, r, n, i, o, a, s) {
            var {
                circle: l,
                seenUids: c,
                overlapMode: u
              } = a,
              a = this.boxCells[i];
            if (null !== a) {
              var h = this.bboxes;
              for (const g of a) if (!c.box[g]) {
                c.box[g] = !0;
                var d = 4 * g,
                  p = this.boxKeys[g];
                if (this._circleAndRectCollide(l.x, l.y, l.radius, h[0 + d], h[1 + d], h[2 + d], h[3 + d]) && (!s || s(p)) && !Re(u, p.overlapMode)) return o.push(!0), !0;
              }
            }
            a = this.circleCells[i];
            if (null !== a) {
              var f = this.circles;
              for (const y of a) if (!c.circle[y]) {
                c.circle[y] = !0;
                var _ = 3 * y,
                  m = this.circleKeys[y];
                if (this._circlesCollide(f[_], f[1 + _], f[2 + _], l.x, l.y, l.radius) && (!s || s(m)) && !Re(u, m.overlapMode)) return o.push(!0), !0;
              }
            }
          }
          _forEachCell(r, n, i, o, a, s, l, c) {
            var e = this._convertToXCellCoord(r),
              u = this._convertToYCellCoord(n),
              h = this._convertToXCellCoord(i),
              d = this._convertToYCellCoord(o);
            for (let t = e; t <= h; t++) for (let e = u; e <= d; e++) {
              var p = this.xCellCount * e + t;
              if (a.call(this, r, n, i, o, p, s, l, c)) return;
            }
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
          }
          _circlesCollide(e, t, r, n, i, o) {
            n -= e, e = i - t, i = r + o;
            return n * n + e * e < i * i;
          }
          _circleAndRectCollide(e, t, r, n, i, o, a) {
            o = (o - n) / 2, e = Math.abs(e - (n + o));
            return !(o + r < e || (n = (a - i) / 2) + r < (a = Math.abs(t - (i + n))) || !(e <= o || a <= n || (t = e - o) * t + (i = a - n) * i <= r * r));
          }
        }
        function Me(e, t, r, n, i) {
          var o = de.create();
          return t ? (de.scale(o, o, [1 / i, 1 / i, 1]), r || de.rotateZ(o, o, n.angle)) : de.multiply(o, n.labelPlaneMatrix, e), o;
        }
        function ke(e, t, r, n, i) {
          return t ? (t = de.clone(e), de.scale(t, t, [i, i, 1]), r || de.rotateZ(t, t, -n.angle), t) : n.glCoordMatrix;
        }
        function pe(e, t, r) {
          let n;
          r ? (n = [e.x, e.y, r(e.x, e.y), 1], de.transformMat4(n, n, t)) : Ge(n = [e.x, e.y, 0, 1], n, t);
          r = n[3];
          return {
            point: new de.Point(n[0] / r, n[1] / r),
            signedDistanceFromCamera: r
          };
        }
        function Le(e, t) {
          return .5 + e / t * .5;
        }
        function Ue(e, t, r, n, i, o, a, s, l, c, u, h, d) {
          var p = s.glyphStartIndex + s.numGlyphs,
            f = s.lineStartIndex,
            _ = s.lineStartIndex + s.lineLength,
            m = t.getoffsetX(s.glyphStartIndex),
            t = t.getoffsetX(p - 1),
            p = He(e * m, r, n, i, o, a, s.segment, f, _, l, c, u, h, d);
          return p && (m = He(e * t, r, n, i, o, a, s.segment, f, _, l, c, u, h, d)) ? {
            first: p,
            last: m
          } : null;
        }
        function Fe(e, t, r, n) {
          if (e === de.WritingMode.horizontal) {
            var i = Math.abs(r.y - t.y);
            if (Math.abs(r.x - t.x) * n < i) return {
              useVertical: !0
            };
          }
          return (e === de.WritingMode.vertical ? t.y < r.y : t.x > r.x) ? {
            needsFlipping: !0
          } : null;
        }
        function Be(t, e, r, n, i, o, a, s, l, c, u, h, d, p, f, _) {
          var m = e / 24,
            g = t.lineOffsetX * m,
            y = t.lineOffsetY * m;
          let v;
          if (1 < t.numGlyphs) {
            var E = t.glyphStartIndex + t.numGlyphs,
              b = t.lineStartIndex,
              w = t.lineStartIndex + t.lineLength,
              e = Ue(m, s, g, y, r, u, h, t, l, o, d, f, _);
            if (!e) return {
              notEnoughRoom: !0
            };
            var T = pe(e.first.point, a, _).point,
              a = pe(e.last.point, a, _).point;
            if (n && !r) {
              T = Fe(t.writingMode, T, a, p);
              if (T) return T;
            }
            v = [e.first];
            for (let e = t.glyphStartIndex + 1; e < E - 1; e++) v.push(He(m * s.getoffsetX(e), g, y, r, u, h, t.segment, b, w, l, o, d, f, _));
            v.push(e.last);
          } else {
            if (n && !r) {
              a = pe(h, i, _).point, T = t.lineStartIndex + t.segment + 1, e = new de.Point(l.getx(T), l.gety(T)), n = pe(e, i, _), T = 0 < n.signedDistanceFromCamera ? n.point : $e(h, e, a, 1, i, _), n = Fe(t.writingMode, a, T, p);
              if (n) return n;
            }
            e = He(m * s.getoffsetX(t.glyphStartIndex), g, y, r, u, h, t.segment, t.lineStartIndex, t.lineStartIndex + t.lineLength, l, o, d, f, _);
            if (!e) return {
              notEnoughRoom: !0
            };
            v = [e];
          }
          for (const S of v) de.addDynamicAttributes(c, S.point, S.angle);
          return {};
        }
        function $e(e, t, r, n, i, o) {
          e = pe(e.add(e.sub(t)._unit()), i, o).point, t = r.sub(e);
          return r.add(t._mult(n / t.mag()));
        }
        function ze(e, t) {
          var r,
            n,
            {
              projectionCache: t,
              lineVertexArray: i,
              labelPlaneMatrix: o,
              tileAnchorPoint: a,
              distanceFromAnchor: s,
              getElevation: l,
              previousVertex: c,
              direction: u,
              absOffsetX: h
            } = t;
          return t.projections[e] || (0 < (n = pe(r = new de.Point(i.getx(e), i.gety(e)), o, l)).signedDistanceFromCamera ? (t.projections[e] = n.point, n.point) : (t = e - u, $e(0 === s ? a : new de.Point(i.getx(t), i.gety(t)), r, c, h - s + 1, o, l)));
        }
        function Ye(e, t, r) {
          return e._unit()._perp()._mult(t * r);
        }
        function He(e, t, r, n, i, o, a, s, l, c, u, h, d, p) {
          e = n ? e - t : e + t;
          let f = 0 < e ? 1 : -1,
            _ = 0,
            m = (n && (f *= -1, _ = Math.PI), f < 0 && (_ += Math.PI), 0 < f ? s + a : s + a + 1),
            g = i,
            y = i,
            v,
            E,
            b = 0,
            w = 0;
          var T = Math.abs(e),
            S = [];
          let x;
          for (; b + w <= T;) {
            if ((m += f) < s || m >= l) return null;
            b += w, y = g, E = v;
            var C = {
              projectionCache: h,
              lineVertexArray: c,
              labelPlaneMatrix: u,
              tileAnchorPoint: o,
              distanceFromAnchor: b,
              getElevation: p,
              previousVertex: y,
              direction: f,
              absOffsetX: T
            };
            if (g = ze(m, C), 0 === r) S.push(y), x = g.sub(y);else {
              let e;
              var A = g.sub(y);
              e = 0 === A.mag() ? Ye(ze(m + f, C).sub(g), r, f) : Ye(A, r, f), E = E || y.add(e), v = function (e, t, r, n, i, o, a, s) {
                var {
                  projectionCache: l,
                  direction: c
                } = s;
                if (!l.offsets[e]) {
                  t = r.add(t);
                  if (e + c < n || i <= e + c) return l.offsets[e] = t;
                  n = ze(e + c, s), i = Ye(n.sub(r), a, c), s = r.add(i), a = n.add(i);
                  l.offsets[e] = de.findLineIntersection(o, t, s, a) || t;
                }
                return l.offsets[e];
              }(m, e, g, s, l, E, r, C), S.push(E), x = v.sub(E);
            }
            w = x.mag();
          }
          t = (T - b) / w, n = x._mult(t)._add(E || y), a = _ + Math.atan2(g.y - y.y, g.x - y.x);
          return S.push(n), {
            point: n,
            angle: d ? a : 0,
            path: S
          };
        }
        const je = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function fe(t, r) {
          for (let e = 0; e < t; e++) {
            var n = r.length;
            r.resize(n + 4), r.float32.set(je, 3 * n);
          }
        }
        function Ge(e, t, r) {
          var n = t[0],
            t = t[1];
          e[0] = r[0] * n + r[4] * t + r[12], e[1] = r[1] * n + r[5] * t + r[13], e[3] = r[3] * n + r[7] * t + r[15];
        }
        class qe {
          constructor(e, t = new Oe(e.width + 200, e.height + 200, 25), r = new Oe(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = t, this.ignoredGrid = r, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + 100, this.screenBottomBoundary = e.height + 100, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6;
          }
          placeCollisionBox(e, t, r, n, i, o) {
            var n = this.projectAndGetPerspectiveRatio(n, e.anchorPointX, e.anchorPointY, o),
              o = r * n.perspectiveRatio,
              r = e.x1 * o + n.point.x,
              a = e.y1 * o + n.point.y,
              s = e.x2 * o + n.point.x,
              e = e.y2 * o + n.point.y;
            return !this.isInsideGrid(r, a, s, e) || "always" !== t && this.grid.hitTest(r, a, s, e, t, i) || n.perspectiveRatio < this.perspectiveRatioCutoff ? {
              box: [],
              offscreen: !1
            } : {
              box: [r, a, s, e],
              offscreen: this.isOffscreen(r, a, s, e)
            };
          }
          placeCollisionCircles(r, e, t, n, i, o, a, s, l, c, u, h, d, p) {
            var f = [],
              _ = new de.Point(e.anchorX, e.anchorY),
              o = pe(_, o, p),
              o = Le(this.transform.cameraToCenterDistance, o.signedDistanceFromCamera),
              c = (c ? i / o : i * o) / de.ONE_EM,
              i = pe(_, a, p).point,
              n = Ue(c, n, e.lineOffsetX * c, e.lineOffsetY * c, !1, i, _, e, t, a, {
                projections: {},
                offsets: {}
              }, !1, p);
            let m = !1,
              g = !1,
              y = !0;
            if (n) {
              var v = .5 * h * o + d,
                c = new de.Point(-100, -100),
                i = new de.Point(this.screenRightBoundary, this.screenBottomBoundary),
                E = new De(),
                b = n.first,
                w = n.last;
              let t = [];
              for (let e = b.path.length - 1; 1 <= e; e--) t.push(b.path[e]);
              for (let e = 1; e < w.path.length; e++) t.push(w.path[e]);
              var T = 2.5 * v;
              s && (_ = t.map(e => pe(e, s, p)), t = _.some(e => e.signedDistanceFromCamera <= 0) ? [] : _.map(e => e.point));
              let e = [];
              if (0 < t.length) {
                var S = t[0].clone(),
                  x = t[0].clone();
                for (let e = 1; e < t.length; e++) S.x = Math.min(S.x, t[e].x), S.y = Math.min(S.y, t[e].y), x.x = Math.max(x.x, t[e].x), x.y = Math.max(x.y, t[e].y);
                e = S.x >= c.x && x.x <= i.x && S.y >= c.y && x.y <= i.y ? [t] : x.x < c.x || S.x > i.x || x.y < c.y || S.y > i.y ? [] : de.clipLine([t], c.x, c.y, i.x, i.y);
              }
              for (const R of e) {
                E.reset(R, .25 * v);
                let t = 0;
                t = E.length <= .5 * v ? 1 : Math.ceil(E.paddedLength / T) + 1;
                for (let e = 0; e < t; e++) {
                  var C = e / Math.max(t - 1, 1),
                    C = E.lerp(C),
                    A = C.x + 100,
                    C = C.y + 100,
                    I = (f.push(A, C, v, 0), A - v),
                    N = C - v,
                    P = A + v,
                    D = C + v;
                  if (y = y && this.isOffscreen(I, N, P, D), g = g || this.isInsideGrid(I, N, P, D), "always" !== r && this.grid.hitTestCircle(A, C, v, r, u) && (m = !0, !l)) return {
                    circles: [],
                    offscreen: !1,
                    collisionDetected: m
                  };
                }
              }
            }
            return {
              circles: !l && m || !g || o < this.perspectiveRatioCutoff ? [] : f,
              offscreen: y,
              collisionDetected: m
            };
          }
          queryRenderedSymbols(e) {
            if (0 === e.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
            var t = [];
            let r = 1 / 0,
              n = 1 / 0,
              i = -1 / 0,
              o = -1 / 0;
            for (const h of e) {
              var a = new de.Point(h.x + 100, h.y + 100);
              r = Math.min(r, a.x), n = Math.min(n, a.y), i = Math.max(i, a.x), o = Math.max(o, a.y), t.push(a);
            }
            var s = {},
              l = {};
            for (const d of this.grid.query(r, n, i, o).concat(this.ignoredGrid.query(r, n, i, o))) {
              var c,
                u = d.key;
              void 0 === s[u.bucketInstanceId] && (s[u.bucketInstanceId] = {}), s[u.bucketInstanceId][u.featureIndex] || (c = [new de.Point(d.x1, d.y1), new de.Point(d.x2, d.y1), new de.Point(d.x2, d.y2), new de.Point(d.x1, d.y2)], de.polygonIntersectsPolygon(t, c) && (s[u.bucketInstanceId][u.featureIndex] = !0, void 0 === l[u.bucketInstanceId] && (l[u.bucketInstanceId] = []), l[u.bucketInstanceId].push(u.featureIndex)));
            }
            return l;
          }
          insertCollisionBox(e, t, r, n, i, o) {
            (r ? this.ignoredGrid : this.grid).insert({
              bucketInstanceId: n,
              featureIndex: i,
              collisionGroupID: o,
              overlapMode: t
            }, e[0], e[1], e[2], e[3]);
          }
          insertCollisionCircles(t, e, r, n, i, o) {
            var a = r ? this.ignoredGrid : this.grid,
              s = {
                bucketInstanceId: n,
                featureIndex: i,
                collisionGroupID: o,
                overlapMode: e
              };
            for (let e = 0; e < t.length; e += 4) a.insertCircle(s, t[e], t[e + 1], t[e + 2]);
          }
          projectAndGetPerspectiveRatio(e, t, r, n) {
            let i;
            return n ? (i = [t, r, n(t, r), 1], de.transformMat4(i, i, e)) : Ge(i = [t, r, 0, 1], i, e), {
              point: new de.Point((i[0] / i[3] + 1) / 2 * this.transform.width + 100, (-i[1] / i[3] + 1) / 2 * this.transform.height + 100),
              perspectiveRatio: .5 + this.transform.cameraToCenterDistance / i[3] * .5
            };
          }
          isOffscreen(e, t, r, n) {
            return r < 100 || e >= this.screenRightBoundary || n < 100 || t > this.screenBottomBoundary;
          }
          isInsideGrid(e, t, r, n) {
            return 0 <= r && e < this.gridRightBoundary && 0 <= n && t < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            var e = de.identity([]);
            return de.translate(e, e, [-100, -100, 0]), e;
          }
        }
        function _e(e, t, r) {
          return t * (de.EXTENT / (e.tileSize * Math.pow(2, r - e.tileID.overscaledZ)));
        }
        class Ve {
          constructor(e, t, r, n) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : n && r ? 1 : 0, this.placed = r;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class x {
          constructor(e, t, r, n, i) {
            this.text = new Ve(e ? e.text : null, t, r, i), this.icon = new Ve(e ? e.icon : null, t, n, i);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Ke {
          constructor(e, t, r) {
            this.text = e, this.icon = t, this.skipFade = r;
          }
        }
        class We {
          constructor() {
            this.invProjMatrix = de.create(), this.viewportMatrix = de.create(), this.circles = [];
          }
        }
        class Ze {
          constructor(e, t, r, n, i) {
            this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = r, this.bucketIndex = n, this.tileID = i;
          }
        }
        class Xe {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e) {
            if (this.crossSourceCollisions) return {
              ID: 0,
              predicate: null
            };
            if (!this.collisionGroups[e]) {
              const t = ++this.maxGroupID;
              this.collisionGroups[e] = {
                ID: t,
                predicate: e => e.collisionGroupID === t
              };
            }
            return this.collisionGroups[e];
          }
        }
        function Je(e, t, r, n, i) {
          var {
            horizontalAlign: e,
            verticalAlign: o
          } = de.getAnchorAlignment(e);
          return new de.Point(-(e - .5) * t + n[0] * i, -(o - .5) * r + n[1] * i);
        }
        function Qe(e, t, r, n, i, o) {
          var {
              x1: e,
              x2: a,
              y1: s,
              y2: l,
              anchorPointX: c,
              anchorPointY: u
            } = e,
            t = new de.Point(t, r);
          return n && t._rotate(i ? o : -o), {
            x1: e + t.x,
            y1: s + t.y,
            x2: a + t.x,
            y2: l + t.y,
            anchorPointX: c,
            anchorPointY: u
          };
        }
        class et {
          constructor(e, t, r, n, i) {
            this.transform = e.clone(), this.terrain = t, this.collisionIndex = new qe(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = r, this.retainedQueryData = {}, this.collisionGroups = new Xe(n), this.collisionCircleArrays = {}, (this.prevPlacement = i) && (i.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(t, r, n, i) {
            var o = n.getBucket(r),
              a = n.latestFeatureIndex;
            if (o && a && r.id === o.layerIds[0]) {
              var r = n.collisionBoxArray,
                s = o.layers[0].layout,
                l = Math.pow(2, this.transform.zoom - n.tileID.overscaledZ),
                c = n.tileSize / de.EXTENT,
                u = this.transform.calculatePosMatrix(n.tileID.toUnwrapped()),
                h = "map" === s.get("text-pitch-alignment"),
                d = "map" === s.get("text-rotation-alignment"),
                p = _e(n, 1, this.transform.zoom),
                f = Me(u, h, d, this.transform, p);
              let e = null;
              h && (h = ke(u, h, d, this.transform, p), e = de.multiply([], this.transform.labelPlaneMatrix, h)), this.retainedQueryData[o.bucketInstanceId] = new Ze(o.bucketInstanceId, a, o.sourceLayerIndex, o.index, n.tileID);
              var _ = {
                bucket: o,
                layout: s,
                posMatrix: u,
                textLabelPlaneMatrix: f,
                labelToScreenMatrix: e,
                scale: l,
                textPixelRatio: c,
                holdingForFade: n.holdingForFade(),
                collisionBoxArray: r,
                partiallyEvaluatedTextSize: de.evaluateSizeForZoom(o.textSizeData, this.transform.zoom),
                collisionGroup: this.collisionGroups.get(o.sourceID)
              };
              if (i) for (const v of o.sortKeyRanges) {
                var {
                  sortKey: m,
                  symbolInstanceStart: g,
                  symbolInstanceEnd: y
                } = v;
                t.push({
                  sortKey: m,
                  symbolInstanceStart: g,
                  symbolInstanceEnd: y,
                  parameters: _
                });
              } else t.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: o.symbolInstances.length,
                parameters: _
              });
            }
          }
          attemptAnchorPlacement(t, r, n, i, o, e, a, s, l, c, u, h, d, p, f, _) {
            var m = de.TextAnchorEnum[t.textAnchor],
              t = [t.textOffset0, t.textOffset1],
              g = Je(m, n, i, t, o),
              r = this.collisionIndex.placeCollisionBox(Qe(r, g.x, g.y, e, a, this.transform.angle), u, s, l, c.predicate, _);
            if (f && 0 === this.collisionIndex.placeCollisionBox(Qe(f, g.x, g.y, e, a, this.transform.angle), u, s, l, c.predicate, _).box.length) return;
            if (0 < r.box.length) {
              let e;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[h.crossTileID] && this.prevPlacement.placements[h.crossTileID] && this.prevPlacement.placements[h.crossTileID].text && (e = this.prevPlacement.variableOffsets[h.crossTileID].anchor), 0 === h.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[h.crossTileID] = {
                textOffset: t,
                width: n,
                height: i,
                anchor: m,
                textBoxScale: o,
                prevAnchor: e
              }, this.markUsedJustification(d, m, h, p), d.allowVerticalPlacement && (this.markUsedOrientation(d, p, h), this.placedOrientations[h.crossTileID] = p), {
                shift: g,
                placedGlyphBoxes: r
              };
            }
          }
          placeLayerBucketPart(t, T, S) {
            const {
                bucket: x,
                layout: C,
                posMatrix: A,
                textLabelPlaneMatrix: I,
                labelToScreenMatrix: N,
                textPixelRatio: P,
                holdingForFade: e,
                collisionBoxArray: r,
                partiallyEvaluatedTextSize: D,
                collisionGroup: R
              } = t.parameters,
              O = C.get("text-optional"),
              M = C.get("icon-optional"),
              k = de.getOverlapMode(C, "text-overlap", "text-allow-overlap"),
              L = "always" === k,
              U = de.getOverlapMode(C, "icon-overlap", "icon-allow-overlap");
            var n = "always" === U;
            const F = "map" === C.get("text-rotation-alignment"),
              B = "map" === C.get("text-pitch-alignment"),
              $ = "none" !== C.get("icon-text-fit");
            var i = "viewport-y" === C.get("symbol-z-order");
            const z = L && (n || !x.hasIconData() || M),
              Y = n && (L || !x.hasTextData() || O),
              o = (!x.collisionArrays && r && x.deserializeCollisionBoxes(r), this.retainedQueryData[x.bucketInstanceId].tileID),
              H = this.terrain ? (e, t) => this.terrain.getElevation(o, e, t) : null;
            var a = (f, c) => {
              if (!T[f.crossTileID]) if (e) this.placements[f.crossTileID] = new Ke(!1, !1, !1);else {
                let d = !1,
                  e = !1,
                  t = !0,
                  p = null,
                  n = {
                    box: null,
                    offscreen: null
                  },
                  i = {
                    box: null,
                    offscreen: null
                  };
                let r = null,
                  o = null,
                  a = 0,
                  s = 0,
                  l = 0;
                c.textFeatureIndex ? a = c.textFeatureIndex : f.useRuntimeCollisionCircles && (a = f.featureIndex), c.verticalTextFeatureIndex && (s = c.verticalTextFeatureIndex);
                const y = c.textBox;
                if (y) {
                  var u = e => {
                      let t = de.WritingMode.horizontal;
                      return x.allowVerticalPlacement && !e && this.prevPlacement && (e = this.prevPlacement.placedOrientations[f.crossTileID]) && (this.placedOrientations[f.crossTileID] = e, t = e, this.markUsedOrientation(x, t, f)), t;
                    },
                    _ = (e, t) => {
                      if (x.allowVerticalPlacement && 0 < f.numVerticalGlyphVertices && c.verticalTextBox) {
                        for (const r of x.writingModes) if (r === de.WritingMode.vertical ? (n = t(), i = n) : n = e(), n && n.box && n.box.length) break;
                      } else n = e();
                    };
                  const v = f.textAnchorOffsetStartIndex,
                    E = f.textAnchorOffsetEndIndex;
                  if (E === v) {
                    const b = (e, t) => {
                      e = this.collisionIndex.placeCollisionBox(e, k, P, A, R.predicate, H);
                      return e && e.box && e.box.length && (this.markUsedOrientation(x, t, f), this.placedOrientations[f.crossTileID] = t), e;
                    };
                    _(() => b(y, de.WritingMode.horizontal), () => {
                      var e = c.verticalTextBox;
                      return x.allowVerticalPlacement && 0 < f.numVerticalGlyphVertices && e ? b(e, de.WritingMode.vertical) : {
                        box: null,
                        offscreen: null
                      };
                    }), u(n && n.box && n.box.length);
                  } else {
                    let h = de.TextAnchorEnum[null == (m = null == (m = this.prevPlacement) ? void 0 : m.variableOffsets[f.crossTileID]) ? void 0 : m.anchor];
                    const w = (t, e, r) => {
                      var n = t.x2 - t.x1,
                        i = t.y2 - t.y1,
                        o = f.textBoxScale,
                        a = $ && "never" === U ? e : null;
                      let s = {
                          box: [],
                          offscreen: !1
                        },
                        l = "never" === k ? 1 : 2,
                        c = "never";
                      h && l++;
                      for (let e = 0; e < l; e++) {
                        for (let e = v; e < E; e++) {
                          var u = x.textAnchorOffsets.get(e);
                          if (!h || u.textAnchor === h) {
                            u = this.attemptAnchorPlacement(u, t, n, i, o, F, B, P, A, R, c, f, x, r, a, H);
                            if (u && (s = u.placedGlyphBoxes) && s.box && s.box.length) return d = !0, p = u.shift, s;
                          }
                        }
                        h ? h = null : c = k;
                      }
                      return s;
                    };
                    _(() => w(y, c.iconBox, de.WritingMode.horizontal), () => {
                      var e = c.verticalTextBox,
                        t = n && n.box && n.box.length;
                      return x.allowVerticalPlacement && !t && 0 < f.numVerticalGlyphVertices && e ? w(e, c.verticalIconBox, de.WritingMode.vertical) : {
                        box: null,
                        offscreen: null
                      };
                    }), n && (d = n.box, t = n.offscreen);
                    var m = u(n && n.box);
                    !d && this.prevPlacement && (_ = this.prevPlacement.variableOffsets[f.crossTileID]) && (this.variableOffsets[f.crossTileID] = _, this.markUsedJustification(x, _.anchor, f, m));
                  }
                }
                u = n, d = u && u.box && 0 < u.box.length, t = u && u.offscreen, f.useRuntimeCollisionCircles && (_ = x.text.placedSymbolArray.get(f.centerJustifiedTextSymbolIndex), m = de.evaluateSizeForFeature(x.textSizeData, D, _), g = C.get("text-padding"), h = f.collisionCircleDiameter, (r = this.collisionIndex.placeCollisionCircles(k, _, x.lineVertexArray, x.glyphOffsetArray, m, A, I, N, S, B, R.predicate, h, g, H)).circles.length && r.collisionDetected && !S && de.warnOnce("Collisions detected, but collision boxes are not shown"), d = L || 0 < r.circles.length && !r.collisionDetected, t = t && r.offscreen), c.iconFeatureIndex && (l = c.iconFeatureIndex), c.iconBox && (_ = e => {
                  e = $ && p ? Qe(e, p.x, p.y, F, B, this.transform.angle) : e;
                  return this.collisionIndex.placeCollisionBox(e, U, P, A, R.predicate, H);
                }, e = 0 < (o = i && i.box && i.box.length && c.verticalIconBox ? _(c.verticalIconBox) : _(c.iconBox)).box.length, t = t && o.offscreen);
                var m = O || 0 === f.numHorizontalGlyphVertices && 0 === f.numVerticalGlyphVertices,
                  h = M || 0 === f.numIconVertices;
                if (m || h ? h ? m || (e = e && d) : d = e && d : e = d = e && d, d && u && u.box && (i && i.box && s ? this.collisionIndex.insertCollisionBox(u.box, k, C.get("text-ignore-placement"), x.bucketInstanceId, s, R.ID) : this.collisionIndex.insertCollisionBox(u.box, k, C.get("text-ignore-placement"), x.bucketInstanceId, a, R.ID)), e && o && this.collisionIndex.insertCollisionBox(o.box, U, C.get("icon-ignore-placement"), x.bucketInstanceId, l, R.ID), r && (d && this.collisionIndex.insertCollisionCircles(r.circles, k, C.get("text-ignore-placement"), x.bucketInstanceId, a, R.ID), S)) {
                  var g = x.bucketInstanceId;
                  let t = this.collisionCircleArrays[g];
                  void 0 === t && (t = this.collisionCircleArrays[g] = new We());
                  for (let e = 0; e < r.circles.length; e += 4) t.circles.push(r.circles[e + 0]), t.circles.push(r.circles[e + 1]), t.circles.push(r.circles[e + 2]), t.circles.push(r.collisionDetected ? 1 : 0);
                }
                if (0 === f.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
                if (0 === x.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[f.crossTileID] = new Ke(d || z, e || Y, t || x.justReloaded), T[f.crossTileID] = !0;
              }
            };
            if (i) {
              if (0 !== t.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
              var s = x.getSortedSymbolIndexes(this.transform.angle);
              for (let e = s.length - 1; 0 <= e; --e) {
                var l = s[e];
                a(x.symbolInstances.get(l), x.collisionArrays[l]);
              }
            } else for (let e = t.symbolInstanceStart; e < t.symbolInstanceEnd; e++) a(x.symbolInstances.get(e), x.collisionArrays[e]);
            S && x.bucketInstanceId in this.collisionCircleArrays && (n = this.collisionCircleArrays[x.bucketInstanceId], de.invert(n.invProjMatrix, A), n.viewportMatrix = this.collisionIndex.getViewportMatrix()), x.justReloaded = !1;
          }
          markUsedJustification(e, t, r, n) {
            var i = {
              left: r.leftJustifiedTextSymbolIndex,
              center: r.centerJustifiedTextSymbolIndex,
              right: r.rightJustifiedTextSymbolIndex
            };
            let o;
            o = n === de.WritingMode.vertical ? r.verticalPlacedTextSymbolIndex : i[de.getAnchorJustification(t)];
            for (const a of [r.leftJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.rightJustifiedTextSymbolIndex, r.verticalPlacedTextSymbolIndex]) 0 <= a && (0 <= o && a !== o ? e.text.placedSymbolArray.get(a).crossTileID = 0 : e.text.placedSymbolArray.get(a).crossTileID = r.crossTileID);
          }
          markUsedOrientation(e, t, r) {
            var n = t === de.WritingMode.horizontal || t === de.WritingMode.horizontalOnly ? t : 0,
              t = t === de.WritingMode.vertical ? t : 0;
            for (const i of [r.leftJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.rightJustifiedTextSymbolIndex]) e.text.placedSymbolArray.get(i).placedOrientation = n;
            r.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(r.verticalPlacedTextSymbolIndex).placedOrientation = t);
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            var t = this.prevPlacement;
            let r = !1;
            this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0;
            var n = t ? t.symbolFadeChange(e) : 1,
              i = t ? t.opacities : {},
              o = t ? t.variableOffsets : {},
              a = t ? t.placedOrientations : {};
            for (const h in this.placements) {
              var s = this.placements[h],
                l = i[h];
              r = l ? (this.opacities[h] = new x(l, n, s.text, s.icon), r || s.text !== l.text.placed || s.icon !== l.icon.placed) : (this.opacities[h] = new x(null, n, s.text, s.icon, s.skipFade), r || s.text || s.icon);
            }
            for (const d in i) {
              var c,
                u = i[d];
              this.opacities[d] || (c = new x(u, n, !1, !1)).isHidden() || (this.opacities[d] = c, r = r || u.text.placed || u.icon.placed);
            }
            for (const p in o) this.variableOffsets[p] || !this.opacities[p] || this.opacities[p].isHidden() || (this.variableOffsets[p] = o[p]);
            for (const f in a) this.placedOrientations[f] || !this.opacities[f] || this.opacities[f].isHidden() || (this.placedOrientations[f] = a[f]);
            if (t && void 0 === t.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
            r ? this.lastPlacementChangeTime = e : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e);
          }
          updateLayerOpacities(e, t) {
            var r = {};
            for (const i of t) {
              var n = i.getBucket(e);
              n && i.latestFeatureIndex && e.id === n.layerIds[0] && this.updateBucketOpacities(n, r, i.collisionBoxArray);
            }
          }
          updateBucketOpacities(n, t, e) {
            n.hasTextData() && (n.text.opacityVertexArray.clear(), n.text.hasVisibleVertices = !1), n.hasIconData() && (n.icon.opacityVertexArray.clear(), n.icon.hasVisibleVertices = !1), n.hasIconCollisionBoxData() && n.iconCollisionBox.collisionVertexArray.clear(), n.hasTextCollisionBoxData() && n.textCollisionBox.collisionVertexArray.clear();
            var r = n.layers[0],
              i = r.layout,
              o = new x(null, 0, !1, !1, !0),
              a = i.get("text-allow-overlap"),
              s = i.get("icon-allow-overlap"),
              l = r._unevaluatedLayout.hasValue("text-variable-anchor") || r._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
              c = "map" === i.get("text-rotation-alignment"),
              u = "map" === i.get("text-pitch-alignment"),
              h = "none" !== i.get("icon-text-fit"),
              d = new x(null, 0, a && (s || !n.hasIconData() || i.get("icon-optional")), s && (a || !n.hasTextData() || i.get("text-optional")), !0),
              p = (!n.collisionArrays && e && (n.hasIconCollisionBoxData() || n.hasTextCollisionBoxData()) && n.deserializeCollisionBoxes(e), (t, r, n) => {
                for (let e = 0; e < r / 4; e++) t.opacityVertexArray.emplaceBack(n);
                t.hasVisibleVertices = t.hasVisibleVertices || n !== C;
              });
            for (let e = 0; e < n.symbolInstances.length; e++) {
              var f = n.symbolInstances.get(e),
                {
                  numHorizontalGlyphVertices: _,
                  numVerticalGlyphVertices: m,
                  crossTileID: g
                } = f,
                y = t[g];
              let r = this.opacities[g];
              y ? r = o : r || (r = d, this.opacities[g] = r), t[g] = !0;
              var y = 0 < f.numIconVertices,
                v = this.placedOrientations[f.crossTileID];
              const T = v === de.WritingMode.vertical;
              var E = v === de.WritingMode.horizontal || v === de.WritingMode.horizontalOnly;
              if (0 < _ || 0 < m) {
                var b = ct(r.text),
                  w = T ? C : b,
                  _ = (p(n.text, _, w), E ? C : b);
                p(n.text, m, _);
                const S = r.text.isHidden();
                [f.rightJustifiedTextSymbolIndex, f.centerJustifiedTextSymbolIndex, f.leftJustifiedTextSymbolIndex].forEach(e => {
                  0 <= e && (n.text.placedSymbolArray.get(e).hidden = S || T ? 1 : 0);
                }), 0 <= f.verticalPlacedTextSymbolIndex && (n.text.placedSymbolArray.get(f.verticalPlacedTextSymbolIndex).hidden = S || E ? 1 : 0);
                var w = this.variableOffsets[f.crossTileID],
                  b = (w && this.markUsedJustification(n, w.anchor, f, v), this.placedOrientations[f.crossTileID]);
                b && (this.markUsedJustification(n, "left", f, b), this.markUsedOrientation(n, b, f));
              }
              if (y && (m = ct(r.icon), _ = !(h && f.verticalPlacedIconSymbolIndex && T), 0 <= f.placedIconSymbolIndex && (w = _ ? m : C, p(n.icon, f.numIconVertices, w), n.icon.placedSymbolArray.get(f.placedIconSymbolIndex).hidden = r.icon.isHidden()), 0 <= f.verticalPlacedIconSymbolIndex) && (v = _ ? C : m, p(n.icon, f.numVerticalIconVertices, v), n.icon.placedSymbolArray.get(f.verticalPlacedIconSymbolIndex).hidden = r.icon.isHidden()), n.hasIconCollisionBoxData() || n.hasTextCollisionBoxData()) {
                b = n.collisionArrays[e];
                if (b) {
                  let t = new de.Point(0, 0);
                  if (b.textBox || b.verticalTextBox) {
                    let e = !0;
                    l && ((y = this.variableOffsets[g]) ? (t = Je(y.anchor, y.width, y.height, y.textOffset, y.textBoxScale), c && t._rotate(u ? this.transform.angle : -this.transform.angle)) : e = !1), b.textBox && tt(n.textCollisionBox.collisionVertexArray, r.text.placed, !e || T, t.x, t.y), b.verticalTextBox && tt(n.textCollisionBox.collisionVertexArray, r.text.placed, !e || E, t.x, t.y);
                  }
                  _ = Boolean(!E && b.verticalIconBox);
                  b.iconBox && tt(n.iconCollisionBox.collisionVertexArray, r.icon.placed, _, h ? t.x : 0, h ? t.y : 0), b.verticalIconBox && tt(n.iconCollisionBox.collisionVertexArray, r.icon.placed, !_, h ? t.x : 0, h ? t.y : 0);
                }
              }
            }
            if (n.sortFeatures(this.transform.angle), this.retainedQueryData[n.bucketInstanceId] && (this.retainedQueryData[n.bucketInstanceId].featureSortOrder = n.featureSortOrder), n.hasTextData() && n.text.opacityVertexBuffer && n.text.opacityVertexBuffer.updateData(n.text.opacityVertexArray), n.hasIconData() && n.icon.opacityVertexBuffer && n.icon.opacityVertexBuffer.updateData(n.icon.opacityVertexArray), n.hasIconCollisionBoxData() && n.iconCollisionBox.collisionVertexBuffer && n.iconCollisionBox.collisionVertexBuffer.updateData(n.iconCollisionBox.collisionVertexArray), n.hasTextCollisionBoxData() && n.textCollisionBox.collisionVertexBuffer && n.textCollisionBox.collisionVertexBuffer.updateData(n.textCollisionBox.collisionVertexArray), n.text.opacityVertexArray.length !== n.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${n.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${n.text.layoutVertexArray.length}) / 4`);
            if (n.icon.opacityVertexArray.length !== n.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${n.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${n.icon.layoutVertexArray.length}) / 4`);
            n.bucketInstanceId in this.collisionCircleArrays && (r = this.collisionCircleArrays[n.bucketInstanceId], n.placementInvProjMatrix = r.invProjMatrix, n.placementViewportMatrix = r.viewportMatrix, n.collisionCircleArray = r.circles, delete this.collisionCircleArrays[n.bucketInstanceId]);
          }
          symbolFadeChange(e) {
            return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5);
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e, t) {
            var r = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;
            return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * r > e;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function tt(e, t, r, n, i) {
          e.emplaceBack(t ? 1 : 0, r ? 1 : 0, n || 0, i || 0), e.emplaceBack(t ? 1 : 0, r ? 1 : 0, n || 0, i || 0), e.emplaceBack(t ? 1 : 0, r ? 1 : 0, n || 0, i || 0), e.emplaceBack(t ? 1 : 0, r ? 1 : 0, n || 0, i || 0);
        }
        const rt = Math.pow(2, 25),
          nt = Math.pow(2, 24),
          it = Math.pow(2, 17),
          ot = Math.pow(2, 16),
          at = Math.pow(2, 9),
          st = Math.pow(2, 8),
          lt = Math.pow(2, 1);
        function ct(e) {
          var t;
          return 0 !== e.opacity || e.placed ? 1 === e.opacity && e.placed ? 4294967295 : (t = e.placed ? 1 : 0, (e = Math.floor(127 * e.opacity)) * rt + t * nt + e * it + t * ot + e * at + t * st + e * lt + t) : 0;
        }
        const C = 0;
        class ut {
          constructor(e) {
            this._sortAcrossTiles = "viewport-y" !== e.layout.get("symbol-z-order") && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e, t, r, n, i) {
            for (var o = this._bucketParts; this._currentTileIndex < e.length;) {
              var a = e[this._currentTileIndex];
              if (t.getBucketParts(o, n, a, this._sortAcrossTiles), this._currentTileIndex++, i()) return !0;
            }
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, o.sort((e, t) => e.sortKey - t.sortKey)); this._currentPartIndex < o.length;) {
              var s = o[this._currentPartIndex];
              if (t.placeLayerBucketPart(s, this._seenCrossTileIDs, r), this._currentPartIndex++, i()) return !0;
            }
            return !1;
          }
        }
        class ht {
          constructor(e, t, r, n, i, o, a, s) {
            this.placement = new et(e, t, o, a, s), this._currentPlacementIndex = r.length - 1, this._forceFullPlacement = n, this._showCollisionBoxes = i, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e, t, r) {
            const n = de.browser.now();
            for (var i = () => !this._forceFullPlacement && 2 < de.browser.now() - n; 0 <= this._currentPlacementIndex;) {
              var o = t[e[this._currentPlacementIndex]],
                a = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === o.type && (!o.minzoom || o.minzoom <= a) && (!o.maxzoom || o.maxzoom > a)) {
                if (this._inProgressLayer || (this._inProgressLayer = new ut(o)), this._inProgressLayer.continuePlacement(r[o.source], this.placement, this._showCollisionBoxes, o, i)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(e) {
            return this.placement.commit(e), this.placement;
          }
        }
        const p = 512 / de.EXTENT / 2;
        class dt {
          constructor(e, t, r) {
            this.tileID = e, this.bucketInstanceId = r, this._symbolsByKey = {};
            var n,
              i,
              o = new Map();
            for (let e = 0; e < t.length; e++) {
              var a = t.get(e),
                s = a.key,
                l = o.get(s);
              l ? l.push(a) : o.set(s, [a]);
            }
            for ([n, i] of o) {
              var c = {
                positions: i.map(e => ({
                  x: Math.floor(e.anchorX * p),
                  y: Math.floor(e.anchorY * p)
                })),
                crossTileIDs: i.map(e => e.crossTileID)
              };
              if (128 < c.positions.length) {
                var u,
                  h,
                  d = new de.KDBush(c.positions.length, 16, Uint16Array);
                for ({
                  x: u,
                  y: h
                } of c.positions) d.add(u, h);
                d.finish(), delete c.positions, c.index = d;
              }
              this._symbolsByKey[n] = c;
            }
          }
          getScaledCoordinates(e, t) {
            var {
                x: r,
                y: n,
                z: i
              } = this.tileID.canonical,
              {
                x: t,
                y: o,
                z: a
              } = t.canonical,
              a = a - i,
              i = p / Math.pow(2, a),
              a = (t * de.EXTENT + e.anchorX) * i,
              t = (o * de.EXTENT + e.anchorY) * i,
              o = r * de.EXTENT * p,
              e = n * de.EXTENT * p;
            return {
              x: Math.floor(a - o),
              y: Math.floor(t - e)
            };
          }
          findMatches(t, r, n) {
            var i = this.tileID.canonical.z < r.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - r.canonical.z);
            for (let e = 0; e < t.length; e++) {
              var o = t.get(e);
              if (!o.crossTileID) {
                var a = this._symbolsByKey[o.key];
                if (a) {
                  var s = this.getScaledCoordinates(o, r);
                  if (a.index) for (const h of a.index.range(s.x - i, s.y - i, s.x + i, s.y + i).sort()) {
                    var l = a.crossTileIDs[h];
                    if (!n[l]) {
                      n[l] = !0, o.crossTileID = l;
                      break;
                    }
                  } else if (a.positions) for (let e = 0; e < a.positions.length; e++) {
                    var c = a.positions[e],
                      u = a.crossTileIDs[e];
                    if (Math.abs(c.x - s.x) <= i && Math.abs(c.y - s.y) <= i && !n[u]) {
                      n[u] = !0, o.crossTileID = u;
                      break;
                    }
                  }
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map(({
              crossTileIDs: e
            }) => e);
          }
        }
        class pt {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class ft {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e) {
            var t = Math.round((e - this.lng) / 360);
            if (0 !== t) for (const o in this.indexes) {
              var r = this.indexes[o],
                n = {};
              for (const a in r) {
                var i = r[a];
                i.tileID = i.tileID.unwrapTo(i.tileID.wrap + t), n[i.tileID.key] = i;
              }
              this.indexes[o] = n;
            }
            this.lng = e;
          }
          addBucket(e, t, r) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
            }
            for (let e = 0; e < t.symbolInstances.length; e++) t.symbolInstances.get(e).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            var n = this.usedCrossTileIDs[e.overscaledZ];
            for (const l in this.indexes) {
              var i = this.indexes[l];
              if (Number(l) > e.overscaledZ) for (const c in i) {
                var o = i[c];
                o.tileID.isChildOf(e) && o.findMatches(t.symbolInstances, e, n);
              } else {
                var a = i[e.scaledTo(Number(l)).key];
                a && a.findMatches(t.symbolInstances, e, n);
              }
            }
            for (let e = 0; e < t.symbolInstances.length; e++) {
              var s = t.symbolInstances.get(e);
              s.crossTileID || (s.crossTileID = r.generate(), n[s.crossTileID] = !0);
            }
            return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new dt(e, t.symbolInstances, t.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(e, t) {
            for (const r of t.getCrossTileIDsLists()) for (const n of r) delete this.usedCrossTileIDs[e][n];
          }
          removeStaleBuckets(e) {
            let t = !1;
            for (const n in this.indexes) {
              var r = this.indexes[n];
              for (const i in r) e[r[i].bucketInstanceId] || (this.removeBucketCrossTileIDs(n, r[i]), delete r[i], t = !0);
            }
            return t;
          }
        }
        class _t {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new pt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e, t, r) {
            let n = this.layerIndexes[e.id],
              i = !1;
            var o = {};
            (n = void 0 === n ? this.layerIndexes[e.id] = new ft() : n).handleWrapJump(r);
            for (const s of t) {
              var a = s.getBucket(e);
              a && e.id === a.layerIds[0] && (a.bucketInstanceId || (a.bucketInstanceId = ++this.maxBucketInstanceId), n.addBucket(s.tileID, a, this.crossTileIDs) && (i = !0), o[a.bucketInstanceId] = !0);
            }
            return i = n.removeStaleBuckets(o) ? !0 : i;
          }
          pruneUnusedLayers(e) {
            const t = {};
            e.forEach(e => {
              t[e] = !0;
            });
            for (const r in this.layerIndexes) t[r] || delete this.layerIndexes[r];
          }
        }
        const mt = (e, t) => de.emitValidationErrors(e, t && t.filter(e => "source.canvas" !== e.identifier)),
          gt = de.pick(de.operations, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setGlyphs", "setSprite"]),
          yt = de.pick(de.operations, ["setCenter", "setZoom", "setBearing", "setPitch"]),
          vt = de.emptyStyle();
        class o extends de.Evented {
          constructor(e, t = {}) {
            super(), this.map = e, this.dispatcher = new X(Pe(), this, e._getMapId()), this.imageManager = new H(), this.imageManager.setEventedParent(this), this.glyphManager = new l(e._requestManager, t.localIdeographFontFamily), this.lineAtlas = new Z(256, 512), this.crossTileSymbolIndex = new _t(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new de.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", de.getReferrer());
            const i = this;
            this._rtlTextPluginCallback = o.registerForPluginStateChange(e => {
              e = {
                pluginStatus: e.pluginStatus,
                pluginURL: e.pluginURL
              };
              i.dispatcher.broadcast("syncRTLPluginState", e, (e, t) => {
                if ((de.triggerPluginCompletionEvent(e), t) && t.every(e => e)) for (const n in i.sourceCaches) {
                  var r = i.sourceCaches[n].getSource().type;
                  "vector" !== r && "geojson" !== r || i.sourceCaches[n].reload();
                }
              });
            }), this.on("data", e => {
              if ("source" === e.dataType && "metadata" === e.sourceDataType) {
                e = this.sourceCaches[e.sourceId];
                if (e) {
                  var t = e.getSource();
                  if (t && t.vectorLayerIds) for (const n in this._layers) {
                    var r = this._layers[n];
                    r.source === t.id && this._validateLayer(r);
                  }
                }
              }
            });
          }
          loadURL(e, r = {}, n) {
            this.fire(new de.Event("dataloading", {
              dataType: "style"
            })), r.validate = "boolean" != typeof r.validate || r.validate;
            e = this.map._requestManager.transformRequest(e, _.Style);
            this._request = de.getJSON(e, (e, t) => {
              this._request = null, e ? this.fire(new de.ErrorEvent(e)) : t && this._load(t, r, n);
            });
          }
          loadJSON(e, t = {}, r) {
            this.fire(new de.Event("dataloading", {
              dataType: "style"
            })), this._request = de.browser.frame(() => {
              this._request = null, t.validate = !1 !== t.validate, this._load(e, t, r);
            });
          }
          loadEmpty() {
            this.fire(new de.Event("dataloading", {
              dataType: "style"
            })), this._load(vt, {
              validate: !1
            });
          }
          _load(e, t, r) {
            var n = t.transformStyle ? t.transformStyle(r, e) : e;
            if (!t.validate || !mt(this, de.validateStyle(n))) {
              this._loaded = !0;
              for (const i in (this.stylesheet = n).sources) this.addSource(i, n.sources[i], {
                validate: !1
              });
              n.sprite ? this._loadSprite(n.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(n.glyphs), this._createLayers(), this.light = new W(this.stylesheet.light), this.map.setTerrain(null != (r = this.stylesheet.terrain) ? r : null), this.fire(new de.Event("data", {
                dataType: "style"
              })), this.fire(new de.Event("style.load"));
            }
          }
          _createLayers() {
            var e = de.derefLayers(this.stylesheet.layers);
            this.dispatcher.broadcast("setLayers", e), this._order = e.map(e => e.id), this._layers = {}, this._serializedLayers = null;
            for (const r of e) {
              var t = de.createStyleLayer(r);
              t.setEventedParent(this, {
                layer: {
                  id: r.id
                }
              }), this._layers[r.id] = t;
            }
          }
          _loadSprite(e, a = !1, s = void 0) {
            this.imageManager.setLoaded(!1), this._spriteRequest = z(e, this.map._requestManager, this.map.getPixelRatio(), (e, t) => {
              if (this._spriteRequest = null, e) this.fire(new de.ErrorEvent(e));else if (t) for (const n in t) {
                this._spritesImagesIds[n] = [];
                for (const i of this._spritesImagesIds[n] ? this._spritesImagesIds[n].filter(e => !(e in t)) : []) this.imageManager.removeImage(i), this._changedImages[i] = !0;
                for (const o in t[n]) {
                  var r = "default" === n ? o : n + ":" + o;
                  this._spritesImagesIds[n].push(r), r in this.imageManager.images ? this.imageManager.updateImage(r, t[n][o], !1) : this.imageManager.addImage(r, t[n][o]), a && (this._changedImages[r] = !0);
                }
              }
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), a && (this._changed = !0), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new de.Event("data", {
                dataType: "style"
              })), s && s(e);
            });
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new de.Event("data", {
              dataType: "style"
            }));
          }
          _validateLayer(e) {
            var t,
              r = this.sourceCaches[e.source];
            r && (t = e.sourceLayer) && ("geojson" === (r = r.getSource()).type || r.vectorLayerIds && -1 === r.vectorLayerIds.indexOf(t)) && this.fire(new de.ErrorEvent(new Error(`Source layer "${t}" ` + `does not exist on source "${r.id}" ` + `as specified by style layer "${e.id}".`)));
          }
          loaded() {
            if (!this._loaded) return !1;
            if (Object.keys(this._updatedSources).length) return !1;
            for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(e) {
            var t = this._serializedAllLayers();
            if (!e || 0 === e.length) return Object.values(t);
            var r = [];
            for (const n of e) t[n] && r.push(t[n]);
            return r;
          }
          _serializedAllLayers() {
            var e = this._serializedLayers;
            if (!e) {
              e = this._serializedLayers = {};
              for (const r of Object.keys(this._layers)) {
                var t = this._layers[r];
                "custom" !== t.type && (e[r] = t.serialize());
              }
            }
            return e;
          }
          hasTransitions() {
            if (this.light && this.light.hasTransition()) return !0;
            for (const e in this.sourceCaches) if (this.sourceCaches[e].hasTransition()) return !0;
            for (const t in this._layers) if (this._layers[t].hasTransition()) return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e) {
            if (this._loaded) {
              var t = this._changed;
              if (this._changed) {
                var r = Object.keys(this._updatedLayers),
                  n = Object.keys(this._removedLayers);
                (r.length || n.length) && this._updateWorkerLayers(r, n);
                for (const c in this._updatedSources) {
                  var i = this._updatedSources[c];
                  if ("reload" === i) this._reloadSource(c);else {
                    if ("clear" !== i) throw new Error("Invalid action " + i);
                    this._clearSource(c);
                  }
                }
                this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
                for (const u in this._updatedPaintProps) this._layers[u].updateTransitions(e);
                this.light.updateTransitions(e), this._resetUpdates();
              }
              var o = {};
              for (const h in this.sourceCaches) {
                var a = this.sourceCaches[h];
                o[h] = a.used, a.used = !1;
              }
              for (const d of this._order) {
                var s = this._layers[d];
                s.recalculate(e, this._availableImages), !s.isHidden(e.zoom) && s.source && (this.sourceCaches[s.source].used = !0);
              }
              for (const p in o) {
                var l = this.sourceCaches[p];
                o[p] !== l.used && l.fire(new de.Event("data", {
                  sourceDataType: "visibility",
                  dataType: "source",
                  sourceId: p
                }));
              }
              this.light.recalculate(e), this.z = e.zoom, t && this.fire(new de.Event("data", {
                dataType: "style"
              }));
            }
          }
          _updateTilesForChangedImages() {
            var e = Object.keys(this._changedImages);
            if (e.length) {
              for (const t in this.sourceCaches) this.sourceCaches[t].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1;
            }
          }
          _updateWorkerLayers(e, t) {
            this.dispatcher.broadcast("updateLayers", {
              layers: this._serializeByIds(e),
              removedIds: t
            });
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
          }
          setState(e, t = {}) {
            this._checkLoaded();
            var r = this.serialize();
            if (e = t.transformStyle ? t.transformStyle(r, e) : e, mt(this, de.validateStyle(e))) return !1;
            (e = de.clone$1(e)).layers = de.derefLayers(e.layers);
            t = de.diffStyles(r, e).filter(e => !(e.command in yt));
            if (0 === t.length) return !1;
            r = t.filter(e => !(e.command in gt));
            if (0 < r.length) throw new Error(`Unimplemented: ${r.map(e => e.command).join(", ")}.`);
            for (const n of t) "setTransition" !== n.command && this[n.command].apply(this, n.args);
            return this.stylesheet = e, !(this._serializedLayers = null);
          }
          addImage(e, t) {
            if (this.getImage(e)) return this.fire(new de.ErrorEvent(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, t), this._afterImageUpdated(e);
          }
          updateImage(e, t) {
            this.imageManager.updateImage(e, t);
          }
          getImage(e) {
            return this.imageManager.getImage(e);
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new de.ErrorEvent(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e);
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new de.Event("data", {
              dataType: "style"
            }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e, t, r = {}) {
            if (this._checkLoaded(), void 0 !== this.sourceCaches[e]) throw new Error(`Source "${e}" already exists.`);
            if (!t.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(t).join(", ")}.`);
            var n = 0 <= ["vector", "raster", "geojson", "video", "image"].indexOf(t.type);
            if (!n || !this._validate(de.validateStyle.source, "sources." + e, t, null, r)) {
              this.map && this.map._collectResourceTiming && (t.collectResourceTiming = !0);
              const i = this.sourceCaches[e] = new N(e, t, this.dispatcher);
              i.style = this, i.setEventedParent(this, () => ({
                isSourceLoaded: i.loaded(),
                source: i.serialize(),
                sourceId: e
              })), i.onAdd(this.map), this._changed = !0;
            }
          }
          removeSource(e) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[e]) throw new Error("There is no source with this ID");
            for (const r in this._layers) if (this._layers[r].source === e) return this.fire(new de.ErrorEvent(new Error(`Source "${e}" cannot be removed while layer "${r}" is using it.`)));
            var t = this.sourceCaches[e];
            delete this.sourceCaches[e], delete this._updatedSources[e], t.fire(new de.Event("data", {
              sourceDataType: "metadata",
              dataType: "source",
              sourceId: e
            })), t.setEventedParent(null), t.onRemove(this.map), this._changed = !0;
          }
          setGeoJSONSourceData(e, t) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[e]) throw new Error("There is no source with this ID=" + e);
            e = this.sourceCaches[e].getSource();
            if ("geojson" !== e.type) throw new Error(`geojsonSource.type is ${e.type}, which is !== 'geojson`);
            e.setData(t), this._changed = !0;
          }
          getSource(e) {
            return this.sourceCaches[e] && this.sourceCaches[e].getSource();
          }
          addLayer(t, r, n = {}) {
            this._checkLoaded();
            var i = t.id;
            if (this.getLayer(i)) this.fire(new de.ErrorEvent(new Error(`Layer "${i}" already exists on this map.`)));else {
              let e;
              if ("custom" === t.type) {
                if (mt(this, de.validateCustomStyleLayer(t))) return;
                e = de.createStyleLayer(t);
              } else {
                if ("source" in t && "object" == typeof t.source && (this.addSource(i, t.source), t = de.clone$1(t), t = de.extend(t, {
                  source: i
                })), this._validate(de.validateStyle.layer, "layers." + i, t, {
                  arrayIndex: -1
                }, n)) return;
                e = de.createStyleLayer(t), this._validateLayer(e), e.setEventedParent(this, {
                  layer: {
                    id: i
                  }
                });
              }
              n = r ? this._order.indexOf(r) : this._order.length;
              r && -1 === n ? this.fire(new de.ErrorEvent(new Error(`Cannot add layer "${i}" before non-existing layer "${r}".`))) : (this._order.splice(n, 0, i), this._layerOrderChanged = !0, this._layers[i] = e, this._removedLayers[i] && e.source && "custom" !== e.type && (t = this._removedLayers[i], delete this._removedLayers[i], t.type !== e.type ? this._updatedSources[e.source] = "clear" : (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause())), this._updateLayer(e), e.onAdd && e.onAdd(this.map));
            }
          }
          moveLayer(e, t) {
            var r;
            this._checkLoaded(), this._changed = !0, this._layers[e] ? e !== t && (r = this._order.indexOf(e), this._order.splice(r, 1), r = t ? this._order.indexOf(t) : this._order.length, t && -1 === r ? this.fire(new de.ErrorEvent(new Error(`Cannot move layer "${e}" before non-existing layer "${t}".`))) : (this._order.splice(r, 0, e), this._layerOrderChanged = !0)) : this.fire(new de.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
          }
          removeLayer(e) {
            this._checkLoaded();
            var t,
              r = this._layers[e];
            r ? (r.setEventedParent(null), t = this._order.indexOf(e), this._order.splice(t, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = r, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], r.onRemove && r.onRemove(this.map)) : this.fire(new de.ErrorEvent(new Error(`Cannot remove non-existing layer "${e}".`)));
          }
          getLayer(e) {
            return this._layers[e];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(e) {
            return e in this._layers;
          }
          setLayerZoomRange(e, t, r) {
            this._checkLoaded();
            var n = this.getLayer(e);
            n ? n.minzoom === t && n.maxzoom === r || (null != t && (n.minzoom = t), null != r && (n.maxzoom = r), this._updateLayer(n)) : this.fire(new de.ErrorEvent(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
          }
          setFilter(e, t, r = {}) {
            this._checkLoaded();
            var n = this.getLayer(e);
            n ? de.deepEqual(n.filter, t) || (null == t ? (n.filter = void 0, this._updateLayer(n)) : this._validate(de.validateStyle.filter, `layers.${n.id}.filter`, t, null, r) || (n.filter = de.clone$1(t), this._updateLayer(n))) : this.fire(new de.ErrorEvent(new Error(`Cannot filter non-existing layer "${e}".`)));
          }
          getFilter(e) {
            return de.clone$1(this.getLayer(e).filter);
          }
          setLayoutProperty(e, t, r, n = {}) {
            this._checkLoaded();
            var i = this.getLayer(e);
            i ? de.deepEqual(i.getLayoutProperty(t), r) || (i.setLayoutProperty(t, r, n), this._updateLayer(i)) : this.fire(new de.ErrorEvent(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          getLayoutProperty(e, t) {
            var r = this.getLayer(e);
            if (r) return r.getLayoutProperty(t);
            this.fire(new de.ErrorEvent(new Error(`Cannot get style of non-existing layer "${e}".`)));
          }
          setPaintProperty(e, t, r, n = {}) {
            this._checkLoaded();
            var i = this.getLayer(e);
            i ? de.deepEqual(i.getPaintProperty(t), r) || (i.setPaintProperty(t, r, n) && this._updateLayer(i), this._changed = !0, this._updatedPaintProps[e] = !0) : this.fire(new de.ErrorEvent(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          getPaintProperty(e, t) {
            return this.getLayer(e).getPaintProperty(t);
          }
          setFeatureState(e, t) {
            this._checkLoaded();
            var r = e.source,
              n = e.sourceLayer,
              i = this.sourceCaches[r];
            void 0 === i ? this.fire(new de.ErrorEvent(new Error(`The source '${r}' does not exist in the map's style.`))) : "geojson" === (r = i.getSource().type) && n ? this.fire(new de.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== r || n ? (void 0 === e.id && this.fire(new de.ErrorEvent(new Error("The feature id parameter must be provided."))), i.setFeatureState(n, e.id, t)) : this.fire(new de.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e, t) {
            this._checkLoaded();
            var r,
              n = e.source,
              i = this.sourceCaches[n];
            void 0 === i ? this.fire(new de.ErrorEvent(new Error(`The source '${n}' does not exist in the map's style.`))) : (r = "vector" === (n = i.getSource().type) ? e.sourceLayer : void 0, "vector" !== n || r ? t && "string" != typeof e.id && "number" != typeof e.id ? this.fire(new de.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : i.removeFeatureState(r, e.id, t) : this.fire(new de.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types."))));
          }
          getFeatureState(e) {
            this._checkLoaded();
            var t = e.source,
              r = e.sourceLayer,
              n = this.sourceCaches[t];
            if (void 0 === n) this.fire(new de.ErrorEvent(new Error(`The source '${t}' does not exist in the map's style.`)));else {
              if ("vector" !== n.getSource().type || r) return void 0 === e.id && this.fire(new de.ErrorEvent(new Error("The feature id parameter must be provided."))), n.getFeatureState(r, e.id);
              this.fire(new de.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
          }
          getTransition() {
            return de.extend({
              duration: 300,
              delay: 0
            }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            var e, t, r, n;
            if (this._loaded) return e = de.mapObject(this.sourceCaches, e => e.serialize()), t = this._serializeByIds(this._order), r = this.map.getTerrain() || void 0, n = this.stylesheet, de.filterObject({
              version: n.version,
              name: n.name,
              metadata: n.metadata,
              light: n.light,
              center: n.center,
              zoom: n.zoom,
              bearing: n.bearing,
              pitch: n.pitch,
              sprite: n.sprite,
              glyphs: n.glyphs,
              transition: n.transition,
              sources: e,
              layers: t,
              terrain: r
            }, e => void 0 !== e);
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && "raster" !== this.sourceCaches[e.source].getSource().type && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0;
          }
          _flattenAndSortRenderedFeatures(r) {
            var n = e => "fill-extrusion" === this._layers[e].type,
              i = {},
              o = [];
            for (let e = this._order.length - 1; 0 <= e; e--) {
              var t = this._order[e];
              if (n(t)) {
                i[t] = e;
                for (const u of r) {
                  var a = u[t];
                  if (a) for (const h of a) o.push(h);
                }
              }
            }
            o.sort((e, t) => t.intersectionZ - e.intersectionZ);
            var s = [];
            for (let t = this._order.length - 1; 0 <= t; t--) {
              var e = this._order[t];
              if (n(e)) for (let e = o.length - 1; 0 <= e; e--) {
                var l = o[e].feature;
                if (i[l.layer.id] < t) break;
                s.push(l), o.pop();
              } else for (const d of r) {
                var c = d[e];
                if (c) for (const p of c) s.push(p.feature);
              }
            }
            return s;
          }
          queryRenderedFeatures(e, t, r) {
            t && t.filter && this._validate(de.validateStyle.filter, "queryRenderedFeatures.filter", t.filter, null, t);
            var n = {};
            if (t && t.layers) {
              if (!Array.isArray(t.layers)) return this.fire(new de.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
              for (const s of t.layers) {
                var i = this._layers[s];
                if (!i) return this.fire(new de.ErrorEvent(new Error(`The layer '${s}' does not exist in the map's style and cannot be queried for features.`))), [];
                n[i.source] = !0;
              }
            }
            var o = [],
              a = (t.availableImages = this._availableImages, this._serializedAllLayers());
            for (const l in this.sourceCaches) t.layers && !n[l] || o.push(ge(this.sourceCaches[l], this._layers, a, e, t, r));
            return this.placement && o.push(ye(this._layers, a, this.sourceCaches, e, t, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o);
          }
          querySourceFeatures(e, t) {
            t && t.filter && this._validate(de.validateStyle.filter, "querySourceFeatures.filter", t.filter, null, t);
            e = this.sourceCaches[e];
            return e ? ve(e, t) : [];
          }
          addSourceType(e, t, r) {
            return ue(e) ? r(new Error(`A source type called "${e}" already exists.`)) : (he(e, t), t.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
              name: e,
              url: t.workerSourceURL
            }, r) : r(null, null));
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e, t = {}) {
            this._checkLoaded();
            var r,
              n = this.light.getLight();
            let i = !1;
            for (const o in e) if (!de.deepEqual(e[o], n[o])) {
              i = !0;
              break;
            }
            i && (r = {
              now: de.browser.now(),
              transition: de.extend({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            }, this.light.setLight(e, t), this.light.updateTransitions(r));
          }
          _validate(e, t, r, n, i = {}) {
            return (!i || !1 !== i.validate) && mt(this, e.call(de.validateStyle, de.extend({
              key: t,
              style: this.serialize(),
              value: r,
              styleSpec: de.v8Spec
            }, n)));
          }
          _remove(e = !0) {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), de.evented.off("pluginStateChange", this._rtlTextPluginCallback);
            for (const r in this._layers) this._layers[r].setEventedParent(null);
            for (const n in this.sourceCaches) {
              var t = this.sourceCaches[n];
              t.setEventedParent(null), t.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove(e);
          }
          _clearSource(e) {
            this.sourceCaches[e].clearTiles();
          }
          _reloadSource(e) {
            this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
          }
          _updateSources(e) {
            for (const t in this.sourceCaches) this.sourceCaches[t].update(e, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const e in this.sourceCaches) this._reloadSource(e);
          }
          _updatePlacement(e, t, r, n, i = !1) {
            let o = !1,
              a = !1;
            var s = {};
            for (const u of this._order) {
              var l = this._layers[u];
              if ("symbol" === l.type) {
                if (!s[l.source]) {
                  const h = this.sourceCaches[l.source];
                  s[l.source] = h.getRenderableIds(!0).map(e => h.getTileByID(e)).sort((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1));
                }
                l = this.crossTileSymbolIndex.addLayer(l, s[l.source], e.center.lng);
                o = o || l;
              }
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((i = i || this._layerOrderChanged || 0 === r) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(de.browser.now(), e.zoom)) && (this.pauseablePlacement = new ht(e, this.map.terrain, this._order, i, t, r, n, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, s), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(de.browser.now()), a = !0), o && this.pauseablePlacement.placement.setStale()), a || o) for (const d of this._order) {
              var c = this._layers[d];
              "symbol" === c.type && this.placement.updateLayerOpacities(c, s[c.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(de.browser.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles();
          }
          getImages(e, t, r) {
            this.imageManager.getImages(t.icons, r), this._updateTilesForChangedImages();
            r = this.sourceCaches[t.source];
            r && r.setDependencies(t.tileID.key, t.type, t.icons);
          }
          getGlyphs(e, t, r) {
            this.glyphManager.getGlyphs(t.stacks, r);
            r = this.sourceCaches[t.source];
            r && r.setDependencies(t.tileID.key, t.type, [""]);
          }
          getResource(e, t, r) {
            return de.makeRequest(t, r);
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e, t = {}) {
            this._checkLoaded(), e && this._validate(de.validateStyle.glyphs, "glyphs", e, null, t) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
          }
          addSprite(e, t, r = {}, n) {
            this._checkLoaded();
            e = [{
              id: e,
              url: t
            }], t = [...$(this.stylesheet.sprite), ...e];
            this._validate(de.validateStyle.sprite, "sprite", t, null, r) || (this.stylesheet.sprite = t, this._loadSprite(e, !0, n));
          }
          removeSprite(t) {
            this._checkLoaded();
            var e = $(this.stylesheet.sprite);
            if (e.find(e => e.id === t)) {
              if (this._spritesImagesIds[t]) for (const r of this._spritesImagesIds[t]) this.imageManager.removeImage(r), this._changedImages[r] = !0;
              e.splice(e.findIndex(e => e.id === t), 1), this.stylesheet.sprite = 0 < e.length ? e : void 0, delete this._spritesImagesIds[t], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new de.Event("data", {
                dataType: "style"
              }));
            } else this.fire(new de.ErrorEvent(new Error(`Sprite "${t}" doesn't exists on this map.`)));
          }
          getSprite() {
            return $(this.stylesheet.sprite);
          }
          setSprite(e, t = {}, r) {
            this._checkLoaded(), e && this._validate(de.validateStyle.sprite, "sprite", e, null, t) || ((this.stylesheet.sprite = e) ? this._loadSprite(e, !0, r) : (this._unloadSprite(), r && r(null)));
          }
        }
        o.registerForPluginStateChange = de.registerForPluginStateChange;
        var Et = de.createLayout([{
            name: "a_pos",
            type: "Int16",
            components: 2
          }]),
          e = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
        const g = {
          prelude: i("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}"),
          background: i("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
          backgroundPattern: i("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
          circle: i("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"),
          clippingMask: i("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
          heatmap: i("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"),
          heatmapTexture: i("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
          collisionBox: i("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
          collisionCircle: i("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
          debug: i("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"),
          fill: i("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"),
          fillOutline: i("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),
          fillOutlinePattern: i("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),
          fillPattern: i("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"),
          fillExtrusion: i("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"),
          fillExtrusionPattern: i("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"),
          hillshadePrepare: i("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
          hillshade: i("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"),
          line: i("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
          lineGradient: i("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
          linePattern: i("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"),
          lineSDF: i("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"),
          raster: i("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),
          symbolIcon: i("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"),
          symbolSDF: i("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"),
          symbolTextAndIcon: i("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"),
          terrain: i("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", e),
          terrainDepth: i("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", e),
          terrainCoords: i("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", e)
        };
        function i(e, t) {
          var r = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            n = t.match(/attribute ([\w]+) ([\w]+)/g),
            i = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            o = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            o = o ? o.concat(i) : i;
          const s = {};
          return {
            fragmentSource: e = e.replace(r, (e, t, r, n, i) => (s[i] = !0, "define" === t ? `
#ifndef HAS_UNIFORM_u_${i}
varying ${r} ${n} ${i};
#else
uniform ${r} ${n} u_${i};
#endif
` : `
#ifdef HAS_UNIFORM_u_${i}
    ${r} ${n} ${i} = u_${i};
#endif
`)),
            vertexSource: t = t.replace(r, (e, t, r, n, i) => {
              var o = "float" === n ? "vec2" : "vec4",
                a = i.match(/color/) ? "color" : o;
              return s[i] ? "define" === t ? `
#ifndef HAS_UNIFORM_u_${i}
uniform lowp float u_${i}_t;
attribute ${r} ${o} a_${i};
varying ${r} ${n} ${i};
#else
uniform ${r} ${n} u_${i};
#endif
` : "vec4" == a ? `
#ifndef HAS_UNIFORM_u_${i}
    ${i} = a_${i};
#else
    ${r} ${n} ${i} = u_${i};
#endif
` : `
#ifndef HAS_UNIFORM_u_${i}
    ${i} = unpack_mix_${a}(a_${i}, u_${i}_t);
#else
    ${r} ${n} ${i} = u_${i};
#endif
` : "define" === t ? `
#ifndef HAS_UNIFORM_u_${i}
uniform lowp float u_${i}_t;
attribute ${r} ${o} a_${i};
#else
uniform ${r} ${n} u_${i};
#endif
` : "vec4" == a ? `
#ifndef HAS_UNIFORM_u_${i}
    ${r} ${n} ${i} = a_${i};
#else
    ${r} ${n} ${i} = u_${i};
#endif
` : `
#ifndef HAS_UNIFORM_u_${i}
    ${r} ${n} ${i} = unpack_mix_${a}(a_${i}, u_${i}_t);
#else
    ${r} ${n} ${i} = u_${i};
#endif
`;
            }),
            staticAttributes: n,
            staticUniforms: o
          };
        }
        class bt {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(e, t, r, n, i, o, a, s, l) {
            this.context = e;
            let c = this.boundPaintVertexBuffers.length !== n.length;
            for (let e = 0; !c && e < n.length; e++) this.boundPaintVertexBuffers[e] !== n[e] && (c = !0);
            !this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== r || c || this.boundIndexBuffer !== i || this.boundVertexOffset !== o || this.boundDynamicVertexBuffer !== a || this.boundDynamicVertexBuffer2 !== s || this.boundDynamicVertexBuffer3 !== l ? this.freshBind(t, r, n, i, o, a, s, l) : (e.bindVertexArray.set(this.vao), a && a.bind(), i && i.dynamicDraw && i.bind(), s && s.bind(), l && l.bind());
          }
          freshBind(e, t, r, n, i, o, a, s) {
            var l = e.numAttributes,
              c = this.context,
              u = c.gl;
            this.vao && this.destroy(), this.vao = c.createVertexArray(), c.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = r, this.boundIndexBuffer = n, this.boundVertexOffset = i, this.boundDynamicVertexBuffer = o, this.boundDynamicVertexBuffer2 = a, this.boundDynamicVertexBuffer3 = s, t.enableAttributes(u, e);
            for (const h of r) h.enableAttributes(u, e);
            o && o.enableAttributes(u, e), a && a.enableAttributes(u, e), s && s.enableAttributes(u, e), t.bind(), t.setVertexAttribPointers(u, e, i);
            for (const d of r) d.bind(), d.setVertexAttribPointers(u, e, i);
            o && (o.bind(), o.setVertexAttribPointers(u, e, i)), n && n.bind(), a && (a.bind(), a.setVertexAttribPointers(u, e, i)), s && (s.bind(), s.setVertexAttribPointers(u, e, i)), c.currentNumAttributes = l;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const wt = (e, t) => ({
          u_depth: new de.Uniform1i(e, t.u_depth),
          u_terrain: new de.Uniform1i(e, t.u_terrain),
          u_terrain_dim: new de.Uniform1f(e, t.u_terrain_dim),
          u_terrain_matrix: new de.UniformMatrix4f(e, t.u_terrain_matrix),
          u_terrain_unpack: new de.Uniform4f(e, t.u_terrain_unpack),
          u_terrain_exaggeration: new de.Uniform1f(e, t.u_terrain_exaggeration)
        });
        function Tt(t) {
          var r,
            n = [];
          for (let e = 0; e < t.length; e++) null !== t[e] && (r = t[e].split(" "), n.push(r.pop()));
          return n;
        }
        class St {
          constructor(e, t, r, n, i, o) {
            var a = e.gl,
              s = (this.program = a.createProgram(), Tt(t.staticAttributes)),
              l = r ? r.getBinderAttributes() : [],
              c = s.concat(l),
              s = g.prelude.staticUniforms ? Tt(g.prelude.staticUniforms) : [],
              l = t.staticUniforms ? Tt(t.staticUniforms) : [],
              u = r ? r.getBinderUniforms() : [],
              h = [];
            for (const _ of s.concat(l).concat(u)) h.indexOf(_) < 0 && h.push(_);
            s = r ? r.defines() : [], i && s.push("#define OVERDRAW_INSPECTOR;"), o && s.push("#define TERRAIN3D;"), l = s.concat(g.prelude.fragmentSource, t.fragmentSource).join("\n"), u = s.concat(g.prelude.vertexSource, t.vertexSource).join("\n"), i = a.createShader(a.FRAGMENT_SHADER);
            if (a.isContextLost()) this.failedToCreate = !0;else {
              if (a.shaderSource(i, l), a.compileShader(i), !a.getShaderParameter(i, a.COMPILE_STATUS)) throw new Error("Could not compile fragment shader: " + a.getShaderInfoLog(i));
              a.attachShader(this.program, i);
              o = a.createShader(a.VERTEX_SHADER);
              if (a.isContextLost()) this.failedToCreate = !0;else {
                if (a.shaderSource(o, u), a.compileShader(o), !a.getShaderParameter(o, a.COMPILE_STATUS)) throw new Error("Could not compile vertex shader: " + a.getShaderInfoLog(o));
                a.attachShader(this.program, o), this.attributes = {};
                var d = {};
                this.numAttributes = c.length;
                for (let e = 0; e < this.numAttributes; e++) c[e] && (a.bindAttribLocation(this.program, e, c[e]), this.attributes[c[e]] = e);
                if (a.linkProgram(this.program), !a.getProgramParameter(this.program, a.LINK_STATUS)) throw new Error("Program failed to link: " + a.getProgramInfoLog(this.program));
                a.deleteShader(o), a.deleteShader(i);
                for (let e = 0; e < h.length; e++) {
                  var p,
                    f = h[e];
                  f && !d[f] && (p = a.getUniformLocation(this.program, f)) && (d[f] = p);
                }
                this.fixedUniforms = n(e, d), this.terrainUniforms = wt(e, d), this.binderUniforms = r ? r.getUniforms(e, d) : [];
              }
            }
          }
          draw(t, r, n, i, o, a, s, l, c, u, h, d, p, f, _, m, g, y) {
            var v = t.gl;
            if (!this.failedToCreate) {
              if (t.program.set(this.program), t.setDepthMode(n), t.setStencilMode(i), t.setColorMode(o), t.setCullFace(a), l) {
                t.activeTexture.set(v.TEXTURE2), v.bindTexture(v.TEXTURE_2D, l.depthTexture), t.activeTexture.set(v.TEXTURE3), v.bindTexture(v.TEXTURE_2D, l.texture);
                for (const b in this.terrainUniforms) this.terrainUniforms[b].set(l[b]);
              }
              for (const w in this.fixedUniforms) this.fixedUniforms[w].set(s[w]);
              _ && _.setUniforms(t, this.binderUniforms, p, {
                zoom: f
              });
              let e = 0;
              switch (r) {
                case v.LINES:
                  e = 2;
                  break;
                case v.TRIANGLES:
                  e = 3;
                  break;
                case v.LINE_STRIP:
                  e = 1;
              }
              for (const T of d.get()) {
                var E = T.vaos || (T.vaos = {});
                (E[c] || (E[c] = new bt())).bind(t, this, u, _ ? _.getPaintVertexBuffers() : [], h, T.vertexOffset, m, g, y), v.drawElements(r, T.primitiveLength * e, v.UNSIGNED_SHORT, T.primitiveOffset * e * 2);
              }
            }
          }
        }
        function xt(e, t, r) {
          var n = 1 / _e(r, 1, t.transform.tileZoom),
            i = Math.pow(2, r.tileID.overscaledZ),
            t = r.tileSize * Math.pow(2, t.transform.tileZoom) / i,
            i = t * (r.tileID.canonical.x + r.tileID.wrap * i),
            t = t * r.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: r.imageAtlasTexture.size,
            u_scale: [n, e.fromScale, e.toScale],
            u_fade: e.t,
            u_pixel_coord_upper: [i >> 16, t >> 16],
            u_pixel_coord_lower: [65535 & i, 65535 & t]
          };
        }
        const Ct = (e, t, r, n) => {
            var i = t.style.light,
              o = i.properties.get("position"),
              o = [o.x, o.y, o.z],
              a = de.create$1(),
              t = ("viewport" === i.properties.get("anchor") && de.fromRotation(a, -t.transform.angle), de.transformMat3(o, o, a), i.properties.get("color"));
            return {
              u_matrix: e,
              u_lightpos: o,
              u_lightintensity: i.properties.get("intensity"),
              u_lightcolor: [t.r, t.g, t.b],
              u_vertical_gradient: +r,
              u_opacity: n
            };
          },
          At = (e, t, r, n, i, o, a) => de.extend(Ct(e, t, r, n), xt(o, t, a), {
            u_height_factor: -Math.pow(2, i.overscaledZ) / a.tileSize / 8
          });
        const It = e => ({
            u_matrix: e
          }),
          Nt = (e, t, r, n) => de.extend(It(e), xt(r, t, n)),
          Pt = (e, t) => ({
            u_matrix: e,
            u_world: t
          }),
          Dt = (e, t, r, n, i) => de.extend(Nt(e, t, r, n), {
            u_world: i
          });
        const Rt = (e, t, r) => {
            var n = _e(r, 1, t.zoom),
              i = Math.pow(2, t.zoom - r.tileID.overscaledZ),
              r = r.tileID.overscaleFactor();
            return {
              u_matrix: e,
              u_camera_to_center_distance: t.cameraToCenterDistance,
              u_pixels_to_tile_units: n,
              u_extrude_scale: [t.pixelsToGLUnits[0] / (n * i), t.pixelsToGLUnits[1] / (n * i)],
              u_overscale_factor: r
            };
          },
          Ot = (e, t, r) => ({
            u_matrix: e,
            u_inv_matrix: t,
            u_camera_to_center_distance: r.cameraToCenterDistance,
            u_viewport_size: [r.width, r.height]
          });
        const Mt = (e, t, r = 1) => ({
          u_matrix: e,
          u_color: t,
          u_overlay: 0,
          u_overlay_scale: r
        });
        const kt = e => ({
          u_matrix: e
        });
        const Lt = (e, t, r, n) => {
          var i = de.create(),
            e = (de.ortho(i, 0, e.width, e.height, 0, 0, 1), e.context.gl);
          return {
            u_matrix: i,
            u_world: [e.drawingBufferWidth, e.drawingBufferHeight],
            u_image: r,
            u_color_ramp: n,
            u_opacity: t.paint.get("heatmap-opacity")
          };
        };
        const Ut = (e, t, r, n) => {
            var i = r.paint.get("hillshade-shadow-color"),
              o = r.paint.get("hillshade-highlight-color"),
              a = r.paint.get("hillshade-accent-color");
            let s = r.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            "viewport" === r.paint.get("hillshade-illumination-anchor") && (s -= e.transform.angle);
            var l = !e.options.moving;
            return {
              u_matrix: n ? n.posMatrix : e.transform.calculatePosMatrix(t.tileID.toUnwrapped(), l),
              u_image: 0,
              u_latrange: (n = t.tileID, e = Math.pow(2, n.canonical.z), n = n.canonical.y, [new de.MercatorCoordinate(0, n / e).toLngLat().lat, new de.MercatorCoordinate(0, (n + 1) / e).toLngLat().lat]),
              u_light: [r.paint.get("hillshade-exaggeration"), s],
              u_shadow: i,
              u_highlight: o,
              u_accent: a
            };
          },
          Ft = (e, t) => {
            var r = t.stride,
              n = de.create();
            return de.ortho(n, 0, de.EXTENT, -de.EXTENT, 0, 0, 1), de.translate(n, n, [0, -de.EXTENT, 0]), {
              u_matrix: n,
              u_image: 1,
              u_dimension: [r, r],
              u_zoom: e.overscaledZ,
              u_unpack: t.getUnpackVector()
            };
          };
        const Bt = (e, t, r, n) => {
          var i = e.transform;
          return {
            u_matrix: zt(e, t, r, n),
            u_ratio: 1 / _e(t, 1, i.zoom),
            u_device_pixel_ratio: e.pixelRatio,
            u_units_to_pixels: [1 / i.pixelsToGLUnits[0], 1 / i.pixelsToGLUnits[1]]
          };
        };
        function $t(e, t) {
          return 1 / _e(e, 1, t.tileZoom);
        }
        function zt(e, t, r, n) {
          return e.translatePosMatrix((n || t.tileID).posMatrix, t, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"));
        }
        const Yt = (e, t, r, n, i) => {
          return {
            u_matrix: e,
            u_tl_parent: t,
            u_scale_parent: r,
            u_buffer_scale: 1,
            u_fade_t: n.mix,
            u_opacity: n.opacity * i.paint.get("raster-opacity"),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: i.paint.get("raster-brightness-min"),
            u_brightness_high: i.paint.get("raster-brightness-max"),
            u_saturation_factor: 0 < (e = i.paint.get("raster-saturation")) ? 1 - 1 / (1.001 - e) : -e,
            u_contrast_factor: 0 < (t = i.paint.get("raster-contrast")) ? 1 / (1 - t) : 1 + t,
            u_spin_weights: (r = i.paint.get("raster-hue-rotate"), r *= Math.PI / 180, n = Math.sin(r), [(2 * (r = Math.cos(r)) + 1) / 3, (-Math.sqrt(3) * n - r + 1) / 3, (Math.sqrt(3) * n - r + 1) / 3])
          };
        };
        const Ht = (e, t, r, n, i, o, a, s, l, c) => {
            var u = i.transform;
            return {
              u_is_size_zoom_constant: +("constant" === e || "source" === e),
              u_is_size_feature_constant: +("constant" === e || "camera" === e),
              u_size_t: t ? t.uSizeT : 0,
              u_size: t ? t.uSize : 0,
              u_camera_to_center_distance: u.cameraToCenterDistance,
              u_pitch: u.pitch / 360 * 2 * Math.PI,
              u_rotate_symbol: +r,
              u_aspect_ratio: u.width / u.height,
              u_fade_change: i.options.fadeDuration ? i.symbolFadeChange : 1,
              u_matrix: o,
              u_label_plane_matrix: a,
              u_coord_matrix: s,
              u_is_text: +l,
              u_pitch_with_map: +n,
              u_texsize: c,
              u_texture: 0
            };
          },
          jt = (e, t, r, n, i, o, a, s, l, c, u) => {
            var h = i.transform;
            return de.extend(Ht(e, t, r, n, i, o, a, s, l, c), {
              u_gamma_scale: n ? Math.cos(h._pitch) * h.cameraToCenterDistance : 1,
              u_device_pixel_ratio: i.pixelRatio,
              u_is_halo: +u
            });
          },
          Gt = (e, t, r, n, i, o, a, s, l, c) => de.extend(jt(e, t, r, n, i, o, a, s, !0, l, !0), {
            u_texsize_icon: c,
            u_texture_icon: 1
          });
        const qt = (e, t, r, n, i, o) => de.extend(function (e, t, r, n) {
            var i = r.imageManager.getPattern(e.from.toString()),
              e = r.imageManager.getPattern(e.to.toString()),
              {
                width: o,
                height: a
              } = r.imageManager.getPixelSize(),
              s = Math.pow(2, n.tileID.overscaledZ),
              s = (l = n.tileSize * Math.pow(2, r.transform.tileZoom) / s) * (n.tileID.canonical.x + n.tileID.wrap * s),
              l = l * n.tileID.canonical.y;
            return {
              u_image: 0,
              u_pattern_tl_a: i.tl,
              u_pattern_br_a: i.br,
              u_pattern_tl_b: e.tl,
              u_pattern_br_b: e.br,
              u_texsize: [o, a],
              u_mix: t.t,
              u_pattern_size_a: i.displaySize,
              u_pattern_size_b: e.displaySize,
              u_scale_a: t.fromScale,
              u_scale_b: t.toScale,
              u_tile_units_to_pixels: 1 / _e(n, 1, r.transform.tileZoom),
              u_pixel_coord_upper: [s >> 16, l >> 16],
              u_pixel_coord_lower: [65535 & s, 65535 & l]
            };
          }(n, o, r, i), {
            u_matrix: e,
            u_opacity: t
          }),
          Vt = {
            fillExtrusion: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_lightpos: new de.Uniform3f(e, t.u_lightpos),
              u_lightintensity: new de.Uniform1f(e, t.u_lightintensity),
              u_lightcolor: new de.Uniform3f(e, t.u_lightcolor),
              u_vertical_gradient: new de.Uniform1f(e, t.u_vertical_gradient),
              u_opacity: new de.Uniform1f(e, t.u_opacity)
            }),
            fillExtrusionPattern: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_lightpos: new de.Uniform3f(e, t.u_lightpos),
              u_lightintensity: new de.Uniform1f(e, t.u_lightintensity),
              u_lightcolor: new de.Uniform3f(e, t.u_lightcolor),
              u_vertical_gradient: new de.Uniform1f(e, t.u_vertical_gradient),
              u_height_factor: new de.Uniform1f(e, t.u_height_factor),
              u_image: new de.Uniform1i(e, t.u_image),
              u_texsize: new de.Uniform2f(e, t.u_texsize),
              u_pixel_coord_upper: new de.Uniform2f(e, t.u_pixel_coord_upper),
              u_pixel_coord_lower: new de.Uniform2f(e, t.u_pixel_coord_lower),
              u_scale: new de.Uniform3f(e, t.u_scale),
              u_fade: new de.Uniform1f(e, t.u_fade),
              u_opacity: new de.Uniform1f(e, t.u_opacity)
            }),
            fill: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix)
            }),
            fillPattern: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_image: new de.Uniform1i(e, t.u_image),
              u_texsize: new de.Uniform2f(e, t.u_texsize),
              u_pixel_coord_upper: new de.Uniform2f(e, t.u_pixel_coord_upper),
              u_pixel_coord_lower: new de.Uniform2f(e, t.u_pixel_coord_lower),
              u_scale: new de.Uniform3f(e, t.u_scale),
              u_fade: new de.Uniform1f(e, t.u_fade)
            }),
            fillOutline: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_world: new de.Uniform2f(e, t.u_world)
            }),
            fillOutlinePattern: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_world: new de.Uniform2f(e, t.u_world),
              u_image: new de.Uniform1i(e, t.u_image),
              u_texsize: new de.Uniform2f(e, t.u_texsize),
              u_pixel_coord_upper: new de.Uniform2f(e, t.u_pixel_coord_upper),
              u_pixel_coord_lower: new de.Uniform2f(e, t.u_pixel_coord_lower),
              u_scale: new de.Uniform3f(e, t.u_scale),
              u_fade: new de.Uniform1f(e, t.u_fade)
            }),
            circle: (e, t) => ({
              u_camera_to_center_distance: new de.Uniform1f(e, t.u_camera_to_center_distance),
              u_scale_with_map: new de.Uniform1i(e, t.u_scale_with_map),
              u_pitch_with_map: new de.Uniform1i(e, t.u_pitch_with_map),
              u_extrude_scale: new de.Uniform2f(e, t.u_extrude_scale),
              u_device_pixel_ratio: new de.Uniform1f(e, t.u_device_pixel_ratio),
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix)
            }),
            collisionBox: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_camera_to_center_distance: new de.Uniform1f(e, t.u_camera_to_center_distance),
              u_pixels_to_tile_units: new de.Uniform1f(e, t.u_pixels_to_tile_units),
              u_extrude_scale: new de.Uniform2f(e, t.u_extrude_scale),
              u_overscale_factor: new de.Uniform1f(e, t.u_overscale_factor)
            }),
            collisionCircle: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_inv_matrix: new de.UniformMatrix4f(e, t.u_inv_matrix),
              u_camera_to_center_distance: new de.Uniform1f(e, t.u_camera_to_center_distance),
              u_viewport_size: new de.Uniform2f(e, t.u_viewport_size)
            }),
            debug: (e, t) => ({
              u_color: new de.UniformColor(e, t.u_color),
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_overlay: new de.Uniform1i(e, t.u_overlay),
              u_overlay_scale: new de.Uniform1f(e, t.u_overlay_scale)
            }),
            clippingMask: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix)
            }),
            heatmap: (e, t) => ({
              u_extrude_scale: new de.Uniform1f(e, t.u_extrude_scale),
              u_intensity: new de.Uniform1f(e, t.u_intensity),
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix)
            }),
            heatmapTexture: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_world: new de.Uniform2f(e, t.u_world),
              u_image: new de.Uniform1i(e, t.u_image),
              u_color_ramp: new de.Uniform1i(e, t.u_color_ramp),
              u_opacity: new de.Uniform1f(e, t.u_opacity)
            }),
            hillshade: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_image: new de.Uniform1i(e, t.u_image),
              u_latrange: new de.Uniform2f(e, t.u_latrange),
              u_light: new de.Uniform2f(e, t.u_light),
              u_shadow: new de.UniformColor(e, t.u_shadow),
              u_highlight: new de.UniformColor(e, t.u_highlight),
              u_accent: new de.UniformColor(e, t.u_accent)
            }),
            hillshadePrepare: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_image: new de.Uniform1i(e, t.u_image),
              u_dimension: new de.Uniform2f(e, t.u_dimension),
              u_zoom: new de.Uniform1f(e, t.u_zoom),
              u_unpack: new de.Uniform4f(e, t.u_unpack)
            }),
            line: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_ratio: new de.Uniform1f(e, t.u_ratio),
              u_device_pixel_ratio: new de.Uniform1f(e, t.u_device_pixel_ratio),
              u_units_to_pixels: new de.Uniform2f(e, t.u_units_to_pixels)
            }),
            lineGradient: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_ratio: new de.Uniform1f(e, t.u_ratio),
              u_device_pixel_ratio: new de.Uniform1f(e, t.u_device_pixel_ratio),
              u_units_to_pixels: new de.Uniform2f(e, t.u_units_to_pixels),
              u_image: new de.Uniform1i(e, t.u_image),
              u_image_height: new de.Uniform1f(e, t.u_image_height)
            }),
            linePattern: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_texsize: new de.Uniform2f(e, t.u_texsize),
              u_ratio: new de.Uniform1f(e, t.u_ratio),
              u_device_pixel_ratio: new de.Uniform1f(e, t.u_device_pixel_ratio),
              u_image: new de.Uniform1i(e, t.u_image),
              u_units_to_pixels: new de.Uniform2f(e, t.u_units_to_pixels),
              u_scale: new de.Uniform3f(e, t.u_scale),
              u_fade: new de.Uniform1f(e, t.u_fade)
            }),
            lineSDF: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_ratio: new de.Uniform1f(e, t.u_ratio),
              u_device_pixel_ratio: new de.Uniform1f(e, t.u_device_pixel_ratio),
              u_units_to_pixels: new de.Uniform2f(e, t.u_units_to_pixels),
              u_patternscale_a: new de.Uniform2f(e, t.u_patternscale_a),
              u_patternscale_b: new de.Uniform2f(e, t.u_patternscale_b),
              u_sdfgamma: new de.Uniform1f(e, t.u_sdfgamma),
              u_image: new de.Uniform1i(e, t.u_image),
              u_tex_y_a: new de.Uniform1f(e, t.u_tex_y_a),
              u_tex_y_b: new de.Uniform1f(e, t.u_tex_y_b),
              u_mix: new de.Uniform1f(e, t.u_mix)
            }),
            raster: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_tl_parent: new de.Uniform2f(e, t.u_tl_parent),
              u_scale_parent: new de.Uniform1f(e, t.u_scale_parent),
              u_buffer_scale: new de.Uniform1f(e, t.u_buffer_scale),
              u_fade_t: new de.Uniform1f(e, t.u_fade_t),
              u_opacity: new de.Uniform1f(e, t.u_opacity),
              u_image0: new de.Uniform1i(e, t.u_image0),
              u_image1: new de.Uniform1i(e, t.u_image1),
              u_brightness_low: new de.Uniform1f(e, t.u_brightness_low),
              u_brightness_high: new de.Uniform1f(e, t.u_brightness_high),
              u_saturation_factor: new de.Uniform1f(e, t.u_saturation_factor),
              u_contrast_factor: new de.Uniform1f(e, t.u_contrast_factor),
              u_spin_weights: new de.Uniform3f(e, t.u_spin_weights)
            }),
            symbolIcon: (e, t) => ({
              u_is_size_zoom_constant: new de.Uniform1i(e, t.u_is_size_zoom_constant),
              u_is_size_feature_constant: new de.Uniform1i(e, t.u_is_size_feature_constant),
              u_size_t: new de.Uniform1f(e, t.u_size_t),
              u_size: new de.Uniform1f(e, t.u_size),
              u_camera_to_center_distance: new de.Uniform1f(e, t.u_camera_to_center_distance),
              u_pitch: new de.Uniform1f(e, t.u_pitch),
              u_rotate_symbol: new de.Uniform1i(e, t.u_rotate_symbol),
              u_aspect_ratio: new de.Uniform1f(e, t.u_aspect_ratio),
              u_fade_change: new de.Uniform1f(e, t.u_fade_change),
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_label_plane_matrix: new de.UniformMatrix4f(e, t.u_label_plane_matrix),
              u_coord_matrix: new de.UniformMatrix4f(e, t.u_coord_matrix),
              u_is_text: new de.Uniform1i(e, t.u_is_text),
              u_pitch_with_map: new de.Uniform1i(e, t.u_pitch_with_map),
              u_texsize: new de.Uniform2f(e, t.u_texsize),
              u_texture: new de.Uniform1i(e, t.u_texture)
            }),
            symbolSDF: (e, t) => ({
              u_is_size_zoom_constant: new de.Uniform1i(e, t.u_is_size_zoom_constant),
              u_is_size_feature_constant: new de.Uniform1i(e, t.u_is_size_feature_constant),
              u_size_t: new de.Uniform1f(e, t.u_size_t),
              u_size: new de.Uniform1f(e, t.u_size),
              u_camera_to_center_distance: new de.Uniform1f(e, t.u_camera_to_center_distance),
              u_pitch: new de.Uniform1f(e, t.u_pitch),
              u_rotate_symbol: new de.Uniform1i(e, t.u_rotate_symbol),
              u_aspect_ratio: new de.Uniform1f(e, t.u_aspect_ratio),
              u_fade_change: new de.Uniform1f(e, t.u_fade_change),
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_label_plane_matrix: new de.UniformMatrix4f(e, t.u_label_plane_matrix),
              u_coord_matrix: new de.UniformMatrix4f(e, t.u_coord_matrix),
              u_is_text: new de.Uniform1i(e, t.u_is_text),
              u_pitch_with_map: new de.Uniform1i(e, t.u_pitch_with_map),
              u_texsize: new de.Uniform2f(e, t.u_texsize),
              u_texture: new de.Uniform1i(e, t.u_texture),
              u_gamma_scale: new de.Uniform1f(e, t.u_gamma_scale),
              u_device_pixel_ratio: new de.Uniform1f(e, t.u_device_pixel_ratio),
              u_is_halo: new de.Uniform1i(e, t.u_is_halo)
            }),
            symbolTextAndIcon: (e, t) => ({
              u_is_size_zoom_constant: new de.Uniform1i(e, t.u_is_size_zoom_constant),
              u_is_size_feature_constant: new de.Uniform1i(e, t.u_is_size_feature_constant),
              u_size_t: new de.Uniform1f(e, t.u_size_t),
              u_size: new de.Uniform1f(e, t.u_size),
              u_camera_to_center_distance: new de.Uniform1f(e, t.u_camera_to_center_distance),
              u_pitch: new de.Uniform1f(e, t.u_pitch),
              u_rotate_symbol: new de.Uniform1i(e, t.u_rotate_symbol),
              u_aspect_ratio: new de.Uniform1f(e, t.u_aspect_ratio),
              u_fade_change: new de.Uniform1f(e, t.u_fade_change),
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_label_plane_matrix: new de.UniformMatrix4f(e, t.u_label_plane_matrix),
              u_coord_matrix: new de.UniformMatrix4f(e, t.u_coord_matrix),
              u_is_text: new de.Uniform1i(e, t.u_is_text),
              u_pitch_with_map: new de.Uniform1i(e, t.u_pitch_with_map),
              u_texsize: new de.Uniform2f(e, t.u_texsize),
              u_texsize_icon: new de.Uniform2f(e, t.u_texsize_icon),
              u_texture: new de.Uniform1i(e, t.u_texture),
              u_texture_icon: new de.Uniform1i(e, t.u_texture_icon),
              u_gamma_scale: new de.Uniform1f(e, t.u_gamma_scale),
              u_device_pixel_ratio: new de.Uniform1f(e, t.u_device_pixel_ratio),
              u_is_halo: new de.Uniform1i(e, t.u_is_halo)
            }),
            background: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_opacity: new de.Uniform1f(e, t.u_opacity),
              u_color: new de.UniformColor(e, t.u_color)
            }),
            backgroundPattern: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_opacity: new de.Uniform1f(e, t.u_opacity),
              u_image: new de.Uniform1i(e, t.u_image),
              u_pattern_tl_a: new de.Uniform2f(e, t.u_pattern_tl_a),
              u_pattern_br_a: new de.Uniform2f(e, t.u_pattern_br_a),
              u_pattern_tl_b: new de.Uniform2f(e, t.u_pattern_tl_b),
              u_pattern_br_b: new de.Uniform2f(e, t.u_pattern_br_b),
              u_texsize: new de.Uniform2f(e, t.u_texsize),
              u_mix: new de.Uniform1f(e, t.u_mix),
              u_pattern_size_a: new de.Uniform2f(e, t.u_pattern_size_a),
              u_pattern_size_b: new de.Uniform2f(e, t.u_pattern_size_b),
              u_scale_a: new de.Uniform1f(e, t.u_scale_a),
              u_scale_b: new de.Uniform1f(e, t.u_scale_b),
              u_pixel_coord_upper: new de.Uniform2f(e, t.u_pixel_coord_upper),
              u_pixel_coord_lower: new de.Uniform2f(e, t.u_pixel_coord_lower),
              u_tile_units_to_pixels: new de.Uniform1f(e, t.u_tile_units_to_pixels)
            }),
            terrain: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_texture: new de.Uniform1i(e, t.u_texture),
              u_ele_delta: new de.Uniform1f(e, t.u_ele_delta)
            }),
            terrainDepth: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_ele_delta: new de.Uniform1f(e, t.u_ele_delta)
            }),
            terrainCoords: (e, t) => ({
              u_matrix: new de.UniformMatrix4f(e, t.u_matrix),
              u_texture: new de.Uniform1i(e, t.u_texture),
              u_terrain_coords_id: new de.Uniform1f(e, t.u_terrain_coords_id),
              u_ele_delta: new de.Uniform1f(e, t.u_ele_delta)
            })
          };
        class Kt {
          constructor(e, t, r) {
            var n = (this.context = e).gl;
            this.buffer = n.createBuffer(), this.dynamicDraw = Boolean(r), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), n.bufferData(n.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e) {
            var t = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          destroy() {
            var e = this.context.gl;
            this.buffer && (e.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Wt = {
          Int8: "BYTE",
          Uint8: "UNSIGNED_BYTE",
          Int16: "SHORT",
          Uint16: "UNSIGNED_SHORT",
          Int32: "INT",
          Uint32: "UNSIGNED_INT",
          Float32: "FLOAT"
        };
        class Zt {
          constructor(e, t, r, n) {
            this.length = t.length, this.attributes = r, this.itemSize = t.bytesPerElement, this.dynamicDraw = n;
            r = (this.context = e).gl;
            this.buffer = r.createBuffer(), e.bindVertexBuffer.set(this.buffer), r.bufferData(r.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ` + this.length);
            var t = this.context.gl;
            this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          enableAttributes(t, r) {
            for (let e = 0; e < this.attributes.length; e++) {
              var n = this.attributes[e],
                n = r.attributes[n.name];
              void 0 !== n && t.enableVertexAttribArray(n);
            }
          }
          setVertexAttribPointers(t, r, n) {
            for (let e = 0; e < this.attributes.length; e++) {
              var i = this.attributes[e],
                o = r.attributes[i.name];
              void 0 !== o && t.vertexAttribPointer(o, i.components, t[Wt[i.type]], !1, this.itemSize, i.offset + this.itemSize * (n || 0));
            }
          }
          destroy() {
            var e = this.context.gl;
            this.buffer && (e.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Xt = new WeakMap();
        function Jt(e) {
          var t;
          return Xt.has(e) ? Xt.get(e) : (t = null == (t = e.getParameter(e.VERSION)) ? void 0 : t.startsWith("WebGL 2.0"), Xt.set(e, t), t);
        }
        class s {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(e) {}
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Qt extends s {
          getDefault() {
            return de.Color.transparent;
          }
          set(e) {
            var t = this.current;
            e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a && !this.dirty || (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
          }
        }
        class er extends s {
          getDefault() {
            return 1;
          }
          set(e) {
            e === this.current && !this.dirty || (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
          }
        }
        class tr extends s {
          getDefault() {
            return 0;
          }
          set(e) {
            e === this.current && !this.dirty || (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
          }
        }
        class rr extends s {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(e) {
            var t = this.current;
            e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && !this.dirty || (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
          }
        }
        class nr extends s {
          getDefault() {
            return !0;
          }
          set(e) {
            e === this.current && !this.dirty || (this.gl.depthMask(e), this.current = e, this.dirty = !1);
          }
        }
        class ir extends s {
          getDefault() {
            return 255;
          }
          set(e) {
            e === this.current && !this.dirty || (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
          }
        }
        class or extends s {
          getDefault() {
            return {
              func: this.gl.ALWAYS,
              ref: 0,
              mask: 255
            };
          }
          set(e) {
            var t = this.current;
            e.func === t.func && e.ref === t.ref && e.mask === t.mask && !this.dirty || (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
          }
        }
        class ar extends s {
          getDefault() {
            var e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP];
          }
          set(e) {
            var t = this.current;
            e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && !this.dirty || (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
          }
        }
        class sr extends s {
          getDefault() {
            return !1;
          }
          set(e) {
            var t;
            e === this.current && !this.dirty || (t = this.gl, e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = !1);
          }
        }
        class lr extends s {
          getDefault() {
            return [0, 1];
          }
          set(e) {
            var t = this.current;
            e[0] === t[0] && e[1] === t[1] && !this.dirty || (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
          }
        }
        class cr extends s {
          getDefault() {
            return !1;
          }
          set(e) {
            var t;
            e === this.current && !this.dirty || (t = this.gl, e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = !1);
          }
        }
        class ur extends s {
          getDefault() {
            return this.gl.LESS;
          }
          set(e) {
            e === this.current && !this.dirty || (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
          }
        }
        class hr extends s {
          getDefault() {
            return !1;
          }
          set(e) {
            var t;
            e === this.current && !this.dirty || (t = this.gl, e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = !1);
          }
        }
        class dr extends s {
          getDefault() {
            var e = this.gl;
            return [e.ONE, e.ZERO];
          }
          set(e) {
            var t = this.current;
            e[0] === t[0] && e[1] === t[1] && !this.dirty || (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
          }
        }
        class pr extends s {
          getDefault() {
            return de.Color.transparent;
          }
          set(e) {
            var t = this.current;
            e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a && !this.dirty || (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
          }
        }
        class fr extends s {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e) {
            e === this.current && !this.dirty || (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
          }
        }
        class _r extends s {
          getDefault() {
            return !1;
          }
          set(e) {
            var t;
            e === this.current && !this.dirty || (t = this.gl, e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = !1);
          }
        }
        class mr extends s {
          getDefault() {
            return this.gl.BACK;
          }
          set(e) {
            e === this.current && !this.dirty || (this.gl.cullFace(e), this.current = e, this.dirty = !1);
          }
        }
        class gr extends s {
          getDefault() {
            return this.gl.CCW;
          }
          set(e) {
            e === this.current && !this.dirty || (this.gl.frontFace(e), this.current = e, this.dirty = !1);
          }
        }
        class yr extends s {
          getDefault() {
            return null;
          }
          set(e) {
            e === this.current && !this.dirty || (this.gl.useProgram(e), this.current = e, this.dirty = !1);
          }
        }
        class vr extends s {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e) {
            e === this.current && !this.dirty || (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
          }
        }
        class Er extends s {
          getDefault() {
            var e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
          }
          set(e) {
            var t = this.current;
            e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && !this.dirty || (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
          }
        }
        class br extends s {
          getDefault() {
            return null;
          }
          set(e) {
            var t;
            e === this.current && !this.dirty || ((t = this.gl).bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = !1);
          }
        }
        class wr extends s {
          getDefault() {
            return null;
          }
          set(e) {
            var t;
            e === this.current && !this.dirty || ((t = this.gl).bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = !1);
          }
        }
        class Tr extends s {
          getDefault() {
            return null;
          }
          set(e) {
            var t;
            e === this.current && !this.dirty || ((t = this.gl).bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = !1);
          }
        }
        class Sr extends s {
          getDefault() {
            return null;
          }
          set(e) {
            var t;
            e === this.current && !this.dirty || ((t = this.gl).bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = !1);
          }
        }
        class xr extends s {
          getDefault() {
            return null;
          }
          set(e) {
            var t = this.gl;
            t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class Cr extends s {
          getDefault() {
            return null;
          }
          set(e) {
            var t;
            e === this.current && !this.dirty || (Jt(t = this.gl) ? t.bindVertexArray(e) : null != (t = t.getExtension("OES_vertex_array_object")) && t.bindVertexArrayOES(e), this.current = e, this.dirty = !1);
          }
        }
        class Ar extends s {
          getDefault() {
            return 4;
          }
          set(e) {
            var t;
            e === this.current && !this.dirty || ((t = this.gl).pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1);
          }
        }
        class Ir extends s {
          getDefault() {
            return !1;
          }
          set(e) {
            var t;
            e === this.current && !this.dirty || ((t = this.gl).pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1);
          }
        }
        class Nr extends s {
          getDefault() {
            return !1;
          }
          set(e) {
            var t;
            e === this.current && !this.dirty || ((t = this.gl).pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1);
          }
        }
        class Pr extends s {
          constructor(e, t) {
            super(e), this.context = e, this.parent = t;
          }
          getDefault() {
            return null;
          }
        }
        class Dr extends Pr {
          setDirty() {
            this.dirty = !0;
          }
          set(e) {
            var t;
            e === this.current && !this.dirty || (this.context.bindFramebuffer.set(this.parent), (t = this.gl).framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1);
          }
        }
        class Rr extends Pr {
          set(e) {
            var t;
            e === this.current && !this.dirty || (this.context.bindFramebuffer.set(this.parent), (t = this.gl).framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e), this.current = e, this.dirty = !1);
          }
        }
        class Or extends Pr {
          set(e) {
            var t;
            e === this.current && !this.dirty || (this.context.bindFramebuffer.set(this.parent), (t = this.gl).framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e), this.current = e, this.dirty = !1);
          }
        }
        class Mr {
          constructor(e, t, r, n, i) {
            this.context = e, this.width = t, this.height = r;
            t = e.gl, r = this.framebuffer = t.createFramebuffer();
            if (this.colorAttachment = new Dr(e, r), n) this.depthAttachment = new (i ? Or : Rr)(e, r);else if (i) throw new Error("Stencil cannot be setted without depth");
            if (t.checkFramebufferStatus(t.FRAMEBUFFER) !== t.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
          }
          destroy() {
            var e = this.context.gl,
              t = this.colorAttachment.get();
            t && e.deleteTexture(t), this.depthAttachment && (t = this.depthAttachment.get()) && e.deleteRenderbuffer(t), e.deleteFramebuffer(this.framebuffer);
          }
        }
        class E {
          constructor(e, t, r) {
            this.blendFunction = e, this.blendColor = t, this.mask = r;
          }
        }
        E.Replace = [1, 0], E.disabled = new E(E.Replace, de.Color.transparent, [!1, !1, !1, !1]), E.unblended = new E(E.Replace, de.Color.transparent, [!0, !0, !0, !0]), E.alphaBlended = new E([1, 771], de.Color.transparent, [!0, !0, !0, !0]);
        class kr {
          constructor(e) {
            var t, r;
            this.gl = e, this.clearColor = new Qt(this), this.clearDepth = new er(this), this.clearStencil = new tr(this), this.colorMask = new rr(this), this.depthMask = new nr(this), this.stencilMask = new ir(this), this.stencilFunc = new or(this), this.stencilOp = new ar(this), this.stencilTest = new sr(this), this.depthRange = new lr(this), this.depthTest = new cr(this), this.depthFunc = new ur(this), this.blend = new hr(this), this.blendFunc = new dr(this), this.blendColor = new pr(this), this.blendEquation = new fr(this), this.cullFace = new _r(this), this.cullFaceSide = new mr(this), this.frontFace = new gr(this), this.program = new yr(this), this.activeTexture = new vr(this), this.viewport = new Er(this), this.bindFramebuffer = new br(this), this.bindRenderbuffer = new wr(this), this.bindTexture = new Tr(this), this.bindVertexBuffer = new Sr(this), this.bindElementBuffer = new xr(this), this.bindVertexArray = new Cr(this), this.pixelStoreUnpack = new Ar(this), this.pixelStoreUnpackPremultiplyAlpha = new Ir(this), this.pixelStoreUnpackFlipY = new Nr(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Jt(e) ? (this.HALF_FLOAT = e.HALF_FLOAT, t = e.getExtension("EXT_color_buffer_half_float"), this.RGBA16F = null != (r = e.RGBA16F) ? r : null == t ? void 0 : t.RGBA16F_EXT, this.RGB16F = null != (r = e.RGB16F) ? r : null == t ? void 0 : t.RGB16F_EXT, e.getExtension("EXT_color_buffer_float")) : (e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear"), r = e.getExtension("OES_texture_half_float"), this.HALF_FLOAT = null == r ? void 0 : r.HALF_FLOAT_OES);
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(e, t) {
            return new Kt(this, e, t);
          }
          createVertexBuffer(e, t, r) {
            return new Zt(this, e, t, r);
          }
          createRenderbuffer(e, t, r) {
            var n = this.gl,
              i = n.createRenderbuffer();
            return this.bindRenderbuffer.set(i), n.renderbufferStorage(n.RENDERBUFFER, e, t, r), this.bindRenderbuffer.set(null), i;
          }
          createFramebuffer(e, t, r, n) {
            return new Mr(this, e, t, r, n);
          }
          clear({
            color: e,
            depth: t,
            stencil: r
          }) {
            var n = this.gl;
            let i = 0;
            e && (i |= n.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== t && (i |= n.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(!0)), void 0 !== r && (i |= n.STENCIL_BUFFER_BIT, this.clearStencil.set(r), this.stencilMask.set(255)), n.clear(i);
          }
          setCullFace(e) {
            !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
              func: e.test.func,
              ref: e.ref,
              mask: e.test.mask
            })) : this.stencilTest.set(!1);
          }
          setColorMode(e) {
            de.deepEqual(e.blendFunction, E.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
          }
          createVertexArray() {
            var e;
            return Jt(this.gl) ? this.gl.createVertexArray() : null == (e = this.gl.getExtension("OES_vertex_array_object")) ? void 0 : e.createVertexArrayOES();
          }
          deleteVertexArray(e) {
            var t;
            return Jt(this.gl) ? this.gl.deleteVertexArray(e) : null == (t = this.gl.getExtension("OES_vertex_array_object")) ? void 0 : t.deleteVertexArrayOES(e);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        class me {
          constructor(e, t, r) {
            this.func = e, this.mask = t, this.range = r;
          }
        }
        me.ReadOnly = !1, me.ReadWrite = !0, me.disabled = new me(519, me.ReadOnly, [0, 1]);
        class R {
          constructor(e, t, r, n, i, o) {
            this.test = e, this.ref = t, this.mask = r, this.fail = n, this.depthFail = i, this.pass = o;
          }
        }
        R.disabled = new R({
          func: 519,
          mask: 0
        }, 0, 0, 7680, 7680, 7680);
        class F {
          constructor(e, t, r) {
            this.enable = e, this.mode = t, this.frontFace = r;
          }
        }
        F.disabled = new F(!1, 1029, 2305), F.backCCW = new F(!0, 1029, 2305);
        let Lr;
        function Ur(r, t, n, i, o, a, s) {
          var l = r.context,
            c = l.gl,
            u = r.useProgram("collisionBox"),
            h = [];
          let d = 0,
            p = 0;
          for (let e = 0; e < i.length; e++) {
            var f = i[e],
              _ = t.getTile(f),
              m = _.getBucket(n);
            if (m) {
              let e = f.posMatrix;
              0 === o[0] && 0 === o[1] || (e = r.translatePosMatrix(f.posMatrix, _, o, a));
              var g,
                y,
                v = s ? m.textCollisionBox : m.iconCollisionBox,
                E = m.collisionCircleArray;
              0 < E.length && (g = de.create(), y = e, de.mul(g, m.placementInvProjMatrix, r.transform.glCoordMatrix), de.mul(g, g, m.placementViewportMatrix), h.push({
                circleArray: E,
                circleOffset: p,
                transform: y,
                invTransform: g,
                coord: f
              }), d += E.length / 4, p = d), v && u.draw(l, c.LINES, me.disabled, R.disabled, r.colorModeForRenderPass(), F.disabled, Rt(e, r.transform, _), r.style.map.terrain && r.style.map.terrain.getTerrainData(f), n.id, v.layoutVertexBuffer, v.indexBuffer, v.segments, null, r.transform.zoom, null, null, v.collisionVertexBuffer);
            }
          }
          if (s && h.length) {
            var e = r.useProgram("collisionCircle"),
              b = new de.CollisionCircleLayoutArray();
            b.resize(4 * d), b._trim();
            let t = 0;
            for (const N of h) for (let e = 0; e < N.circleArray.length / 4; e++) {
              var w = 4 * e,
                T = N.circleArray[0 + w],
                S = N.circleArray[1 + w],
                x = N.circleArray[2 + w],
                w = N.circleArray[3 + w];
              b.emplace(t++, T, S, x, w, 0), b.emplace(t++, T, S, x, w, 1), b.emplace(t++, T, S, x, w, 2), b.emplace(t++, T, S, x, w, 3);
            }
            (!Lr || Lr.length < 2 * d) && (Lr = function (e) {
              var t = 2 * e,
                r = new de.QuadTriangleArray();
              r.resize(t), r._trim();
              for (let e = 0; e < t; e++) {
                var n = 6 * e;
                r.uint16[0 + n] = 4 * e + 0, r.uint16[1 + n] = 4 * e + 1, r.uint16[2 + n] = 4 * e + 2, r.uint16[3 + n] = 4 * e + 2, r.uint16[4 + n] = 4 * e + 3, r.uint16[5 + n] = 4 * e + 0;
              }
              return r;
            }(d));
            var C = l.createIndexBuffer(Lr, !0),
              A = l.createVertexBuffer(b, de.collisionCircleLayout.members, !0);
            for (const P of h) {
              var I = Ot(P.transform, P.invTransform, r.transform);
              e.draw(l, c.TRIANGLES, me.disabled, R.disabled, r.colorModeForRenderPass(), F.disabled, I, r.style.map.terrain && r.style.map.terrain.getTerrainData(P.coord), n.id, A, C, de.SegmentVector.simpleSegment(0, 2 * P.circleOffset, P.circleArray.length, P.circleArray.length / 2), null, r.transform.zoom, null, null, null);
            }
            A.destroy(), C.destroy();
          }
        }
        const Fr = de.identity(new Float32Array(16));
        function Br(e, t, r, n, i) {
          if ("translucent" === e.renderPass) {
            var o = R.disabled,
              a = e.colorModeForRenderPass();
            if (r._unevaluatedLayout.hasValue("text-variable-anchor") || r._unevaluatedLayout.hasValue("text-variable-anchor-offset")) {
              var s = n,
                l = e,
                c = r,
                u = t,
                h = r.layout.get("text-rotation-alignment"),
                d = r.layout.get("text-pitch-alignment"),
                p = i,
                f = l.transform,
                _ = "map" === h,
                m = "map" === d;
              for (const T of s) {
                var g,
                  y,
                  v,
                  E,
                  b = u.getTile(T),
                  w = b.getBucket(c);
                w && w.text && w.text.segments.get().length && (g = w.textSizeData, g = de.evaluateSizeForZoom(g, f.zoom), y = _e(b, 1, l.transform.zoom), y = Me(T.posMatrix, m, _, l.transform, y), v = "none" !== c.layout.get("icon-text-fit") && w.hasIconData(), g) && (b = Math.pow(2, f.zoom - b.tileID.overscaledZ), E = l.style.map.terrain ? (e, t) => l.style.map.terrain.getElevation(T, e, t) : null, function (t, r, n, i, o, a, s, l, c, u, h) {
                  var d = t.text.placedSymbolArray,
                    p = t.text.dynamicLayoutVertexArray,
                    f = t.icon.dynamicLayoutVertexArray,
                    _ = {};
                  p.clear();
                  for (let e = 0; e < d.length; e++) {
                    var m = d.get(e),
                      g = t.allowVerticalPlacement && !m.placedOrientation,
                      g = m.hidden || !m.crossTileID || g ? null : i[m.crossTileID];
                    if (g) {
                      var y = new de.Point(m.anchorX, m.anchorY),
                        v = pe(y, n ? s : a, h),
                        E = Le(o.cameraToCenterDistance, v.signedDistanceFromCamera);
                      let e = de.evaluateSizeForFeature(t.textSizeData, c, m) * E / de.ONE_EM;
                      n && (e *= t.tilePixelRatio / l);
                      var {
                          width: E,
                          height: g,
                          anchor: b,
                          textOffset: w,
                          textBoxScale: T
                        } = g,
                        b = function (e, t, r, n, i, o) {
                          var {
                              horizontalAlign: e,
                              verticalAlign: a
                            } = de.getAnchorAlignment(e),
                            e = -(e - .5) * t,
                            t = -(a - .5) * r;
                          return new de.Point((e / i + n[0]) * o, (t / i + n[1]) * o);
                        }(b, E, g, w, T, e),
                        S = n ? pe(y.add(b), a, h).point : v.point.add(r ? b.rotate(-o.angle) : b),
                        x = t.allowVerticalPlacement && m.placedOrientation === de.WritingMode.vertical ? Math.PI / 2 : 0;
                      for (let e = 0; e < m.numGlyphs; e++) de.addDynamicAttributes(p, S, x);
                      u && 0 <= m.associatedIconIndex && (_[m.associatedIconIndex] = {
                        shiftedAnchor: S,
                        angle: x
                      });
                    } else fe(m.numGlyphs, p);
                  }
                  if (u) {
                    f.clear();
                    var C = t.icon.placedSymbolArray;
                    for (let e = 0; e < C.length; e++) {
                      var A = C.get(e);
                      if (A.hidden) fe(A.numGlyphs, f);else {
                        var I = _[e];
                        if (I) for (let e = 0; e < A.numGlyphs; e++) de.addDynamicAttributes(f, I.shiftedAnchor, I.angle);else fe(A.numGlyphs, f);
                      }
                    }
                    t.icon.dynamicLayoutVertexBuffer.updateData(f);
                  }
                  t.text.dynamicLayoutVertexBuffer.updateData(p);
                }(w, _, m, p, f, y, T.posMatrix, b, g, v, E));
              }
            }
            0 !== r.paint.get("icon-opacity").constantOr(1) && $r(e, t, r, n, !1, r.paint.get("icon-translate"), r.paint.get("icon-translate-anchor"), r.layout.get("icon-rotation-alignment"), r.layout.get("icon-pitch-alignment"), r.layout.get("icon-keep-upright"), o, a), 0 !== r.paint.get("text-opacity").constantOr(1) && $r(e, t, r, n, !0, r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), r.layout.get("text-rotation-alignment"), r.layout.get("text-pitch-alignment"), r.layout.get("text-keep-upright"), o, a), t.map.showCollisionBoxes && (Ur(e, t, r, n, r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), !0), Ur(e, t, r, n, r.paint.get("icon-translate"), r.paint.get("icon-translate-anchor"), !1));
          }
        }
        function $r(s, i, l, o, c, B, $, a, z, Y, H, j) {
          var e = s.context,
            u = e.gl,
            G = s.transform,
            h = "map" === a,
            d = "map" === z,
            q = "viewport" !== a && "point" !== l.layout.get("symbol-placement"),
            V = h && !d && !q,
            K = !l.layout.get("symbol-sort-key").isConstant();
          let W = !1;
          var Z = s.depthModeForSublayer(0, me.ReadOnly),
            X = l._unevaluatedLayout.hasValue("text-variable-anchor") || l._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
            p = [];
          for (const F of o) {
            var f = i.getTile(F),
              _ = f.getBucket(l);
            if (_) {
              var m = c ? _.text : _.icon;
              if (m && m.segments.get().length && m.hasVisibleVertices) {
                var g = m.programConfigurations.get(l.id),
                  y = c || _.sdfIcons,
                  v = c ? _.textSizeData : _.iconSizeData,
                  E = d || 0 !== G.pitch,
                  J = s.useProgram((b = y, J = c, _.iconsInText && J ? "symbolTextAndIcon" : b ? "symbolSDF" : "symbolIcon"), g),
                  b = de.evaluateSizeForZoom(v, G.zoom),
                  Q = s.style.map.terrain && s.style.map.terrain.getTerrainData(F);
                let e,
                  t = [0, 0],
                  r,
                  n,
                  i = null,
                  o;
                c ? (r = f.glyphAtlasTexture, n = u.LINEAR, e = f.glyphAtlasTexture.size, _.iconsInText && (t = f.imageAtlasTexture.size, i = f.imageAtlasTexture, g = "composite" === v.kind || "camera" === v.kind, o = E || s.options.rotating || s.options.zooming || g ? u.LINEAR : u.NEAREST)) : (g = 1 !== l.layout.get("icon-size").constantOr(0) || _.iconsNeedLinear, r = f.imageAtlasTexture, n = y || s.options.rotating || s.options.zooming || g || E ? u.LINEAR : u.NEAREST, e = f.imageAtlasTexture.size);
                var g = _e(f, 1, s.transform.zoom),
                  E = Me(F.posMatrix, d, h, s.transform, g),
                  g = ke(F.posMatrix, d, h, s.transform, g),
                  w = X && _.hasTextData(),
                  w = "none" !== l.layout.get("icon-text-fit") && w && _.hasIconData();
                if (q) {
                  var T = s.style.map.terrain ? (e, t) => s.style.map.terrain.getElevation(F, e, t) : null,
                    S = "map" === l.layout.get("text-rotation-alignment");
                  {
                    x = void 0;
                    C = void 0;
                    A = void 0;
                    I = void 0;
                    N = void 0;
                    ee = void 0;
                    te = void 0;
                    re = void 0;
                    ne = void 0;
                    P = void 0;
                    ie = void 0;
                    oe = void 0;
                    ae = void 0;
                    D = void 0;
                    se = void 0;
                    le = void 0;
                    ce = void 0;
                    U = void 0;
                    O = void 0;
                    M = void 0;
                    R = void 0;
                    k = void 0;
                    L = void 0;
                    var x = _;
                    var C = F.posMatrix;
                    var A = s;
                    var I = c;
                    var N = E;
                    var ee = g;
                    var te = d;
                    var re = Y;
                    var ne = S;
                    var P = T;
                    var ie = I ? x.textSizeData : x.iconSizeData,
                      oe = de.evaluateSizeForZoom(ie, A.transform.zoom),
                      ae = [256 / A.width * 2 + 1, 256 / A.height * 2 + 1],
                      D = (I ? x.text : x.icon).dynamicLayoutVertexArray,
                      se = (D.clear(), x.lineVertexArray),
                      le = (I ? x.text : x.icon).placedSymbolArray,
                      ce = A.transform.width / A.transform.height;
                    let t = !1;
                    for (let e = 0; e < le.length; e++) {
                      var R,
                        O,
                        M,
                        k,
                        L,
                        U = le.get(e);
                      if (U.hidden || U.writingMode === de.WritingMode.vertical && !t) fe(U.numGlyphs, D);else {
                        t = !1;
                        let e;
                        P ? (e = [U.anchorX, U.anchorY, P(U.anchorX, U.anchorY), 1], de.transformMat4(e, e, C)) : Ge(e = [U.anchorX, U.anchorY, 0, 1], e, C), M = e, O = ae, R = void 0, R = M[0] / M[3], M = M[1] / M[3], (!(R >= -O[0] && R <= O[0] && M >= -O[1] && M <= O[1]) || (R = e[3], M = Le(A.transform.cameraToCenterDistance, R), O = de.evaluateSizeForFeature(ie, oe, U), R = te ? O / M : O * M, M = pe(O = new de.Point(U.anchorX, U.anchorY), N, P).point, L = Be(U, R, !(k = {
                          projections: {},
                          offsets: {}
                        }), re, C, N, ee, x.glyphOffsetArray, se, D, M, O, k, ce, ne, P), t = L.useVertical, L.notEnoughRoom) || t || L.needsFlipping && Be(U, R, !0, re, C, N, ee, x.glyphOffsetArray, se, D, M, O, k, ce, ne, P).notEnoughRoom) && fe(U.numGlyphs, D);
                      }
                    }
                    (I ? x.text : x.icon).dynamicLayoutVertexBuffer.updateData(D);
                  }
                }
                S = s.translatePosMatrix(F.posMatrix, f, B, $), T = q || c && X || w ? Fr : E, I = s.translatePosMatrix(g, f, B, $, !0), w = y && 0 !== l.paint.get(c ? "text-halo-width" : "icon-halo-width").constantOr(1);
                var ue = {
                  program: J,
                  buffers: m,
                  uniformValues: y ? _.iconsInText ? Gt(v.kind, b, V, d, s, S, T, I, e, t) : jt(v.kind, b, V, d, s, S, T, I, c, e, !0) : Ht(v.kind, b, V, d, s, S, T, I, c, e),
                  atlasTexture: r,
                  atlasTextureIcon: i,
                  atlasInterpolation: n,
                  atlasInterpolationIcon: o,
                  isSDF: y,
                  hasHalo: w
                };
                if (K && _.canOverlap) {
                  W = !0;
                  for (const he of m.segments.get()) p.push({
                    segments: new de.SegmentVector([he]),
                    sortKey: he.sortKey,
                    state: ue,
                    terrainData: Q
                  });
                } else p.push({
                  segments: m.segments,
                  sortKey: 0,
                  state: ue,
                  terrainData: Q
                });
              }
            }
          }
          W && p.sort((e, t) => e.sortKey - t.sortKey);
          for (const n of p) {
            var t,
              r = n.state;
            e.activeTexture.set(u.TEXTURE0), r.atlasTexture.bind(r.atlasInterpolation, u.CLAMP_TO_EDGE), r.atlasTextureIcon && (e.activeTexture.set(u.TEXTURE1), r.atlasTextureIcon) && r.atlasTextureIcon.bind(r.atlasInterpolationIcon, u.CLAMP_TO_EDGE), r.isSDF && (t = r.uniformValues, r.hasHalo && (t.u_is_halo = 1, zr(r.buffers, n.segments, l, s, r.program, Z, H, j, t, n.terrainData)), t.u_is_halo = 0), zr(r.buffers, n.segments, l, s, r.program, Z, H, j, r.uniformValues, n.terrainData);
          }
        }
        function zr(e, t, r, n, i, o, a, s, l, c) {
          var u = n.context,
            h = u.gl;
          i.draw(u, h.TRIANGLES, o, a, s, F.disabled, l, c, r.id, e.layoutVertexBuffer, e.indexBuffer, t, r.paint, n.transform.zoom, e.programConfigurations.get(r.id), e.dynamicLayoutVertexBuffer, e.opacityVertexBuffer);
        }
        function Yr(t, r, n, i) {
          if ("translucent" === t.renderPass) {
            var e = n.paint.get("circle-opacity"),
              o = n.paint.get("circle-stroke-width"),
              a = n.paint.get("circle-stroke-opacity"),
              s = !n.layout.get("circle-sort-key").isConstant();
            if (0 !== e.constantOr(1) || 0 !== o.constantOr(1) && 0 !== a.constantOr(1)) {
              var l = t.context,
                c = l.gl,
                u = t.depthModeForSublayer(0, me.ReadOnly),
                h = R.disabled,
                d = t.colorModeForRenderPass(),
                p = [];
              for (let e = 0; e < i.length; e++) {
                var f = i[e],
                  _ = r.getTile(f),
                  m = _.getBucket(n);
                if (m) {
                  var g = m.programConfigurations.get(n.id),
                    y = t.useProgram("circle", g),
                    v = m.layoutVertexBuffer,
                    E = m.indexBuffer,
                    b = t.style.map.terrain && t.style.map.terrain.getTerrainData(f),
                    w = {
                      programConfiguration: g,
                      program: y,
                      layoutVertexBuffer: v,
                      indexBuffer: E,
                      uniformValues: ((e, t, r, n) => {
                        var i,
                          o = e.transform;
                        let a, s;
                        return s = "map" === n.paint.get("circle-pitch-alignment") ? (i = _e(r, 1, o.zoom), a = !0, [i, i]) : (a = !1, o.pixelsToGLUnits), {
                          u_camera_to_center_distance: o.cameraToCenterDistance,
                          u_scale_with_map: +("map" === n.paint.get("circle-pitch-scale")),
                          u_matrix: e.translatePosMatrix(t.posMatrix, r, n.paint.get("circle-translate"), n.paint.get("circle-translate-anchor")),
                          u_pitch_with_map: +a,
                          u_device_pixel_ratio: e.pixelRatio,
                          u_extrude_scale: s
                        };
                      })(t, f, _, n),
                      terrainData: b
                    };
                  if (s) for (const P of m.segments.get()) p.push({
                    segments: new de.SegmentVector([P]),
                    sortKey: P.sortKey,
                    state: w
                  });else p.push({
                    segments: m.segments,
                    sortKey: 0,
                    state: w
                  });
                }
              }
              s && p.sort((e, t) => e.sortKey - t.sortKey);
              for (const D of p) {
                var {
                    programConfiguration: T,
                    program: S,
                    layoutVertexBuffer: x,
                    indexBuffer: C,
                    uniformValues: A,
                    terrainData: I
                  } = D.state,
                  N = D.segments;
                S.draw(l, c.TRIANGLES, u, h, d, F.disabled, A, I, n.id, x, C, N, n.paint, t.transform.zoom, T);
              }
            }
          }
        }
        function Hr(t, r, n, i) {
          if (0 !== n.paint.get("heatmap-opacity")) if ("offscreen" === t.renderPass) {
            var o = t.context,
              a = o.gl,
              s = R.disabled,
              l = new E([a.ONE, a.ONE], de.Color.transparent, [!0, !0, !0, !0]);
            {
              var c = o;
              var u = t;
              var h = n;
              var d = c.gl;
              c.activeTexture.set(d.TEXTURE1), c.viewport.set([0, 0, u.width / 4, u.height / 4]);
              let e = h.heatmapFbo;
              e ? (d.bindTexture(d.TEXTURE_2D, e.colorAttachment.get()), c.bindFramebuffer.set(e.framebuffer)) : (v = d.createTexture(), d.bindTexture(d.TEXTURE_2D, v), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR), e = h.heatmapFbo = c.createFramebuffer(u.width / 4, u.height / 4, !1, !1), function (e, t, r, n) {
                var i = e.gl,
                  o = null != (o = e.HALF_FLOAT) ? o : i.UNSIGNED_BYTE,
                  e = null != (e = e.RGBA16F) ? e : i.RGBA;
                i.texImage2D(i.TEXTURE_2D, 0, e, t.width / 4, t.height / 4, 0, i.RGBA, o, null), n.colorAttachment.set(r);
              }(c, u, v, e));
            }
            o.clear({
              color: de.Color.transparent
            });
            for (let e = 0; e < i.length; e++) {
              var p,
                f,
                _,
                m,
                g,
                y = i[e];
              r.hasRenderableParent(y) || (f = (p = r.getTile(y)).getBucket(n)) && (_ = f.programConfigurations.get(n.id), m = t.useProgram("heatmap", _), g = t.transform["zoom"], m.draw(o, a.TRIANGLES, me.disabled, s, l, F.disabled, (m = y.posMatrix, y = p, p = g, g = n.paint.get("heatmap-intensity"), {
                u_matrix: m,
                u_extrude_scale: _e(y, 1, p),
                u_intensity: g
              }), null, n.id, f.layoutVertexBuffer, f.indexBuffer, f.segments, n.paint, t.transform.zoom, _));
            }
            o.viewport.set([0, 0, t.width, t.height]);
          } else if ("translucent" === t.renderPass) {
            t.context.setColorMode(t.colorModeForRenderPass());
            var d = t,
              h = n,
              c = d.context,
              u = c.gl,
              v = h.heatmapFbo;
            if (v) {
              c.activeTexture.set(u.TEXTURE0), u.bindTexture(u.TEXTURE_2D, v.colorAttachment.get()), c.activeTexture.set(u.TEXTURE1);
              let e = h.colorRampTexture;
              (e = e || (h.colorRampTexture = new U(c, h.colorRamp, u.RGBA))).bind(u.LINEAR, u.CLAMP_TO_EDGE), d.useProgram("heatmapTexture").draw(c, u.TRIANGLES, me.disabled, R.disabled, d.colorModeForRenderPass(), F.disabled, Lt(d, h, 0, 1), null, h.id, d.viewportBuffer, d.quadTriangleIndexBuffer, d.viewportSegments, h.paint, d.transform.zoom);
            }
          }
        }
        function jr(r, n, i, t) {
          if ("translucent" === r.renderPass) {
            var e = i.paint.get("line-opacity"),
              o = i.paint.get("line-width");
            if (0 !== e.constantOr(1) && 0 !== o.constantOr(1)) {
              var a,
                s,
                l,
                c,
                u,
                h,
                d,
                p,
                f,
                _,
                m = r.depthModeForSublayer(0, me.ReadOnly),
                g = r.colorModeForRenderPass(),
                y = i.paint.get("line-dasharray"),
                v = i.paint.get("line-pattern"),
                E = v.constantOr(1),
                b = i.paint.get("line-gradient"),
                w = i.getCrossfadeParameters(),
                L = E ? "linePattern" : y ? "lineSDF" : b ? "lineGradient" : "line",
                T = r.context,
                S = T.gl;
              let e = !0;
              for (const k of t) {
                var x = n.getTile(k);
                if (!E || x.patternsLoaded()) {
                  var C = x.getBucket(i);
                  if (C) {
                    var A,
                      I,
                      N = C.programConfigurations.get(i.id),
                      P = r.context.program.get(),
                      D = r.useProgram(L, N),
                      P = e || D.program !== P,
                      R = r.style.map.terrain && r.style.map.terrain.getTerrainData(k),
                      O = v.constantOr(null),
                      O = (O && x.imageAtlas && (A = (I = x.imageAtlas).patternPositions[O.to.toString()], I = I.patternPositions[O.from.toString()], A) && I && N.setConstantPatternPositions(A, I), R ? k : null),
                      M = E ? (A = x, I = i, d = w, p = O, _ = f = void 0, f = (h = r).transform, _ = $t(A, f), {
                        u_matrix: zt(h, A, I, p),
                        u_texsize: A.imageAtlasTexture.size,
                        u_ratio: 1 / _e(A, 1, f.zoom),
                        u_device_pixel_ratio: h.pixelRatio,
                        u_image: 0,
                        u_scale: [_, d.fromScale, d.toScale],
                        u_fade: d.t,
                        u_units_to_pixels: [1 / f.pixelsToGLUnits[0], 1 / f.pixelsToGLUnits[1]]
                      }) : y ? (p = x, h = i, _ = y, d = w, f = O, u = c = M = c = s = l = s = void 0, s = (a = r).transform, l = a.lineAtlas, s = $t(p, s), c = "round" === h.layout.get("line-cap"), M = l.getDash(_.from, c), _ = l.getDash(_.to, c), c = M.width * d.fromScale, u = _.width * d.toScale, de.extend(Bt(a, p, h, f), {
                        u_patternscale_a: [s / c, -M.height / 2],
                        u_patternscale_b: [s / u, -_.height / 2],
                        u_sdfgamma: l.width / (256 * Math.min(c, u) * a.pixelRatio) / 2,
                        u_image: 0,
                        u_tex_y_a: M.y,
                        u_tex_y_b: _.y,
                        u_mix: d.t
                      })) : b ? (s = r, l = x, c = i, u = C.lineClipsArray.length, a = O, de.extend(Bt(s, l, c, a), {
                        u_image: 0,
                        u_image_height: u
                      })) : Bt(r, x, i, O);
                    if (E) T.activeTexture.set(S.TEXTURE0), x.imageAtlasTexture.bind(S.LINEAR, S.CLAMP_TO_EDGE), N.updatePaintBuffers(w);else if (y && (P || r.lineAtlas.dirty)) T.activeTexture.set(S.TEXTURE0), r.lineAtlas.bind(T);else if (b) {
                      O = C.gradients[i.id];
                      let t = O.texture;
                      if (i.gradientVersion !== O.version) {
                        let e = 256;
                        i.stepInterpolant && (x = n.getSource().maxzoom, P = k.canonical.z === x ? Math.ceil(1 << r.transform.maxZoom - k.canonical.z) : 1, x = C.maxLineLength / de.EXTENT, e = de.clamp(de.nextPowerOfTwo(1024 * x * P), 256, T.maxTextureSize)), O.gradient = de.renderColorRamp({
                          expression: i.gradientExpression(),
                          evaluationKey: "lineProgress",
                          resolution: e,
                          image: O.gradient || void 0,
                          clips: C.lineClipsArray
                        }), O.texture ? O.texture.update(O.gradient) : O.texture = new U(T, O.gradient, S.RGBA), O.version = i.gradientVersion, t = O.texture;
                      }
                      T.activeTexture.set(S.TEXTURE0), t.bind(i.stepInterpolant ? S.NEAREST : S.LINEAR, S.CLAMP_TO_EDGE);
                    }
                    D.draw(T, S.TRIANGLES, m, r.stencilModeForClipping(k), g, F.disabled, M, R, i.id, C.layoutVertexBuffer, C.indexBuffer, C.segments, i.paint, r.transform.zoom, N, C.layoutVertexBuffer2), e = !1;
                  }
                }
              }
            }
          }
        }
        function Gr(r, n, i, o, a) {
          if (i && o && o.imageAtlas) {
            o = o.imageAtlas.patternPositions;
            let e = o[i.to.toString()],
              t = o[i.from.toString()];
            e && t || (i = a.getPaintProperty(n), e = o[i], t = o[i]), e && t && r.setConstantPatternPositions(e, t);
          }
        }
        function qr(e, t, r, n) {
          var i,
            o,
            a = r.paint.get("fill-color"),
            s = r.paint.get("fill-opacity");
          0 !== s.constantOr(1) && (i = e.colorModeForRenderPass(), o = r.paint.get("fill-pattern"), o = e.opaquePassEnabledForLayer() && !o.constantOr(1) && 1 === a.constantOr(de.Color.transparent).a && 1 === s.constantOr(0) ? "opaque" : "translucent", e.renderPass === o && (a = e.depthModeForSublayer(1, "opaque" === e.renderPass ? me.ReadWrite : me.ReadOnly), Vr(e, t, r, n, a, i, !1)), "translucent" === e.renderPass) && r.paint.get("fill-antialias") && (s = e.depthModeForSublayer(r.getPaintProperty("fill-outline-color") ? 2 : 0, me.ReadOnly), Vr(e, t, r, n, s, i, !0));
        }
        function Vr(e, t, r, n, i, o, a) {
          var s = e.context.gl,
            l = "fill-pattern",
            c = r.paint.get(l),
            u = c && c.constantOr(1),
            h = r.getCrossfadeParameters();
          let d, p, f, _, m;
          d = a ? (p = u && !r.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", s.LINES) : (p = u ? "fillPattern" : "fill", s.TRIANGLES);
          var g = c.constantOr(null);
          for (const x of n) {
            var y,
              v,
              E,
              b,
              w,
              T,
              S = t.getTile(x);
            u && !S.patternsLoaded() || (y = S.getBucket(r)) && (v = y.programConfigurations.get(r.id), E = e.useProgram(p, v), b = e.style.map.terrain && e.style.map.terrain.getTerrainData(x), u && (e.context.activeTexture.set(s.TEXTURE0), S.imageAtlasTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE), v.updatePaintBuffers(h)), Gr(v, l, g, S, r), w = ((b ? x : null) || x).posMatrix, w = e.translatePosMatrix(w, S, r.paint.get("fill-translate"), r.paint.get("fill-translate-anchor")), f = a ? (_ = y.indexBuffer2, m = y.segments2, T = [s.drawingBufferWidth, s.drawingBufferHeight], "fillOutlinePattern" === p && u ? Dt(w, e, h, S, T) : Pt(w, T)) : (_ = y.indexBuffer, m = y.segments, u ? Nt(w, e, h, S) : It(w)), E.draw(e.context, d, i, e.stencilModeForClipping(x), o, F.disabled, f, b, r.id, y.layoutVertexBuffer, _, m, r.paint, e.transform.zoom, v));
          }
        }
        function Kr(e, t, r, n) {
          var i,
            o = r.paint.get("fill-extrusion-opacity");
          0 !== o && "translucent" === e.renderPass && (i = new me(e.context.gl.LEQUAL, me.ReadWrite, e.depthRangeFor3D), 1 !== o || r.paint.get("fill-extrusion-pattern").constantOr(1) ? (Wr(e, t, r, n, i, R.disabled, E.disabled), Wr(e, t, r, n, i, e.stencilModeFor3D(), e.colorModeForRenderPass())) : (o = e.colorModeForRenderPass(), Wr(e, t, r, n, i, R.disabled, o)));
        }
        function Wr(e, t, r, n, i, o, a) {
          var s = e.context,
            l = s.gl,
            c = "fill-extrusion-pattern",
            u = r.paint.get(c),
            h = u.constantOr(1),
            d = r.getCrossfadeParameters(),
            p = r.paint.get("fill-extrusion-opacity"),
            f = u.constantOr(null);
          for (const w of n) {
            var _,
              m,
              g,
              y,
              v,
              E = t.getTile(w),
              b = E.getBucket(r);
            b && (_ = e.style.map.terrain && e.style.map.terrain.getTerrainData(w), m = b.programConfigurations.get(r.id), g = e.useProgram(h ? "fillExtrusionPattern" : "fillExtrusion", m), h && (e.context.activeTexture.set(l.TEXTURE0), E.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), m.updatePaintBuffers(d)), Gr(m, c, f, E, r), y = e.translatePosMatrix(w.posMatrix, E, r.paint.get("fill-extrusion-translate"), r.paint.get("fill-extrusion-translate-anchor")), v = r.paint.get("fill-extrusion-vertical-gradient"), E = h ? At(y, e, v, p, w, d, E) : Ct(y, e, v, p), g.draw(s, s.gl.TRIANGLES, i, o, a, F.backCCW, E, _, r.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, r.paint, e.transform.zoom, m, e.style.map.terrain && b.centroidVertexBuffer));
          }
        }
        function Zr(e, t, r, n) {
          if ("offscreen" === e.renderPass || "translucent" === e.renderPass) {
            var i = e.context,
              o = e.depthModeForSublayer(0, me.ReadOnly),
              a = e.colorModeForRenderPass(),
              [s, n] = "translucent" === e.renderPass ? e.stencilConfigForOverlap(n) : [{}, n];
            for (const b of n) {
              var l = t.getTile(b);
              if (void 0 !== l.needsHillshadePrepare && l.needsHillshadePrepare && "offscreen" === e.renderPass) {
                E = v = y = g = m = _ = f = p = d = h = u = c = void 0;
                var c = e,
                  u = l,
                  h = r,
                  d = o,
                  p = R.disabled,
                  f = a,
                  _ = c.context,
                  m = _.gl,
                  g = u.dem;
                if (g && g.data) {
                  var y = g.dim,
                    v = g.stride,
                    E = g.getPixels();
                  _.activeTexture.set(m.TEXTURE1), _.pixelStoreUnpackPremultiplyAlpha.set(!1), u.demTexture = u.demTexture || c.getTileTexture(v), (u.demTexture ? ((v = u.demTexture).update(E, {
                    premultiply: !1
                  }), v) : (u.demTexture = new U(_, E, m.RGBA, {
                    premultiply: !1
                  }), u.demTexture)).bind(m.NEAREST, m.CLAMP_TO_EDGE), _.activeTexture.set(m.TEXTURE0);
                  let e = u.fbo;
                  e || ((v = new U(_, {
                    width: y,
                    height: y,
                    data: null
                  }, m.RGBA)).bind(m.LINEAR, m.CLAMP_TO_EDGE), (e = u.fbo = _.createFramebuffer(y, y, !0, !1)).colorAttachment.set(v.texture)), _.bindFramebuffer.set(e.framebuffer), _.viewport.set([0, 0, y, y]), c.useProgram("hillshadePrepare").draw(_, m.TRIANGLES, d, p, f, F.disabled, Ft(u.tileID, g), null, h.id, c.rasterBoundsBuffer, c.quadTriangleIndexBuffer, c.rasterBoundsSegments), u.needsHillshadePrepare = !1;
                }
              } else "translucent" === e.renderPass && (E = e, v = b, y = l, _ = r, m = o, d = s[b.overscaledZ], p = a, u = c = h = g = f = void 0, f = E.context, g = f.gl, h = y.fbo) && (c = E.useProgram("hillshade"), u = E.style.map.terrain && E.style.map.terrain.getTerrainData(v), f.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, h.colorAttachment.get()), h = u ? v : null, c.draw(f, g.TRIANGLES, m, d, p, F.disabled, Ut(E, y, _, h), u, _.id, E.rasterBoundsBuffer, E.quadTriangleIndexBuffer, E.rasterBoundsSegments));
            }
            i.viewport.set([0, 0, e.width, e.height]);
          }
        }
        function Xr(r, n, i, e) {
          if ("translucent" === r.renderPass && 0 !== i.paint.get("raster-opacity") && e.length) {
            var o = r.context,
              a = o.gl,
              s = n.getSource(),
              l = r.useProgram("raster"),
              c = r.colorModeForRenderPass(),
              [u, e] = s instanceof v ? [{}, e] : r.stencilConfigForOverlap(e),
              h = e[e.length - 1].overscaledZ,
              d = !r.options.moving;
            for (const y of e) {
              var p = r.depthModeForSublayer(y.overscaledZ - h, 1 === i.paint.get("raster-opacity") ? me.ReadWrite : me.ReadOnly, a.LESS),
                f = n.getTile(y),
                _ = (f.registerFadeDuration(i.paint.get("raster-fade-duration")), n.findLoadedParent(y, 0)),
                m = function (e, t, r, n, i, o) {
                  n = n.paint.get("raster-fade-duration");
                  {
                    var a;
                    return !o && 0 < n ? (o = de.browser.now(), a = (o - e.timeAdded) / n, o = t ? (o - t.timeAdded) / n : -1, n = r.getSource(), r = i.coveringZoomLevel({
                      tileSize: n.tileSize,
                      roundZoom: n.roundZoom
                    }), i = !t || Math.abs(t.tileID.overscaledZ - r) > Math.abs(e.tileID.overscaledZ - r), n = i && e.refreshedUponExpiration ? 1 : de.clamp(i ? a : 1 - o, 0, 1), e.refreshedUponExpiration && 1 <= a && (e.refreshedUponExpiration = !1), t ? {
                      opacity: 1,
                      mix: 1 - n
                    } : {
                      opacity: n,
                      mix: 0
                    }) : {
                      opacity: 1,
                      mix: 0
                    };
                  }
                }(f, _, n, i, r.transform, r.style.map.terrain);
              let e, t;
              var g = "nearest" === i.paint.get("raster-resampling") ? a.NEAREST : a.LINEAR,
                _ = (o.activeTexture.set(a.TEXTURE0), f.texture.bind(g, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), o.activeTexture.set(a.TEXTURE1), _ ? (_.texture.bind(g, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), e = Math.pow(2, _.tileID.overscaledZ - f.tileID.overscaledZ), t = [f.tileID.canonical.x * e % 1, f.tileID.canonical.y * e % 1]) : f.texture.bind(g, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), r.style.map.terrain && r.style.map.terrain.getTerrainData(y)),
                f = _ ? y : null,
                g = f ? f.posMatrix : r.transform.calculatePosMatrix(y.toUnwrapped(), d),
                f = Yt(g, t || [0, 0], e || 1, m, i);
              s instanceof v ? l.draw(o, a.TRIANGLES, p, R.disabled, c, F.disabled, f, _, i.id, s.boundsBuffer, r.quadTriangleIndexBuffer, s.boundsSegments) : l.draw(o, a.TRIANGLES, p, u[y.overscaledZ], c, F.disabled, f, _, i.id, r.rasterBoundsBuffer, r.quadTriangleIndexBuffer, r.rasterBoundsSegments);
            }
          }
        }
        function Jr(e, t, r, n) {
          var i = r.paint.get("background-color"),
            o = r.paint.get("background-opacity");
          if (0 !== o) {
            var a = e.context,
              s = a.gl,
              l = e.transform,
              c = l.tileSize,
              u = r.paint.get("background-pattern");
            if (!e.isPatternMissing(u)) {
              var h = !u && 1 === i.a && 1 === o && e.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (e.renderPass === h) {
                var d = R.disabled,
                  p = e.depthModeForSublayer(0, "opaque" == h ? me.ReadWrite : me.ReadOnly),
                  f = e.colorModeForRenderPass(),
                  _ = e.useProgram(u ? "backgroundPattern" : "background"),
                  h = n || l.coveringTiles({
                    tileSize: c,
                    terrain: e.style.map.terrain
                  }),
                  m = (u && (a.activeTexture.set(s.TEXTURE0), e.imageManager.bind(e.context)), r.getCrossfadeParameters());
                for (const v of h) {
                  var g = n ? v.posMatrix : e.transform.calculatePosMatrix(v.toUnwrapped()),
                    g = u ? qt(g, o, e, u, {
                      tileID: v,
                      tileSize: c
                    }, m) : {
                      u_matrix: g,
                      u_opacity: o,
                      u_color: i
                    },
                    y = e.style.map.terrain && e.style.map.terrain.getTerrainData(v);
                  _.draw(a, s.TRIANGLES, p, d, f, F.disabled, g, y, r.id, e.tileExtentBuffer, e.quadTriangleIndexBuffer, e.tileExtentSegments);
                }
              }
            }
          }
        }
        const Qr = new de.Color(1, 0, 0, 1),
          en = new de.Color(0, 1, 0, 1),
          tn = new de.Color(0, 0, 1, 1),
          rn = new de.Color(1, 0, 1, 1),
          nn = new de.Color(0, 1, 1, 1);
        function on(e) {
          var t,
            r,
            n = e.transform.padding,
            n = (an(e, e.transform.height - (n.top || 0), 3, Qr), an(e, n.bottom || 0, 3, en), sn(e, n.left || 0, 3, tn), sn(e, e.transform.width - (n.right || 0), 3, rn), e.transform.centerPoint);
          t = e, r = n.x, e = e.transform.height - n.y, n = nn, ln(t, r - 1, e - 10, 2, 20, n), ln(t, r - 10, e - 1, 20, 2, n);
        }
        function an(e, t, r, n) {
          ln(e, 0, t + r / 2, e.transform.width, r, n);
        }
        function sn(e, t, r, n) {
          ln(e, t - r / 2, 0, r, e.transform.height, n);
        }
        function ln(e, t, r, n, i, o) {
          var a = e.context,
            s = a.gl;
          s.enable(s.SCISSOR_TEST), s.scissor(t * e.pixelRatio, r * e.pixelRatio, n * e.pixelRatio, i * e.pixelRatio), a.clear({
            color: o
          }), s.disable(s.SCISSOR_TEST);
        }
        function cn(r, n, i) {
          for (let t = 0; t < i.length; t++) {
            o = void 0;
            a = void 0;
            s = void 0;
            l = void 0;
            c = void 0;
            u = void 0;
            h = void 0;
            d = void 0;
            p = void 0;
            f = void 0;
            _ = void 0;
            m = void 0;
            var o = r;
            var a = n;
            var s = i[t];
            var l = o.context,
              c = l.gl,
              u = s.posMatrix,
              h = o.useProgram("debug"),
              d = me.disabled,
              p = R.disabled,
              f = o.colorModeForRenderPass(),
              _ = o.style.map.terrain && o.style.map.terrain.getTerrainData(s),
              m = (l.activeTexture.set(c.TEXTURE0), a.getTileByID(s.key).latestRawTileData),
              m = m && m.byteLength || 0,
              m = Math.floor(m / 1024),
              a = a.getTile(s).tileSize,
              a = 512 / Math.min(a, 512) * (s.overscaledZ / o.transform.zoom) * .5;
            let e = s.canonical.toString();
            s.overscaledZ !== s.canonical.z && (e += " => " + s.overscaledZ);
            s = e + ` ${m}kB`;
            ((function (e, t) {
              e.initDebugOverlayCanvas();
              var r = e.debugOverlayCanvas,
                n = e.context.gl,
                i = e.debugOverlayCanvas.getContext("2d");
              i.clearRect(0, 0, r.width, r.height), i.shadowColor = "white", i.shadowBlur = 2, i.lineWidth = 1.5, i.strokeStyle = "white", i.textBaseline = "top", i.font = "bold 36px Open Sans, sans-serif", i.fillText(t, 5, 5), i.strokeText(t, 5, 5), e.debugOverlayTexture.update(r), e.debugOverlayTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE);
            }))(o, s), h.draw(l, c.TRIANGLES, d, p, E.alphaBlended, F.disabled, Mt(u, de.Color.transparent, a), null, "$debug", o.debugBuffer, o.quadTriangleIndexBuffer, o.debugSegments), h.draw(l, c.LINE_STRIP, d, p, f, F.disabled, Mt(u, de.Color.red), _, "$debug", o.debugBuffer, o.tileBorderIndexBuffer, o.debugSegments);
          }
        }
        function un(t, r) {
          let n = null;
          var e = Object.values(t._layers).flatMap(e => {
              return e.source && !e.isHidden(r) ? [t.sourceCaches[e.source]] : [];
            }),
            i = e.filter(e => "vector" === e.getSource().type),
            e = e.filter(e => "vector" !== e.getSource().type);
          const o = e => {
            (!n || n.getSource().maxzoom < e.getSource().maxzoom) && (n = e);
          };
          return i.forEach(e => o(e)), n || e.forEach(e => o(e)), n;
        }
        function hn(e, t, r) {
          var n,
            i = e.context,
            r = r.implementation;
          "offscreen" === e.renderPass ? (n = r.prerender) && (e.setCustomLayerDefaults(), i.setColorMode(e.colorModeForRenderPass()), n.call(r, i.gl, e.transform.customLayerMatrix()), i.setDirty(), e.setBaseState()) : "translucent" === e.renderPass && (e.setCustomLayerDefaults(), i.setColorMode(e.colorModeForRenderPass()), i.setStencilMode(R.disabled), n = "3d" === r.renderingMode ? new me(e.context.gl.LEQUAL, me.ReadWrite, e.depthRangeFor3D) : e.depthModeForSublayer(0, me.ReadOnly), i.setDepthMode(n), r.render(i.gl, e.transform.customLayerMatrix()), i.setDirty(), e.setBaseState(), i.bindFramebuffer.set(null));
        }
        function dn(e, t) {
          var r = e.context,
            n = r.gl,
            i = E.unblended,
            o = new me(n.LEQUAL, me.ReadWrite, [0, 1]),
            a = t.getTerrainMesh(),
            s = t.sourceCache.getRenderableTiles(),
            l = e.useProgram("terrainDepth");
          r.bindFramebuffer.set(t.getFramebuffer("depth").framebuffer), r.viewport.set([0, 0, e.width / devicePixelRatio, e.height / devicePixelRatio]), r.clear({
            color: de.Color.transparent,
            depth: 1
          });
          for (const h of s) {
            var c = t.getTerrainData(h.tileID),
              u = {
                u_matrix: e.transform.calculatePosMatrix(h.tileID.toUnwrapped()),
                u_ele_delta: t.getMeshFrameDelta(e.transform.zoom)
              };
            l.draw(r, n.TRIANGLES, o, R.disabled, i, F.backCCW, u, c, "terrain", a.vertexBuffer, a.indexBuffer, a.segments);
          }
          r.bindFramebuffer.set(null), r.viewport.set([0, 0, e.width, e.height]);
        }
        function pn(e, t) {
          var r = e.context,
            n = r.gl,
            i = E.unblended,
            o = new me(n.LEQUAL, me.ReadWrite, [0, 1]),
            a = t.getTerrainMesh(),
            s = t.getCoordsTexture(),
            l = t.sourceCache.getRenderableTiles(),
            c = e.useProgram("terrainCoords");
          r.bindFramebuffer.set(t.getFramebuffer("coords").framebuffer), r.viewport.set([0, 0, e.width / devicePixelRatio, e.height / devicePixelRatio]), r.clear({
            color: de.Color.transparent,
            depth: 1
          }), t.coordsIndex = [];
          for (const d of l) {
            var u = t.getTerrainData(d.tileID),
              h = (r.activeTexture.set(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, s.texture), e.transform.calculatePosMatrix(d.tileID.toUnwrapped())),
              h = {
                u_matrix: h,
                u_terrain_coords_id: (255 - t.coordsIndex.length) / 255,
                u_texture: 0,
                u_ele_delta: t.getMeshFrameDelta(e.transform.zoom)
              };
            c.draw(r, n.TRIANGLES, o, R.disabled, i, F.backCCW, h, u, "terrain", a.vertexBuffer, a.indexBuffer, a.segments), t.coordsIndex.push(d.tileID.key);
          }
          r.bindFramebuffer.set(null), r.viewport.set([0, 0, e.width, e.height]);
        }
        function fn(e, t, r) {
          var n = e.context,
            i = n.gl,
            o = e.colorModeForRenderPass(),
            a = new me(i.LEQUAL, me.ReadWrite, e.depthRangeFor3D),
            s = e.useProgram("terrain"),
            l = t.getTerrainMesh();
          n.bindFramebuffer.set(null), n.viewport.set([0, 0, e.width, e.height]);
          for (const h of r) {
            var c = e.renderToTexture.getTexture(h),
              u = t.getTerrainData(h.tileID),
              c = (n.activeTexture.set(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, c.texture), e.transform.calculatePosMatrix(h.tileID.toUnwrapped())),
              c = {
                u_matrix: c,
                u_texture: 0,
                u_ele_delta: t.getMeshFrameDelta(e.transform.zoom)
              };
            s.draw(n, i.TRIANGLES, a, R.disabled, o, F.backCCW, c, u, "terrain", l.vertexBuffer, l.indexBuffer, l.segments);
          }
        }
        class _n {
          constructor(e, t) {
            this.context = new kr(e), this.transform = t, this._tileTextures = {}, this.terrainFacilitator = {
              dirty: !0,
              matrix: de.create(),
              renderTime: 0
            }, this.setup(), this.numSublayers = N.maxUnderzooming + N.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new _t();
          }
          resize(e, t, r) {
            if (this.width = Math.floor(e * r), this.height = Math.floor(t * r), this.pixelRatio = r, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const n of this.style._order) this.style._layers[n].resize();
          }
          setup() {
            var e = this.context,
              t = new de.PosArray(),
              t = (t.emplaceBack(0, 0), t.emplaceBack(de.EXTENT, 0), t.emplaceBack(0, de.EXTENT), t.emplaceBack(de.EXTENT, de.EXTENT), this.tileExtentBuffer = e.createVertexBuffer(t, Et.members), this.tileExtentSegments = de.SegmentVector.simpleSegment(0, 0, 4, 2), new de.PosArray()),
              t = (t.emplaceBack(0, 0), t.emplaceBack(de.EXTENT, 0), t.emplaceBack(0, de.EXTENT), t.emplaceBack(de.EXTENT, de.EXTENT), this.debugBuffer = e.createVertexBuffer(t, Et.members), this.debugSegments = de.SegmentVector.simpleSegment(0, 0, 4, 5), new de.RasterBoundsArray()),
              t = (t.emplaceBack(0, 0, 0, 0), t.emplaceBack(de.EXTENT, 0, de.EXTENT, 0), t.emplaceBack(0, de.EXTENT, 0, de.EXTENT), t.emplaceBack(de.EXTENT, de.EXTENT, de.EXTENT, de.EXTENT), this.rasterBoundsBuffer = e.createVertexBuffer(t, ie.members), this.rasterBoundsSegments = de.SegmentVector.simpleSegment(0, 0, 4, 2), new de.PosArray()),
              t = (t.emplaceBack(0, 0), t.emplaceBack(1, 0), t.emplaceBack(0, 1), t.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(t, Et.members), this.viewportSegments = de.SegmentVector.simpleSegment(0, 0, 4, 2), new de.LineStripIndexArray()),
              t = (t.emplaceBack(0), t.emplaceBack(1), t.emplaceBack(3), t.emplaceBack(2), t.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(t), new de.TriangleIndexArray()),
              e = (t.emplaceBack(0, 1, 2), t.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(t), this.context.gl);
            this.stencilClearMode = new R({
              func: e.ALWAYS,
              mask: 0
            }, 0, 255, e.ZERO, e.ZERO, e.ZERO);
          }
          clearStencil() {
            var e = this.context,
              t = e.gl,
              r = (this.nextStencilID = 1, this.currentStencilSource = void 0, de.create());
            de.ortho(r, 0, this.width, this.height, 0, 0, 1), de.scale(r, r, [t.drawingBufferWidth, t.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e, t.TRIANGLES, me.disabled, this.stencilClearMode, E.disabled, F.disabled, kt(r), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(e, t) {
            if (this.currentStencilSource !== e.source && e.isTileClipped() && t && t.length) {
              this.currentStencilSource = e.source;
              var r = this.context,
                n = r.gl,
                i = (256 < this.nextStencilID + t.length && this.clearStencil(), r.setColorMode(E.disabled), r.setDepthMode(me.disabled), this.useProgram("clippingMask"));
              this._tileClippingMaskIDs = {};
              for (const s of t) {
                var o = this._tileClippingMaskIDs[s.key] = this.nextStencilID++,
                  a = this.style.map.terrain && this.style.map.terrain.getTerrainData(s);
                i.draw(r, n.TRIANGLES, me.disabled, new R({
                  func: n.ALWAYS,
                  mask: 0
                }, o, 255, n.KEEP, n.KEEP, n.REPLACE), E.disabled, F.disabled, kt(s.posMatrix), a, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
              }
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, 256 < this.nextStencilID + 1 && this.clearStencil();
            var e = this.nextStencilID++,
              t = this.context.gl;
            return new R({
              func: t.NOTEQUAL,
              mask: 255
            }, e, 255, t.KEEP, t.KEEP, t.REPLACE);
          }
          stencilModeForClipping(e) {
            var t = this.context.gl;
            return new R({
              func: t.EQUAL,
              mask: 255
            }, this._tileClippingMaskIDs[e.key], 0, t.KEEP, t.KEEP, t.REPLACE);
          }
          stencilConfigForOverlap(e) {
            var t = this.context.gl,
              e = e.sort((e, t) => t.overscaledZ - e.overscaledZ),
              r = e[e.length - 1].overscaledZ,
              n = e[0].overscaledZ - r + 1;
            if (1 < n) {
              this.currentStencilSource = void 0, 256 < this.nextStencilID + n && this.clearStencil();
              var i = {};
              for (let e = 0; e < n; e++) i[e + r] = new R({
                func: t.GEQUAL,
                mask: 255
              }, e + this.nextStencilID, 255, t.KEEP, t.KEEP, t.REPLACE);
              return this.nextStencilID += n, [i, e];
            }
            return [{
              [r]: R.disabled
            }, e];
          }
          colorModeForRenderPass() {
            var e = this.context.gl;
            return this._showOverdrawInspector ? (new E([e.CONSTANT_COLOR, e.ONE], new de.Color(1 / 8, 1 / 8, 1 / 8, 0), [!0, !0, !0, !0])) : "opaque" === this.renderPass ? E.unblended : E.alphaBlended;
          }
          depthModeForSublayer(e, t, r) {
            return this.opaquePassEnabledForLayer() ? (e = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon, new me(r || this.context.gl.LEQUAL, t, [e, e])) : me.disabled;
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e, t) {
            this.style = e, this.options = t, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(de.browser.now()), this.imageManager.beginFrame();
            var r,
              n = this.style._order,
              i = this.style.sourceCaches,
              o = {},
              a = {},
              s = {};
            for (const y in i) {
              var l = i[y];
              l.used && l.prepare(this.context), o[y] = l.getVisibleCoordinates(), a[y] = o[y].slice().reverse(), s[y] = l.getVisibleCoordinates(!0).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let e = 0; e < n.length; e++) {
              var c = n[e];
              if (this.style._layers[c].is3D()) {
                this.opaquePassCutoff = e;
                break;
              }
            }
            this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0, r = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime), !this.terrainFacilitator.dirty && de.equals(this.terrainFacilitator.matrix, this.transform.projMatrix) && !r.length || (de.copy(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, dn(this, this.style.map.terrain), pn(this, this.style.map.terrain))), this.renderPass = "offscreen";
            for (const v of n) {
              var u,
                h = this.style._layers[v];
              h.hasOffscreenPass() && !h.isHidden(this.transform.zoom) && (u = a[h.source], "custom" === h.type || u.length) && this.renderLayer(this, i[h.source], h, u);
            }
            if (this.context.bindFramebuffer.set(null), this.context.clear({
              color: t.showOverdrawInspector ? de.Color.black : de.Color.transparent,
              depth: 1
            }), this.clearStencil(), this._showOverdrawInspector = t.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = n.length - 1; 0 <= this.currentLayer; this.currentLayer--) {
              var d = this.style._layers[n[this.currentLayer]],
                p = i[d.source],
                f = o[d.source];
              this._renderTileClippingMasks(d, f), this.renderLayer(this, p, d, f);
            }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < n.length; this.currentLayer++) {
              var _,
                m = this.style._layers[n[this.currentLayer]],
                g = i[m.source];
              this.renderToTexture && this.renderToTexture.renderLayer(m) || (_ = ("symbol" === m.type ? s : a)[m.source], this._renderTileClippingMasks(m, o[m.source]), this.renderLayer(this, g, m, _));
            }
            this.options.showTileBoundaries && (r = un(this.style, this.transform.zoom)) && cn(this, r, r.getVisibleCoordinates()), this.options.showPadding && on(this), this.context.setDefault();
          }
          renderLayer(e, t, r, n) {
            if (!r.isHidden(this.transform.zoom) && ("background" === r.type || "custom" === r.type || (n || []).length)) switch (this.id = r.id, r.type) {
              case "symbol":
                Br(e, t, r, n, this.style.placement.variableOffsets);
                break;
              case "circle":
                Yr(e, t, r, n);
                break;
              case "heatmap":
                Hr(e, t, r, n);
                break;
              case "line":
                jr(e, t, r, n);
                break;
              case "fill":
                qr(e, t, r, n);
                break;
              case "fill-extrusion":
                Kr(e, t, r, n);
                break;
              case "hillshade":
                Zr(e, t, r, n);
                break;
              case "raster":
                Xr(e, t, r, n);
                break;
              case "background":
                Jr(e, 0, r, n);
                break;
              case "custom":
                hn(e, 0, r);
            }
          }
          translatePosMatrix(e, t, r, n, i) {
            var o;
            return r[0] || r[1] ? ((n = i ? "map" === n ? this.transform.angle : 0 : "viewport" === n ? -this.transform.angle : 0) && (o = Math.sin(n), n = Math.cos(n), r = [r[0] * n - r[1] * o, r[0] * o + r[1] * n]), o = [i ? r[0] : _e(t, r[0], this.transform.zoom), i ? r[1] : _e(t, r[1], this.transform.zoom), 0], n = new Float32Array(16), de.translate(n, e, o), n) : e;
          }
          saveTileTexture(e) {
            var t = this._tileTextures[e.size[0]];
            t ? t.push(e) : this._tileTextures[e.size[0]] = [e];
          }
          getTileTexture(e) {
            e = this._tileTextures[e];
            return e && 0 < e.length ? e.pop() : null;
          }
          isPatternMissing(e) {
            var t;
            return !(!e || e.from && e.to && (t = this.imageManager.getPattern(e.from.toString()), e = this.imageManager.getPattern(e.to.toString()), t) && e);
          }
          useProgram(e, t) {
            this.cache = this.cache || {};
            var r = e + (t ? t.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
            return this.cache[r] || (this.cache[r] = new St(this.context, g[e], t, Vt[e], this._showOverdrawInspector, this.style.map.terrain)), this.cache[r];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            var e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            var e;
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, e = this.context.gl, this.debugOverlayTexture = new U(this.context, this.debugOverlayCanvas, e.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            var {
              drawingBufferWidth: e,
              drawingBufferHeight: t
            } = this.context.gl;
            return this.width !== e || this.height !== t;
          }
        }
        class mn {
          constructor(e, t) {
            this.points = e, this.planes = t;
          }
          static fromInvProjectionMatrix(r, n, e) {
            const i = Math.pow(2, e),
              o = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(e => {
                var t = 1 / (e = de.transformMat4([], e, r))[3] / n * i;
                return de.mul$1(e, e, [t, t, 1 / e[3], t]);
              });
            e = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(e => {
              var t = de.sub([], o[e[0]], o[e[1]]),
                r = de.sub([], o[e[2]], o[e[1]]),
                t = de.normalize([], de.cross([], t, r)),
                r = -de.dot(t, o[e[1]]);
              return t.concat(r);
            });
            return new mn(o, e);
          }
        }
        class gn {
          constructor(e, t) {
            this.min = e, this.max = t, this.center = de.scale$1([], de.add([], this.min, this.max), .5);
          }
          quadrant(e) {
            var t = [e % 2 == 0, e < 2],
              r = de.clone$2(this.min),
              n = de.clone$2(this.max);
            for (let e = 0; e < t.length; e++) r[e] = (t[e] ? this.min : this.center)[e], n[e] = (t[e] ? this.center : this.max)[e];
            return n[2] = this.max[2], new gn(r, n);
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
          }
          intersects(i) {
            var r = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
            let n = !0;
            for (let e = 0; e < i.planes.length; e++) {
              var o = i.planes[e];
              let t = 0;
              for (let e = 0; e < r.length; e++) 0 <= de.dot$1(o, r[e]) && t++;
              if (0 === t) return 0;
              t !== r.length && (n = !1);
            }
            if (n) return 2;
            for (let n = 0; n < 3; n++) {
              let t = Number.MAX_VALUE,
                r = -Number.MAX_VALUE;
              for (let e = 0; e < i.points.length; e++) {
                var a = i.points[e][n] - this.min[n];
                t = Math.min(t, a), r = Math.max(r, a);
              }
              if (r < 0 || t > this.max[n] - this.min[n]) return 0;
            }
            return 1;
          }
        }
        class yn {
          constructor(e = 0, t = 0, r = 0, n = 0) {
            if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(r) || r < 0 || isNaN(n) || n < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = t, this.left = r, this.right = n;
          }
          interpolate(e, t, r) {
            return null != t.top && null != e.top && (this.top = de.interpolate.number(e.top, t.top, r)), null != t.bottom && null != e.bottom && (this.bottom = de.interpolate.number(e.bottom, t.bottom, r)), null != t.left && null != e.left && (this.left = de.interpolate.number(e.left, t.left, r)), null != t.right && null != e.right && (this.right = de.interpolate.number(e.right, t.right, r)), this;
          }
          getCenter(e, t) {
            e = de.clamp((this.left + e - this.right) / 2, 0, e), t = de.clamp((this.top + t - this.bottom) / 2, 0, t);
            return new de.Point(e, t);
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
          }
          clone() {
            return new yn(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right
            };
          }
        }
        class vn {
          constructor(e, t, r, n, i) {
            this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === i || !!i, this._minZoom = e || 0, this._maxZoom = t || 22, this._minPitch = null == r ? 0 : r, this._maxPitch = null == n ? 60 : n, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new de.LngLat(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new yn(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._minEleveationForCurrentTile = 0;
          }
          clone() {
            var e = new vn(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
            return e.apply(this), e;
          }
          apply(e) {
            this.tileSize = e.tileSize, this.latRange = e.latRange, this.width = e.width, this.height = e.height, this._center = e._center, this._elevation = e._elevation, this._minEleveationForCurrentTile = e._minEleveationForCurrentTile, this.zoom = e.zoom, this.angle = e.angle, this._fov = e._fov, this._pitch = e._pitch, this._unmodified = e._unmodified, this._edgeInsets = e._edgeInsets.clone(), this._calcMatrices();
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          set renderWorldCopies(e) {
            void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new de.Point(this.width, this.height);
          }
          get bearing() {
            return -this.angle / Math.PI * 180;
          }
          set bearing(e) {
            e = -de.wrap(e, -180, 180) * Math.PI / 180;
            this.angle !== e && (this._unmodified = !1, this.angle = e, this._calcMatrices(), this.rotationMatrix = de.create$2(), de.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(e) {
            e = de.clamp(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== e && (this._unmodified = !1, this._pitch = e, this._calcMatrices());
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          set fov(e) {
            e = Math.max(.01, Math.min(60, e)), this._fov !== e && (this._unmodified = !1, this._fov = e / 180 * Math.PI, this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(e) {
            e = Math.min(Math.max(e, this.minZoom), this.maxZoom);
            this._zoom !== e && (this._unmodified = !1, this._zoom = e, this.tileZoom = Math.max(0, Math.floor(e)), this.scale = this.zoomScale(e), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          set center(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(e) {
            e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e);
          }
          interpolatePadding(e, t, r) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, t, r), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(e) {
            e = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
            return Math.max(0, e);
          }
          getVisibleUnwrappedCoordinates(t) {
            var r = [new de.UnwrappedTileID(0, t)];
            if (this._renderWorldCopies) {
              var e = this.pointCoordinate(new de.Point(0, 0)),
                n = this.pointCoordinate(new de.Point(this.width, 0)),
                i = this.pointCoordinate(new de.Point(this.width, this.height)),
                o = this.pointCoordinate(new de.Point(0, this.height)),
                a = Math.floor(Math.min(e.x, n.x, i.x, o.x)),
                s = Math.floor(Math.max(e.x, n.x, i.x, o.x));
              for (let e = a - 1; e <= s + 1; e++) 0 !== e && r.push(new de.UnwrappedTileID(e, t));
            }
            return r;
          }
          coveringTiles(n) {
            let e = this.coveringZoomLevel(n);
            var t = e;
            if (void 0 !== n.minzoom && e < n.minzoom) return [];
            void 0 !== n.maxzoom && e > n.maxzoom && (e = n.maxzoom);
            var r = this.pointCoordinate(this.getCameraPoint()),
              i = de.MercatorCoordinate.fromLngLat(this.center);
            const o = Math.pow(2, e);
            var a = [o * r.x, o * r.y, 0],
              s = [o * i.x, o * i.y, 0],
              l = mn.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, e);
            let c = n.minzoom || 0;
            !n.terrain && this.pitch <= 60 && this._edgeInsets.top < .1 && (c = e);
            var u = n.terrain ? 2 / Math.min(this.tileSize, n.tileSize) * this.tileSize : 3,
              h = e => ({
                aabb: new gn([e * o, 0, 0], [(e + 1) * o, o, 0]),
                zoom: 0,
                x: 0,
                y: 0,
                wrap: e,
                fullyVisible: !1
              }),
              d = [],
              p = [],
              f = e,
              _ = n.reparseOverscaled ? t : e;
            if (this._renderWorldCopies) for (let e = 1; e <= 3; e++) d.push(h(-e)), d.push(h(e));
            for (d.push(h(0)); 0 < d.length;) {
              var m = d.pop(),
                g = m.x,
                y = m.y;
              let r = m.fullyVisible;
              if (!r) {
                var v = m.aabb.intersects(l);
                if (0 === v) continue;
                r = 2 === v;
              }
              var v = n.terrain ? a : s,
                E = m.aabb.distanceX(v),
                b = m.aabb.distanceY(v),
                E = Math.max(Math.abs(E), Math.abs(b)),
                b = u + (1 << f - m.zoom) - 2;
              if (m.zoom === f || b < E && m.zoom >= c) {
                b = f - m.zoom, E = a[0] - .5 - (g << b), b = a[1] - .5 - (y << b);
                p.push({
                  tileID: new de.OverscaledTileID(m.zoom === f ? _ : m.zoom, m.wrap, m.zoom, g, y),
                  distanceSq: de.sqrLen([s[0] - .5 - g, s[1] - .5 - y]),
                  tileDistanceToCamera: Math.sqrt(E * E + b * b)
                });
              } else for (let t = 0; t < 4; t++) {
                var w,
                  T,
                  S = (g << 1) + t % 2,
                  x = (y << 1) + (t >> 1),
                  C = m.zoom + 1;
                let e = m.aabb.quadrant(t);
                n.terrain && (T = new de.OverscaledTileID(C, m.wrap, C, S, x), w = null != (w = (T = n.terrain.getMinMaxElevation(T)).minElevation) ? w : this.elevation, T = null != (T = T.maxElevation) ? T : this.elevation, e = new gn([e.min[0], e.min[1], w], [e.max[0], e.max[1], T])), d.push({
                  aabb: e,
                  zoom: C,
                  x: S,
                  y: x,
                  wrap: m.wrap,
                  fullyVisible: r
                });
              }
            }
            return p.sort((e, t) => e.distanceSq - t.distanceSq).map(e => e.tileID);
          }
          resize(e, t) {
            this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(e) {
            return Math.pow(2, e);
          }
          scaleZoom(e) {
            return Math.log(e) / Math.LN2;
          }
          project(e) {
            var t = de.clamp(e.lat, -this.maxValidLatitude, this.maxValidLatitude);
            return new de.Point(de.mercatorXfromLng(e.lng) * this.worldSize, de.mercatorYfromLat(t) * this.worldSize);
          }
          unproject(e) {
            return new de.MercatorCoordinate(e.x / this.worldSize, e.y / this.worldSize).toLngLat();
          }
          get point() {
            return this.project(this.center);
          }
          getCameraPosition() {
            return {
              lngLat: this.pointLocation(this.getCameraPoint()),
              altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation
            };
          }
          recalculateZoom(e) {
            var t,
              r,
              n,
              i,
              o = this.pointLocation(this.centerPoint, e),
              e = e.getElevationForLngLatZoom(o, this.tileZoom);
            this.elevation - e && (r = this.getCameraPosition(), r = de.MercatorCoordinate.fromLngLat(r.lngLat, r.altitude), n = de.MercatorCoordinate.fromLngLat(o, e), i = r.x - n.x, t = r.y - n.y, r = r.z - n.z, n = Math.sqrt(i * i + t * t + r * r), i = this.scaleZoom(this.cameraToCenterDistance / n / this.tileSize), this._elevation = e, this._center = o, this.zoom = i);
          }
          setLocationAtPoint(e, t) {
            var t = this.pointCoordinate(t),
              r = this.pointCoordinate(this.centerPoint),
              e = this.locationCoordinate(e),
              e = new de.MercatorCoordinate(e.x - (t.x - r.x), e.y - (t.y - r.y));
            this.center = this.coordinateLocation(e), this._renderWorldCopies && (this.center = this.center.wrap());
          }
          locationPoint(e, t) {
            return t ? this.coordinatePoint(this.locationCoordinate(e), t.getElevationForLngLatZoom(e, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(e));
          }
          pointLocation(e, t) {
            return this.coordinateLocation(this.pointCoordinate(e, t));
          }
          locationCoordinate(e) {
            return de.MercatorCoordinate.fromLngLat(e);
          }
          coordinateLocation(e) {
            return e && e.toLngLat();
          }
          pointCoordinate(e, t) {
            if (t) {
              t = t.pointCoordinate(e);
              if (null != t) return t;
            }
            var t = [e.x, e.y, 0, 1],
              e = [e.x, e.y, 1, 1],
              r = (de.transformMat4(t, t, this.pixelMatrixInverse), de.transformMat4(e, e, this.pixelMatrixInverse), t[3]),
              n = e[3],
              i = t[1] / r,
              o = e[1] / n,
              a = t[2] / r,
              s = e[2] / n,
              s = a == s ? 0 : (0 - a) / (s - a);
            return new de.MercatorCoordinate(de.interpolate.number(t[0] / r, e[0] / n, s) / this.worldSize, de.interpolate.number(i, o, s) / this.worldSize);
          }
          coordinatePoint(e, t = 0, r = this.pixelMatrix) {
            e = [e.x * this.worldSize, e.y * this.worldSize, t, 1];
            return de.transformMat4(e, e, r), new de.Point(e[0] / e[3], e[1] / e[3]);
          }
          getBounds() {
            var e = Math.max(0, this.height / 2 - this.getHorizon());
            return new a().extend(this.pointLocation(new de.Point(0, e))).extend(this.pointLocation(new de.Point(this.width, e))).extend(this.pointLocation(new de.Point(this.width, this.height))).extend(this.pointLocation(new de.Point(0, this.height)));
          }
          getMaxBounds() {
            return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new a([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
          }
          getHorizon() {
            return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * .85;
          }
          setMaxBounds(e) {
            e ? (this.lngRange = [e.getWest(), e.getEast()], this.latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
          }
          calculatePosMatrix(e, t = !1) {
            var r,
              n,
              i,
              o = e.key,
              a = t ? this._alignedPosMatrixCache : this._posMatrixCache;
            return a[o] || (r = e.canonical, n = this.worldSize / this.zoomScale(r.z), e = r.x + Math.pow(2, r.z) * e.wrap, i = de.identity(new Float64Array(16)), de.translate(i, i, [e * n, r.y * n, 0]), de.scale(i, i, [n / de.EXTENT, n / de.EXTENT, 1]), de.multiply(i, t ? this.alignedProjMatrix : this.projMatrix, i), a[o] = new Float32Array(i)), a[o];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          _constrain() {
            if (this.center && this.width && this.height && !this._constraining) {
              this._constraining = !0;
              let e = -90,
                t = 90,
                r = -180,
                n = 180,
                i,
                o,
                a,
                s;
              var l,
                c = this.size,
                u = this._unmodified,
                h = (this.latRange && (h = this.latRange, e = de.mercatorYfromLat(h[1]) * this.worldSize, t = de.mercatorYfromLat(h[0]) * this.worldSize, i = t - e < c.y ? c.y / (t - e) : 0), this.lngRange && (h = this.lngRange, r = de.wrap(de.mercatorXfromLng(h[0]) * this.worldSize, 0, this.worldSize), (n = de.wrap(de.mercatorXfromLng(h[1]) * this.worldSize, 0, this.worldSize)) < r && (n += this.worldSize), o = n - r < c.x ? c.x / (n - r) : 0), this.point),
                d = Math.max(o || 0, i || 0);
              d ? (this.center = this.unproject(new de.Point(o ? (n + r) / 2 : h.x, i ? (t + e) / 2 : h.y)), this.zoom += this.scaleZoom(d)) : (this.latRange && ((d = h.y) - (l = c.y / 2) < e && (s = e + l), d + l > t) && (s = t - l), void 0 === (a = this.lngRange && (d = (r + n) / 2, (l = de.wrap(h.x, d - this.worldSize / 2, d + this.worldSize / 2)) - (d = c.x / 2) < r && (a = r + d), l + d > n) ? n - d : a) && void 0 === s || (this.center = this.unproject(new de.Point(void 0 !== a ? a : h.x, void 0 !== s ? s : h.y)).wrap())), this._unmodified = u, this._constraining = !1;
            }
          }
          _calcMatrices() {
            if (this.height) {
              var t = this._fov / 2,
                r = this.centerOffset,
                n = this.point.x,
                i = this.point.y;
              this.cameraToCenterDistance = .5 / Math.tan(t) * this.height, this._pixelPerMeter = de.mercatorZfromAltitude(1, this.center.lat) * this.worldSize;
              let e = de.identity(new Float64Array(16));
              de.scale(e, e, [this.width / 2, -this.height / 2, 1]), de.translate(e, e, [1, -1, 0]), this.labelPlaneMatrix = e, e = de.identity(new Float64Array(16)), de.scale(e, e, [1, -1, 1]), de.translate(e, e, [-1, -1, 0]), de.scale(e, e, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = e;
              var t = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch),
                o = Math.min(this.elevation, this._minEleveationForCurrentTile),
                a = t - o * this._pixelPerMeter / Math.cos(this._pitch),
                o = o < 0 ? a : t,
                a = Math.PI / 2 + this._pitch,
                t = this._fov * (.5 + r.y / this.height),
                t = Math.sin(t) * o / Math.sin(de.clamp(Math.PI - a - t, .01, Math.PI - .01)),
                s = this.getHorizon(),
                s = 2 * Math.atan(s / this.cameraToCenterDistance) * (.5 + r.y / (2 * s)),
                a = Math.sin(s) * o / Math.sin(de.clamp(Math.PI - a - s, .01, Math.PI - .01)),
                s = Math.min(t, a),
                t = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * s + o),
                a = this.height / 50,
                s = (e = new Float64Array(16), de.perspective(e, this._fov, this.width / this.height, a, t), e[8] = 2 * -r.x / this.width, e[9] = 2 * r.y / this.height, de.scale(e, e, [1, -1, 1]), de.translate(e, e, [0, 0, -this.cameraToCenterDistance]), de.rotateX(e, e, this._pitch), de.rotateZ(e, e, this.angle), de.translate(e, e, [-n, -i, 0]), this.mercatorMatrix = de.scale([], e, [this.worldSize, this.worldSize, this.worldSize]), de.scale(e, e, [1, 1, this._pixelPerMeter]), this.pixelMatrix = de.multiply(new Float64Array(16), this.labelPlaneMatrix, e), de.translate(e, e, [0, 0, -this.elevation]), this.projMatrix = e, this.invProjMatrix = de.invert([], e), this.pixelMatrix3D = de.multiply(new Float64Array(16), this.labelPlaneMatrix, e), this.width % 2 / 2),
                o = this.height % 2 / 2,
                a = Math.cos(this.angle),
                t = Math.sin(this.angle),
                r = n - Math.round(n) + a * s + t * o,
                n = i - Math.round(i) + a * o + t * s,
                i = new Float64Array(e);
              if (de.translate(i, i, [.5 < r ? r - 1 : r, .5 < n ? n - 1 : n, 0]), this.alignedProjMatrix = i, !(e = de.invert(new Float64Array(16), this.pixelMatrix))) throw new Error("failed to invert matrix");
              this.pixelMatrixInverse = e, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
            }
          }
          maxPitchScaleFactor() {
            var e;
            return this.pixelMatrixInverse ? (e = [(e = this.pointCoordinate(new de.Point(0, 0))).x * this.worldSize, e.y * this.worldSize, 0, 1], de.transformMat4(e, e, this.pixelMatrix)[3] / this.cameraToCenterDistance) : 1;
          }
          getCameraPoint() {
            var e = this._pitch,
              e = Math.tan(e) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new de.Point(0, e));
          }
          getCameraQueryGeometry(i) {
            var o = this.getCameraPoint();
            if (1 === i.length) return [i[0], o];
            {
              let e = o.x,
                t = o.y,
                r = o.x,
                n = o.y;
              for (const a of i) e = Math.min(e, a.x), t = Math.min(t, a.y), r = Math.max(r, a.x), n = Math.max(n, a.y);
              return [new de.Point(e, t), new de.Point(r, t), new de.Point(r, n), new de.Point(e, n), new de.Point(e, t)];
            }
          }
        }
        function En(e, t) {
          let r = !1,
            n = null,
            i,
            o;
          const a = () => {
            n = null, r && (e.apply(i, o), n = setTimeout(a, t), r = !1);
          };
          return (...e) => (r = !0, i = this, o = e, n || a(), n);
        }
        class bn {
          constructor(e) {
            this._getCurrentHash = () => {
              var e = window.location.hash.replace("#", "");
              if (this._hashName) {
                let t;
                return e.split("&").map(e => e.split("=")).forEach(e => {
                  e[0] === this._hashName && (t = e);
                }), (t && t[1] || "").split("/");
              }
              return e.split("/");
            }, this._onHashChange = () => {
              var e,
                t = this._getCurrentHash();
              return 3 <= t.length && !t.some(e => isNaN(e)) && (e = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t[3] || 0) : this._map.getBearing(), this._map.jumpTo({
                center: [+t[2], +t[1]],
                zoom: +t[0],
                bearing: e,
                pitch: +(t[4] || 0)
              }), !0);
            }, this._updateHashUnthrottled = () => {
              var e = window.location.href.replace(/(#.+)?$/, this.getHashString());
              try {
                window.history.replaceState(window.history.state, null, e);
              } catch (e) {}
            }, this._updateHash = En(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
          }
          getHashString(e) {
            var t = this._map.getCenter(),
              r = Math.round(100 * this._map.getZoom()) / 100,
              n = Math.ceil((r * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
              n = Math.pow(10, n),
              i = Math.round(t.lng * n) / n,
              t = Math.round(t.lat * n) / n,
              n = this._map.getBearing(),
              o = this._map.getPitch();
            let a = "";
            if (a += e ? `/${i}/${t}/` + r : r + `/${t}/` + i, (n || o) && (a += "/" + Math.round(10 * n) / 10), o && (a += "/" + Math.round(o)), this._hashName) {
              const s = this._hashName;
              let r = !1;
              e = window.location.hash.slice(1).split("&").map(e => {
                var t = e.split("=")[0];
                return t === s ? (r = !0, t + "=" + a) : e;
              }).filter(e => e);
              return r || e.push(s + "=" + a), "#" + e.join("&");
            }
            return "#" + a;
          }
        }
        e = {
          linearity: .3,
          easing: de.bezier(0, 0, .3, 1)
        };
        const wn = de.extend({
            deceleration: 2500,
            maxSpeed: 1400
          }, e),
          Tn = de.extend({
            deceleration: 20,
            maxSpeed: 1400
          }, e),
          Sn = de.extend({
            deceleration: 1e3,
            maxSpeed: 360
          }, e),
          xn = de.extend({
            deceleration: 1e3,
            maxSpeed: 90
          }, e);
        class Cn {
          constructor(e) {
            this._map = e, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({
              time: de.browser.now(),
              settings: e
            });
          }
          _drainInertiaBuffer() {
            for (var e = this._inertiaBuffer, t = de.browser.now(); 0 < e.length && 160 < t - e[0].time;) e.shift();
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) {
              var t,
                r = {
                  zoom: 0,
                  bearing: 0,
                  pitch: 0,
                  pan: new de.Point(0, 0),
                  pinchAround: void 0,
                  around: void 0
                };
              for ({
                settings: t
              } of this._inertiaBuffer) r.zoom += t.zoomDelta || 0, r.bearing += t.bearingDelta || 0, r.pitch += t.pitchDelta || 0, t.panDelta && r.pan._add(t.panDelta), t.around && (r.around = t.around), t.pinchAround && (r.pinchAround = t.pinchAround);
              var n = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
                i = {};
              return r.pan.mag() && (e = In(r.pan.mag(), n, de.extend({}, wn, e || {})), i.offset = r.pan.mult(e.amount / r.pan.mag()), i.center = this._map.transform.center, An(i, e)), r.zoom && (e = In(r.zoom, n, Tn), i.zoom = this._map.transform.zoom + e.amount, An(i, e)), r.bearing && (e = In(r.bearing, n, Sn), i.bearing = this._map.transform.bearing + de.clamp(e.amount, -179, 179), An(i, e)), r.pitch && (e = In(r.pitch, n, xn), i.pitch = this._map.transform.pitch + e.amount, An(i, e)), (i.zoom || i.bearing) && (i.around = (n = void 0 === r.pinchAround ? r.around : r.pinchAround) ? this._map.unproject(n) : this._map.getCenter()), this.clear(), de.extend(i, {
                noMoveStart: !0
              });
            }
          }
        }
        function An(e, t) {
          (!e.duration || e.duration < t.duration) && (e.duration = t.duration, e.easing = t.easing);
        }
        function In(e, t, r) {
          var {
              maxSpeed: n,
              linearity: i,
              deceleration: o
            } = r,
            e = de.clamp(e * i / (t / 1e3), -n, n),
            t = Math.abs(e) / (o * i);
          return {
            easing: r.easing,
            duration: 1e3 * t,
            amount: e * (t / 2)
          };
        }
        class c extends de.Event {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, t, r, n = {}) {
            var i = m.mousePos(t.getCanvasContainer(), r),
              o = t.unproject(i);
            super(e, de.extend({
              point: i,
              lngLat: o,
              originalEvent: r
            }, n)), this._defaultPrevented = !1, this.target = t;
          }
        }
        class Nn extends de.Event {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, t, r) {
            var n = "touchend" === e ? r.changedTouches : r.touches,
              n = m.touchPos(t.getCanvasContainer(), n),
              i = n.map(e => t.unproject(e)),
              o = n.reduce((e, t, r, n) => e.add(t.div(n.length)), new de.Point(0, 0));
            super(e, {
              points: n,
              point: o,
              lngLats: i,
              lngLat: t.unproject(o),
              originalEvent: r
            }), this._defaultPrevented = !1;
          }
        }
        class Pn extends de.Event {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, t, r) {
            super(e, {
              originalEvent: r
            }), this._defaultPrevented = !1;
          }
        }
        class Dn {
          constructor(e, t) {
            this._map = e, this._clickTolerance = t.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e) {
            return this._firePreventable(new Pn(e.type, this._map, e));
          }
          mousedown(e, t) {
            return this._mousedownPos = t, this._firePreventable(new c(e.type, this._map, e));
          }
          mouseup(e) {
            this._map.fire(new c(e.type, this._map, e));
          }
          click(e, t) {
            this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || this._map.fire(new c(e.type, this._map, e));
          }
          dblclick(e) {
            return this._firePreventable(new c(e.type, this._map, e));
          }
          mouseover(e) {
            this._map.fire(new c(e.type, this._map, e));
          }
          mouseout(e) {
            this._map.fire(new c(e.type, this._map, e));
          }
          touchstart(e) {
            return this._firePreventable(new Nn(e.type, this._map, e));
          }
          touchmove(e) {
            this._map.fire(new Nn(e.type, this._map, e));
          }
          touchend(e) {
            this._map.fire(new Nn(e.type, this._map, e));
          }
          touchcancel(e) {
            this._map.fire(new Nn(e.type, this._map, e));
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {}
          disable() {}
        }
        class Rn {
          constructor(e) {
            this._map = e;
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
          }
          mousemove(e) {
            this._map.fire(new c(e.type, this._map, e));
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new c("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new c(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {}
          disable() {}
        }
        class u {
          constructor(e) {
            this._map = e;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat
            };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e) {
            return this.transform.pointLocation(de.Point.convert(e), this._map.terrain);
          }
        }
        class On {
          constructor(e, t) {
            this._map = e, this._tr = new u(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(e, t) {
            this.isEnabled() && e.shiftKey && 0 === e.button && (m.disableDrag(), this._startPos = this._lastPos = t, this._active = !0);
          }
          mousemoveWindow(e, t) {
            var r, n, i;
            !this._active || this._lastPos.equals(t = t) || !this._box && t.dist(this._startPos) < this._clickTolerance || (i = this._startPos, this._lastPos = t, this._box || (this._box = m.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e)), e = Math.min(i.x, t.x), r = Math.max(i.x, t.x), n = Math.min(i.y, t.y), i = Math.max(i.y, t.y), m.setTransform(this._box, `translate(${e}px,${n}px)`), this._box.style.width = r - e + "px", this._box.style.height = i - n + "px");
          }
          mouseupWindow(e, t) {
            if (this._active && 0 === e.button) {
              const r = this._startPos,
                n = t;
              if (this.reset(), m.suppressClick(), r.x !== n.x || r.y !== n.y) return this._map.fire(new de.Event("boxzoomend", {
                originalEvent: e
              })), {
                cameraAnimation: e => e.fitScreenCoordinates(r, n, this._tr.bearing, {
                  linear: !0
                })
              };
              this._fireEvent("boxzoomcancel", e);
            }
          }
          keydown(e) {
            this._active && 27 === e.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e));
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (m.remove(this._box), this._box = null), m.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e, t) {
            return this._map.fire(new de.Event(e, {
              originalEvent: t
            }));
          }
        }
        function Mn(t, r) {
          if (t.length !== r.length) throw new Error(`The number of touches and points are not equal - touches ${t.length}, points ` + r.length);
          var n = {};
          for (let e = 0; e < t.length; e++) n[t[e].identifier] = r[e];
          return n;
        }
        function kn(e) {
          var t = new de.Point(0, 0);
          for (const r of e) t._add(r);
          return t.div(e.length);
        }
        class Ln {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
          }
          touchstart(e, t, r) {
            (this.centroid || r.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = e.timeStamp), r.length === this.numTouches && (this.centroid = kn(t), this.touches = Mn(r, t)));
          }
          touchmove(e, t, r) {
            if (!this.aborted && this.centroid) {
              var n = Mn(r, t);
              for (const a in this.touches) {
                var i = this.touches[a],
                  o = n[a];
                (!o || 30 < o.dist(i)) && (this.aborted = !0);
              }
            }
          }
          touchend(e, t, r) {
            if ((!this.centroid || 500 < e.timeStamp - this.startTime) && (this.aborted = !0), 0 === r.length) {
              e = !this.aborted && this.centroid;
              if (this.reset(), e) return e;
            }
          }
        }
        class Un {
          constructor(e) {
            this.singleTap = new Ln(e), this.numTaps = e.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(e, t, r) {
            this.singleTap.touchstart(e, t, r);
          }
          touchmove(e, t, r) {
            this.singleTap.touchmove(e, t, r);
          }
          touchend(e, t, r) {
            t = this.singleTap.touchend(e, t, r);
            if (t) {
              var r = e.timeStamp - this.lastTime < 500,
                n = !this.lastTap || this.lastTap.dist(t) < 30;
              if (r && n || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = t, this.count === this.numTaps) return this.reset(), t;
            }
          }
        }
        class Fn {
          constructor(e) {
            this._tr = new u(e), this._zoomIn = new Un({
              numTouches: 1,
              numTaps: 2
            }), this._zoomOut = new Un({
              numTouches: 2,
              numTaps: 1
            }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e, t, r) {
            this._zoomIn.touchstart(e, t, r), this._zoomOut.touchstart(e, t, r);
          }
          touchmove(e, t, r) {
            this._zoomIn.touchmove(e, t, r), this._zoomOut.touchmove(e, t, r);
          }
          touchend(t, e, r) {
            const n = this._zoomIn.touchend(t, e, r),
              i = this._zoomOut.touchend(t, e, r),
              o = this._tr;
            return n ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), {
              cameraAnimation: e => e.easeTo({
                duration: 300,
                zoom: o.zoom + 1,
                around: o.unproject(n)
              }, {
                originalEvent: t
              })
            }) : i ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), {
              cameraAnimation: e => e.easeTo({
                duration: 300,
                zoom: o.zoom - 1,
                around: o.unproject(i)
              }, {
                originalEvent: t
              })
            }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class h {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e);
          }
          _move(...e) {
            e = this._moveFunction(...e);
            if (e.bearingDelta || e.pitchDelta || e.around || e.panDelta) return this._active = !0, e;
          }
          dragStart(e, t) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = t.length ? t[0] : t, this._activateOnStart) && this._lastPoint && (this._active = !0);
          }
          dragMove(e, t) {
            if (this.isEnabled()) {
              var r = this._lastPoint;
              if (r) if (e.preventDefault(), this._moveStateManager.isValidMoveEvent(e)) {
                t = t.length ? t[0] : t;
                if (this._moved || !(t.dist(r) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t, this._move(r, t);
              } else this.reset(e);
            }
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && m.suppressClick(), this.reset(e));
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Bn = {
          [0]: 1,
          2: 2
        };
        function $n(e, t) {
          t = Bn[t];
          return void 0 === e.buttons || (e.buttons & t) !== t;
        }
        class zn {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent;
          }
          startMove(e) {
            e = m.mouseButton(e);
            this._eventButton = e;
          }
          endMove(e) {
            delete this._eventButton;
          }
          isValidStartEvent(e) {
            return this._correctEvent(e);
          }
          isValidMoveEvent(e) {
            return !$n(e, this._eventButton);
          }
          isValidEndEvent(e) {
            return m.mouseButton(e) === this._eventButton;
          }
        }
        class Yn {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(e) {
            return 1 === e.targetTouches.length;
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(e) {
            e = e.targetTouches[0].identifier;
            this._firstTouch = e;
          }
          endMove(e) {
            delete this._firstTouch;
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e);
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
        }
        const Hn = e => {
            e.mousedown = e.dragStart, e.mousemoveWindow = e.dragMove, e.mouseup = e.dragEnd, e.contextmenu = function (e) {
              e.preventDefault();
            };
          },
          jn = ({
            enable: e,
            clickTolerance: t
          }) => {
            var r = new zn({
              checkCorrectEvent: e => 0 === m.mouseButton(e) && !e.ctrlKey
            });
            return new h({
              clickTolerance: t,
              move: (e, t) => ({
                around: t,
                panDelta: t.sub(e)
              }),
              activateOnStart: !0,
              moveStateManager: r,
              enable: e,
              assignEvents: Hn
            });
          },
          Gn = ({
            enable: e,
            clickTolerance: t,
            bearingDegreesPerPixelMoved: r = .8
          }) => {
            var n = new zn({
              checkCorrectEvent: e => 0 === m.mouseButton(e) && e.ctrlKey || 2 === m.mouseButton(e)
            });
            return new h({
              clickTolerance: t,
              move: (e, t) => ({
                bearingDelta: (t.x - e.x) * r
              }),
              moveStateManager: n,
              enable: e,
              assignEvents: Hn
            });
          },
          qn = ({
            enable: e,
            clickTolerance: t,
            pitchDegreesPerPixelMoved: r = -.5
          }) => {
            var n = new zn({
              checkCorrectEvent: e => 0 === m.mouseButton(e) && e.ctrlKey || 2 === m.mouseButton(e)
            });
            return new h({
              clickTolerance: t,
              move: (e, t) => ({
                pitchDelta: (t.y - e.y) * r
              }),
              moveStateManager: n,
              enable: e,
              assignEvents: Hn
            });
          };
        class Vn {
          constructor(e, t) {
            this._minTouches = e.cooperativeGestures ? 2 : 1, this._clickTolerance = e.clickTolerance || 1, this._map = t, this.reset();
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new de.Point(0, 0), setTimeout(() => {
              this._cancelCooperativeMessage = !1;
            }, 200);
          }
          touchstart(e, t, r) {
            return this._calculateTransform(e, t, r);
          }
          touchmove(e, t, r) {
            if (this._map._cooperativeGestures && (2 === this._minTouches && r.length < 2 && !this._cancelCooperativeMessage ? this._map._onCooperativeGesture(e, !1, r.length) : this._cancelCooperativeMessage || (this._cancelCooperativeMessage = !0)), this._active && !(r.length < this._minTouches)) return e.preventDefault(), this._calculateTransform(e, t, r);
          }
          touchend(e, t, r) {
            this._calculateTransform(e, t, r), this._active && r.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e, t, r) {
            0 < r.length && (this._active = !0);
            var n = Mn(r, t),
              i = new de.Point(0, 0),
              o = new de.Point(0, 0);
            let a = 0;
            for (const c in n) {
              var s = n[c],
                l = this._touches[c];
              l && (i._add(s), o._add(s.sub(l)), a++, n[c] = s);
            }
            if (this._touches = n, !(a < this._minTouches) && o.mag()) {
              r = o.div(a);
              if (this._sum._add(r), !(this._sum.mag() < this._clickTolerance)) return {
                around: i.div(a),
                panDelta: r
              };
            }
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Kn {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches;
          }
          touchstart(e, t, r) {
            this._firstTwoTouches || r.length < 2 || (this._firstTwoTouches = [r[0].identifier, r[1].identifier], this._start([t[0], t[1]]));
          }
          touchmove(e, t, r) {
            if (this._firstTwoTouches) {
              e.preventDefault();
              var [n, i] = this._firstTwoTouches,
                n = Wn(r, t, n),
                r = Wn(r, t, i);
              if (n && r) return t = this._aroundCenter ? null : n.add(r).div(2), this._move([n, r], t, e);
            }
          }
          touchend(e, t, r) {
            var n, i;
            this._firstTwoTouches && ([i, n] = this._firstTwoTouches, i = Wn(r, t, i), r = Wn(r, t, n), i && r || (this._active && m.suppressClick(), this.reset()));
          }
          touchcancel() {
            this.reset();
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && "center" === e.around;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function Wn(t, r, n) {
          for (let e = 0; e < t.length; e++) if (t[e].identifier === n) return r[e];
        }
        function Zn(e, t) {
          return Math.log(e / t) / Math.LN2;
        }
        class Xn extends Kn {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1]);
          }
          _move(e, t) {
            var r = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Zn(this._distance, this._startDistance)) < .1)) return this._active = !0, {
              zoomDelta: Zn(this._distance, r),
              pinchAround: t
            };
          }
        }
        function Jn(e, t) {
          return 180 * e.angleWith(t) / Math.PI;
        }
        class Qn extends Kn {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
          }
          _move(e, t) {
            var r = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
              bearingDelta: Jn(this._vector, r),
              pinchAround: t
            };
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            var t = 25 / (Math.PI * this._minDiameter) * 360,
              e = Jn(e, this._startVector);
            return Math.abs(e) < t;
          }
        }
        function ei(e) {
          return Math.abs(e.y) > Math.abs(e.x);
        }
        class ti extends Kn {
          constructor(e) {
            super(), this._map = e;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(e, t, r) {
            super.touchstart(e, t, r), this._currentTouchCount = r.length;
          }
          _start(e) {
            ei((this._lastPoints = e)[0].sub(e[1])) && (this._valid = !1);
          }
          _move(e, t, r) {
            if (!(this._map._cooperativeGestures && this._currentTouchCount < 3)) {
              var n = e[0].sub(this._lastPoints[0]),
                i = e[1].sub(this._lastPoints[1]);
              if (this._valid = this.gestureBeginsVertically(n, i, r.timeStamp), this._valid) return this._lastPoints = e, this._active = !0, {
                pitchDelta: -.5 * ((n.y + i.y) / 2)
              };
            }
          }
          gestureBeginsVertically(e, t, r) {
            var n, i;
            return void 0 !== this._valid ? this._valid : (i = 2 <= e.mag(), n = 2 <= t.mag(), i || n ? i && n ? (i = 0 < e.y == 0 < t.y, ei(e) && ei(t) && i) : (void 0 === this._firstMove && (this._firstMove = r), r - this._firstMove < 100 && void 0) : void 0);
          }
        }
        const ri = {
          panStep: 100,
          bearingStep: 15,
          pitchStep: 10
        };
        class ni {
          constructor(e) {
            this._tr = new u(e);
            e = ri;
            this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1;
          }
          reset() {
            this._active = !1;
          }
          keydown(s) {
            if (!(s.altKey || s.ctrlKey || s.metaKey)) {
              let r = 0,
                n = 0,
                i = 0,
                o = 0,
                a = 0;
              switch (s.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                  r = 1;
                  break;
                case 189:
                case 109:
                case 173:
                  r = -1;
                  break;
                case 37:
                  s.shiftKey ? n = -1 : (s.preventDefault(), o = -1);
                  break;
                case 39:
                  s.shiftKey ? n = 1 : (s.preventDefault(), o = 1);
                  break;
                case 38:
                  s.shiftKey ? i = 1 : (s.preventDefault(), a = -1);
                  break;
                case 40:
                  s.shiftKey ? i = -1 : (s.preventDefault(), a = 1);
                  break;
                default:
                  return;
              }
              return this._rotationDisabled && (n = 0, i = 0), {
                cameraAnimation: e => {
                  var t = this._tr;
                  e.easeTo({
                    duration: 300,
                    easeId: "keyboardHandler",
                    easing: ii,
                    zoom: r ? Math.round(t.zoom) + r * (s.shiftKey ? 2 : 1) : t.zoom,
                    bearing: t.bearing + n * this._bearingStep,
                    pitch: t.pitch + i * this._pitchStep,
                    offset: [-o * this._panStep, -a * this._panStep],
                    center: t.center
                  }, {
                    originalEvent: s
                  });
                }
              };
            }
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function ii(e) {
          return e * (2 - e);
        }
        const oi = 4.000244140625;
        class ai {
          constructor(e, t) {
            this._onTimeout = e => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e);
            }, this._map = e, this._tr = new u(e), this._el = e.getCanvasContainer(), this._triggerRenderFrame = t, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = 1 / 450;
          }
          setZoomRate(e) {
            this._defaultZoomRate = e;
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && "center" === e.around);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          wheel(t) {
            if (this.isEnabled()) {
              if (this._map._cooperativeGestures) {
                if (!t[this._map._metaKey]) return;
                t.preventDefault();
              }
              let e = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
              var r = de.browser.now(),
                n = r - (this._lastWheelEventTime || 0);
              this._lastWheelEventTime = r, 0 !== e && e % oi == 0 ? this._type = "wheel" : 0 !== e && Math.abs(e) < 4 ? this._type = "trackpad" : 400 < n ? (this._type = null, this._lastValue = e, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(n * e) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, e += this._lastValue)), t.shiftKey && e && (e /= 4), this._type && (this._lastWheelEvent = t, this._delta -= e, this._active || this._start(t)), t.preventDefault();
            }
          }
          _start(e) {
            var t;
            this._delta && (this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout), e = m.mousePos(this._el, e), t = this._tr, this._around = de.LngLat.convert(this._aroundCenter ? t.center : t.unproject(e)), this._aroundPoint = t.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._triggerRenderFrame()));
          }
          renderFrame() {
            if (this._frameId && (this._frameId = null, this.isActive())) {
              var r = this._tr.transform;
              if (0 !== this._delta) {
                var n = "wheel" === this._type && Math.abs(this._delta) > oi ? this._wheelZoomRate : this._defaultZoomRate;
                let e = 2 / (1 + Math.exp(-Math.abs(this._delta * n)));
                this._delta < 0 && 0 !== e && (e = 1 / e);
                n = "number" == typeof this._targetZoom ? r.zoomScale(this._targetZoom) : r.scale;
                this._targetZoom = Math.min(r.maxZoom, Math.max(r.minZoom, r.scaleZoom(n * e))), "wheel" === this._type && (this._startZoom = r.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
              }
              var i,
                n = "number" == typeof this._targetZoom ? this._targetZoom : r.zoom,
                o = this._startZoom,
                a = this._easing;
              let e = !1,
                t;
              return "wheel" === this._type && o && a ? (i = a(a = Math.min((de.browser.now() - this._lastWheelEventTime) / 200, 1)), t = de.interpolate.number(o, n, i), a < 1 ? this._frameId || (this._frameId = !0) : e = !0) : (t = n, e = !0), this._active = !0, e && (this._active = !1, this._finishTimeout = setTimeout(() => {
                this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
              }, 200)), {
                noInertia: !0,
                needsRenderFrame: !e,
                zoomDelta: t - r.zoom,
                around: this._aroundPoint,
                originalEvent: this._lastWheelEvent
              };
            }
          }
          _smoothOutEasing(e) {
            let t = de.defaultEasing;
            var r, n;
            return this._prevEase && (n = this._prevEase, r = (de.browser.now() - n.start) / n.duration, n = n.easing(.01 + r) - n.easing(r), r = .27 / Math.sqrt(n * n + 1e-4) * .01, n = Math.sqrt(.0729 - r * r), t = de.bezier(r, n, .25, 1)), this._prevEase = {
              start: de.browser.now(),
              duration: e,
              easing: t
            }, t;
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class si {
          constructor(e, t) {
            this._clickZoom = e, this._tapZoom = t;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class li {
          constructor(e) {
            this._tr = new u(e), this.reset();
          }
          reset() {
            this._active = !1;
          }
          dblclick(t, r) {
            return t.preventDefault(), {
              cameraAnimation: e => {
                e.easeTo({
                  duration: 300,
                  zoom: this._tr.zoom + (t.shiftKey ? -1 : 1),
                  around: this._tr.unproject(r)
                }, {
                  originalEvent: t
                });
              }
            };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ci {
          constructor() {
            this._tap = new Un({
              numTouches: 1,
              numTaps: 1
            }), this.reset();
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(e, t, r) {
            var n, i, o;
            this._swipePoint || (this._tapTime ? (n = t[0], i = e.timeStamp - this._tapTime < 500, o = this._tapPoint.dist(n) < 30, i && o ? 0 < r.length && (this._swipePoint = n, this._swipeTouch = r[0].identifier) : this.reset()) : this._tap.touchstart(e, t, r));
          }
          touchmove(e, t, r) {
            if (this._tapTime) {
              if (this._swipePoint) {
                var n, i;
                if (r[0].identifier === this._swipeTouch) return i = (n = t[0]).y - this._swipePoint.y, this._swipePoint = n, e.preventDefault(), this._active = !0, {
                  zoomDelta: i / 128
                };
              }
            } else this._tap.touchmove(e, t, r);
          }
          touchend(e, t, r) {
            this._tapTime ? this._swipePoint && 0 === r.length && this.reset() : (t = this._tap.touchend(e, t, r)) && (this._tapTime = e.timeStamp, this._tapPoint = t);
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ui {
          constructor(e, t, r) {
            this._el = e, this._mousePan = t, this._touchPan = r;
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class hi {
          constructor(e, t, r) {
            this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t, this._mousePitch = r;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class di {
          constructor(e, t, r, n) {
            this._el = e, this._touchZoom = t, this._touchRotate = r, this._tapDragZoom = n, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        const pi = e => e.zoom || e.drag || e.pitch || e.rotate;
        class fi extends de.Event {}
        function _i(e) {
          return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta;
        }
        class mi {
          constructor(e, t) {
            this.handleWindowEvent = e => {
              this.handleEvent(e, e.type + "Window");
            }, this.handleEvent = (t, r) => {
              if ("blur" === t.type) this.stop(!0);else {
                this._updatingCamera = !0;
                var n,
                  i,
                  o,
                  a = "renderFrame" === t.type ? void 0 : t,
                  s = {
                    needsRenderFrame: !1
                  },
                  l = {},
                  c = {},
                  e = t.touches,
                  u = e ? this._getMapTouches(e) : void 0,
                  h = u ? m.touchPos(this._el, u) : m.mousePos(this._el, t);
                for ({
                  handlerName: n,
                  handler: i,
                  allowed: o
                } of this._handlers) if (i.isEnabled()) {
                  let e;
                  this._blockedByActive(c, o, n) ? i.reset() : i[r || t.type] && (e = i[r || t.type](t, h, u), this.mergeHandlerResult(s, l, e, n, a), e) && e.needsRenderFrame && this._triggerRenderFrame(), (e || i.isActive()) && (c[n] = i);
                }
                var d = {};
                for (const p in this._previousActiveHandlers) c[p] || (d[p] = a);
                this._previousActiveHandlers = c, (Object.keys(d).length || _i(s)) && (this._changes.push([s, l, d]), this._triggerRenderFrame()), (Object.keys(c).length || _i(s)) && this._map._stop(!0), this._updatingCamera = !1;
                e = s["cameraAnimation"];
                e && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], e(this._map));
              }
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Cn(e), this._bearingSnap = t.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(t);
            var r,
              n,
              i,
              e = this._el;
            this._listeners = [[e, "touchstart", {
              passive: !0
            }], [e, "touchmove", {
              passive: !1
            }], [e, "touchend", void 0], [e, "touchcancel", void 0], [e, "mousedown", void 0], [e, "mousemove", void 0], [e, "mouseup", void 0], [document, "mousemove", {
              capture: !0
            }], [document, "mouseup", void 0], [e, "mouseover", void 0], [e, "mouseout", void 0], [e, "dblclick", void 0], [e, "click", void 0], [e, "keydown", {
              capture: !1
            }], [e, "keyup", void 0], [e, "wheel", {
              passive: !1
            }], [e, "contextmenu", void 0], [window, "blur", void 0]];
            for ([r, n, i] of this._listeners) m.addEventListener(r, n, r === document ? this.handleWindowEvent : this.handleEvent, i);
          }
          destroy() {
            for (var [e, t, r] of this._listeners) m.removeEventListener(e, t, e === document ? this.handleWindowEvent : this.handleEvent, r);
          }
          _addDefaultHandlers(e) {
            var t = this._map,
              r = t.getCanvasContainer(),
              n = (this._add("mapEvent", new Dn(t, e)), t.boxZoom = new On(t, e)),
              n = (this._add("boxZoom", n), e.interactive && e.boxZoom && n.enable(), new Fn(t)),
              i = new li(t),
              n = (t.doubleClickZoom = new si(i, n), this._add("tapZoom", n), this._add("clickZoom", i), e.interactive && e.doubleClickZoom && t.doubleClickZoom.enable(), new ci()),
              i = (this._add("tapDragZoom", n), t.touchPitch = new ti(t)),
              i = (this._add("touchPitch", i), e.interactive && e.touchPitch && t.touchPitch.enable(e.touchPitch), Gn(e)),
              o = qn(e),
              i = (t.dragRotate = new hi(e, i, o), this._add("mouseRotate", i, ["mousePitch"]), this._add("mousePitch", o, ["mouseRotate"]), e.interactive && e.dragRotate && t.dragRotate.enable(), jn(e)),
              o = new Vn(e, t),
              i = (t.dragPan = new ui(r, i, o), this._add("mousePan", i), this._add("touchPan", o, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && t.dragPan.enable(e.dragPan), new Qn()),
              o = new Xn(),
              r = (t.touchZoomRotate = new di(r, o, i, n), this._add("touchRotate", i, ["touchPan", "touchZoom"]), this._add("touchZoom", o, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && t.touchZoomRotate.enable(e.touchZoomRotate), t.scrollZoom = new ai(t, () => this._triggerRenderFrame())),
              n = (this._add("scrollZoom", r, ["mousePan"]), e.interactive && e.scrollZoom && t.scrollZoom.enable(e.scrollZoom), t.keyboard = new ni(t));
            this._add("keyboard", n), e.interactive && e.keyboard && t.keyboard.enable(), this._add("blockableMapEvent", new Rn(t));
          }
          _add(e, t, r) {
            this._handlers.push({
              handlerName: e,
              handler: t,
              allowed: r
            }), this._handlersById[e] = t;
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (var {
                handler: t
              } of this._handlers) t.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
            }
          }
          isActive() {
            for (var {
              handler: e
            } of this._handlers) if (e.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return Boolean(pi(this._eventsInProgress)) || this.isZooming();
          }
          _blockedByActive(e, t, r) {
            for (const n in e) if (n !== r && (!t || t.indexOf(n) < 0)) return !0;
            return !1;
          }
          _getMapTouches(e) {
            var t = [];
            for (const n of e) {
              var r = n.target;
              this._el.contains(r) && t.push(n);
            }
            return t;
          }
          mergeHandlerResult(e, t, r, n, i) {
            r && (de.extend(e, r), e = {
              handlerName: n,
              originalEvent: r.originalEvent || i
            }, void 0 !== r.zoomDelta && (t.zoom = e), void 0 !== r.panDelta && (t.drag = e), void 0 !== r.pitchDelta && (t.pitch = e), void 0 !== r.bearingDelta) && (t.rotate = e);
          }
          _applyChanges() {
            var e,
              t,
              r,
              n = {},
              i = {},
              o = {};
            for ([e, t, r] of this._changes) e.panDelta && (n.panDelta = (n.panDelta || new de.Point(0, 0))._add(e.panDelta)), e.zoomDelta && (n.zoomDelta = (n.zoomDelta || 0) + e.zoomDelta), e.bearingDelta && (n.bearingDelta = (n.bearingDelta || 0) + e.bearingDelta), e.pitchDelta && (n.pitchDelta = (n.pitchDelta || 0) + e.pitchDelta), void 0 !== e.around && (n.around = e.around), void 0 !== e.pinchAround && (n.pinchAround = e.pinchAround), e.noInertia && (n.noInertia = e.noInertia), de.extend(i, t), de.extend(o, r);
            this._updateMapTransform(n, i, o), this._changes = [];
          }
          _updateMapTransform(e, t, r) {
            const n = this._map,
              i = n._getTransformForUpdate();
            var o = n.terrain;
            if (!(_i(e) || o && this._terrainMovement)) return this._fireEvents(t, r, !0);
            let {
              panDelta: a,
              zoomDelta: s,
              bearingDelta: l,
              pitchDelta: c,
              around: u,
              pinchAround: h
            } = e;
            void 0 !== h && (u = h), n._stop(!0), u = u || n.transform.centerPoint;
            var d = i.pointLocation(a ? u.sub(a) : u);
            l && (i.bearing += l), c && (i.pitch += c), s && (i.zoom += s), o ? this._terrainMovement || !t.drag && !t.zoom ? t.drag && this._terrainMovement ? i.center = i.pointLocation(i.centerPoint.sub(a)) : i.setLocationAtPoint(d, u) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, i.setLocationAtPoint(d, u), this._map.once("moveend", () => {
              this._map._elevationFreeze = !1, this._terrainMovement = !1, i.recalculateZoom(n.terrain);
            })) : i.setLocationAtPoint(d, u), n._applyUpdatedTransform(i), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(t, r, !0);
          }
          _fireEvents(e, t, r) {
            var n = pi(this._eventsInProgress),
              i = pi(e),
              o = {};
            for (const p in e) {
              var a = e[p]["originalEvent"];
              this._eventsInProgress[p] || (o[p + "start"] = a), this._eventsInProgress[p] = e[p];
            }
            !n && i && this._fireEvent("movestart", i.originalEvent);
            for (const f in o) this._fireEvent(f, o[f]);
            i && this._fireEvent("move", i.originalEvent);
            for (const _ in e) {
              var s = e[_]["originalEvent"];
              this._fireEvent(_, s);
            }
            var l = {};
            let c;
            for (const m in this._eventsInProgress) {
              var {
                handlerName: u,
                originalEvent: h
              } = this._eventsInProgress[m];
              this._handlersById[u].isActive() || (delete this._eventsInProgress[m], c = t[u] || h, l[m + "end"] = c);
            }
            for (const g in l) this._fireEvent(g, l[g]);
            var d = pi(this._eventsInProgress);
            r && (n || i) && !d && (this._updatingCamera = !0, r = e => 0 !== e && -this._bearingSnap < e && e < this._bearingSnap, !(n = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions)) || !n.essential && de.browser.prefersReducedMotion ? (this._map.fire(new de.Event("moveend", {
              originalEvent: c
            })), r(this._map.getBearing()) && this._map.resetNorth()) : (r(n.bearing || this._map.getBearing()) && (n.bearing = 0), n.freezeElevation = !0, this._map.easeTo(n, {
              originalEvent: c
            })), this._updatingCamera = !1);
          }
          _fireEvent(e, t) {
            this._map.fire(new de.Event(e, t ? {
              originalEvent: t
            } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(e => {
              delete this._frameId, this.handleEvent(new fi("renderFrame", {
                timeStamp: e
              })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        class gi extends de.Evented {
          constructor(e, t) {
            super(), this._renderFrameCallback = () => {
              var e = Math.min((de.browser.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(e)), e < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = t.bearingSnap, this.on("moveend", () => {
              delete this._requestedCameraState;
            });
          }
          getCenter() {
            return new de.LngLat(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e, t) {
            return this.jumpTo({
              center: e
            }, t);
          }
          panBy(e, t, r) {
            return e = de.Point.convert(e).mult(-1), this.panTo(this.transform.center, de.extend({
              offset: e
            }, t), r);
          }
          panTo(e, t, r) {
            return this.easeTo(de.extend({
              center: e
            }, t), r);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e, t) {
            return this.jumpTo({
              zoom: e
            }, t), this;
          }
          zoomTo(e, t, r) {
            return this.easeTo(de.extend({
              zoom: e
            }, t), r);
          }
          zoomIn(e, t) {
            return this.zoomTo(this.getZoom() + 1, e, t), this;
          }
          zoomOut(e, t) {
            return this.zoomTo(this.getZoom() - 1, e, t), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e, t) {
            return this.jumpTo({
              bearing: e
            }, t), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e, t) {
            return this.jumpTo({
              padding: e
            }, t), this;
          }
          rotateTo(e, t, r) {
            return this.easeTo(de.extend({
              bearing: e
            }, t), r);
          }
          resetNorth(e, t) {
            return this.rotateTo(0, de.extend({
              duration: 1e3
            }, e), t), this;
          }
          resetNorthPitch(e, t) {
            return this.easeTo(de.extend({
              bearing: 0,
              pitch: 0,
              duration: 1e3
            }, e), t), this;
          }
          snapToNorth(e, t) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e, t) {
            return this.jumpTo({
              pitch: e
            }, t), this;
          }
          cameraForBounds(e, t) {
            e = a.convert(e);
            var r = t && t.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), r, t);
          }
          _cameraForBoxAndBearing(e, t, r, n) {
            var i = {
                top: 0,
                bottom: 0,
                right: 0,
                left: 0
              },
              o = ("number" == typeof (n = de.extend({
                padding: i,
                offset: [0, 0],
                maxZoom: this.transform.maxZoom
              }, n)).padding && (o = n.padding, n.padding = {
                top: o,
                bottom: o,
                right: o,
                left: o
              }), n.padding = de.extend(i, n.padding), this.transform),
              i = o.padding,
              e = o.project(de.LngLat.convert(e)),
              t = o.project(de.LngLat.convert(t)),
              a = e.rotate(-r * Math.PI / 180),
              s = t.rotate(-r * Math.PI / 180),
              l = new de.Point(Math.max(a.x, s.x), Math.max(a.y, s.y)),
              a = new de.Point(Math.min(a.x, s.x), Math.min(a.y, s.y)),
              s = l.sub(a),
              l = (o.width - (i.left + i.right + n.padding.left + n.padding.right)) / s.x,
              a = (o.height - (i.top + i.bottom + n.padding.top + n.padding.bottom)) / s.y;
            if (!(a < 0 || l < 0)) return i = Math.min(o.scaleZoom(o.scale * Math.min(l, a)), n.maxZoom), s = de.Point.convert(n.offset), l = (n.padding.left - n.padding.right) / 2, a = (n.padding.top - n.padding.bottom) / 2, n = new de.Point(l, a).rotate(r * Math.PI / 180), l = s.add(n).mult(o.scale / o.zoomScale(i)), {
              center: o.unproject(e.add(t).div(2).sub(l)),
              zoom: i,
              bearing: r
            };
            de.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          }
          fitBounds(e, t, r) {
            return this._fitInternal(this.cameraForBounds(e, t), t, r);
          }
          fitScreenCoordinates(e, t, r, n, i) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(de.Point.convert(e)), this.transform.pointLocation(de.Point.convert(t)), r, n), n, i);
          }
          _fitInternal(e, t, r) {
            return e ? (delete (t = de.extend(e, t)).padding, t.linear ? this.easeTo(t, r) : this.flyTo(t, r)) : this;
          }
          jumpTo(e, t) {
            this.stop();
            var r = this._getTransformForUpdate();
            let n = !1,
              i = !1,
              o = !1;
            return "zoom" in e && r.zoom !== +e.zoom && (n = !0, r.zoom = +e.zoom), void 0 !== e.center && (r.center = de.LngLat.convert(e.center)), "bearing" in e && r.bearing !== +e.bearing && (i = !0, r.bearing = +e.bearing), "pitch" in e && r.pitch !== +e.pitch && (o = !0, r.pitch = +e.pitch), null == e.padding || r.isPaddingEqual(e.padding) || (r.padding = e.padding), this._applyUpdatedTransform(r), this.fire(new de.Event("movestart", t)).fire(new de.Event("move", t)), n && this.fire(new de.Event("zoomstart", t)).fire(new de.Event("zoom", t)).fire(new de.Event("zoomend", t)), i && this.fire(new de.Event("rotatestart", t)).fire(new de.Event("rotate", t)).fire(new de.Event("rotateend", t)), o && this.fire(new de.Event("pitchstart", t)).fire(new de.Event("pitch", t)).fire(new de.Event("pitchend", t)), this.fire(new de.Event("moveend", t));
          }
          calculateCameraOptionsFromTo(e, t, r, n = 0) {
            var e = de.MercatorCoordinate.fromLngLat(e, t),
              t = de.MercatorCoordinate.fromLngLat(r, n),
              r = t.x - e.x,
              n = t.y - e.y,
              e = t.z - e.z,
              i = Math.hypot(r, n, e);
            if (0 === i) throw new Error("Can't calculate camera options with same From and To");
            var o = Math.hypot(r, n),
              a = this.transform.scaleZoom(this.transform.cameraToCenterDistance / i / this.transform.tileSize),
              r = 180 * Math.atan2(r, -n) / Math.PI,
              n = 180 * Math.acos(o / i) / Math.PI,
              n = e < 0 ? 90 - n : 90 + n;
            return {
              center: t.toLngLat(),
              zoom: a,
              pitch: n,
              bearing: r
            };
          }
          easeTo(n, i) {
            this._stop(!1, n.easeId), (!1 === (n = de.extend({
              offset: [0, 0],
              duration: 500,
              easing: de.defaultEasing
            }, n)).animate || !n.essential && de.browser.prefersReducedMotion) && (n.duration = 0);
            const o = this._getTransformForUpdate(),
              a = this.getZoom(),
              s = this.getBearing(),
              l = this.getPitch(),
              c = this.getPadding(),
              u = "zoom" in n ? +n.zoom : a,
              h = "bearing" in n ? this._normalizeBearing(n.bearing, s) : s,
              d = "pitch" in n ? +n.pitch : l,
              p = ("padding" in n ? n : o).padding,
              f = de.Point.convert(n.offset);
            let _ = o.centerPoint.add(f);
            var e = o.pointLocation(_),
              t = de.LngLat.convert(n.center || e);
            this._normalizeCenter(t);
            const m = o.project(e),
              g = o.project(t).sub(m),
              y = o.zoomScale(u - a);
            let v, E;
            n.around && (v = de.LngLat.convert(n.around), E = o.locationPoint(v));
            e = {
              moving: this._moving,
              zooming: this._zooming,
              rotating: this._rotating,
              pitching: this._pitching
            };
            return this._zooming = this._zooming || u !== a, this._rotating = this._rotating || s !== h, this._pitching = this._pitching || d !== l, this._padding = !o.isPaddingEqual(p), this._easeId = n.easeId, this._prepareEase(i, n.noMoveStart, e), this.terrain && this._prepareElevation(t), this._ease(e => {
              var t, r;
              this._zooming && (o.zoom = de.interpolate.number(a, u, e)), this._rotating && (o.bearing = de.interpolate.number(s, h, e)), this._pitching && (o.pitch = de.interpolate.number(l, d, e)), this._padding && (o.interpolatePadding(c, p, e), _ = o.centerPoint.add(f)), this.terrain && !n.freezeElevation && this._updateElevation(e), v ? o.setLocationAtPoint(v, E) : (t = o.zoomScale(o.zoom - a), r = u > a ? Math.min(2, y) : Math.max(.5, y), r = Math.pow(r, 1 - e), e = o.unproject(m.add(g.mult(e * r)).mult(t)), o.setLocationAtPoint(o.renderWorldCopies ? e.wrap() : e, _)), this._applyUpdatedTransform(o), this._fireMoveEvents(i);
            }, e => {
              this.terrain && this._finalizeElevation(), this._afterEase(i, e);
            }, n), this;
          }
          _prepareEase(e, t, r = {}) {
            this._moving = !0, t || r.moving || this.fire(new de.Event("movestart", e)), this._zooming && !r.zooming && this.fire(new de.Event("zoomstart", e)), this._rotating && !r.rotating && this.fire(new de.Event("rotatestart", e)), this._pitching && !r.pitching && this.fire(new de.Event("pitchstart", e));
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0;
          }
          _updateElevation(e) {
            this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            var t,
              r,
              n = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            e < 1 && n !== this._elevationTarget && (r = (n - ((t = this._elevationTarget - this._elevationStart) * e + this._elevationStart)) / (1 - e), this._elevationStart += e * (t - r), this._elevationTarget = n), this.transform.elevation = de.interpolate.number(this._elevationStart, this._elevationTarget, e);
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.transform.recalculateZoom(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _applyUpdatedTransform(e) {
            var t, r, n, i, o;
            this.transformCameraUpdate && (e = e.clone(), ({
              center: t,
              zoom: r,
              pitch: n,
              bearing: i,
              elevation: o
            } = this.transformCameraUpdate(e)), t && (e.center = t), void 0 !== r && (e.zoom = r), void 0 !== n && (e.pitch = n), void 0 !== i && (e.bearing = i), void 0 !== o && (e.elevation = o), this.transform.apply(e));
          }
          _fireMoveEvents(e) {
            this.fire(new de.Event("move", e)), this._zooming && this.fire(new de.Event("zoom", e)), this._rotating && this.fire(new de.Event("rotate", e)), this._pitching && this.fire(new de.Event("pitch", e));
          }
          _afterEase(e, t) {
            var r, n;
            this._easeId && t && this._easeId === t || (delete this._easeId, this.fire(new de.Event("freezeElevation", {
              freeze: !1
            })), t = this._zooming, r = this._rotating, n = this._pitching, this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, t && this.fire(new de.Event("zoomend", e)), r && this.fire(new de.Event("rotateend", e)), n && this.fire(new de.Event("pitchend", e)), this.fire(new de.Event("moveend", e)));
          }
          flyTo(n, i) {
            if (!n.essential && de.browser.prefersReducedMotion) return e = de.pick(n, ["center", "zoom", "bearing", "pitch", "around"]), this.jumpTo(e, i);
            this.stop(), n = de.extend({
              offset: [0, 0],
              speed: 1.2,
              curve: 1.42,
              easing: de.defaultEasing
            }, n);
            const o = this._getTransformForUpdate(),
              a = this.getZoom(),
              s = this.getBearing(),
              l = this.getPitch(),
              c = this.getPadding(),
              u = "zoom" in n ? de.clamp(+n.zoom, o.minZoom, o.maxZoom) : a,
              h = "bearing" in n ? this._normalizeBearing(n.bearing, s) : s,
              d = "pitch" in n ? +n.pitch : l,
              p = ("padding" in n ? n : o).padding;
            var e = o.zoomScale(u - a);
            const f = de.Point.convert(n.offset);
            let _ = o.centerPoint.add(f);
            var t = o.pointLocation(_);
            const m = de.LngLat.convert(n.center || t),
              g = (this._normalizeCenter(m), o.project(t)),
              y = o.project(m).sub(g);
            let r = n.curve;
            const v = Math.max(o.width, o.height),
              E = v / e,
              b = y.mag(),
              w = ("minZoom" in n && (t = de.clamp(Math.min(n.minZoom, a, u), o.minZoom, o.maxZoom), e = v / o.zoomScale(t - a), r = Math.sqrt(e / b * 2)), r * r);
            function T(e) {
              e = (E * E - v * v + (e ? -1 : 1) * w * w * b * b) / (2 * (e ? E : v) * w * b);
              return Math.log(Math.sqrt(e * e + 1) - e);
            }
            function S(e) {
              return (Math.exp(e) - Math.exp(-e)) / 2;
            }
            function x(e) {
              return (Math.exp(e) + Math.exp(-e)) / 2;
            }
            const C = T(!1);
            let A = function (e) {
                return x(C) / x(C + r * e);
              },
              I = function (e) {
                return v * ((x(C) * (S(e = C + r * e) / x(e)) - S(C)) / w) / b;
              },
              N = (T(!0) - C) / r;
            if (Math.abs(b) < 1e-6 || !isFinite(N)) {
              if (Math.abs(v - E) < 1e-6) return this.easeTo(n, i);
              const P = E < v ? -1 : 1;
              N = Math.abs(Math.log(E / v)) / r, I = function () {
                return 0;
              }, A = function (e) {
                return Math.exp(P * r * e);
              };
            }
            return "duration" in n ? n.duration = +n.duration : (t = "screenSpeed" in n ? +n.screenSpeed / r : +n.speed, n.duration = 1e3 * N / t), n.maxDuration && n.duration > n.maxDuration && (n.duration = 0), this._zooming = !0, this._rotating = s !== h, this._pitching = d !== l, this._padding = !o.isPaddingEqual(p), this._prepareEase(i, !1), this.terrain && this._prepareElevation(m), this._ease(e => {
              var t = e * N,
                r = 1 / A(t),
                e = (o.zoom = 1 === e ? u : a + o.scaleZoom(r), this._rotating && (o.bearing = de.interpolate.number(s, h, e)), this._pitching && (o.pitch = de.interpolate.number(l, d, e)), this._padding && (o.interpolatePadding(c, p, e), _ = o.centerPoint.add(f)), this.terrain && !n.freezeElevation && this._updateElevation(e), 1 === e ? m : o.unproject(g.add(y.mult(I(t))).mult(r)));
              o.setLocationAtPoint(o.renderWorldCopies ? e.wrap() : e, _), this._applyUpdatedTransform(o), this._fireMoveEvents(i);
            }, () => {
              this.terrain && this._finalizeElevation(), this._afterEase(i);
            }, n), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e, t) {
            var r;
            return this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd && (r = this._onEaseEnd, delete this._onEaseEnd, r.call(this, t)), e || (r = this.handlers) && r.stop(!1), this;
          }
          _ease(e, t, r) {
            !1 === r.animate || 0 === r.duration ? (e(1), t()) : (this._easeStart = de.browser.now(), this._easeOptions = r, this._onEaseFrame = e, this._onEaseEnd = t, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e, t) {
            e = de.wrap(e, -180, 180);
            var r = Math.abs(e - t);
            return Math.abs(e - 360 - t) < r && (e -= 360), Math.abs(e + 360 - t) < r && (e += 360), e;
          }
          _normalizeCenter(e) {
            var t = this.transform;
            t.renderWorldCopies && !t.lngRange && (t = e.lng - t.center.lng, e.lng += 180 < t ? -360 : t < -180 ? 360 : 0);
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(de.LngLat.convert(e), this.transform.tileZoom) - this.transform.elevation : null;
          }
        }
        class yi {
          constructor(e = {}) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = e => {
              !e || "metadata" !== e.sourceDataType && "visibility" !== e.sourceDataType && "style" !== e.dataType && "terrain" !== e.type || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options && this.options.compact, this._container = m.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = m.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = m.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            m.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e, t) {
            t = this._map._getUIString("AttributionControl." + t);
            e.title = t, e.setAttribute("aria-label", t);
          }
          _updateAttributions() {
            if (this._map.style) {
              let n = [];
              this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? n = n.concat(this.options.customAttribution.map(e => "string" != typeof e ? "" : e)) : "string" == typeof this.options.customAttribution && n.push(this.options.customAttribution)), this._map.style.stylesheet && (r = this._map.style.stylesheet, this.styleOwner = r.owner, this.styleId = r.id);
              var e = this._map.style.sourceCaches;
              for (const i in e) {
                var t = e[i];
                (t.used || t.usedForTerrain) && (t = t.getSource()).attribution && n.indexOf(t.attribution) < 0 && n.push(t.attribution);
              }
              (n = n.filter(e => String(e).trim())).sort((e, t) => e.length - t.length);
              var r = (n = n.filter((t, r) => {
                for (let e = r + 1; e < n.length; e++) if (0 <= n[e].indexOf(t)) return !1;
                return !0;
              })).join(" | ");
              r !== this._attribHTML && (this._attribHTML = r, n.length ? (this._innerContainer.innerHTML = r, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
            }
          }
        }
        class vi {
          constructor(e = {}) {
            this._updateCompact = () => {
              var e = this._container.children;
              e.length && (e = e[0], this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 !== this._compact && e.classList.add("maplibregl-compact") : e.classList.remove("maplibregl-compact"));
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = m.create("div", "maplibregl-ctrl");
            e = m.create("a", "maplibregl-ctrl-logo");
            return e.target = "_blank", e.rel = "noopener nofollow", e.href = "https://maplibre.org/", e.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            m.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class Ei {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(e) {
            var t = ++this._id;
            return this._queue.push({
              callback: e,
              id: t,
              cancelled: !1
            }), t;
          }
          remove(e) {
            var t = this._currentlyRunning;
            for (const r of t ? this._queue.concat(t) : this._queue) if (r.id === e) return void (r.cancelled = !0);
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            var t = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const r of t) if (!r.cancelled && (r.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        const bi = {
          "AttributionControl.ToggleAttribution": "Toggle attribution",
          "AttributionControl.MapFeedback": "Map feedback",
          "FullscreenControl.Enter": "Enter fullscreen",
          "FullscreenControl.Exit": "Exit fullscreen",
          "GeolocateControl.FindMyLocation": "Find my location",
          "GeolocateControl.LocationNotAvailable": "Location not available",
          "LogoControl.Title": "Mapbox logo",
          "NavigationControl.ResetBearing": "Reset bearing to north",
          "NavigationControl.ZoomIn": "Zoom in",
          "NavigationControl.ZoomOut": "Zoom out",
          "ScaleControl.Feet": "ft",
          "ScaleControl.Meters": "m",
          "ScaleControl.Kilometers": "km",
          "ScaleControl.Miles": "mi",
          "ScaleControl.NauticalMiles": "nm",
          "TerrainControl.enableTerrain": "Enable terrain",
          "TerrainControl.disableTerrain": "Disable terrain"
        };
        var wi = de.createLayout([{
          name: "a_pos3d",
          type: "Int16",
          components: 3
        }]);
        class Ti extends de.Evented {
          constructor(e) {
            super(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, e.usedForTerrain = !0, e.tileSize = this.tileSize * 2 ** this.deltaZoom;
          }
          destruct() {
            this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
          }
          update(e, t) {
            this.sourceCache.update(e, t), this._renderableTilesKeys = [];
            var r = {};
            for (const n of e.coveringTiles({
              tileSize: this.tileSize,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              reparseOverscaled: !1,
              terrain: t
            })) r[n.key] = !0, this._renderableTilesKeys.push(n.key), this._tiles[n.key] || (n.posMatrix = new Float64Array(16), de.ortho(n.posMatrix, 0, de.EXTENT, 0, de.EXTENT, 0, 1), this._tiles[n.key] = new we(n, this.tileSize));
            for (const i in this._tiles) r[i] || delete this._tiles[i];
          }
          freeRtt(e) {
            for (const r in this._tiles) {
              var t = this._tiles[r];
              (!e || t.tileID.equals(e) || t.tileID.isChildOf(e) || e.isChildOf(t.tileID)) && (t.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map(e => this.getTileByID(e));
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          getTerrainCoords(e) {
            var t = {};
            for (const l of this._renderableTilesKeys) {
              var r,
                n,
                i,
                o,
                a,
                s = this._tiles[l].tileID;
              s.canonical.equals(e.canonical) ? ((r = e.clone()).posMatrix = new Float64Array(16), de.ortho(r.posMatrix, 0, de.EXTENT, 0, de.EXTENT, 0, 1), t[l] = r) : s.canonical.isChildOf(e.canonical) ? ((r = e.clone()).posMatrix = new Float64Array(16), o = s.canonical.z - e.canonical.z, n = s.canonical.x - (s.canonical.x >> o << o), i = s.canonical.y - (s.canonical.y >> o << o), o = de.EXTENT >> o, de.ortho(r.posMatrix, 0, o, 0, o, 0, 1), de.translate(r.posMatrix, r.posMatrix, [-n * o, -i * o, 0]), t[l] = r) : e.canonical.isChildOf(s.canonical) && ((n = e.clone()).posMatrix = new Float64Array(16), i = e.canonical.z - s.canonical.z, o = e.canonical.x - (e.canonical.x >> i << i), s = e.canonical.y - (e.canonical.y >> i << i), a = de.EXTENT >> i, de.ortho(n.posMatrix, 0, de.EXTENT, 0, de.EXTENT, 0, 1), de.translate(n.posMatrix, n.posMatrix, [o * a, s * a, 0]), de.scale(n.posMatrix, n.posMatrix, [1 / 2 ** i, 1 / 2 ** i, 0]), t[l] = n);
            }
            return t;
          }
          getSourceTile(e, t) {
            var r = this.sourceCache._source;
            let n = e.overscaledZ - this.deltaZoom;
            if ((n = n > r.maxzoom ? r.maxzoom : n) < r.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(n).key);
            let i = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
            if ((!i || !i.dem) && t) for (; n >= r.minzoom && (!i || !i.dem);) i = this.sourceCache.getTileByID(e.scaledTo(n--).key);
            return i;
          }
          tilesAfterTime(t = Date.now()) {
            return Object.values(this._tiles).filter(e => e.timeAdded >= t);
          }
        }
        class Si {
          constructor(e, t, r) {
            this.painter = e, this.sourceCache = new Ti(t), this.options = r, this.exaggeration = "number" == typeof r.exaggeration ? r.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e, t, r, n = de.EXTENT) {
            var i;
            return 0 <= t && t < n && 0 <= r && r < n && (i = null == (i = (e = this.getTerrainData(e)).tile) ? void 0 : i.dem) ? (r = [(t = de.transformMat4$1([], [t / n * de.EXTENT, r / n * de.EXTENT], e.u_terrain_matrix))[0] * i.dim, t[1] * i.dim], n = Math.floor(r[0]), e = Math.floor(r[1]), t = r[0] - n, r = r[1] - e, i.get(n, e) * (1 - t) * (1 - r) + i.get(n + 1, e) * t * (1 - r) + i.get(n, e + 1) * (1 - t) * r + i.get(n + 1, e + 1) * t * r) : 0;
          }
          getElevationForLngLatZoom(e, t) {
            var {
              tileID: e,
              mercatorX: t,
              mercatorY: r
            } = this._getOverscaledTileIDFromLngLatZoom(e, t);
            return this.getElevation(e, t % de.EXTENT, r % de.EXTENT, de.EXTENT);
          }
          getElevation(e, t, r, n = de.EXTENT) {
            return this.getDEMElevation(e, t, r, n) * this.exaggeration;
          }
          getTerrainData(t) {
            this._emptyDemTexture || (e = this.painter.context, r = new de.RGBAImage({
              width: 1,
              height: 1
            }, new Uint8Array(4)), this._emptyDepthTexture = new U(e, r, e.gl.RGBA, {
              premultiply: !1
            }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new U(e, new de.RGBAImage({
              width: 1,
              height: 1
            }), e.gl.RGBA, {
              premultiply: !1
            }), this._emptyDemTexture.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = de.identity([]));
            var r = this.sourceCache.getSourceTile(t, !0),
              e = (r && r.dem && (!r.demTexture || r.needsTerrainPrepare) && (e = this.painter.context, r.demTexture = this.painter.getTileTexture(r.dem.stride), r.demTexture ? r.demTexture.update(r.dem.getPixels(), {
                premultiply: !1
              }) : r.demTexture = new U(e, r.dem.getPixels(), e.gl.RGBA, {
                premultiply: !1
              }), r.demTexture.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), r.needsTerrainPrepare = !1), r && r + r.tileID.key + t.key);
            if (e && !this._demMatrixCache[e]) {
              var n = this.sourceCache.sourceCache._source.maxzoom;
              let e = t.canonical.z - r.tileID.canonical.z;
              t.overscaledZ > t.canonical.z && (t.canonical.z >= n ? e = t.canonical.z - n : de.warnOnce("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              var n = t.canonical.x - (t.canonical.x >> e << e),
                i = t.canonical.y - (t.canonical.y >> e << e),
                o = de.fromScaling(new Float64Array(16), [1 / (de.EXTENT << e), 1 / (de.EXTENT << e), 0]);
              de.translate(o, o, [n * de.EXTENT, i * de.EXTENT, 0]), this._demMatrixCache[t.key] = {
                matrix: o,
                coord: t
              };
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: r && r.dem && r.dem.dim || 1,
              u_terrain_matrix: e ? this._demMatrixCache[t.key].matrix : this._emptyDemMatrix,
              u_terrain_unpack: r && r.dem && r.dem.getUnpackVector() || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: (r && r.demTexture || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
              tile: r
            };
          }
          getFramebuffer(e) {
            var t = this.painter,
              r = t.width / devicePixelRatio,
              n = t.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === r && this._fbo.height === n || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new U(t.context, {
              width: r,
              height: n,
              data: null
            }, t.context.gl.RGBA, {
              premultiply: !1
            }), this._fboCoordsTexture.bind(t.context.gl.NEAREST, t.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new U(t.context, {
              width: r,
              height: n,
              data: null
            }, t.context.gl.RGBA, {
              premultiply: !1
            }), this._fboDepthTexture.bind(t.context.gl.NEAREST, t.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = t.context.createFramebuffer(r, n, !0, !1), this._fbo.depthAttachment.set(t.context.createRenderbuffer(t.context.gl.DEPTH_COMPONENT16, r, n))), this._fbo.colorAttachment.set(("coords" === e ? this._fboCoordsTexture : this._fboDepthTexture).texture), this._fbo;
          }
          getCoordsTexture() {
            var e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            var n = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let t = 0, r = 0; t < this._coordsTextureSize; t++) for (let e = 0; e < this._coordsTextureSize; e++, r += 4) n[r + 0] = 255 & e, n[r + 1] = 255 & t, n[r + 2] = e >> 8 << 4 | t >> 8, n[r + 3] = 0;
            var t = new de.RGBAImage({
                width: this._coordsTextureSize,
                height: this._coordsTextureSize
              }, new Uint8Array(n.buffer)),
              t = new U(e, t, e.gl.RGBA, {
                premultiply: !1
              });
            return t.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = t;
          }
          pointCoordinate(e) {
            var t,
              r = new Uint8Array(4),
              n = this.painter.context,
              i = n.gl,
              e = (n.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), i.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, i.RGBA, i.UNSIGNED_BYTE, r), n.bindFramebuffer.set(null), r[0] + (r[2] >> 4 << 8)),
              i = r[1] + ((15 & r[2]) << 8),
              n = this.coordsIndex[255 - r[3]],
              r = n && this.sourceCache.getTileByID(n);
            return r ? (n = this._coordsTextureSize, t = (1 << r.tileID.canonical.z) * n, new de.MercatorCoordinate((r.tileID.canonical.x * n + e) / t, (r.tileID.canonical.y * n + i) / t, this.getElevation(r.tileID, e, i, n))) : null;
          }
          getTerrainMesh() {
            if (!this._mesh) {
              var e = this.painter.context,
                r = new de.Pos3dArray(),
                n = new de.TriangleIndexArray(),
                i = this.meshSize,
                o = de.EXTENT / i,
                a = i * i;
              for (let t = 0; t <= i; t++) for (let e = 0; e <= i; e++) r.emplaceBack(e * o, t * o, 0);
              for (let t = 0; t < a; t += i + 1) for (let e = 0; e < i; e++) n.emplaceBack(e + t, i + e + t + 1, i + e + t + 2), n.emplaceBack(e + t, i + e + t + 2, e + t + 1);
              var t = r.length,
                s = t + 2 * (i + 1);
              for (const u of [0, 1]) for (let e = 0; e <= i; e++) for (const h of [0, 1]) r.emplaceBack(e * o, u * de.EXTENT, h);
              for (let e = 0; e < 2 * i; e += 2) n.emplaceBack(s + e, s + e + 1, s + e + 3), n.emplaceBack(s + e, s + e + 3, s + e + 2), n.emplaceBack(t + e, t + e + 3, t + e + 1), n.emplaceBack(t + e, t + e + 2, t + e + 3);
              var l = r.length,
                c = l + 2 * (i + 1);
              for (const d of [0, 1]) for (let e = 0; e <= i; e++) for (const p of [0, 1]) r.emplaceBack(d * de.EXTENT, e * o, p);
              for (let e = 0; e < 2 * i; e += 2) n.emplaceBack(l + e, l + e + 1, l + e + 3), n.emplaceBack(l + e, l + e + 3, l + e + 2), n.emplaceBack(c + e, c + e + 3, c + e + 1), n.emplaceBack(c + e, c + e + 2, c + e + 3);
              this._mesh = {
                indexBuffer: e.createIndexBuffer(n),
                vertexBuffer: e.createVertexBuffer(r, wi.members),
                segments: de.SegmentVector.simpleSegment(0, 0, r.length, n.length)
              };
            }
            return this._mesh;
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * de.earthRadius / Math.pow(2, e) / 5;
          }
          getMinTileElevationForLngLatZoom(e, t) {
            e = this._getOverscaledTileIDFromLngLatZoom(e, t).tileID;
            return null != (t = this.getMinMaxElevation(e).minElevation) ? t : 0;
          }
          getMinMaxElevation(e) {
            var e = this.getTerrainData(e).tile,
              t = {
                minElevation: null,
                maxElevation: null
              };
            return e && e.dem && (t.minElevation = e.dem.min * this.exaggeration, t.maxElevation = e.dem.max * this.exaggeration), t;
          }
          _getOverscaledTileIDFromLngLatZoom(e, t) {
            var e = de.MercatorCoordinate.fromLngLat(e.wrap()),
              r = (1 << t) * de.EXTENT,
              n = e.x * r,
              e = e.y * r,
              r = Math.floor(n / de.EXTENT),
              i = Math.floor(e / de.EXTENT);
            return {
              tileID: new de.OverscaledTileID(t, 0, t, r, i),
              mercatorX: n,
              mercatorY: e
            };
          }
        }
        class xi {
          constructor(e, t, r) {
            this._context = e, this._size = t, this._tileSize = r, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
          }
          _createObject(e) {
            var t = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0),
              r = new U(this._context, {
                width: this._tileSize,
                height: this._tileSize,
                data: null
              }, this._context.gl.RGBA);
            return r.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), t.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), t.colorAttachment.set(r.texture), {
              id: e,
              fbo: t,
              texture: r,
              stamp: -1,
              inUse: !1
            };
          }
          getObjectForId(e) {
            return this._objects[e];
          }
          useObject(t) {
            t.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(e => t.id !== e), this._recentlyUsed.push(t.id);
          }
          stampObject(e) {
            e.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const t of this._recentlyUsed) if (!this._objects[t].inUse) return this._objects[t];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            var e = this._createObject(this._objects.length);
            return this._objects.push(e), e;
          }
          freeObject(e) {
            e.inUse = !1;
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e);
          }
          isFull() {
            return !(this._objects.length < this._size) && !1 === this._objects.some(e => !e.inUse);
          }
        }
        const b = {
          background: !0,
          fill: !0,
          line: !0,
          raster: !0,
          hillshade: !0
        };
        class Ci {
          constructor(e, t) {
            this.painter = e, this.terrain = t, this.pool = new xi(e.context, 30, t.sourceCache.tileSize * t.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(t, r) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t._order.filter(e => !t._layers[e].isHidden(r)), this._coordsDescendingInv = {};
            for (const a in t.sourceCaches) {
              this._coordsDescendingInv[a] = {};
              for (const s of t.sourceCaches[a].getVisibleCoordinates()) {
                var e = this.terrain.sourceCache.getTerrainCoords(s);
                for (const l in e) this._coordsDescendingInv[a][l] || (this._coordsDescendingInv[a][l] = []), this._coordsDescendingInv[a][l].push(e[l]);
              }
            }
            this._coordsDescendingInvStr = {};
            for (const c of t._order) {
              var n = t._layers[c],
                i = n.source;
              if (b[n.type] && !this._coordsDescendingInvStr[i]) {
                this._coordsDescendingInvStr[i] = {};
                for (const u in this._coordsDescendingInv[i]) this._coordsDescendingInvStr[i][u] = this._coordsDescendingInv[i][u].map(e => e.key).sort().join();
              }
            }
            for (const h of this._renderableTiles) for (const d in this._coordsDescendingInvStr) {
              var o = this._coordsDescendingInvStr[d][h.tileID.key];
              o && o !== h.rttCoords[d] && (h.rtt = []);
            }
          }
          renderLayer(t) {
            if (!t.isHidden(this.painter.transform.zoom)) {
              var e = t.type,
                r = this.painter,
                n = this._renderableLayerIds[this._renderableLayerIds.length - 1] === t.id;
              if (b[e] && (this._prevType && b[this._prevType] || this._stacks.push([]), this._prevType = e, this._stacks[this._stacks.length - 1].push(t.id), !n)) return !0;
              if (b[this._prevType] || b[e] && n) {
                this._prevType = e;
                var i = this._stacks.length - 1,
                  o = this._stacks[i] || [];
                for (const c of this._renderableTiles) {
                  if (this.pool.isFull() && (fn(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(c), c.rtt[i]) {
                    var a = this.pool.getObjectForId(c.rtt[i].id);
                    if (a.stamp === c.rtt[i].stamp) {
                      this.pool.useObject(a);
                      continue;
                    }
                  }
                  var s = this.pool.getOrCreateFreeObject();
                  this.pool.useObject(s), this.pool.stampObject(s), c.rtt[i] = {
                    id: s.id,
                    stamp: s.stamp
                  }, r.context.bindFramebuffer.set(s.fbo.framebuffer), r.context.clear({
                    color: de.Color.transparent,
                    stencil: 0
                  }), r.currentStencilSource = void 0;
                  for (let e = 0; e < o.length; e++) {
                    const t = r.style._layers[o[e]];
                    var l = t.source ? this._coordsDescendingInv[t.source][c.tileID.key] : [c.tileID];
                    r.context.viewport.set([0, 0, s.fbo.width, s.fbo.height]), r._renderTileClippingMasks(t, l), r.renderLayer(r, r.style.sourceCaches[t.source], t, l), t.source && (c.rttCoords[t.source] = this._coordsDescendingInvStr[t.source][c.tileID.key]);
                  }
                }
                return fn(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), b[e];
              }
            }
            return !1;
          }
        }
        const Ai = A,
          Ii = {
            center: [0, 0],
            zoom: 0,
            bearing: 0,
            pitch: 0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            interactive: !0,
            scrollZoom: !0,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: void 0,
            bearingSnap: 7,
            clickTolerance: 3,
            pitchWithRotate: !0,
            hash: !1,
            attributionControl: !0,
            maplibreLogo: !1,
            failIfMajorPerformanceCaveat: !1,
            preserveDrawingBuffer: !1,
            trackResize: !0,
            renderWorldCopies: !0,
            refreshExpiredTiles: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: de.config.MAX_TILE_CACHE_ZOOM_LEVELS,
            localIdeographFontFamily: "sans-serif",
            transformRequest: null,
            transformCameraUpdate: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096]
          };
        e = class extends gi {
          constructor(e) {
            if (de.PerformanceUtils.mark(de.PerformanceMarkers.create), null != (e = de.extend({}, Ii, e)).minZoom && null != e.maxZoom && e.minZoom > e.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != e.minPitch && null != e.maxPitch && e.minPitch > e.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != e.minPitch && e.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (null != e.maxPitch && 85 < e.maxPitch) throw new Error("maxPitch must be less than or equal to 85");
            if (super(new vn(e.minZoom, e.maxZoom, e.minPitch, e.maxPitch, e.renderWorldCopies), {
              bearingSnap: e.bearingSnap
            }), this._cooperativeGesturesOnWheel = e => {
              this._onCooperativeGesture(e, e[this._metaKey], 1);
            }, this._contextLost = e => {
              e.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new de.Event("webglcontextlost", {
                originalEvent: e
              }));
            }, this._contextRestored = e => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new de.Event("webglcontextrestored", {
                originalEvent: e
              }));
            }, this._onMapScroll = e => {
              if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = e.interactive, this._cooperativeGestures = e.cooperativeGestures, this._metaKey = 0 === navigator.platform.indexOf("Mac") ? "metaKey" : "ctrlKey", this._maxTileCacheSize = e.maxTileCacheSize, this._maxTileCacheZoomLevels = e.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e.preserveDrawingBuffer, this._antialias = e.antialias, this._trackResize = e.trackResize, this._bearingSnap = e.bearingSnap, this._refreshExpiredTiles = e.refreshExpiredTiles, this._fadeDuration = e.fadeDuration, this._crossSourceCollisions = e.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e.collectResourceTiming, this._renderTaskQueue = new Ei(), this._controls = [], this._mapId = de.uniqueId(), this._locale = de.extend({}, bi, e.locale), this._clickTolerance = e.clickTolerance, this._overridePixelRatio = e.pixelRatio, this._maxCanvasSize = e.maxCanvasSize, this.transformCameraUpdate = e.transformCameraUpdate, this._imageQueueHandle = f.addThrottleControl(() => this.isMoving()), this._requestManager = new M(e.transformRequest), "string" == typeof e.container) {
              if (this._container = document.getElementById(e.container), !this._container) throw new Error(`Container '${e.container}' not found.`);
            } else {
              if (!(e.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = e.container;
            }
            if (e.maxBounds && this.setMaxBounds(e.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this.on("terrain", () => {
              this.painter.terrainFacilitator.dirty = !0, this._update(!0);
            }), this.once("idle", () => {
              this._idleTriggered = !0;
            }), "undefined" != typeof window) {
              addEventListener("online", this._onWindowOnline, !1);
              let t = !1;
              const r = En(e => {
                this._trackResize && !this._removed && this.resize(e)._update();
              }, 50);
              this._resizeObserver = new ResizeObserver(e => {
                t ? r(e) : t = !0;
              }), this._resizeObserver.observe(this._container);
            }
            this.handlers = new mi(this, e), this._cooperativeGestures && this._setupCooperativeGestures();
            var t = "string" == typeof e.hash && e.hash || void 0;
            this._hash = e.hash && new bn(t).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
              center: e.center,
              zoom: e.zoom,
              bearing: e.bearing,
              pitch: e.pitch
            }), e.bounds && (this.resize(), this.fitBounds(e.bounds, de.extend({}, e.fitBoundsOptions, {
              duration: 0
            })))), this.resize(), this._localIdeographFontFamily = e.localIdeographFontFamily, this._validateStyle = e.validateStyle, e.style && this.setStyle(e.style, {
              localIdeographFontFamily: e.localIdeographFontFamily
            }), e.attributionControl && this.addControl(new yi({
              customAttribution: e.customAttribution
            })), e.maplibreLogo && this.addControl(new vi(), e.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet);
            }), this.on("data", e => {
              this._update("style" === e.dataType), this.fire(new de.Event(e.dataType + "data", e));
            }), this.on("dataloading", e => {
              this.fire(new de.Event(e.dataType + "dataloading", e));
            }), this.on("dataabort", e => {
              this.fire(new de.Event("sourcedataabort", e));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(e, t) {
            var r;
            return void 0 === t && (t = e.getDefaultPosition ? e.getDefaultPosition() : "top-right"), e && e.onAdd ? (r = e.onAdd(this), this._controls.push(e), e = this._controlPositions[t], -1 !== t.indexOf("bottom") ? e.insertBefore(r, e.firstChild) : e.appendChild(r), this) : this.fire(new de.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          }
          removeControl(e) {
            var t;
            return e && e.onRemove ? (-1 < (t = this._controls.indexOf(e)) && this._controls.splice(t, 1), e.onRemove(this), this) : this.fire(new de.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          }
          hasControl(e) {
            return -1 < this._controls.indexOf(e);
          }
          calculateCameraOptionsFromTo(e, t, r, n) {
            return null == n && this.terrain && (n = this.terrain.getElevationForLngLatZoom(r, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(e, t, r, n);
          }
          resize(e) {
            var t = this._containerDimensions(),
              r = t[0],
              t = t[1];
            const n = this._getClampedPixelRatio(r, t);
            if (this._resizeCanvas(r, t, n), this.painter.resize(r, t, n), this.painter.overLimit()) {
              var i = this.painter.context.gl;
              this._maxCanvasSize = [i.drawingBufferWidth, i.drawingBufferHeight];
              const n = this._getClampedPixelRatio(r, t);
              this._resizeCanvas(r, t, n), this.painter.resize(r, t, n);
            }
            this.transform.resize(r, t), null != (i = this._requestedCameraState) && i.resize(r, t);
            i = !this._moving;
            return i && (this.stop(), this.fire(new de.Event("movestart", e)).fire(new de.Event("move", e))), this.fire(new de.Event("resize", e)), i && this.fire(new de.Event("moveend", e)), this;
          }
          _getClampedPixelRatio(e, t) {
            var {
                0: r,
                1: n
              } = this._maxCanvasSize,
              i = this.getPixelRatio(),
              e = e * i,
              t = t * i;
            return Math.min(r < e ? r / e : 1, n < t ? n / t : 1) * i;
          }
          getPixelRatio() {
            var e;
            return null != (e = this._overridePixelRatio) ? e : devicePixelRatio;
          }
          setPixelRatio(e) {
            this._overridePixelRatio = e, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(e) {
            return this.transform.setMaxBounds(a.convert(e)), this._update();
          }
          setMinZoom(e) {
            if (-2 <= (e = null == e ? -2 : e) && e <= this.transform.maxZoom) return this.transform.minZoom = e, this._update(), this.getZoom() < e && this.setZoom(e), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(e) {
            if ((e = null == e ? 22 : e) >= this.transform.minZoom) return this.transform.maxZoom = e, this._update(), this.getZoom() > e && this.setZoom(e), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(e) {
            if ((e = null == e ? 0 : e) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (0 <= e && e <= this.transform.maxPitch) return this.transform.minPitch = e, this._update(), this.getPitch() < e && this.setPitch(e), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(e) {
            if (85 < (e = null == e ? 60 : e)) throw new Error("maxPitch must be less than or equal to 85");
            if (e >= this.transform.minPitch) return this.transform.maxPitch = e, this._update(), this.getPitch() > e && this.setPitch(e), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(e) {
            return this.transform.renderWorldCopies = e, this._update();
          }
          getCooperativeGestures() {
            return this._cooperativeGestures;
          }
          setCooperativeGestures(e) {
            return this._cooperativeGestures = e, this._cooperativeGestures ? this._setupCooperativeGestures() : this._destroyCooperativeGestures(), this;
          }
          project(e) {
            return this.transform.locationPoint(de.LngLat.convert(e), this.style && this.terrain);
          }
          unproject(e) {
            return this.transform.pointLocation(de.Point.convert(e), this.terrain);
          }
          isMoving() {
            var e;
            return this._moving || (null == (e = this.handlers) ? void 0 : e.isMoving());
          }
          isZooming() {
            var e;
            return this._zooming || (null == (e = this.handlers) ? void 0 : e.isZooming());
          }
          isRotating() {
            var e;
            return this._rotating || (null == (e = this.handlers) ? void 0 : e.isRotating());
          }
          _createDelegatedListener(n, i, o) {
            if ("mouseenter" === n || "mouseover" === n) {
              let r = !1;
              return {
                layer: i,
                listener: o,
                delegates: {
                  mousemove: e => {
                    var t = this.getLayer(i) ? this.queryRenderedFeatures(e.point, {
                      layers: [i]
                    }) : [];
                    t.length ? r || (r = !0, o.call(this, new c(n, this, e.originalEvent, {
                      features: t
                    }))) : r = !1;
                  },
                  mouseout: () => {
                    r = !1;
                  }
                }
              };
            }
            if ("mouseleave" !== n && "mouseout" !== n) return {
              layer: i,
              listener: o,
              delegates: {
                [n]: e => {
                  var t = this.getLayer(i) ? this.queryRenderedFeatures(e.point, {
                    layers: [i]
                  }) : [];
                  t.length && (e.features = t, o.call(this, e), delete e.features);
                }
              }
            };
            {
              let t = !1;
              return {
                layer: i,
                listener: o,
                delegates: {
                  mousemove: e => {
                    (this.getLayer(i) ? this.queryRenderedFeatures(e.point, {
                      layers: [i]
                    }) : []).length ? t = !0 : t && (t = !1, o.call(this, new c(n, this, e.originalEvent)));
                  },
                  mouseout: e => {
                    t && (t = !1, o.call(this, new c(n, this, e.originalEvent)));
                  }
                }
              };
            }
          }
          on(e, t, r) {
            if (void 0 === r) return super.on(e, t);
            var n = this._createDelegatedListener(e, t, r);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(n);
            for (const i in n.delegates) this.on(i, n.delegates[i]);
            return this;
          }
          once(e, t, r) {
            if (void 0 === r) return super.once(e, t);
            var n = this._createDelegatedListener(e, t, r);
            for (const i in n.delegates) this.once(i, n.delegates[i]);
            return this;
          }
          off(i, o, a) {
            return void 0 === a ? super.off(i, o) : (this._delegatedListeners && this._delegatedListeners[i] && (e => {
              var t = e[i];
              for (let e = 0; e < t.length; e++) {
                var r = t[e];
                if (r.layer === o && r.listener === a) {
                  for (const n in r.delegates) this.off(n, r.delegates[n]);
                  return t.splice(e, 1), this;
                }
              }
            })(this._delegatedListeners), this);
          }
          queryRenderedFeatures(e, t) {
            if (!this.style) return [];
            let r;
            var n = e instanceof de.Point || Array.isArray(e),
              i = n ? e : [[0, 0], [this.transform.width, this.transform.height]];
            return t = t || (n ? {} : e) || {}, r = i instanceof de.Point || "number" == typeof i[0] ? [de.Point.convert(i)] : (n = de.Point.convert(i[0]), e = de.Point.convert(i[1]), [n, new de.Point(e.x, n.y), e, new de.Point(n.x, e.y), n]), this.style.queryRenderedFeatures(r, t, this.transform);
          }
          querySourceFeatures(e, t) {
            return this.style.querySourceFeatures(e, t);
          }
          setStyle(e, t) {
            return !1 !== (t = de.extend({}, {
              localIdeographFontFamily: this._localIdeographFontFamily,
              validate: this._validateStyle
            }, t)).diff && t.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e ? (this._diffStyle(e, t), this) : (this._localIdeographFontFamily = t.localIdeographFontFamily, this._updateStyle(e, t));
          }
          setTransformRequest(e) {
            return this._requestManager.setTransformRequest(e), this;
          }
          _getUIString(e) {
            var t = this._locale[e];
            if (null == t) throw new Error(`Missing UI string '${e}'`);
            return t;
          }
          _updateStyle(e, t) {
            var r;
            if (!t.transformStyle || !this.style || this.style._loaded) return r = this.style && t.transformStyle ? this.style.serialize() : void 0, this.style && (this.style.setEventedParent(null), this.style._remove(!e)), e ? (this.style = new o(this, t || {}), this.style.setEventedParent(this, {
              style: this.style
            }), "string" == typeof e ? this.style.loadURL(e, t, r) : this.style.loadJSON(e, t, r)) : delete this.style, this;
            this.style.once("style.load", () => this._updateStyle(e, t));
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new o(this, {}), this.style.setEventedParent(this, {
              style: this.style
            }), this.style.loadEmpty());
          }
          _diffStyle(e, r) {
            var t;
            "string" == typeof e ? (t = this._requestManager.transformRequest(e, _.Style), de.getJSON(t, (e, t) => {
              e ? this.fire(new de.ErrorEvent(e)) : t && this._updateDiff(t, r);
            })) : "object" == typeof e && this._updateDiff(e, r);
          }
          _updateDiff(t, r) {
            try {
              this.style.setState(t, r) && this._update(!0);
            } catch (e) {
              de.warnOnce(`Unable to perform style diff: ${e.message || e.error || e}.  Rebuilding the style from scratch.`), this._updateStyle(t, r);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : de.warnOnce("There is no style added to the map.");
          }
          addSource(e, t) {
            return this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0);
          }
          isSourceLoaded(e) {
            var t = this.style && this.style.sourceCaches[e];
            if (void 0 !== t) return t.loaded();
            this.fire(new de.ErrorEvent(new Error(`There is no source with ID '${e}'`)));
          }
          setTerrain(t) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), t) {
              var e = this.style.sourceCaches[t.source];
              if (!e) throw new Error("cannot load terrain, because there exists no source with ID: " + t.source);
              for (const n in this.style._layers) {
                var r = this.style._layers[n];
                "hillshade" === r.type && r.source === t.source && de.warnOnce("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new Si(this.painter, e, t), this.painter.renderToTexture = new Ci(this.painter, this.terrain), this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = e => {
                "style" === e.dataType ? this.terrain.sourceCache.freeRtt() : "source" === e.dataType && e.tile && (e.sourceId !== t.source || this._elevationFreeze || (this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(e.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform._minEleveationForCurrentTile = 0, this.transform.elevation = 0;
            return this.fire(new de.Event("terrain", {
              terrain: t
            })), this;
          }
          getTerrain() {
            var e;
            return null != (e = null == (e = this.terrain) ? void 0 : e.options) ? e : null;
          }
          areTilesLoaded() {
            var e = this.style && this.style.sourceCaches;
            for (const n in e) {
              var t = e[n]._tiles;
              for (const i in t) {
                var r = t[i];
                if ("loaded" !== r.state && "errored" !== r.state) return !1;
              }
            }
            return !0;
          }
          addSourceType(e, t, r) {
            return this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, r);
          }
          removeSource(e) {
            return this.style.removeSource(e), this._update(!0);
          }
          getSource(e) {
            return this.style.getSource(e);
          }
          addImage(e, t, r = {}) {
            var n,
              i,
              o,
              a,
              {
                pixelRatio: r = 1,
                sdf: s = !1,
                stretchX: l,
                stretchY: c,
                content: u,
                contentMatch: h
              } = r;
            this._lazyInitEmptyStyle();
            if (!(t instanceof HTMLImageElement || de.isImageBitmap(t))) return void 0 === t.width || void 0 === t.height ? this.fire(new de.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : (({
              width: n,
              height: i,
              data: o
            } = t), a = t, this.style.addImage(e, {
              data: new de.RGBAImage({
                width: n,
                height: i
              }, new Uint8Array(o)),
              pixelRatio: r,
              stretchX: l,
              stretchY: c,
              content: u,
              contentMatch: h,
              sdf: s,
              version: 0,
              userImage: a
            }), a.onAdd && a.onAdd(this, e), this);
            (({
              width: n,
              height: i,
              data: o
            } = de.browser.getImageData(t))), this.style.addImage(e, {
              data: new de.RGBAImage({
                width: n,
                height: i
              }, o),
              pixelRatio: r,
              stretchX: l,
              stretchY: c,
              content: u,
              contentMatch: h,
              sdf: s,
              version: 0
            });
          }
          updateImage(e, t) {
            var r,
              n,
              i,
              o = this.style.getImage(e);
            return o ? (({
              width: i,
              height: r,
              data: n
            } = t instanceof HTMLImageElement || de.isImageBitmap(t) ? de.browser.getImageData(t) : t), void 0 === i || void 0 === r ? this.fire(new de.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : i !== o.data.width || r !== o.data.height ? this.fire(new de.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (i = !(t instanceof HTMLImageElement || de.isImageBitmap(t)), o.data.replace(n, i), this.style.updateImage(e, o), this)) : this.fire(new de.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          }
          getImage(e) {
            return this.style.getImage(e);
          }
          hasImage(e) {
            return e ? !!this.style.getImage(e) : (this.fire(new de.ErrorEvent(new Error("Missing required image id"))), !1);
          }
          removeImage(e) {
            this.style.removeImage(e);
          }
          loadImage(e, t) {
            f.getImage(this._requestManager.transformRequest(e, _.Image), t);
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(e, t) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0);
          }
          moveLayer(e, t) {
            return this.style.moveLayer(e, t), this._update(!0);
          }
          removeLayer(e) {
            return this.style.removeLayer(e), this._update(!0);
          }
          getLayer(e) {
            return this.style.getLayer(e);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(e, t, r) {
            return this.style.setLayerZoomRange(e, t, r), this._update(!0);
          }
          setFilter(e, t, r = {}) {
            return this.style.setFilter(e, t, r), this._update(!0);
          }
          getFilter(e) {
            return this.style.getFilter(e);
          }
          setPaintProperty(e, t, r, n = {}) {
            return this.style.setPaintProperty(e, t, r, n), this._update(!0);
          }
          getPaintProperty(e, t) {
            return this.style.getPaintProperty(e, t);
          }
          setLayoutProperty(e, t, r, n = {}) {
            return this.style.setLayoutProperty(e, t, r, n), this._update(!0);
          }
          getLayoutProperty(e, t) {
            return this.style.getLayoutProperty(e, t);
          }
          setGlyphs(e, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(e, t), this._update(!0);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(e, t, r = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(e, t, r, e => {
              e || this._update(!0);
            }), this;
          }
          removeSprite(e) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(e), this._update(!0);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(e, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(e, t, e => {
              e || this._update(!0);
            }), this;
          }
          setLight(e, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(e, t), this._update(!0);
          }
          getLight() {
            return this.style.getLight();
          }
          setFeatureState(e, t) {
            return this.style.setFeatureState(e, t), this._update();
          }
          removeFeatureState(e, t) {
            return this.style.removeFeatureState(e, t), this._update();
          }
          getFeatureState(e) {
            return this.style.getFeatureState(e);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let e = 0,
              t = 0;
            return this._container && (e = this._container.clientWidth || 400, t = this._container.clientHeight || 300), [e, t];
          }
          _setupContainer() {
            var e = this._container,
              t = (e.classList.add("maplibregl-map"), this._canvasContainer = m.create("div", "maplibregl-canvas-container", e)),
              t = (this._interactive && t.classList.add("maplibregl-interactive"), this._canvas = m.create("canvas", "maplibregl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region"), this._containerDimensions()),
              r = this._getClampedPixelRatio(t[0], t[1]);
            this._resizeCanvas(t[0], t[1], r);
            const n = this._controlContainer = m.create("div", "maplibregl-control-container", e),
              i = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(e => {
              i[e] = m.create("div", `maplibregl-ctrl-${e} `, n);
            }), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _setupCooperativeGestures() {
            var e = this._container;
            this._cooperativeGesturesScreen = m.create("div", "maplibregl-cooperative-gesture-screen", e);
            let t = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.windowsHelpText ? this._cooperativeGestures.windowsHelpText : "Use Ctrl + scroll to zoom the map";
            0 === navigator.platform.indexOf("Mac") && (t = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.macHelpText ? this._cooperativeGestures.macHelpText : "Use ⌘ + scroll to zoom the map");
            e = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.mobileHelpText ? this._cooperativeGestures.mobileHelpText : "Use two fingers to move the map";
            this._cooperativeGesturesScreen.innerHTML = `
            <div class="maplibregl-desktop-message">${t}</div>
            <div class="maplibregl-mobile-message">${e}</div>
        `, this._cooperativeGesturesScreen.setAttribute("aria-hidden", "true"), this._canvasContainer.addEventListener("wheel", this._cooperativeGesturesOnWheel, !1), this._canvasContainer.classList.add("maplibregl-cooperative-gestures");
          }
          _destroyCooperativeGestures() {
            m.remove(this._cooperativeGesturesScreen), this._canvasContainer.removeEventListener("wheel", this._cooperativeGesturesOnWheel, !1), this._canvasContainer.classList.remove("maplibregl-cooperative-gestures");
          }
          _resizeCanvas(e, t, r) {
            this._canvas.width = Math.floor(r * e), this._canvas.height = Math.floor(r * t), this._canvas.style.width = e + "px", this._canvas.style.height = t + "px";
          }
          _setupPainter() {
            const t = {
              alpha: !0,
              stencil: !0,
              depth: !0,
              failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
              preserveDrawingBuffer: this._preserveDrawingBuffer,
              antialias: this._antialias || !1
            };
            let r = null;
            this._canvas.addEventListener("webglcontextcreationerror", e => {
              r = {
                requestedAttributes: t
              }, e && (r.statusMessage = e.statusMessage, r.type = e.type);
            }, {
              once: !0
            });
            var e,
              n = this._canvas.getContext("webgl2", t) || this._canvas.getContext("webgl", t);
            if (!n) throw e = "Failed to initialize WebGL", r ? (r.message = e, new Error(JSON.stringify(r))) : new Error(e);
            this.painter = new _n(n, this.transform), I.testSupport(n);
          }
          _onCooperativeGesture(e, t, r) {
            return !t && r < 2 && (this._cooperativeGesturesScreen.classList.add("maplibregl-show"), setTimeout(() => {
              this._cooperativeGesturesScreen.classList.remove("maplibregl-show");
            }, 100)), !1;
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(e) {
            return this.style && this.style._loaded && (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint()), this;
          }
          _requestRenderFrame(e) {
            return this._update(), this._renderTaskQueue.add(e);
          }
          _cancelRenderFrame(e) {
            this._renderTaskQueue.remove(e);
          }
          _render(t) {
            var r = this._idleTriggered ? this._fadeDuration : 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t), !this._removed) {
              let e = !1;
              this.style && this._styleDirty && (this._styleDirty = !1, t = this.transform.zoom, n = de.browser.now(), this.style.zoomHistory.update(t, n), 1 === (n = (t = new de.EvaluationParameters(t, {
                now: n,
                fadeDuration: r,
                zoomHistory: this.style.zoomHistory,
                transition: this.style.getTransition()
              })).crossFadingFactor()) && n === this._crossFadingFactor || (e = !0, this._crossFadingFactor = n), this.style.update(t)), this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform._minEleveationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, r, this._crossSourceCollisions), this.painter.render(this.style, {
                showTileBoundaries: this.showTileBoundaries,
                showOverdrawInspector: this._showOverdrawInspector,
                rotating: this.isRotating(),
                zooming: this.isZooming(),
                moving: this.isMoving(),
                fadeDuration: r,
                showPadding: this.showPadding
              }), this.fire(new de.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, de.PerformanceUtils.mark(de.PerformanceMarkers.load), this.fire(new de.Event("load"))), this.style && (this.style.hasTransitions() || e) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
              var n = this._sourcesDirty || this._styleDirty || this._placementDirty;
              return n || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new de.Event("idle")), !this._loaded || this._fullyLoaded || n || (this._fullyLoaded = !0, de.PerformanceUtils.mark(de.PerformanceMarkers.fullLoad)), this;
            }
          }
          redraw() {
            return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;
          }
          remove() {
            this._hash && this._hash.remove();
            for (const t of this._controls) t.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, !1), f.removeThrottleControl(this._imageQueueHandle), null != (e = this._resizeObserver) && e.disconnect();
            var e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), m.remove(this._canvasContainer), m.remove(this._controlContainer), this._cooperativeGestures && this._destroyCooperativeGestures(), this._container.classList.remove("maplibregl-map"), de.PerformanceUtils.clearMetrics(), this._removed = !0, this.fire(new de.Event("remove"));
          }
          triggerRepaint() {
            this.style && !this._frame && (this._frame = de.browser.frame(e => {
              de.PerformanceUtils.frame(e), this._frame = null, this._render(e);
            }));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(e) {
            this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(e) {
            this._showPadding !== e && (this._showPadding = e, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(e) {
            this._showCollisionBoxes !== e && ((this._showCollisionBoxes = e) ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(e) {
            this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(e) {
            this._repaint !== e && (this._repaint = e, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(e) {
            this._vertices = e, this._update();
          }
          get version() {
            return Ai;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
        };
        const Ni = e => {
            e.touchstart = e.dragStart, e.touchmoveWindow = e.dragMove, e.touchend = e.dragEnd;
          },
          Pi = ({
            enable: e,
            clickTolerance: t,
            bearingDegreesPerPixelMoved: r = .8
          }) => {
            var n = new Yn();
            return new h({
              clickTolerance: t,
              move: (e, t) => ({
                bearingDelta: (t.x - e.x) * r
              }),
              moveStateManager: n,
              enable: e,
              assignEvents: Ni
            });
          },
          Di = ({
            enable: e,
            clickTolerance: t,
            pitchDegreesPerPixelMoved: r = -.5
          }) => {
            var n = new Yn();
            return new h({
              clickTolerance: t,
              move: (e, t) => ({
                pitchDelta: (t.y - e.y) * r
              }),
              moveStateManager: n,
              enable: e,
              assignEvents: Ni
            });
          },
          Ri = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1
          };
        class Oi {
          constructor(e, t, r = !1) {
            this.mousedown = e => {
              this.startMouse(de.extend({}, e, {
                ctrlKey: !0,
                preventDefault: () => e.preventDefault()
              }), m.mousePos(this.element, e)), m.addEventListener(window, "mousemove", this.mousemove), m.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = e => {
              this.moveMouse(e, m.mousePos(this.element, e));
            }, this.mouseup = e => {
              this.mouseRotate.dragEnd(e), this.mousePitch && this.mousePitch.dragEnd(e), this.offTemp();
            }, this.touchstart = e => {
              1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m.touchPos(this.element, e.targetTouches)[0], this.startTouch(e, this._startPos), m.addEventListener(window, "touchmove", this.touchmove, {
                passive: !1
              }), m.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = e => {
              1 !== e.targetTouches.length ? this.reset() : (this._lastPos = m.touchPos(this.element, e.targetTouches)[0], this.moveTouch(e, this._lastPos));
            }, this.touchend = e => {
              0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10;
            var n = e.dragRotate._mouseRotate.getClickTolerance(),
              i = e.dragRotate._mousePitch.getClickTolerance();
            this.element = t, this.mouseRotate = Gn({
              clickTolerance: n,
              enable: !0
            }), this.touchRotate = Pi({
              clickTolerance: n,
              enable: !0
            }), this.map = e, r && (this.mousePitch = qn({
              clickTolerance: i,
              enable: !0
            }), this.touchPitch = Di({
              clickTolerance: i,
              enable: !0
            })), m.addEventListener(t, "mousedown", this.mousedown), m.addEventListener(t, "touchstart", this.touchstart, {
              passive: !1
            }), m.addEventListener(t, "touchcancel", this.reset);
          }
          startMouse(e, t) {
            this.mouseRotate.dragStart(e, t), this.mousePitch && this.mousePitch.dragStart(e, t), m.disableDrag();
          }
          startTouch(e, t) {
            this.touchRotate.dragStart(e, t), this.touchPitch && this.touchPitch.dragStart(e, t), m.disableDrag();
          }
          moveMouse(e, t) {
            var r = this.map,
              n = (this.mouseRotate.dragMove(e, t) || {})["bearingDelta"];
            n && r.setBearing(r.getBearing() + n), this.mousePitch && (n = (this.mousePitch.dragMove(e, t) || {})["pitchDelta"], n) && r.setPitch(r.getPitch() + n);
          }
          moveTouch(e, t) {
            var r = this.map,
              n = (this.touchRotate.dragMove(e, t) || {})["bearingDelta"];
            n && r.setBearing(r.getBearing() + n), this.touchPitch && (n = (this.touchPitch.dragMove(e, t) || {})["pitchDelta"], n) && r.setPitch(r.getPitch() + n);
          }
          off() {
            var e = this.element;
            m.removeEventListener(e, "mousedown", this.mousedown), m.removeEventListener(e, "touchstart", this.touchstart, {
              passive: !1
            }), m.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), m.removeEventListener(window, "touchend", this.touchend), m.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            m.enableDrag(), m.removeEventListener(window, "mousemove", this.mousemove), m.removeEventListener(window, "mouseup", this.mouseup), m.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), m.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let d;
        function Mi(t, e = !1) {
          void 0 === d || e ? void 0 !== window.navigator.permissions ? window.navigator.permissions.query({
            name: "geolocation"
          }).then(e => {
            d = "denied" !== e.state, t(d);
          }).catch(() => {
            d = !!window.navigator.geolocation, t(d);
          }) : (d = !!window.navigator.geolocation, t(d)) : t(d);
        }
        function ki(e, t, r) {
          var n, i, o;
          for (e = new de.LngLat(e.lng, e.lat), t && (n = new de.LngLat(e.lng - 360, e.lat), i = new de.LngLat(e.lng + 360, e.lat), o = r.locationPoint(e).distSqr(t), r.locationPoint(n).distSqr(t) < o ? e = n : r.locationPoint(i).distSqr(t) < o && (e = i)); 180 < Math.abs(e.lng - r.center.lng);) {
            var a = r.locationPoint(e);
            if (0 <= a.x && 0 <= a.y && a.x <= r.width && a.y <= r.height) break;
            e.lng > r.center.lng ? e.lng -= 360 : e.lng += 360;
          }
          return e;
        }
        const Li = {
          center: "translate(-50%,-50%)",
          top: "translate(-50%,0)",
          "top-left": "translate(0,0)",
          "top-right": "translate(-100%,0)",
          bottom: "translate(-50%,-100%)",
          "bottom-left": "translate(0,-100%)",
          "bottom-right": "translate(-100%,-100%)",
          left: "translate(0,-50%)",
          right: "translate(-100%,-50%)"
        };
        function Ui(e, t, r) {
          var n = e.classList;
          for (const i in Li) n.remove(`maplibregl-${r}-anchor-` + i);
          n.add(`maplibregl-${r}-anchor-` + t);
        }
        class Fi extends de.Evented {
          constructor(e) {
            if (super(), this._onKeyPress = e => {
              var t = e.code,
                e = e.charCode || e.keyCode;
              "Space" !== t && "Enter" !== t && 32 !== e && 13 !== e || this.togglePopup();
            }, this._onMapClick = e => {
              var e = e.originalEvent.target,
                t = this._element;
              this._popup && (e === t || t.contains(e)) && this.togglePopup();
            }, this._update = r => {
              if (this._map) {
                var n = this._map.loaded() && !this._map.isMoving();
                "terrain" !== (null == r ? void 0 : r.type) && ("render" !== (null == r ? void 0 : r.type) || n) || this._map.once("render", this._update), this._map.transform.renderWorldCopies && (this._lngLat = ki(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
                let e = "",
                  t = ("viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (e = `rotateZ(${this._rotation - this._map.getBearing()}deg)`), "");
                "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? t = "rotateX(0deg)" : "map" === this._pitchAlignment && (t = `rotateX(${this._map.getPitch()}deg)`), r && "moveend" !== r.type || (this._pos = this._pos.round()), m.setTransform(this._element, `${Li[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${t} ` + e), this._map.terrain && !this._opacityTimeout && (this._opacityTimeout = setTimeout(() => {
                  var e = this._map.unproject(this._pos),
                    t = 40075016.686 * Math.abs(Math.cos(this._lngLat.lat * Math.PI / 180)) / Math.pow(2, this._map.transform.tileZoom + 8);
                  this._element.style.opacity = e.distanceTo(this._lngLat) > 20 * t ? "0.2" : "1.0", this._opacityTimeout = null;
                }, 100));
              }
            }, this._onMove = e => {
              var t;
              this._isDragging || (t = this._clickTolerance || this._map._clickTolerance, this._isDragging = e.point.dist(this._pointerdownPos) >= t), this._isDragging && (this._pos = e.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new de.Event("dragstart"))), this.fire(new de.Event("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new de.Event("dragend")), this._state = "inactive";
            }, this._addDragHandler = e => {
              this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(this._pos).add(this._offset), this._pointerdownPos = e.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && "auto" !== e.pitchAlignment ? e.pitchAlignment : this._rotationAlignment, e && e.element) this._element = e.element, this._offset = de.Point.convert(e && e.offset || [0, 0]);else {
              this._defaultMarker = !0, this._element = m.create("div"), this._element.setAttribute("aria-label", "Map marker");
              var t = m.createNS("http://www.w3.org/2000/svg", "svg"),
                r = (t.setAttributeNS(null, "display", "block"), t.setAttributeNS(null, "height", "41px"), t.setAttributeNS(null, "width", "27px"), t.setAttributeNS(null, "viewBox", "0 0 27 41"), m.createNS("http://www.w3.org/2000/svg", "g")),
                r = (r.setAttributeNS(null, "stroke", "none"), r.setAttributeNS(null, "stroke-width", "1"), r.setAttributeNS(null, "fill", "none"), r.setAttributeNS(null, "fill-rule", "evenodd"), m.createNS("http://www.w3.org/2000/svg", "g")),
                n = (r.setAttributeNS(null, "fill-rule", "nonzero"), m.createNS("http://www.w3.org/2000/svg", "g")),
                i = (n.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), n.setAttributeNS(null, "fill", "#000000"), [{
                  rx: "10.5",
                  ry: "5.25002273"
                }, {
                  rx: "10.5",
                  ry: "5.25002273"
                }, {
                  rx: "9.5",
                  ry: "4.77275007"
                }, {
                  rx: "8.5",
                  ry: "4.29549936"
                }, {
                  rx: "7.5",
                  ry: "3.81822308"
                }, {
                  rx: "6.5",
                  ry: "3.34094679"
                }, {
                  rx: "5.5",
                  ry: "2.86367051"
                }, {
                  rx: "4.5",
                  ry: "2.38636864"
                }]);
              for (const h of i) {
                var o = m.createNS("http://www.w3.org/2000/svg", "ellipse");
                o.setAttributeNS(null, "opacity", "0.04"), o.setAttributeNS(null, "cx", "10.5"), o.setAttributeNS(null, "cy", "5.80029008"), o.setAttributeNS(null, "rx", h.rx), o.setAttributeNS(null, "ry", h.ry), n.appendChild(o);
              }
              var i = m.createNS("http://www.w3.org/2000/svg", "g"),
                a = (i.setAttributeNS(null, "fill", this._color), m.createNS("http://www.w3.org/2000/svg", "path")),
                a = (a.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), i.appendChild(a), m.createNS("http://www.w3.org/2000/svg", "g")),
                s = (a.setAttributeNS(null, "opacity", "0.25"), a.setAttributeNS(null, "fill", "#000000"), m.createNS("http://www.w3.org/2000/svg", "path")),
                s = (s.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), a.appendChild(s), m.createNS("http://www.w3.org/2000/svg", "g")),
                l = (s.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), s.setAttributeNS(null, "fill", "#FFFFFF"), m.createNS("http://www.w3.org/2000/svg", "g")),
                c = (l.setAttributeNS(null, "transform", "translate(8.0, 8.0)"), m.createNS("http://www.w3.org/2000/svg", "circle")),
                u = (c.setAttributeNS(null, "fill", "#000000"), c.setAttributeNS(null, "opacity", "0.25"), c.setAttributeNS(null, "cx", "5.5"), c.setAttributeNS(null, "cy", "5.5"), c.setAttributeNS(null, "r", "5.4999962"), m.createNS("http://www.w3.org/2000/svg", "circle"));
              u.setAttributeNS(null, "fill", "#FFFFFF"), u.setAttributeNS(null, "cx", "5.5"), u.setAttributeNS(null, "cy", "5.5"), u.setAttributeNS(null, "r", "5.4999962"), l.appendChild(c), l.appendChild(u), r.appendChild(n), r.appendChild(i), r.appendChild(a), r.appendChild(s), r.appendChild(l), t.appendChild(r), t.setAttributeNS(null, "height", 41 * this._scale + "px"), t.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(t), this._offset = de.Point.convert(e && e.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", e => {
              e.preventDefault();
            }), this._element.addEventListener("mousedown", e => {
              e.preventDefault();
            }), Ui(this._element, this._anchor, "marker"), e && e.className) for (const d of e.className.split(" ")) this._element.classList.add(d);
            this._popup = null;
          }
          addTo(e) {
            return this.remove(), (this._map = e).getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), m.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e) {
            return this._lngLat = de.LngLat.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e) {
            var t;
            return this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e && ("offset" in e.options || (t = Math.abs(13.5) / Math.SQRT2, e.options.offset = this._defaultMarker ? {
              top: [0, 0],
              "top-left": [0, 0],
              "top-right": [0, 0],
              bottom: [0, -38.1],
              "bottom-left": [t, -1 * (24.6 + t)],
              "bottom-right": [-t, -1 * (24.6 + t)],
              left: [13.5, -24.6],
              right: [-13.5, -24.6]
            } : this._offset), this._popup = e, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress)), this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            var e = this._popup;
            return e && (e.isOpen() ? e.remove() : e.addTo(this._map)), this;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e) {
            return this._offset = de.Point.convert(e), this._update(), this;
          }
          addClassName(e) {
            this._element.classList.add(e);
          }
          removeClassName(e) {
            this._element.classList.remove(e);
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e);
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && "auto" !== e ? e : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
        }
        const Bi = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3
          },
          fitBoundsOptions: {
            maxZoom: 15
          },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0
        };
        let $i = 0,
          zi = !1;
        class Yi extends de.Evented {
          constructor(e) {
            super(), this._onSuccess = e => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) this._setErrorState(), this.fire(new de.Event("outofmaxbounds", e)), this._updateMarker();else {
                  if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                    case "WAITING_ACTIVE":
                    case "ACTIVE_LOCK":
                    case "ACTIVE_ERROR":
                      this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                      break;
                    case "BACKGROUND":
                    case "BACKGROUND_ERROR":
                      this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                      break;
                    default:
                      throw new Error("Unexpected watchState " + this._watchState);
                  }
                  this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new de.Event("geolocate", e));
                }
                this._finish();
              }
            }, this._updateCamera = e => {
              var t = new de.LngLat(e.coords.longitude, e.coords.latitude),
                e = e.coords.accuracy,
                r = this._map.getBearing(),
                r = de.extend({
                  bearing: r
                }, this.options.fitBoundsOptions),
                t = a.fromLngLat(t, e);
              this._map.fitBounds(t, r, {
                geolocateSource: !0
              });
            }, this._updateMarker = e => {
              var t;
              e ? (t = new de.LngLat(e.coords.longitude, e.coords.latitude), this._accuracyCircleMarker.setLngLat(t).addTo(this._map), this._userLocationDotMarker.setLngLat(t).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()) : (this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove());
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, this._onError = e => {
              if (this._map) {
                if (this.options.trackUserLocation) if (1 === e.code) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  var t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = t, this._geolocateButton.setAttribute("aria-label", t), void 0 !== this._geolocationWatchID && this._clearWatch();
                } else {
                  if (3 === e.code && zi) return;
                  this._setErrorState();
                }
                "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new de.Event("error", e)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = e => {
              this._map && (this._container.addEventListener("contextmenu", e => e.preventDefault()), this._geolocateButton = m.create("button", "maplibregl-ctrl-geolocate", this._container), m.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), !(this._geolocateButton.type = "button") === e ? (de.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled."), e = this._map._getUIString("GeolocateControl.LocationNotAvailable"), this._geolocateButton.disabled = !0, this._geolocateButton.title = e, this._geolocateButton.setAttribute("aria-label", e)) : (e = this._map._getUIString("GeolocateControl.FindMyLocation"), this._geolocateButton.title = e, this._geolocateButton.setAttribute("aria-label", e)), this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = m.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Fi({
                element: this._dotElement
              }), this._circleElement = m.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Fi({
                element: this._circleElement,
                pitchAlignment: "map"
              }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation) && this._map.on("movestart", e => {
                var t = e.originalEvent && "resize" === e.originalEvent.type;
                e.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new de.Event("trackuserlocationend")));
              });
            }, this.options = de.extend({}, Bi, e);
          }
          onAdd(e) {
            return this._map = e, this._container = m.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), Mi(this._setupUI), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), m.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, $i = 0, zi = !1;
          }
          _isOutOfMapMaxBounds(e) {
            var t = this._map.getMaxBounds(),
              e = e.coords;
            return t && (e.longitude < t.getWest() || e.longitude > t.getEast() || e.latitude < t.getSouth() || e.latitude > t.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error("Unexpected watchState " + this._watchState);
            }
          }
          _updateCircleRadius() {
            var e = this._map.getBounds(),
              t = e.getSouthEast(),
              e = e.getNorthEast(),
              t = t.distanceTo(e),
              e = this._map._container.clientHeight,
              t = Math.ceil(this._accuracy / (t / e) * 2);
            this._circleElement.style.width = t + "px", this._circleElement.style.height = t + "px";
          }
          trigger() {
            if (!this._setup) return de.warnOnce("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new de.Event("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  $i--, zi = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new de.Event("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new de.Event("trackuserlocationstart"));
                  break;
                default:
                  throw new Error("Unexpected watchState " + this._watchState);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error("Unexpected watchState " + this._watchState);
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();else if (void 0 === this._geolocationWatchID) {
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), $i++;
                let e;
                zi = 1 < $i ? (e = {
                  maximumAge: 6e5,
                  timeout: 0
                }, !0) : (e = this.options.positionOptions, !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }
        const Hi = {
          maxWidth: 100,
          unit: "metric"
        };
        function ji(e, t, r) {
          var n = r && r.maxWidth || 100,
            i = e._container.clientHeight / 2,
            o = e.unproject([0, i]),
            i = e.unproject([n, i]),
            o = o.distanceTo(i);
          r && "imperial" === r.unit ? 5280 < (i = 3.2808 * o) ? w(t, n, i / 5280, e._getUIString("ScaleControl.Miles")) : w(t, n, i, e._getUIString("ScaleControl.Feet")) : r && "nautical" === r.unit ? w(t, n, o / 1852, e._getUIString("ScaleControl.NauticalMiles")) : 1e3 <= o ? w(t, n, o / 1e3, e._getUIString("ScaleControl.Kilometers")) : w(t, n, o, e._getUIString("ScaleControl.Meters"));
        }
        function w(e, t, r, n) {
          var i = function (e) {
            var t = Math.pow(10, ("" + Math.floor(e)).length - 1);
            e /= t;
            return e = 10 <= e ? 10 : 5 <= e ? 5 : 3 <= e ? 3 : 2 <= e ? 2 : 1 <= e ? 1 : function (e) {
              var t = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));
              return Math.round(e * t) / t;
            }(e), t * e;
          }(r);
          e.style.width = t * (i / r) + "px", e.innerHTML = i + "&nbsp;" + n;
        }
        class Gi extends de.Evented {
          constructor(e = {}) {
            super(), this._onFullscreenChange = () => {
              (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = !1, e && e.container && (e.container instanceof HTMLElement ? this._container = e.container : de.warnOnce("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(e) {
            return this._map = e, this._container || (this._container = this._map.getContainer()), this._controlContainer = m.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            m.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            var e = this._fullscreenButton = m.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            m.create("span", "maplibregl-ctrl-icon", e).setAttribute("aria-hidden", "true"), e.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            var e = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", e), this._fullscreenButton.title = e;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new de.Event("fullscreenstart")), this._map._cooperativeGestures && (this._prevCooperativeGestures = this._map._cooperativeGestures, this._map.setCooperativeGestures())) : (this.fire(new de.Event("fullscreenend")), this._prevCooperativeGestures && (this._map.setCooperativeGestures(this._prevCooperativeGestures), delete this._prevCooperativeGestures));
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }
        const qi = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px"
          },
          Vi = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        class Ki extends de.Evented {
          constructor(e) {
            super(), this.remove = () => (this._content && m.remove(this._content), this._container && (m.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new de.Event("close")), this), this._onMouseUp = e => {
              this._update(e.point);
            }, this._onMouseMove = e => {
              this._update(e.point);
            }, this._onDrag = e => {
              this._update(e.point);
            }, this._update = r => {
              var n = this._lngLat || this._trackPointer;
              if (this._map && n && this._content) {
                if (!this._container) {
                  if (this._container = m.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = m.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const e of this.options.className.split(" ")) this._container.classList.add(e);
                  this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
                }
                if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = ki(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || r) {
                  n = this._pos = this._trackPointer && r ? r : this._map.project(this._lngLat);
                  let t = this.options.anchor;
                  r = Wi(this.options.offset);
                  if (!t) {
                    var i = this._container.offsetWidth,
                      o = this._container.offsetHeight;
                    let e;
                    e = n.y + r.bottom.y < o ? ["top"] : n.y > this._map.transform.height - o ? ["bottom"] : [], n.x < i / 2 ? e.push("left") : n.x > this._map.transform.width - i / 2 && e.push("right"), t = 0 === e.length ? "bottom" : e.join("-");
                  }
                  o = n.add(r[t]).round();
                  m.setTransform(this._container, `${Li[t]} translate(${o.x}px,${o.y}px)`), Ui(this._container, t, "popup");
                }
              }
            }, this._onClose = () => {
              this.remove();
            }, this.options = de.extend(Object.create(qi), e);
          }
          addTo(e) {
            return this._map && this.remove(), this._map = e, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new de.Event("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e) {
            return this._lngLat = de.LngLat.convert(e), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(e) {
            return this.setDOMContent(document.createTextNode(e));
          }
          setHTML(e) {
            var t,
              r = document.createDocumentFragment(),
              n = document.createElement("body");
            for (n.innerHTML = e;;) {
              if (!(t = n.firstChild)) break;
              r.appendChild(t);
            }
            return this.setDOMContent(r);
          }
          getMaxWidth() {
            var e;
            return null == (e = this._container) ? void 0 : e.style.maxWidth;
          }
          setMaxWidth(e) {
            return this.options.maxWidth = e, this._update(), this;
          }
          setDOMContent(e) {
            if (this._content) for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);else this._content = m.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(e), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(e) {
            this._container && this._container.classList.add(e);
          }
          removeClassName(e) {
            this._container && this._container.classList.remove(e);
          }
          setOffset(e) {
            return this.options.offset = e, this._update(), this;
          }
          toggleClassName(e) {
            if (this._container) return this._container.classList.toggle(e);
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = m.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            var e;
            this.options.focusAfterOpen && this._container && (e = this._container.querySelector(Vi)) && e.focus();
          }
        }
        function Wi(e) {
          var t;
          return e ? "number" == typeof e ? (t = Math.round(Math.abs(e) / Math.SQRT2), {
            center: new de.Point(0, 0),
            top: new de.Point(0, e),
            "top-left": new de.Point(t, t),
            "top-right": new de.Point(-t, t),
            bottom: new de.Point(0, -e),
            "bottom-left": new de.Point(t, -t),
            "bottom-right": new de.Point(-t, -t),
            left: new de.Point(e, 0),
            right: new de.Point(-e, 0)
          }) : e instanceof de.Point || Array.isArray(e) ? {
            center: t = de.Point.convert(e),
            top: t,
            "top-left": t,
            "top-right": t,
            bottom: t,
            "bottom-left": t,
            "bottom-right": t,
            left: t,
            right: t
          } : {
            center: de.Point.convert(e.center || [0, 0]),
            top: de.Point.convert(e.top || [0, 0]),
            "top-left": de.Point.convert(e["top-left"] || [0, 0]),
            "top-right": de.Point.convert(e["top-right"] || [0, 0]),
            bottom: de.Point.convert(e.bottom || [0, 0]),
            "bottom-left": de.Point.convert(e["bottom-left"] || [0, 0]),
            "bottom-right": de.Point.convert(e["bottom-right"] || [0, 0]),
            left: de.Point.convert(e.left || [0, 0]),
            right: de.Point.convert(e.right || [0, 0])
          } : Wi(new de.Point(0, 0));
        }
        const Zi = function (e, ...t) {
            return de.extend(e, ...t);
          },
          Xi = A;
        class T {
          static get version() {
            return Xi;
          }
          static get workerCount() {
            return n.workerCount;
          }
          static set workerCount(e) {
            n.workerCount = e;
          }
          static get maxParallelImageRequests() {
            return de.config.MAX_PARALLEL_IMAGE_REQUESTS;
          }
          static set maxParallelImageRequests(e) {
            de.config.MAX_PARALLEL_IMAGE_REQUESTS = e;
          }
          static get workerUrl() {
            return de.config.WORKER_URL;
          }
          static set workerUrl(e) {
            de.config.WORKER_URL = e;
          }
          static addProtocol(e, t) {
            de.config.REGISTERED_PROTOCOLS[e] = t;
          }
          static removeProtocol(e) {
            delete de.config.REGISTERED_PROTOCOLS[e];
          }
        }
        return T.Map = e, T.NavigationControl = class {
          constructor(e) {
            this._updateZoomButtons = () => {
              var e = this._map.getZoom(),
                t = e === this._map.getMaxZoom(),
                e = e === this._map.getMinZoom();
              this._zoomInButton.disabled = t, this._zoomOutButton.disabled = e, this._zoomInButton.setAttribute("aria-disabled", t.toString()), this._zoomOutButton.setAttribute("aria-disabled", e.toString());
            }, this._rotateCompassArrow = () => {
              var e = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
              this._compassIcon.style.transform = e;
            }, this._setButtonTitle = (e, t) => {
              t = this._map._getUIString("NavigationControl." + t);
              e.title = t, e.setAttribute("aria-label", t);
            }, this.options = de.extend({}, Ri, e), this._container = m.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", e => e.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", e => this._map.zoomIn({}, {
              originalEvent: e
            })), m.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", e => this._map.zoomOut({}, {
              originalEvent: e
            })), m.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", e => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                originalEvent: e
              }) : this._map.resetNorth({}, {
                originalEvent: e
              });
            }), this._compassIcon = m.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(e) {
            return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Oi(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            m.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(e, t) {
            e = m.create("button", e, this._container);
            return e.type = "button", e.addEventListener("click", t), e;
          }
        }, T.GeolocateControl = Yi, T.AttributionControl = yi, T.LogoControl = vi, T.ScaleControl = class {
          constructor(e) {
            this._onMove = () => {
              ji(this._map, this._container, this.options);
            }, this.setUnit = e => {
              this.options.unit = e, ji(this._map, this._container, this.options);
            }, this.options = de.extend({}, Hi, e);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e) {
            return this._map = e, this._container = m.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            m.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, T.FullscreenControl = Gi, T.TerrainControl = class {
          constructor(e) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.disableTerrain")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.enableTerrain"));
            }, this.options = e;
          }
          onAdd(e) {
            return this._map = e, this._container = m.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = m.create("button", "maplibregl-ctrl-terrain", this._container), m.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            m.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, T.Popup = Ki, T.Marker = Fi, T.Style = o, T.LngLat = de.LngLat, T.LngLatBounds = a, T.Point = de.Point, T.MercatorCoordinate = de.MercatorCoordinate, T.Evented = de.Evented, T.AJAXError = de.AJAXError, T.config = de.config, T.CanvasSource = se, T.GeoJSONSource = ne, T.ImageSource = v, T.RasterDEMTileSource = re, T.RasterTileSource = te, T.VectorTileSource = ee, T.VideoSource = ae, T.setRTLTextPlugin = de.setRTLTextPlugin, T.getRTLTextPluginStatus = de.getRTLTextPluginStatus, T.prewarm = function () {
          Pe().acquire(Ie);
        }, T.clearPrewarmedResources = function () {
          var e = Ne;
          e && (e.isPreloaded() && 1 === e.numActive() ? (e.release(Ie), Ne = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, Zi(T, {
          isSafari: de.isSafari,
          getPerformanceMetrics: de.PerformanceUtils.getPerformanceMetrics
        }), T;
      }), a;
    }, azuremapsMaplibreGlDev.exports = e();
  }(), azuremapsMaplibreGlDev.exports),
  maplibregl = getDefaultExportFromCjs(azuremapsMaplibreGlDevExports),
  env = {
    domain: "atlas.microsoft.com",
    staticAssetsDomain: "atlas.microsoft.com",
    stylePath: "styling",
    styleDefinitionsVersion: "2023-01-01",
    appInsightsKey: "e96cb745-c6f5-409c-a775-c4313e468c1d",
    aadInstance: "https://login.microsoftonline.com/"
  },
  constants = {
    apiVersionQueryParameter: "api-version",
    authorizationHeaderName: "Authorization",
    authorizationTokenPrefix: "Bearer ",
    jwtSasPrefix: "jwt-sas ",
    domainPlaceHolder: "{{azMapsDomain}}",
    legacyDomainPlaceHolder: "{azMapsDomain}",
    viewPlaceHolder: "{{azMapsView}}",
    viewParameter: "view",
    languagePlaceHolder: "{{azMapsLanguage}}",
    stylePathHolder: "{{azMapsStylingPath}}",
    styleResourcePlaceholder: "{{azMapsStylePath}}",
    stylePath: "styling",
    styleResourcePath: "styles",
    styleApiVersion: "2.0",
    mapAgentHeaderName: "Map-Agent",
    msClientIdHeaderName: "x-ms-client-id",
    msOriginHeaderName: "Ms-Am-Request-Origin",
    msOriginHeaderValue: "MapControl",
    aadResourceId: "https://atlas.microsoft.com/.default",
    sessionIdHeaderName: "Session-Id"
  },
  __values$k = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  Options = function () {
    function c() {}
    return c.prototype.merge = function () {
      for (var t, e, r, n = [], i = 0; i < arguments.length; i++) n[i] = arguments[i];
      try {
        for (var o = __values$k(n), a = o.next(); !a.done; a = o.next()) {
          var s = a.value;
          if (s) for (var l in s) s.hasOwnProperty(l) && this.hasOwnProperty(l) && (void 0 !== s[l] && null != s[l] ? this[l] instanceof c ? this[l].merge(s[l]) : this[l] = s[l] : (r = r || new (Object.getPrototypeOf(this).constructor)(), this[l] = r[l]));
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          a && !a.done && (e = o.return) && e.call(o);
        } finally {
          if (t) throw t.error;
        }
      }
      return this;
    }, c;
  }(),
  __extends$1j = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __read$h = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  UrlOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.domain = void 0, e.headers = {}, e.path = "", e.protocol = "https", e.queryParams = {}, e.subdomain = "", e;
    }
    return __extends$1j(e, t), e;
  }(Options),
  Url = function () {
    function n(e) {
      this.options = new UrlOptions().merge(e);
    }
    return n.prototype.get = function () {
      return fetch(this.toString(), {
        method: "GET",
        mode: "cors",
        headers: new Headers(this.options.headers)
      }).then(function (e) {
        if (e.ok) return e.json();
        throw new Error("HTTP ".concat(e.status, ": ").concat(e.statusText));
      });
    }, n.prototype.toString = function () {
      var e = Object.entries(this.options.queryParams).map(function (e) {
          var e = __read$h(e, 2),
            t = e[0],
            e = e[1];
          return "".concat(t, "=").concat(e);
        }).join("&"),
        t = [],
        r = this.options.path || "";
      return n.protoRegEx.test(r) ? t.push(r) : (this.options.domain && (n.protoRegEx.test(this.options.domain) || (t.push("".concat(this.options.protocol, "://")), t.push(this.options.subdomain ? "".concat(this.options.subdomain, ".") : "")), t.push(this.options.domain)), t.push(this.options.path ? "/".concat(r) : "")), t.push(e ? "?".concat(e) : ""), t.join("");
    }, n.protoRegEx = new RegExp(/^(((file|http|https):\/\/)|blob:)/i), n;
  }(),
  version$3 = "3.1.2",
  Version$1 = function () {
    function e() {}
    return e.getFullVersion = function () {
      return version$3;
    }, e.getEndpointVersion = function () {
      var e = version$3.indexOf(".");
      return -1 === (e = version$3.indexOf(".", e + 1)) ? version$3 : version$3.substring(0, e);
    }, e;
  }(),
  tooltipVerticalOffset = 4,
  buildAccessibleTooltip = function (e) {
    var t = document.createElement("span");
    return t.innerText = e, t.classList.add("tooltiptext"), -1 != navigator.userAgent.indexOf("Edg") ? t.classList.add("edge") : -1 != navigator.userAgent.indexOf("Chrome") ? t.classList.add("chrome") : -1 != navigator.userAgent.indexOf("Safari") ? t.classList.add("safari") : -1 != navigator.userAgent.indexOf("Firefox") && t.classList.add("firefox"), -1 != navigator.userAgent.indexOf("Windows") ? t.classList.add("win") : -1 != navigator.userAgent.indexOf("Macintosh") && t.classList.add("mac"), t;
  },
  positionTooltip = function (i, o, a) {
    void 0 === a && (a = !1);
    function e(e) {
      var t = o.getBoundingClientRect(),
        r = i.getBoundingClientRect(),
        n = t.x + r.width > window.innerWidth ? window.innerWidth - r.width : t.x,
        r = t.y + t.height + r.height + tooltipVerticalOffset > window.innerHeight ? t.y - r.height - tooltipVerticalOffset : t.y + t.height + tooltipVerticalOffset;
      a && o.parentElement && (t = o.parentElement ? o.parentElement.getBoundingClientRect() : null, i.style.position = "absolute", n -= t.x, r -= t.y), i.style.transform = "translate(".concat(n, "px, ").concat(r, "px)"), i.style.display = "block";
    }
    o.addEventListener("mouseover", e), o.addEventListener("focusin", e), o.addEventListener("keydown", function (e) {
      "Escape" !== e.key && "Esc" !== e.key || "block" !== i.style.display || (e.stopPropagation(), i.style.display = "none");
    });
  },
  __extends$1i = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  ControlOptions = (!function (e) {
    e.TopLeft = "top-left", e.TopRight = "top-right", e.BottomLeft = "bottom-left", e.BottomRight = "bottom-right", e.NonFixed = "non-fixed";
  }(ControlPosition = ControlPosition || {}), function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.position = ControlPosition.NonFixed, e;
    }
    return __extends$1i(e, t), e;
  }(Options)),
  Color = function () {
    function e(e) {
      var t;
      e && (t = void 0, 3 <= (t = "string" == typeof e ? this.getRBGA(e) : e).length) && (this.r = t[0], this.g = t[1], this.b = t[2], 3 < t.length) && (this.a = t[3]);
    }
    return e.prototype.getLuminosity = function () {
      for (var e = [this.r, this.g, this.b], t = [], r = 0; r < e.length; r++) {
        var n = e[r] / 255;
        t[r] = n <= .03928 ? n / 12.92 : Math.pow((.055 + n) / 1.055, 2.4);
      }
      return .2126 * t[0] + .7152 * t[1] + .0722 * t[2];
    }, e.prototype.getRBGA = function (e) {
      var t = document.createElement("canvas").getContext("2d"),
        e = (t.globalAlpha = 1, t.fillStyle = e, t.fillRect(0, 0, 1, 1), t.getImageData(0, 0, 1, 1).data);
      return [e[0], e[1], e[2], e[3]];
    }, e;
  }(),
  Dictionary = (!function (e) {
    e.light = "light", e.dark = "dark", e.auto = "auto";
  }(ControlStyle = ControlStyle || {}), Map),
  EventEmitter = function () {
    function e() {
      this.listeners = new Dictionary();
    }
    return e.prototype._addEventListener = function (e, t, r) {
      this.listeners.has(e) || this.listeners.set(e, new Dictionary()), this.listeners.get(e).set(t, r);
    }, e.prototype._removeEventListener = function (e, t) {
      this.listeners.has(e) && this.listeners.get(e).delete(t);
    }, e.prototype._invokeEvent = function (r, n) {
      var i = this;
      this.listeners.has(r) && this.listeners.get(r).forEach(function (e, t) {
        e && i._removeEventListener(r, t);
        try {
          t(n);
        } catch (e) {
          console.error(e);
        }
      });
    }, e;
  }(),
  index$5 = Object.freeze({
    __proto__: null,
    EventEmitter: EventEmitter
  }),
  __extends$1h = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  ControlBase = function (e) {
    function t() {
      var t = null !== e && e.apply(this, arguments) || this;
      return t._onStyleChange = function () {
        t._map.getStyle().style.toLowerCase().startsWith("blank") ? t._observer || (t._onBackgroundChange(), t._observer = new MutationObserver(t._onBackgroundChange), t._observer.observe(t._map.getMapContainer(), {
          attributes: !0,
          attributeFilter: ["style"]
        })) : (t._observer && (t._observer.disconnect(), delete t._observer), t._map.styles.getThemeAsync(t._map.getStyle()).then(function (e) {
          t._setTheme(e);
        }));
      }, t._onBackgroundChange = function () {
        var e = new Color(t._map.getMapContainer().style.backgroundColor).getLuminosity(),
          e = isNaN(e) || .5 < e ? ControlStyle.light : ControlStyle.dark;
        t._setTheme(e);
      }, t;
    }
    return __extends$1h(t, e), t.prototype.onRemove = function () {
      this._container && (this._container.remove(), delete this._container), this._map && (this._map.events.remove("stylechanged", this._onStyleChange), delete this._map), this._observer && (this._observer.disconnect(), delete this._observer), delete this._theme;
    }, t.prototype.buildContainer = function (e, t, r, n) {
      return this._map = e, this._container = document.createElement(n || "div"), this._container.classList.add("azure-maps-control-container"), "string" == typeof r && this._container.setAttribute("aria-label", r), t.toLowerCase() === ControlStyle.auto ? this._map && this._map.events.add("stylechanged", this._onStyleChange) : this._container.classList.add(t), this._container;
    }, t.prototype._setTheme = function (e) {
      this._theme !== e && (this._container.classList.remove(this._theme), this._container.classList.add(e), this._theme = e);
    }, t.activateClickDelay = 100, t;
  }(EventEmitter),
  __extends$1g = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  CompassControlOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.rotationDegreesDelta = 15, e.style = ControlStyle.light, e.inverted = !1, e;
    }
    return __extends$1g(e, t), e;
  }(Options),
  __extends$1f = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  CompassControl = function (r) {
    function s(e) {
      var t = r.call(this) || this;
      return t.hasMouse = !1, t.hasFocus = !1, t.options = new CompassControlOptions().merge(e), t;
    }
    return __extends$1f(s, r), s.prototype.onAdd = function (e, t) {
      var r = this,
        n = this.buildContainer(e, this.options.style, "Rotation Control"),
        i = this.constructRotationButton(e),
        o = this.constructRotationGrid(e, t),
        a = buildAccessibleTooltip("Reset to Default Rotation");
      return n.addEventListener("mouseover", function (e) {
        r.lastActiveTime = r.lastActiveTime || e.timeStamp, r.hasMouse = !0, n.classList.add("in-use"), o.classList.remove("hidden-accessible-element");
      }), n.addEventListener("focusin", function (e) {
        r.lastActiveTime = r.lastActiveTime || e.timeStamp, r.hasFocus = !0, n.classList.add("in-use"), o.classList.remove("hidden-accessible-element");
      }), n.addEventListener("mouseleave", function () {
        r.hasMouse = !1, r.hasFocus || (delete r.lastActiveTime, n.classList.remove("in-use"), o.classList.add("hidden-accessible-element"));
      }), n.addEventListener("focusout", function (e) {
        e.relatedTarget instanceof Node && n.contains(e.relatedTarget) || (r.hasFocus = !1, r.hasMouse) || (delete r.lastActiveTime, n.classList.remove("in-use"), o.classList.add("hidden-accessible-element"));
      }), o.addEventListener("keydown", function (e) {
        "Escape" !== e.key && "Esc" !== e.key || (e.stopPropagation(), i.focus(), n.classList.remove("in-use"), o.classList.add("hidden-accessible-element"));
      }), i.addEventListener("keydown", function (e) {
        "Escape" !== e.key && "Esc" !== e.key || null == n || !n.classList.contains("in-use") || "none" !== (null == a ? void 0 : a.style.display) || (e.stopPropagation(), n.classList.remove("in-use"), o.classList.add("hidden-accessible-element"));
      }), t && s.InvertOrderPositions.includes(t.position) ? (n.appendChild(o), n.appendChild(i), n.appendChild(a), positionTooltip(a, i)) : (n.appendChild(i), n.appendChild(a), positionTooltip(a, i), n.appendChild(o)), n;
    }, s.prototype.constructRotationGrid = function (e, t) {
      var r = document.createElement("div"),
        n = (r.classList.add("sub-container"), r.classList.add("hidden-accessible-element"), this.constructRightRotationButton(e)),
        e = this.constructLeftRotationButton(e),
        i = buildAccessibleTooltip("Rotate Left"),
        o = buildAccessibleTooltip("Rotate Right");
      return t && s.InvertOrderPositions.includes(t.position) ? (r.appendChild(n), r.appendChild(o), positionTooltip(o, n), r.appendChild(e), r.appendChild(i), positionTooltip(i, e)) : (r.appendChild(e), r.appendChild(i), positionTooltip(i, e), r.appendChild(n), r.appendChild(o), positionTooltip(o, n)), r;
    }, s.prototype.constructRotationButton = function (t) {
      var r = this,
        e = document.createElement("button"),
        n = (e.classList.add("azure-maps-control-button"), e.classList.add("rotation"), e.setAttribute("aria-label", "Reset to Default Rotation"), e.setAttribute("alt", "Reset to Default Rotation"), e.setAttribute("type", "button"), document.createElement("div"));
      return e.appendChild(n), e.addEventListener("click", function (e) {
        e.timeStamp - r.lastActiveTime > ControlBase.activateClickDelay && t.setCamera({
          bearing: s.DefaultRotation
        }, !0);
      }), t.events.add("rotate", function (e) {
        n.style.transform = "rotate(".concat(-e.map.getCamera().bearing, "deg)");
      }), e;
    }, s.prototype.constructRightRotationButton = function (e) {
      var t = this,
        r = document.createElement("button");
      return r.classList.add("azure-maps-control-button"), r.classList.add("rotation-right"), r.setAttribute("aria-label", "Rotate Right"), r.setAttribute("alt", "Rotate Right"), r.setAttribute("type", "button"), r.addEventListener("click", function () {
        e.setCamera({
          bearing: e.getCamera().bearing - (t.options.inverted ? -1 : 1) * t.options.rotationDegreesDelta,
          duration: s.RotationDuration,
          type: "ease"
        }, !0);
      }), r;
    }, s.prototype.constructLeftRotationButton = function (e) {
      var t = this,
        r = document.createElement("button");
      return r.classList.add("azure-maps-control-button"), r.classList.add("rotation-left"), r.setAttribute("aria-label", "Rotate Left"), r.setAttribute("alt", "Rotate Left"), r.setAttribute("type", "button"), r.addEventListener("click", function () {
        e.setCamera({
          bearing: e.getCamera().bearing + (t.options.inverted ? -1 : 1) * t.options.rotationDegreesDelta,
          duration: s.RotationDuration,
          type: "ease"
        }, !0);
      }), r;
    }, s.DefaultRotation = 0, s.RotationDuration = 100, s.InvertOrderPositions = [ControlPosition.BottomRight, ControlPosition.TopRight], s;
  }(ControlBase),
  __extends$1e = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  PitchControlOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.pitchDegreesDelta = 10, e.style = ControlStyle.light, e.inverted = !1, e;
    }
    return __extends$1e(e, t), e;
  }(Options),
  __extends$1d = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  PitchControl = function (t) {
    function s(e) {
      var r = t.call(this) || this;
      return r.container = null, r.map = null, r.pitchButton = null, r.pitchIncrementButton = null, r.pitchDecrementButton = null, r.hasMouse = !1, r.hasFocus = !1, r.pitchChanged = function (e) {
        return r.updatePitchButtonsState();
      }, r.updatePitchButtonsState = function () {
        var e = r.map.getCamera().pitch <= 0,
          t = 60 <= r.map.getCamera().pitch;
        r.hasFocus && r.pitchButton && (e || t) && r.pitchButton.focus(), r.options.inverted ? (r.pitchIncrementButton && r.pitchIncrementButton.disabled != e && (r.pitchIncrementButton.disabled = e), r.pitchDecrementButton && r.pitchDecrementButton.disabled != t && (r.pitchDecrementButton.disabled = t)) : (r.pitchIncrementButton && r.pitchIncrementButton.disabled != t && (r.pitchIncrementButton.disabled = t), r.pitchDecrementButton && r.pitchDecrementButton.disabled != e && (r.pitchDecrementButton.disabled = e));
      }, r.options = new PitchControlOptions().merge(e), r;
    }
    return __extends$1d(s, t), s.prototype.onAdd = function (e, t) {
      var r = this,
        n = this.buildContainer(e, this.options.style, "Pitch Control"),
        i = this.constructPitchButton(e),
        o = this.constructPitchGrid(e, t),
        a = buildAccessibleTooltip("Reset to Default Pitch");
      return n.addEventListener("mouseover", function (e) {
        r.lastActiveTime = r.lastActiveTime || e.timeStamp, r.hasMouse = !0, n.classList.add("in-use"), o.classList.remove("hidden-accessible-element");
      }), n.addEventListener("focusin", function (e) {
        r.lastActiveTime = r.lastActiveTime || e.timeStamp, r.hasFocus = !0, n.classList.add("in-use"), o.classList.remove("hidden-accessible-element");
      }), n.addEventListener("mouseleave", function () {
        r.hasMouse = !1, r.hasFocus || (delete r.lastActiveTime, n.classList.remove("in-use"), o.classList.add("hidden-accessible-element"));
      }), n.addEventListener("focusout", function (e) {
        e.relatedTarget instanceof Node && n.contains(e.relatedTarget) || (r.hasFocus = !1, r.hasMouse) || (delete r.lastActiveTime, n.classList.remove("in-use"), o.classList.add("hidden-accessible-element"));
      }), o.addEventListener("keydown", function (e) {
        "Escape" !== e.key && "Esc" !== e.key || (e.stopPropagation(), i.focus(), n.classList.remove("in-use"), o.classList.add("hidden-accessible-element"));
      }), i.addEventListener("keydown", function (e) {
        "Escape" !== e.key && "Esc" !== e.key || null == n || !n.classList.contains("in-use") || "none" !== (null == a ? void 0 : a.style.display) || (e.stopPropagation(), n.classList.remove("in-use"), o.classList.add("hidden-accessible-element"));
      }), t && s.INVERT_ORDER_POSITIONS.includes(t.position) ? (n.appendChild(o), n.appendChild(i), n.appendChild(a), positionTooltip(a, n)) : (n.appendChild(i), n.appendChild(a), positionTooltip(a, n), n.appendChild(o)), this.map = e, this.container = n, this.pitchButton = i, e.events.add("pitch", this.pitchChanged), this.updatePitchButtonsState(), n;
    }, s.prototype.onRemove = function () {
      this.container && (this.container.remove(), this.container = null, this.pitchButton = null, this.pitchIncrementButton = null, this.pitchDecrementButton = null), this.map && (this.map.events.remove("pitch", this.pitchChanged), this.map = null);
    }, s.prototype.constructPitchGrid = function (e, t) {
      var r = document.createElement("div"),
        e = (r.classList.add("sub-container"), r.classList.add("hidden-accessible-element"), this.pitchIncrementButton = this.constructPitchIncrementButton(e), this.pitchDecrementButton = this.constructPitchDecrementButton(e), buildAccessibleTooltip("Increase Pitch")),
        n = buildAccessibleTooltip("Decrease Pitch");
      return t && s.INVERT_ORDER_POSITIONS.includes(t.position) ? (r.appendChild(this.pitchDecrementButton), r.appendChild(n), positionTooltip(n, this.pitchDecrementButton), r.appendChild(this.pitchIncrementButton), r.appendChild(e), positionTooltip(e, this.pitchIncrementButton)) : (r.appendChild(this.pitchIncrementButton), r.appendChild(e), positionTooltip(e, this.pitchIncrementButton), r.appendChild(this.pitchDecrementButton), r.appendChild(n), positionTooltip(n, this.pitchDecrementButton)), r;
    }, s.prototype.constructPitchButton = function (e) {
      var t = this,
        r = document.createElement("button");
      return r.classList.add("azure-maps-control-button"), r.classList.add("pitch"), r.setAttribute("aria-label", "Reset to Default Pitch"), r.setAttribute("alt", "Reset to Default Pitch"), r.setAttribute("type", "button"), r.addEventListener("click", function () {
        event.timeStamp - t.lastActiveTime > ControlBase.activateClickDelay && e.setCamera({
          pitch: s.DEFAULT_PITCH
        }, !0);
      }), r;
    }, s.prototype.constructPitchDecrementButton = function (e) {
      var t = this,
        r = document.createElement("button");
      return r.classList.add("azure-maps-control-button"), r.classList.add("pitch-down"), r.setAttribute("aria-label", "Decrease Pitch"), r.setAttribute("alt", "Decrease Pitch"), r.setAttribute("type", "button"), r.addEventListener("click", function () {
        e.setCamera({
          pitch: e.getCamera().pitch - (t.options.inverted ? -1 : 1) * t.options.pitchDegreesDelta,
          duration: s.PITCH_DURATION_MS,
          type: "ease"
        }, !0);
      }), r;
    }, s.prototype.constructPitchIncrementButton = function (e) {
      var t = this,
        r = document.createElement("button");
      return r.classList.add("azure-maps-control-button"), r.classList.add("pitch-up"), r.setAttribute("aria-label", "Increase Pitch"), r.setAttribute("alt", "Increase Pitch"), r.setAttribute("type", "button"), r.addEventListener("click", function () {
        e.setCamera({
          pitch: e.getCamera().pitch + (t.options.inverted ? -1 : 1) * t.options.pitchDegreesDelta,
          duration: s.PITCH_DURATION_MS,
          type: "ease"
        }, !0);
      }), r;
    }, s.PITCH_DURATION_MS = 100, s.DEFAULT_PITCH = 0, s.INVERT_ORDER_POSITIONS = [ControlPosition.BottomRight, ControlPosition.TopRight], s;
  }(ControlBase),
  __extends$1c = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  ScaleControl = function (r) {
    function e(e) {
      var t = r.call(this) || this;
      return t.map = null, t.control = new maplibregl.ScaleControl({
        maxWidth: null == e ? void 0 : e.maxWidth,
        unit: null == e ? void 0 : e.unit
      }), t;
    }
    return __extends$1c(e, r), e.prototype.onAdd = function (e, t) {
      this.map = e, null != (r = null == (r = this.map) ? void 0 : r._getMap()) && r.addControl(this.control);
      var r = this.buildContainer(e, ControlStyle.auto, "Scale Bar");
      return r.appendChild(null == (e = this.control) ? void 0 : e._container), r;
    }, e.prototype.onRemove = function () {
      var e;
      r.prototype.onRemove.call(this), null != (e = null == (e = this.map) ? void 0 : e._getMap()) && e.removeControl(this.control), this.map = null;
    }, e.prototype.setUnit = function (e) {
      var t;
      null != (t = this.control) && t.setUnit(e);
    }, e;
  }(ControlBase);
function listCacheClear$1() {
  this.__data__ = [], this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$5(e, t) {
  return e === t || e != e && t != t;
}
var eq_1 = eq$5,
  eq$4 = eq_1;
function assocIndexOf$4(e, t) {
  for (var r = e.length; r--;) if (eq$4(e[r][0], t)) return r;
  return -1;
}
var _assocIndexOf = assocIndexOf$4,
  assocIndexOf$3 = _assocIndexOf,
  arrayProto = Array.prototype,
  splice = arrayProto.splice;
function listCacheDelete$1(e) {
  var t = this.__data__,
    e = assocIndexOf$3(t, e);
  return !(e < 0 || (e == t.length - 1 ? t.pop() : splice.call(t, e, 1), --this.size, 0));
}
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(e) {
  var t = this.__data__,
    e = assocIndexOf$2(t, e);
  return e < 0 ? void 0 : t[e][1];
}
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(e) {
  return -1 < assocIndexOf$1(this.__data__, e);
}
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(e, t) {
  var r = this.__data__,
    n = assocIndexOf(r, e);
  return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this;
}
var listCacheClear = _listCacheClear,
  listCacheDelete = listCacheDelete$1,
  listCacheGet = listCacheGet$1,
  listCacheHas = listCacheHas$1,
  listCacheSet = listCacheSet$1;
function ListCache$4(e) {
  var t = -1,
    r = null == e ? 0 : e.length;
  for (this.clear(); ++t < r;) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear, ListCache$4.prototype.delete = listCacheDelete, ListCache$4.prototype.get = listCacheGet, ListCache$4.prototype.has = listCacheHas, ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4,
  ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3(), this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(e) {
  var t = this.__data__,
    e = t.delete(e);
  return this.size = t.size, e;
}
var _stackDelete = stackDelete$1;
function stackGet$1(e) {
  return this.__data__.get(e);
}
var _stackGet = stackGet$1;
function stackHas$1(e) {
  return this.__data__.has(e);
}
var _stackHas = stackHas$1,
  freeGlobal$1 = "object" == typeof commonjsGlobal && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal,
  _freeGlobal = freeGlobal$1,
  freeGlobal = _freeGlobal,
  freeSelf = "object" == typeof self && self && self.Object === Object && self,
  root$8 = freeGlobal || freeSelf || Function("return this")(),
  _root = root$8,
  Symbol$5 = _root.Symbol,
  _Symbol = Symbol$5,
  Symbol$4 = _Symbol,
  objectProto$f = Object.prototype,
  hasOwnProperty$c = objectProto$f.hasOwnProperty,
  nativeObjectToString$1 = objectProto$f.toString,
  symToStringTag$1 = Symbol$4 ? Symbol$4.toStringTag : void 0;
function getRawTag$1(e) {
  var t = hasOwnProperty$c.call(e, symToStringTag$1),
    r = e[symToStringTag$1];
  try {
    var n = !(e[symToStringTag$1] = void 0);
  } catch (e) {}
  var i = nativeObjectToString$1.call(e);
  return n && (t ? e[symToStringTag$1] = r : delete e[symToStringTag$1]), i;
}
var _getRawTag = getRawTag$1,
  objectProto$e = Object.prototype,
  nativeObjectToString = objectProto$e.toString;
function objectToString$1(e) {
  return nativeObjectToString.call(e);
}
var getRawTag = _getRawTag,
  objectToString = objectToString$1,
  nullTag = "[object Null]",
  undefinedTag = "[object Undefined]",
  symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
function baseGetTag$5(e) {
  return null == e ? void 0 === e ? undefinedTag : nullTag : (symToStringTag && symToStringTag in Object(e) ? getRawTag : objectToString)(e);
}
var _baseGetTag = baseGetTag$5;
function isObject$9(e) {
  var t = typeof e;
  return null != e && ("object" == t || "function" == t);
}
var isObject_1 = isObject$9,
  baseGetTag$4 = _baseGetTag,
  isObject$8 = isObject_1,
  asyncTag = "[object AsyncFunction]",
  funcTag$2 = "[object Function]",
  genTag$1 = "[object GeneratorFunction]",
  proxyTag = "[object Proxy]";
function isFunction$4(e) {
  return !!isObject$8(e) && ((e = baseGetTag$4(e)) == funcTag$2 || e == genTag$1 || e == asyncTag || e == proxyTag);
}
var isFunction_1 = isFunction$4,
  coreJsData$1 = _root["__core-js_shared__"],
  coreJsData = coreJsData$1,
  maskSrcKey = function () {
    var e = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : "";
  }();
function isMasked$1(e) {
  return !!maskSrcKey && maskSrcKey in e;
}
var _isMasked = isMasked$1,
  funcProto$2 = Function.prototype,
  funcToString$2 = funcProto$2.toString;
function toSource$2(e) {
  if (null != e) {
    try {
      return funcToString$2.call(e);
    } catch (e) {}
    try {
      return e + "";
    } catch (e) {}
  }
  return "";
}
var _toSource = toSource$2,
  isFunction$3 = isFunction_1,
  isMasked = _isMasked,
  isObject$7 = isObject_1,
  toSource$1 = _toSource,
  reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
  reIsHostCtor = /^\[object .+?Constructor\]$/,
  funcProto$1 = Function.prototype,
  objectProto$d = Object.prototype,
  funcToString$1 = funcProto$1.toString,
  hasOwnProperty$b = objectProto$d.hasOwnProperty,
  reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(e) {
  return !(!isObject$7(e) || isMasked(e)) && (isFunction$3(e) ? reIsNative : reIsHostCtor).test(toSource$1(e));
}
function getValue$1(e, t) {
  return null == e ? void 0 : e[t];
}
var baseIsNative = baseIsNative$1,
  getValue = getValue$1;
function getNative$7(e, t) {
  e = getValue(e, t);
  return baseIsNative(e) ? e : void 0;
}
var _getNative = getNative$7,
  Map$5 = _getNative(_root, "Map"),
  _Map = Map$5,
  nativeCreate$4 = _getNative(Object, "create"),
  _nativeCreate = nativeCreate$4,
  nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {}, this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(e) {
  e = this.has(e) && delete this.__data__[e];
  return this.size -= e ? 1 : 0, e;
}
var _hashDelete = hashDelete$1,
  nativeCreate$2 = _nativeCreate,
  HASH_UNDEFINED$2 = "__lodash_hash_undefined__",
  objectProto$c = Object.prototype,
  hasOwnProperty$a = objectProto$c.hasOwnProperty;
function hashGet$1(e) {
  var t,
    r = this.__data__;
  return nativeCreate$2 ? (t = r[e]) === HASH_UNDEFINED$2 ? void 0 : t : hasOwnProperty$a.call(r, e) ? r[e] : void 0;
}
var _hashGet = hashGet$1,
  nativeCreate$1 = _nativeCreate,
  objectProto$b = Object.prototype,
  hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function hashHas$1(e) {
  var t = this.__data__;
  return nativeCreate$1 ? void 0 !== t[e] : hasOwnProperty$9.call(t, e);
}
var nativeCreate = _nativeCreate,
  HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = nativeCreate && void 0 === t ? HASH_UNDEFINED$1 : t, this;
}
var hashClear = _hashClear,
  hashDelete = _hashDelete,
  hashGet = _hashGet,
  hashHas = hashHas$1,
  hashSet = hashSet$1;
function Hash$1(e) {
  var t = -1,
    r = null == e ? 0 : e.length;
  for (this.clear(); ++t < r;) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
Hash$1.prototype.clear = hashClear, Hash$1.prototype.delete = hashDelete, Hash$1.prototype.get = hashGet, Hash$1.prototype.has = hashHas, Hash$1.prototype.set = hashSet;
var Hash = Hash$1,
  ListCache$2 = _ListCache,
  Map$4 = _Map;
function mapCacheClear$1() {
  this.size = 0, this.__data__ = {
    hash: new Hash(),
    map: new (Map$4 || ListCache$2)(),
    string: new Hash()
  };
}
function isKeyable$1(e) {
  var t = typeof e;
  return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== e : null === e;
}
var isKeyable = isKeyable$1;
function getMapData$4(e, t) {
  e = e.__data__;
  return isKeyable(t) ? e["string" == typeof t ? "string" : "hash"] : e.map;
}
var getMapData$3 = getMapData$4;
function mapCacheDelete$1(e) {
  e = getMapData$3(this, e).delete(e);
  return this.size -= e ? 1 : 0, e;
}
var getMapData$2 = getMapData$4;
function mapCacheGet$1(e) {
  return getMapData$2(this, e).get(e);
}
var getMapData$1 = getMapData$4;
function mapCacheHas$1(e) {
  return getMapData$1(this, e).has(e);
}
var getMapData = getMapData$4;
function mapCacheSet$1(e, t) {
  var r = getMapData(this, e),
    n = r.size;
  return r.set(e, t), this.size += r.size == n ? 0 : 1, this;
}
var mapCacheClear = mapCacheClear$1,
  mapCacheDelete = mapCacheDelete$1,
  mapCacheGet = mapCacheGet$1,
  mapCacheHas = mapCacheHas$1,
  mapCacheSet = mapCacheSet$1;
function MapCache$2(e) {
  var t = -1,
    r = null == e ? 0 : e.length;
  for (this.clear(); ++t < r;) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
MapCache$2.prototype.clear = mapCacheClear, MapCache$2.prototype.delete = mapCacheDelete, MapCache$2.prototype.get = mapCacheGet, MapCache$2.prototype.has = mapCacheHas, MapCache$2.prototype.set = mapCacheSet;
var _MapCache = MapCache$2,
  ListCache$1 = _ListCache,
  Map$3 = _Map,
  MapCache$1 = _MapCache,
  LARGE_ARRAY_SIZE = 200;
function stackSet$1(e, t) {
  var r = this.__data__;
  if (r instanceof ListCache$1) {
    var n = r.__data__;
    if (!Map$3 || n.length < LARGE_ARRAY_SIZE - 1) return n.push([e, t]), this.size = ++r.size, this;
    r = this.__data__ = new MapCache$1(n);
  }
  return r.set(e, t), this.size = r.size, this;
}
var ListCache = _ListCache,
  stackClear = _stackClear,
  stackDelete = _stackDelete,
  stackGet = _stackGet,
  stackHas = _stackHas,
  stackSet = stackSet$1;
function Stack$3(e) {
  e = this.__data__ = new ListCache(e);
  this.size = e.size;
}
Stack$3.prototype.clear = stackClear, Stack$3.prototype.delete = stackDelete, Stack$3.prototype.get = stackGet, Stack$3.prototype.has = stackHas, Stack$3.prototype.set = stackSet;
var _Stack = Stack$3;
function arrayEach$1(e, t) {
  for (var r = -1, n = null == e ? 0 : e.length; ++r < n && !1 !== t(e[r], r, e););
  return e;
}
var _arrayEach = arrayEach$1,
  getNative$4 = _getNative,
  defineProperty$2 = function () {
    try {
      var e = getNative$4(Object, "defineProperty");
      return e({}, "", {}), e;
    } catch (e) {}
  }(),
  _defineProperty = defineProperty$2,
  defineProperty$1 = _defineProperty;
function baseAssignValue$3(e, t, r) {
  "__proto__" == t && defineProperty$1 ? defineProperty$1(e, t, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : e[t] = r;
}
var _baseAssignValue = baseAssignValue$3,
  baseAssignValue$2 = _baseAssignValue,
  eq$3 = eq_1,
  objectProto$a = Object.prototype,
  hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function assignValue$2(e, t, r) {
  var n = e[t];
  hasOwnProperty$8.call(e, t) && eq$3(n, r) && (void 0 !== r || t in e) || baseAssignValue$2(e, t, r);
}
var _assignValue = assignValue$2,
  assignValue$1 = _assignValue,
  baseAssignValue$1 = _baseAssignValue;
function copyObject$5(e, t, r, n) {
  for (var i = !r, o = (r = r || {}, -1), a = t.length; ++o < a;) {
    var s = t[o],
      l = n ? n(r[s], e[s], s, r, e) : void 0;
    void 0 === l && (l = e[s]), (i ? baseAssignValue$1 : assignValue$1)(r, s, l);
  }
  return r;
}
var _copyObject = copyObject$5;
function baseTimes$1(e, t) {
  for (var r = -1, n = Array(e); ++r < e;) n[r] = t(r);
  return n;
}
var _baseTimes = baseTimes$1;
function isObjectLike$9(e) {
  return null != e && "object" == typeof e;
}
var isObjectLike_1 = isObjectLike$9,
  baseGetTag$3 = _baseGetTag,
  isObjectLike$8 = isObjectLike_1,
  argsTag$3 = "[object Arguments]";
function baseIsArguments$1(e) {
  return isObjectLike$8(e) && baseGetTag$3(e) == argsTag$3;
}
var baseIsArguments = baseIsArguments$1,
  isObjectLike$7 = isObjectLike_1,
  objectProto$9 = Object.prototype,
  hasOwnProperty$7 = objectProto$9.hasOwnProperty,
  propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable,
  isArguments$2 = baseIsArguments(function () {
    return arguments;
  }()) ? baseIsArguments : function (e) {
    return isObjectLike$7(e) && hasOwnProperty$7.call(e, "callee") && !propertyIsEnumerable$1.call(e, "callee");
  },
  isArguments_1 = isArguments$2,
  isArray$6 = Array.isArray,
  isArray_1 = isArray$6,
  isBuffer$4 = {
    exports: {}
  };
function stubFalse() {
  return !1;
}
var stubFalse_1 = stubFalse,
  isBufferExports = (isBuffer$4.exports, !function (e, t) {
    var t = t && !t.nodeType && t,
      r = t && e && !e.nodeType && e,
      r = r && r.exports === t ? _root.Buffer : void 0,
      t = r ? r.isBuffer : void 0;
    e.exports = t || stubFalse_1;
  }(isBuffer$4, isBuffer$4.exports), isBuffer$4.exports),
  MAX_SAFE_INTEGER$1 = 9007199254740991,
  reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$2(e, t) {
  var r = typeof e;
  return !!(t = null == t ? MAX_SAFE_INTEGER$1 : t) && ("number" == r || "symbol" != r && reIsUint.test(e)) && -1 < e && e % 1 == 0 && e < t;
}
var _isIndex = isIndex$2,
  MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(e) {
  return "number" == typeof e && -1 < e && e % 1 == 0 && e <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2,
  baseGetTag$2 = _baseGetTag,
  isLength$1 = isLength_1,
  isObjectLike$6 = isObjectLike_1,
  argsTag$2 = "[object Arguments]",
  arrayTag$2 = "[object Array]",
  boolTag$3 = "[object Boolean]",
  dateTag$3 = "[object Date]",
  errorTag$2 = "[object Error]",
  funcTag$1 = "[object Function]",
  mapTag$5 = "[object Map]",
  numberTag$3 = "[object Number]",
  objectTag$4 = "[object Object]",
  regexpTag$3 = "[object RegExp]",
  setTag$5 = "[object Set]",
  stringTag$3 = "[object String]",
  weakMapTag$2 = "[object WeakMap]",
  arrayBufferTag$3 = "[object ArrayBuffer]",
  dataViewTag$4 = "[object DataView]",
  float32Tag$2 = "[object Float32Array]",
  float64Tag$2 = "[object Float64Array]",
  int8Tag$2 = "[object Int8Array]",
  int16Tag$2 = "[object Int16Array]",
  int32Tag$2 = "[object Int32Array]",
  uint8Tag$2 = "[object Uint8Array]",
  uint8ClampedTag$2 = "[object Uint8ClampedArray]",
  uint16Tag$2 = "[object Uint16Array]",
  uint32Tag$2 = "[object Uint32Array]",
  typedArrayTags = {};
function baseIsTypedArray$1(e) {
  return isObjectLike$6(e) && isLength$1(e.length) && !!typedArrayTags[baseGetTag$2(e)];
}
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0, typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = !1;
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(t) {
  return function (e) {
    return t(e);
  };
}
var _baseUnary = baseUnary$3,
  _nodeUtil = {
    exports: {}
  },
  _nodeUtilExports = (_nodeUtil.exports, !function (e, t) {
    var t = t && !t.nodeType && t,
      r = t && e && !e.nodeType && e,
      n = r && r.exports === t && _freeGlobal.process,
      t = function () {
        try {
          var e = r && r.require && r.require("util").types;
          return e ? e : n && n.binding && n.binding("util");
        } catch (e) {}
      }();
    e.exports = t;
  }(_nodeUtil, _nodeUtil.exports), _nodeUtil.exports),
  baseIsTypedArray = _baseIsTypedArray,
  baseUnary$2 = _baseUnary,
  nodeIsTypedArray = _nodeUtilExports && _nodeUtilExports.isTypedArray,
  isTypedArray$3 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray,
  isTypedArray_1 = isTypedArray$3,
  baseTimes = _baseTimes,
  isArguments$1 = isArguments_1,
  isArray$5 = isArray_1,
  isBuffer$3 = isBufferExports,
  isIndex$1 = _isIndex,
  isTypedArray$2 = isTypedArray_1,
  objectProto$8 = Object.prototype,
  hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function arrayLikeKeys$2(e, t) {
  var r,
    n = isArray$5(e),
    i = !n && isArguments$1(e),
    o = !n && !i && isBuffer$3(e),
    a = !n && !i && !o && isTypedArray$2(e),
    s = n || i || o || a,
    l = s ? baseTimes(e.length, String) : [],
    c = l.length;
  for (r in e) !t && !hasOwnProperty$6.call(e, r) || s && ("length" == r || o && ("offset" == r || "parent" == r) || a && ("buffer" == r || "byteLength" == r || "byteOffset" == r) || isIndex$1(r, c)) || l.push(r);
  return l;
}
var _arrayLikeKeys = arrayLikeKeys$2,
  objectProto$7 = Object.prototype;
function isPrototype$3(e) {
  var t = e && e.constructor;
  return e === ("function" == typeof t && t.prototype || objectProto$7);
}
var _isPrototype = isPrototype$3;
function overArg$2(t, r) {
  return function (e) {
    return t(r(e));
  };
}
var _overArg = overArg$2,
  nativeKeys$1 = _overArg(Object.keys, Object),
  isPrototype$2 = _isPrototype,
  nativeKeys = nativeKeys$1,
  objectProto$6 = Object.prototype,
  hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function baseKeys$1(e) {
  if (!isPrototype$2(e)) return nativeKeys(e);
  var t,
    r = [];
  for (t in Object(e)) hasOwnProperty$5.call(e, t) && "constructor" != t && r.push(t);
  return r;
}
var isFunction$2 = isFunction_1,
  isLength = isLength_1;
function isArrayLike$4(e) {
  return null != e && isLength(e.length) && !isFunction$2(e);
}
var isArrayLike_1 = isArrayLike$4,
  arrayLikeKeys$1 = _arrayLikeKeys,
  baseKeys = baseKeys$1,
  isArrayLike$3 = isArrayLike_1;
function keys$3(e) {
  return (isArrayLike$3(e) ? arrayLikeKeys$1 : baseKeys)(e);
}
var keys_1 = keys$3,
  copyObject$4 = _copyObject,
  keys$2 = keys_1;
function baseAssign$1(e, t) {
  return e && copyObject$4(t, keys$2(t), e);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(e) {
  var t = [];
  if (null != e) for (var r in Object(e)) t.push(r);
  return t;
}
var isObject$6 = isObject_1,
  isPrototype$1 = _isPrototype,
  nativeKeysIn = nativeKeysIn$1,
  objectProto$5 = Object.prototype,
  hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function baseKeysIn$1(e) {
  if (!isObject$6(e)) return nativeKeysIn(e);
  var t,
    r = isPrototype$1(e),
    n = [];
  for (t in e) ("constructor" != t || !r && hasOwnProperty$4.call(e, t)) && n.push(t);
  return n;
}
var arrayLikeKeys = _arrayLikeKeys,
  baseKeysIn = baseKeysIn$1,
  isArrayLike$2 = isArrayLike_1;
function keysIn$5(e) {
  return isArrayLike$2(e) ? arrayLikeKeys(e, !0) : baseKeysIn(e);
}
var keysIn_1 = keysIn$5,
  copyObject$3 = _copyObject,
  keysIn$4 = keysIn_1;
function baseAssignIn$1(e, t) {
  return e && copyObject$3(t, keysIn$4(t), e);
}
var _baseAssignIn = baseAssignIn$1,
  _cloneBuffer = {
    exports: {}
  },
  _cloneBufferExports = (_cloneBuffer.exports, !function (e, t) {
    var t = t && !t.nodeType && t,
      r = t && e && !e.nodeType && e,
      r = r && r.exports === t ? _root.Buffer : void 0,
      n = r ? r.allocUnsafe : void 0;
    e.exports = function (e, t) {
      return t ? e.slice() : (t = e.length, t = n ? n(t) : new e.constructor(t), e.copy(t), t);
    };
  }(_cloneBuffer, _cloneBuffer.exports), _cloneBuffer.exports);
function copyArray$2(e, t) {
  var r = -1,
    n = e.length;
  for (t = t || Array(n); ++r < n;) t[r] = e[r];
  return t;
}
var _copyArray = copyArray$2;
function arrayFilter$1(e, t) {
  for (var r = -1, n = null == e ? 0 : e.length, i = 0, o = []; ++r < n;) {
    var a = e[r];
    t(a, r, e) && (o[i++] = a);
  }
  return o;
}
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2,
  arrayFilter = arrayFilter$1,
  stubArray$1 = stubArray_1,
  objectProto$4 = Object.prototype,
  propertyIsEnumerable = objectProto$4.propertyIsEnumerable,
  nativeGetSymbols$1 = Object.getOwnPropertySymbols,
  getSymbols$3 = nativeGetSymbols$1 ? function (t) {
    return null == t ? [] : (t = Object(t), arrayFilter(nativeGetSymbols$1(t), function (e) {
      return propertyIsEnumerable.call(t, e);
    }));
  } : stubArray$1,
  _getSymbols = getSymbols$3,
  copyObject$2 = _copyObject,
  getSymbols$2 = _getSymbols;
function copySymbols$1(e, t) {
  return copyObject$2(e, getSymbols$2(e), t);
}
var _copySymbols = copySymbols$1;
function arrayPush$2(e, t) {
  for (var r = -1, n = t.length, i = e.length; ++r < n;) e[i + r] = t[r];
  return e;
}
var _arrayPush = arrayPush$2,
  getPrototype$3 = _overArg(Object.getPrototypeOf, Object),
  _getPrototype = getPrototype$3,
  arrayPush$1 = _arrayPush,
  getPrototype$2 = _getPrototype,
  getSymbols$1 = _getSymbols,
  stubArray = stubArray_1,
  nativeGetSymbols = Object.getOwnPropertySymbols,
  getSymbolsIn$2 = nativeGetSymbols ? function (e) {
    for (var t = []; e;) arrayPush$1(t, getSymbols$1(e)), e = getPrototype$2(e);
    return t;
  } : stubArray,
  copyObject$1 = _copyObject,
  getSymbolsIn$1 = getSymbolsIn$2;
function copySymbolsIn$1(e, t) {
  return copyObject$1(e, getSymbolsIn$1(e), t);
}
var _copySymbolsIn = copySymbolsIn$1,
  arrayPush = _arrayPush,
  isArray$4 = isArray_1;
function baseGetAllKeys$2(e, t, r) {
  t = t(e);
  return isArray$4(e) ? t : arrayPush(t, r(e));
}
var baseGetAllKeys$1 = baseGetAllKeys$2,
  getSymbols = _getSymbols,
  keys$1 = keys_1;
function getAllKeys$2(e) {
  return baseGetAllKeys$1(e, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$2,
  baseGetAllKeys = baseGetAllKeys$2,
  getSymbolsIn = getSymbolsIn$2,
  keysIn$3 = keysIn_1;
function getAllKeysIn$1(e) {
  return baseGetAllKeys(e, keysIn$3, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1,
  DataView$1 = _getNative(_root, "DataView"),
  _DataView = DataView$1,
  Promise$2 = _getNative(_root, "Promise"),
  _Promise = Promise$2,
  Set$2 = _getNative(_root, "Set"),
  _Set = Set$2,
  WeakMap$2 = _getNative(_root, "WeakMap"),
  DataView = _DataView,
  Map$2 = _Map,
  Promise$1 = _Promise,
  Set$1 = _Set,
  WeakMap$1 = WeakMap$2,
  baseGetTag$1 = _baseGetTag,
  toSource = _toSource,
  mapTag$4 = "[object Map]",
  objectTag$3 = "[object Object]",
  promiseTag = "[object Promise]",
  setTag$4 = "[object Set]",
  weakMapTag$1 = "[object WeakMap]",
  dataViewTag$3 = "[object DataView]",
  dataViewCtorString = toSource(DataView),
  mapCtorString = toSource(Map$2),
  promiseCtorString = toSource(Promise$1),
  setCtorString = toSource(Set$1),
  weakMapCtorString = toSource(WeakMap$1),
  getTag$4 = baseGetTag$1,
  _getTag = getTag$4 = DataView && getTag$4(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag$4(new Map$2()) != mapTag$4 || Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag || Set$1 && getTag$4(new Set$1()) != setTag$4 || WeakMap$1 && getTag$4(new WeakMap$1()) != weakMapTag$1 ? function (e) {
    var t = baseGetTag$1(e),
      e = t == objectTag$3 ? e.constructor : void 0,
      e = e ? toSource(e) : "";
    if (e) switch (e) {
      case dataViewCtorString:
        return dataViewTag$3;
      case mapCtorString:
        return mapTag$4;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag$4;
      case weakMapCtorString:
        return weakMapTag$1;
    }
    return t;
  } : getTag$4,
  objectProto$3 = Object.prototype,
  hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function initCloneArray$1(e) {
  var t = e.length,
    r = new e.constructor(t);
  return t && "string" == typeof e[0] && hasOwnProperty$3.call(e, "index") && (r.index = e.index, r.input = e.input), r;
}
var _initCloneArray = initCloneArray$1,
  Uint8Array$3 = _root.Uint8Array,
  _Uint8Array = Uint8Array$3,
  Uint8Array$2 = _Uint8Array;
function cloneArrayBuffer$3(e) {
  var t = new e.constructor(e.byteLength);
  return new Uint8Array$2(t).set(new Uint8Array$2(e)), t;
}
var _cloneArrayBuffer = cloneArrayBuffer$3,
  cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(e, t) {
  t = t ? cloneArrayBuffer$2(e.buffer) : e.buffer;
  return new e.constructor(t, e.byteOffset, e.byteLength);
}
var _cloneDataView = cloneDataView$1,
  reFlags = /\w*$/;
function cloneRegExp$1(e) {
  var t = new e.constructor(e.source, reFlags.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var _cloneRegExp = cloneRegExp$1,
  symbolProto$1 = _Symbol ? _Symbol.prototype : void 0,
  symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol$1(e) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(e)) : {};
}
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$2(e, t) {
  t = t ? cloneArrayBuffer$1(e.buffer) : e.buffer;
  return new e.constructor(t, e.byteOffset, e.length);
}
var _cloneTypedArray = cloneTypedArray$2,
  cloneArrayBuffer = _cloneArrayBuffer,
  cloneDataView = _cloneDataView,
  cloneRegExp = _cloneRegExp,
  cloneSymbol = cloneSymbol$1,
  cloneTypedArray$1 = _cloneTypedArray,
  boolTag$2 = "[object Boolean]",
  dateTag$2 = "[object Date]",
  mapTag$3 = "[object Map]",
  numberTag$2 = "[object Number]",
  regexpTag$2 = "[object RegExp]",
  setTag$3 = "[object Set]",
  stringTag$2 = "[object String]",
  symbolTag$2 = "[object Symbol]",
  arrayBufferTag$2 = "[object ArrayBuffer]",
  dataViewTag$2 = "[object DataView]",
  float32Tag$1 = "[object Float32Array]",
  float64Tag$1 = "[object Float64Array]",
  int8Tag$1 = "[object Int8Array]",
  int16Tag$1 = "[object Int16Array]",
  int32Tag$1 = "[object Int32Array]",
  uint8Tag$1 = "[object Uint8Array]",
  uint8ClampedTag$1 = "[object Uint8ClampedArray]",
  uint16Tag$1 = "[object Uint16Array]",
  uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(e, t, r) {
  var n = e.constructor;
  switch (t) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(e);
    case boolTag$2:
    case dateTag$2:
      return new n(+e);
    case dataViewTag$2:
      return cloneDataView(e, r);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray$1(e, r);
    case mapTag$3:
      return new n();
    case numberTag$2:
    case stringTag$2:
      return new n(e);
    case regexpTag$2:
      return cloneRegExp(e);
    case setTag$3:
      return new n();
    case symbolTag$2:
      return cloneSymbol(e);
  }
}
var _initCloneByTag = initCloneByTag$1,
  isObject$5 = isObject_1,
  objectCreate = Object.create,
  baseCreate$1 = function () {
    function t() {}
    return function (e) {
      if (!isObject$5(e)) return {};
      if (objectCreate) return objectCreate(e);
      t.prototype = e;
      e = new t();
      return t.prototype = void 0, e;
    };
  }(),
  baseCreate = baseCreate$1,
  getPrototype$1 = _getPrototype,
  isPrototype = _isPrototype;
function initCloneObject$2(e) {
  return "function" != typeof e.constructor || isPrototype(e) ? {} : baseCreate(getPrototype$1(e));
}
var _initCloneObject = initCloneObject$2,
  getTag$3 = _getTag,
  isObjectLike$5 = isObjectLike_1,
  mapTag$2 = "[object Map]";
function baseIsMap$1(e) {
  return isObjectLike$5(e) && getTag$3(e) == mapTag$2;
}
var baseIsMap = baseIsMap$1,
  baseUnary$1 = _baseUnary,
  nodeIsMap = _nodeUtilExports && _nodeUtilExports.isMap,
  isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap,
  isMap_1 = isMap$1,
  getTag$2 = _getTag,
  isObjectLike$4 = isObjectLike_1,
  setTag$2 = "[object Set]";
function baseIsSet$1(e) {
  return isObjectLike$4(e) && getTag$2(e) == setTag$2;
}
var baseIsSet = baseIsSet$1,
  baseUnary = _baseUnary,
  nodeIsSet = _nodeUtilExports && _nodeUtilExports.isSet,
  isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet,
  Stack$2 = _Stack,
  arrayEach = _arrayEach,
  assignValue = _assignValue,
  baseAssign = _baseAssign,
  baseAssignIn = _baseAssignIn,
  cloneBuffer$1 = _cloneBufferExports,
  copyArray$1 = _copyArray,
  copySymbols = _copySymbols,
  copySymbolsIn = _copySymbolsIn,
  getAllKeys$1 = _getAllKeys,
  getAllKeysIn = _getAllKeysIn,
  getTag$1 = _getTag,
  initCloneArray = _initCloneArray,
  initCloneByTag = _initCloneByTag,
  initCloneObject$1 = _initCloneObject,
  isArray$3 = isArray_1,
  isBuffer$2 = isBufferExports,
  isMap = isMap_1,
  isObject$4 = isObject_1,
  isSet = isSet$1,
  keys = keys_1,
  keysIn$2 = keysIn_1,
  CLONE_DEEP_FLAG$2 = 1,
  CLONE_FLAT_FLAG = 2,
  CLONE_SYMBOLS_FLAG$2 = 4,
  argsTag$1 = "[object Arguments]",
  arrayTag$1 = "[object Array]",
  boolTag$1 = "[object Boolean]",
  dateTag$1 = "[object Date]",
  errorTag$1 = "[object Error]",
  funcTag = "[object Function]",
  genTag = "[object GeneratorFunction]",
  mapTag$1 = "[object Map]",
  numberTag$1 = "[object Number]",
  objectTag$2 = "[object Object]",
  regexpTag$1 = "[object RegExp]",
  setTag$1 = "[object Set]",
  stringTag$1 = "[object String]",
  symbolTag$1 = "[object Symbol]",
  weakMapTag = "[object WeakMap]",
  arrayBufferTag$1 = "[object ArrayBuffer]",
  dataViewTag$1 = "[object DataView]",
  float32Tag = "[object Float32Array]",
  float64Tag = "[object Float64Array]",
  int8Tag = "[object Int8Array]",
  int16Tag = "[object Int16Array]",
  int32Tag = "[object Int32Array]",
  uint8Tag = "[object Uint8Array]",
  uint8ClampedTag = "[object Uint8ClampedArray]",
  uint16Tag = "[object Uint16Array]",
  uint32Tag = "[object Uint32Array]",
  cloneableTags = {};
function baseClone$2(r, n, i, e, t, o) {
  var a,
    s = n & CLONE_DEEP_FLAG$2,
    l = n & CLONE_FLAT_FLAG,
    c = n & CLONE_SYMBOLS_FLAG$2;
  if (void 0 === (a = i ? t ? i(r, e, t, o) : i(r) : a)) {
    if (!isObject$4(r)) return r;
    e = isArray$3(r);
    if (e) {
      if (a = initCloneArray(r), !s) return copyArray$1(r, a);
    } else {
      var u = getTag$1(r),
        h = u == funcTag || u == genTag;
      if (isBuffer$2(r)) return cloneBuffer$1(r, s);
      if (u == objectTag$2 || u == argsTag$1 || h && !t) {
        if (a = l || h ? {} : initCloneObject$1(r), !s) return l ? copySymbolsIn(r, baseAssignIn(a, r)) : copySymbols(r, baseAssign(a, r));
      } else {
        if (!cloneableTags[u]) return t ? r : {};
        a = initCloneByTag(r, u, s);
      }
    }
    h = (o = o || new Stack$2()).get(r);
    if (h) return h;
    o.set(r, a), isSet(r) ? r.forEach(function (e) {
      a.add(baseClone$2(e, n, i, e, r, o));
    }) : isMap(r) && r.forEach(function (e, t) {
      a.set(t, baseClone$2(e, n, i, t, r, o));
    });
    var d = e ? void 0 : (c ? l ? getAllKeysIn : getAllKeys$1 : l ? keysIn$2 : keys)(r);
    arrayEach(d || r, function (e, t) {
      d && (e = r[t = e]), assignValue(a, t, baseClone$2(e, n, i, t, r, o));
    });
  }
  return a;
}
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
var _baseClone = baseClone$2,
  baseClone$1 = _baseClone,
  CLONE_DEEP_FLAG$1 = 1,
  CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(e) {
  return baseClone$1(e, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}
var cloneDeep$1 = getDefaultExportFromCjs(cloneDeep),
  baseAssignValue = _baseAssignValue,
  eq$2 = eq_1;
function assignMergeValue$2(e, t, r) {
  (void 0 === r || eq$2(e[t], r)) && (void 0 !== r || t in e) || baseAssignValue(e, t, r);
}
var _assignMergeValue = assignMergeValue$2;
function createBaseFor$1(l) {
  return function (e, t, r) {
    for (var n = -1, i = Object(e), o = r(e), a = o.length; a--;) {
      var s = o[l ? a : ++n];
      if (!1 === t(i[s], s, i)) break;
    }
    return e;
  };
}
var baseFor$1 = createBaseFor$1(),
  _baseFor = baseFor$1,
  isArrayLike$1 = isArrayLike_1,
  isObjectLike$3 = isObjectLike_1;
function isArrayLikeObject$1(e) {
  return isObjectLike$3(e) && isArrayLike$1(e);
}
var isArrayLikeObject_1 = isArrayLikeObject$1,
  baseGetTag = _baseGetTag,
  getPrototype = _getPrototype,
  isObjectLike$2 = isObjectLike_1,
  objectTag$1 = "[object Object]",
  funcProto = Function.prototype,
  objectProto$2 = Object.prototype,
  funcToString = funcProto.toString,
  hasOwnProperty$2 = objectProto$2.hasOwnProperty,
  objectCtorString = funcToString.call(Object);
function isPlainObject$3(e) {
  return !(!isObjectLike$2(e) || baseGetTag(e) != objectTag$1) && (null === (e = getPrototype(e)) || "function" == typeof (e = hasOwnProperty$2.call(e, "constructor") && e.constructor) && e instanceof e && funcToString.call(e) == objectCtorString);
}
var isPlainObject_1 = isPlainObject$3;
function safeGet$3(e, t) {
  if (("constructor" !== t || "function" != typeof e[t]) && "__proto__" != t) return e[t];
}
var copyObject = _copyObject,
  keysIn$1 = keysIn_1;
function toPlainObject$1(e) {
  return copyObject(e, keysIn$1(e));
}
var assignMergeValue$1 = _assignMergeValue,
  cloneBuffer = _cloneBufferExports,
  cloneTypedArray = _cloneTypedArray,
  copyArray = _copyArray,
  initCloneObject = _initCloneObject,
  isArguments = isArguments_1,
  isArray$2 = isArray_1,
  isArrayLikeObject = isArrayLikeObject_1,
  isBuffer$1 = isBufferExports,
  isFunction$1 = isFunction_1,
  isObject$3 = isObject_1,
  isPlainObject$2 = isPlainObject_1,
  isTypedArray$1 = isTypedArray_1,
  safeGet$2 = safeGet$3,
  toPlainObject = toPlainObject$1;
function baseMergeDeep$1(e, t, r, n, i, o, a) {
  var s,
    l,
    c,
    u = safeGet$2(e, r),
    h = safeGet$2(t, r),
    d = a.get(h);
  d || ((t = void 0 === (d = o ? o(u, h, r + "", e, t, a) : void 0)) && (l = !(s = isArray$2(h)) && isBuffer$1(h), c = !s && !l && isTypedArray$1(h), d = h, s || l || c ? d = isArray$2(u) ? u : isArrayLikeObject(u) ? copyArray(u) : l ? cloneBuffer(h, !(t = !1)) : c ? cloneTypedArray(h, !(t = !1)) : [] : isPlainObject$2(h) || isArguments(h) ? isArguments(d = u) ? d = toPlainObject(u) : isObject$3(u) && !isFunction$1(u) || (d = initCloneObject(h)) : t = !1), t && (a.set(h, d), i(d, h, n, o, a), a.delete(h))), assignMergeValue$1(e, r, d);
}
var Stack$1 = _Stack,
  assignMergeValue = _assignMergeValue,
  baseFor = _baseFor,
  baseMergeDeep = baseMergeDeep$1,
  isObject$2 = isObject_1,
  keysIn = keysIn_1,
  safeGet$1 = safeGet$3;
function baseMerge$1(n, i, o, a, s) {
  n !== i && baseFor(i, function (e, t) {
    var r;
    s = s || new Stack$1(), isObject$2(e) ? baseMergeDeep(n, i, t, o, baseMerge$1, a, s) : (r = a ? a(safeGet$1(n, t), e, t + "", n, i, s) : void 0, assignMergeValue(n, t, r = void 0 === r ? e : r));
  }, keysIn);
}
var _baseMerge = baseMerge$1;
function identity$2(e) {
  return e;
}
var identity_1 = identity$2;
function apply$1(e, t, r) {
  switch (r.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, r[0]);
    case 2:
      return e.call(t, r[0], r[1]);
    case 3:
      return e.call(t, r[0], r[1], r[2]);
  }
  return e.apply(t, r);
}
var apply = apply$1,
  nativeMax = Math.max;
function overRest$1(o, a, s) {
  return a = nativeMax(void 0 === a ? o.length - 1 : a, 0), function () {
    for (var e = arguments, t = -1, r = nativeMax(e.length - a, 0), n = Array(r); ++t < r;) n[t] = e[a + t];
    for (var t = -1, i = Array(a + 1); ++t < a;) i[t] = e[t];
    return i[a] = s(n), apply(o, this, i);
  };
}
var _overRest = overRest$1;
function constant$1(e) {
  return function () {
    return e;
  };
}
var constant = constant$1,
  defineProperty = _defineProperty,
  baseSetToString$1 = defineProperty ? function (e, t) {
    return defineProperty(e, "toString", {
      configurable: !0,
      enumerable: !1,
      value: constant(t),
      writable: !0
    });
  } : identity_1,
  _baseSetToString = baseSetToString$1,
  HOT_COUNT = 800,
  HOT_SPAN = 16,
  nativeNow = Date.now;
function shortOut$1(r) {
  var n = 0,
    i = 0;
  return function () {
    var e = nativeNow(),
      t = HOT_SPAN - (e - i);
    if (i = e, 0 < t) {
      if (++n >= HOT_COUNT) return arguments[0];
    } else n = 0;
    return r.apply(void 0, arguments);
  };
}
var setToString$1 = shortOut$1(_baseSetToString),
  identity = identity_1,
  overRest = _overRest,
  setToString = setToString$1;
function baseRest$1(e, t) {
  return setToString(overRest(e, t, identity), e + "");
}
var eq$1 = eq_1,
  isArrayLike = isArrayLike_1,
  isIndex = _isIndex,
  isObject$1 = isObject_1;
function isIterateeCall$1(e, t, r) {
  var n;
  return !!isObject$1(r) && !!("number" == (n = typeof t) ? isArrayLike(r) && isIndex(t, r.length) : "string" == n && t in r) && eq$1(r[t], e);
}
var baseRest = baseRest$1,
  isIterateeCall = isIterateeCall$1;
function createAssigner$1(s) {
  return baseRest(function (e, t) {
    var r = -1,
      n = t.length,
      i = 1 < n ? t[n - 1] : void 0,
      o = 2 < n ? t[2] : void 0,
      i = 3 < s.length && "function" == typeof i ? (n--, i) : void 0;
    for (o && isIterateeCall(t[0], t[1], o) && (i = n < 3 ? void 0 : i, n = 1), e = Object(e); ++r < n;) {
      var a = t[r];
      a && s(e, a, r, i);
    }
    return e;
  });
}
var baseMerge = _baseMerge,
  merge = createAssigner$1(function (e, t, r) {
    baseMerge(e, t, r);
  }),
  merge$1 = getDefaultExportFromCjs(merge),
  __extends$1b = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  StyleControlOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.layout = "icons", e.mapStyles = ["road", "grayscale_light", "grayscale_dark", "night", "road_shaded_relief"], e.style = ControlStyle.light, e.autoSelectionMode = !0, e;
    }
    return __extends$1b(e, t), e;
  }(Options),
  __extends$1a = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __awaiter$7 = window && window.__awaiter || function (e, a, s, l) {
    return new (s = s || Promise)(function (r, t) {
      function n(e) {
        try {
          o(l.next(e));
        } catch (e) {
          t(e);
        }
      }
      function i(e) {
        try {
          o(l.throw(e));
        } catch (e) {
          t(e);
        }
      }
      function o(e) {
        var t;
        e.done ? r(e.value) : ((t = e.value) instanceof s ? t : new s(function (e) {
          e(t);
        })).then(n, i);
      }
      o((l = l.apply(e, a || [])).next());
    });
  },
  __generator$7 = window && window.__generator || function (n, i) {
    var o,
      a,
      s,
      l = {
        label: 0,
        sent: function () {
          if (1 & s[0]) throw s[1];
          return s[1];
        },
        trys: [],
        ops: []
      },
      c = {
        next: e(0),
        throw: e(1),
        return: e(2)
      };
    return "function" == typeof Symbol && (c[Symbol.iterator] = function () {
      return this;
    }), c;
    function e(r) {
      return function (e) {
        var t = [r, e];
        if (o) throw new TypeError("Generator is already executing.");
        for (; l = c && t[c = 0] ? 0 : l;) try {
          if (o = 1, a && (s = 2 & t[0] ? a.return : t[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, t[1])).done) return s;
          switch (a = 0, (t = s ? [2 & t[0], s.value] : t)[0]) {
            case 0:
            case 1:
              s = t;
              break;
            case 4:
              return l.label++, {
                value: t[1],
                done: !1
              };
            case 5:
              l.label++, a = t[1], t = [0];
              continue;
            case 7:
              t = l.ops.pop(), l.trys.pop();
              continue;
            default:
              if (!(s = 0 < (s = l.trys).length && s[s.length - 1]) && (6 === t[0] || 2 === t[0])) {
                l = 0;
                continue;
              }
              if (3 === t[0] && (!s || t[1] > s[0] && t[1] < s[3])) l.label = t[1];else if (6 === t[0] && l.label < s[1]) l.label = s[1], s = t;else {
                if (!(s && l.label < s[2])) {
                  s[2] && l.ops.pop(), l.trys.pop();
                  continue;
                }
                l.label = s[2], l.ops.push(t);
              }
          }
          t = i.call(n, l);
        } catch (e) {
          t = [6, e], a = 0;
        } finally {
          o = s = 0;
        }
        if (5 & t[0]) throw t[1];
        return {
          value: t[0] ? t[1] : void 0,
          done: !0
        };
      };
    }
  },
  __read$g = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  StyleControl = function (r) {
    function s(e) {
      var t = r.call(this) || this;
      return t.styleOpsGrid = null, t.hasMouse = !1, t.hasFocus = !1, t.styleButtons = new Dictionary(), t.styleIcons = new Dictionary(), t.thumbnailCache = {
        assumedConfiguration: void 0,
        response: new Dictionary(),
        blob: new Dictionary()
      }, t.onStyleChange = function () {
        var e;
        t.options.autoSelectionMode && (e = t.map.getStyle().style, t.setSelectedStyle(e));
      }, t.onMapConfigurationChange = function (e) {
        !t.styleOpsGrid || 0 < t.styleOpsGrid.children.length && t.thumbnailCache.assumedConfiguration === e || (t.thumbnailCache.assumedConfiguration = e, Array.from(t.styleOpsGrid.children).forEach(function (e) {
          return e.remove();
        }), t.styleButtons.clear(), t.populateOpsGridFromDefinitions(e));
      }, t.mapToFriendlyStyleName = function (t, e) {
        e = e.configurations.find(function (e) {
          return e.name === t;
        });
        return (null == e ? void 0 : e.displayName) || t;
      }, t.options = new StyleControlOptions().merge(cloneDeep$1(e)), t;
    }
    return __extends$1a(s, r), s.prototype.onAdd = function (e, t) {
      var r = this,
        n = (this.map = e, this.buildContainer(e, this.options.style, "Map Style Control")),
        i = this.buildStyleOpsGrid(),
        o = (this.styleOpsGrid = i, this.buildCurrStyleBtn()),
        e = buildAccessibleTooltip("Select Style");
      return i.classList.add(t && t.position || "top-right"), n.addEventListener("mouseover", function () {
        r.hasMouse = !0, n.classList.add(s.Css.inUse), i.classList.remove("hidden-accessible-element");
      }), n.addEventListener("focusin", function () {
        r.hasFocus = !0, n.classList.add(s.Css.inUse), i.classList.remove("hidden-accessible-element");
      }), n.addEventListener("mouseleave", function () {
        r.hasMouse = !1, r.hasFocus || (n.classList.remove(s.Css.inUse), i.classList.add("hidden-accessible-element"));
      }), n.addEventListener("focusout", function (e) {
        e.target === o && Array.from(i.children).forEach(function (e) {
          return e.removeAttribute("tabIndex");
        }), e.relatedTarget instanceof Node && n.contains(e.relatedTarget) || (r.hasFocus = !1, r.hasMouse) || (n.classList.remove(s.Css.inUse), i.classList.add("hidden-accessible-element"));
      }), i.addEventListener("keydown", function (e) {
        27 === e.keyCode && (e.stopPropagation(), o.focus(), Array.from(i.children).forEach(function (e) {
          return e.setAttribute("tabIndex", "-1");
        }), n.classList.contains(s.Css.inUse)) && (n.classList.remove(s.Css.inUse), i.classList.add("hidden-accessible-element"));
      }), o.addEventListener("click", function (e) {
        n.classList.contains(s.Css.inUse) ? (n.classList.remove(s.Css.inUse), i.classList.add("hidden-accessible-element")) : (n.classList.add(s.Css.inUse), i.classList.remove("hidden-accessible-element"), i.firstElementChild && i.firstElementChild.focus());
      }), t && s.InvertOrderPositions.includes(t.position) ? (n.appendChild(i), n.appendChild(o), n.appendChild(e), positionTooltip(e, o)) : (n.appendChild(o), n.appendChild(e), positionTooltip(e, o), n.appendChild(i)), n;
    }, s.prototype.onRemove = function () {
      r.prototype.onRemove.call(this), this.styleOpsGrid = null, this.styleButtons.clear(), this.thumbnailCache.response.clear(), this.thumbnailCache.blob.clear(), this.thumbnailCache.assumedConfiguration = void 0, this.map.events.remove("stylechanged", this.onStyleChange), this.map.events.remove("mapconfigurationchanged", this.onMapConfigurationChange);
    }, s.prototype.setSelectedStyle = function (r) {
      var t,
        e,
        n = this;
      this.styleIcons.has(r) && (t = this.currStyleImage, e = this.styleIcons.get(r), t.src !== e && (t.src = e), Object.entries(this.styleButtons).forEach(function (e) {
        var e = __read$g(e, 2),
          t = e[0];
        return e[1].setAttribute("aria-current", t === r ? "true" : "false");
      }), this.map.styles.definitions().then(function (e) {
        e = n.mapToFriendlyStyleName(r, e);
        t.alt !== e && (t.alt = e), t.parentElement.lastChild instanceof Text && (t.parentElement.lastChild.textContent = e);
      }));
    }, s.prototype.disableStyle = function (e) {
      e = this.styleButtons[e];
      e && e.setAttribute("disabled", "true");
    }, s.prototype.enableStyle = function (e) {
      e = this.styleButtons[e];
      e && e.removeAttribute("disabled");
    }, s.prototype.buildSelectStyleBtn = function (r, e, t) {
      var n = this,
        i = document.createElement("button"),
        o = this.mapToFriendlyStyleName(r, e),
        a = (i.setAttribute("aria-label", o), i.setAttribute("type", "button"), new Image()),
        e = (t.then(function (e) {
          var t;
          return n.thumbnailCache.blob.has(e.url) ? n.thumbnailCache.blob.get(e.url) : (t = e.clone().blob(), n.thumbnailCache.blob.set(e.url, t), t);
        }).then(function (e) {
          e = URL.createObjectURL(e);
          a.src = e, r === n.map.getStyle().style && (n.currStyleImage.src = e, n.currStyleImage.alt = o, n.currStyleImage.parentElement.lastChild.nodeType == Node.TEXT_NODE ? n.currStyleImage.parentElement.lastChild.textContent = o : n.currStyleImage.parentElement.appendChild(document.createTextNode(o))), n.styleIcons.set(r, e);
        }), a.setAttribute("aria-hidden", "true"), i.appendChild(a), "icons" === this.options.layout ? i.classList.add(s.Css.button) : (i.classList.add(s.Css.listButton), i.classList.add(s.Css.expanded), i.appendChild(document.createTextNode(o))), i.addEventListener("click", function () {
          n.hasMouse = !1, n.hasFocus = !1;
          var e = n.styleButtons[r];
          e && !e.hasAttribute("disabled") && (n._invokeEvent("styleselected", r), n.options.autoSelectionMode && n.map.setStyle({
            style: r
          }), Object.entries(n.styleButtons).forEach(function (e) {
            var e = __read$g(e, 2),
              t = e[0];
            return e[1].setAttribute("aria-current", t === r ? "true" : "false");
          }));
        }), document.createElement("div"));
      return e.classList.add("selected-icon"), i.appendChild(e), i;
    }, s.prototype.buildCurrStyleBtn = function () {
      var e = document.createElement("button"),
        t = ("icons" == this.options.layout ? e.classList.add(s.Css.button) : e.classList.add(s.Css.listButton), e.classList.add(s.Css.currentStyle), e.setAttribute("aria-label", "Select Style"), e.setAttribute("tabindex", "-1"), this.currStyleImage = new Image(), e.appendChild(this.currStyleImage), document.createElement("div"));
      return t.classList.add("icon"), e.appendChild(t), e;
    }, s.prototype.buildStyleOpsGrid = function () {
      var e = this,
        t = document.createElement("div");
      return t.classList.add(s.Css.styleOptions), "icons" === this.options.layout ? t.classList.add(this.options.layout) : t.classList.add(s.Css.dropdown), t.setAttribute("aria-label", "Style Options"), t.classList.add("hidden-accessible-element"), this.map.styles.definitions().then(function (t) {
        return __awaiter$7(e, void 0, void 0, function () {
          return __generator$7(this, function (e) {
            return this.onMapConfigurationChange(t), this.map.events.add("stylechanged", this.onStyleChange), [2];
          });
        });
      }), this.map.events.add("mapconfigurationchanged", this.onMapConfigurationChange), t;
    }, s.prototype.populateOpsGridFromDefinitions = function (i) {
      var e,
        r,
        o = this;
      this.styleOpsGrid && (e = i.configurations, (e = Array.isArray(this.options.mapStyles) ? e.filter(function (e) {
        return o.options.mapStyles.includes(e.name.split("_indoor")[0]);
      }) : e).forEach(function (e) {
        var t,
          r = {
            url: e.thumbnail
          },
          n = (e.thumbnail && o.map.styles._transformStyleRequest(e.thumbnail, r), o.map.getServiceOptions()),
          n = (n.transformRequest && merge$1(r, n.transformRequest(r.url, "Thumbnail")), o.thumbnailCache.response.has(r.url) ? t = Promise.resolve(o.thumbnailCache.response.get(r.url)) : (t = fetch(r.url, {
            headers: r.headers
          }), o.thumbnailCache.response.set(r.url, t)), o.buildSelectStyleBtn(e.name, i, t));
        o.styleOpsGrid.appendChild(n), o.styleButtons[e.name] = n, "icons" === o.options.layout && (r = buildAccessibleTooltip(o.mapToFriendlyStyleName(e.name, i)), o.styleOpsGrid.appendChild(r), positionTooltip(r, n));
      }), r = this.map.getStyle().style, Object.entries(this.styleButtons).forEach(function (e) {
        var e = __read$g(e, 2),
          t = e[0];
        return e[1].setAttribute("aria-current", t === r ? "true" : "false");
      }));
    }, s.InvertOrderPositions = [ControlPosition.TopRight, ControlPosition.BottomRight], s.Css = {
      button: "azure-maps-control-button",
      listButton: "azure-maps-control-list-button",
      expanded: "expanded",
      currentStyle: "curr-style",
      inUse: "in-use",
      styleOptions: "style-options",
      dropdown: "azure-maps-control-dropdown"
    }, s;
  }(ControlBase),
  __extends$19 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  TrafficOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.flow = "none", e.incidents = !1, e;
    }
    return __extends$19(e, t), e;
  }(Options),
  __extends$18 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  TrafficControlOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.isActive = !1, e.style = ControlStyle.light, e;
    }
    return __extends$18(e, t), e;
  }(TrafficOptions),
  __extends$17 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  TrafficControl = function (n) {
    function e(e) {
      var t,
        r = this;
      return (r = n.call(this) || this).hasMouse = !1, r.hasFocus = !1, r.options = new TrafficOptions().merge({
        flow: "relative",
        incidents: !0
      }), r.style = ControlStyle.light, r.container = null, r.trafficButton = null, r.map = null, e && (r.initIsActive = null != (t = e.isActive) && t, r.options.flow = e.flow || "relative", r.options.incidents = null == (t = e.incidents) || t, r.style = e.style || ControlStyle.light), r;
    }
    return __extends$17(e, n), Object.defineProperty(e.prototype, "isActive", {
      get: function () {
        var e;
        return !!this.map && ("none" !== (e = this.map.getTraffic()).flow || e.incidents);
      },
      set: function (e) {
        this.map && this.map.setTraffic({
          flow: e ? this.options.flow : "none",
          incidents: !!e && this.options.incidents
        });
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.onAdd = function (e) {
      (this.map = e).getTraffic(), void 0 !== this.initIsActive && (this.isActive = this.initIsActive), this.container = this.buildContainer(e, this.style, "Traffic Control"), this.container.style.flexDirection = "column";
      var e = this.constructTrafficButton(e),
        t = (this.container.appendChild(e), buildAccessibleTooltip("Toggle Traffic Display"));
      return this.container.appendChild(t), positionTooltip(t, e), this.container;
    }, e.prototype.onRemove = function () {
      n.prototype.onRemove.call(this), this.map = null;
    }, e.prototype.getOptions = function () {
      return new TrafficControlOptions().merge({
        isActive: this.isActive,
        flow: this.options.flow,
        incidents: this.options.incidents,
        style: this.style
      });
    }, e.prototype.updateButtonState = function () {
      this.trafficButton && (this.isActive ? (this.container.classList.add("in-use"), this.trafficButton.setAttribute("aria-description", "Traffic is displayed")) : (this.container.classList.remove("in-use"), this.trafficButton.removeAttribute("aria-description")), this.trafficButton.setAttribute("aria-pressed", this.isActive ? "true" : "false"));
    }, e.prototype.constructTrafficButton = function (e) {
      var t = this,
        r = document.createElement("button");
      return r.classList.add("azure-maps-control-button"), r.classList.add("traffic"), r.setAttribute("aria-label", "Toggle Traffic Display"), r.setAttribute("alt", "Toggle Traffic Display"), r.setAttribute("type", "button"), this.trafficButton = r, this.updateButtonState(), r.addEventListener("click", function () {
        t.isActive = !t.isActive;
      }), r;
    }, e;
  }(ControlBase),
  __extends$16 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __values$j = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  TrafficLegendControl = function (t) {
    function e() {
      var e = t.call(this) || this;
      return e.table = ["Fast", ["green", "yellow", "red", "dark-red"], "Slow"], e.map = null, e.syncHiddenState = null, e;
    }
    return __extends$16(e, t), e.prototype.onAdd = function (e) {
      this.map = e;
      var t = this.buildContainer(e, ControlStyle.auto, "Traffic Legend"),
        e = this.buildTrafficLegendDiv(e);
      return t.setAttribute("role", "definition"), t.appendChild(e), t;
    }, e.prototype.onRemove = function () {
      t.prototype.onRemove.call(this), this.syncHiddenState && (this.map.events.remove("styledata", this.syncHiddenState), this.syncHiddenState = null), this.map = null;
    }, e.prototype.buildTrafficLegendDiv = function (t) {
      var r,
        e,
        n,
        i,
        o = document.createElement("div"),
        a = (o.classList.add("traffic-legend", "hidden"), o.setAttribute("alt", "Traffic Legend"), document.createElement("table")),
        s = document.createElement("tr"),
        l = document.createElement("td"),
        c = (l.setAttribute("alt", "Traffic"), l.appendChild(document.createTextNode("Traffic")), buildAccessibleTooltip("Traffic")),
        u = (l.classList.add("traffic-legend-title"), l.colSpan = 6, s.appendChild(l), s.appendChild(c), positionTooltip(c, l), a.appendChild(s), document.createElement("tr"));
      try {
        for (var h = __values$j(this.table), d = h.next(); !d.done; d = h.next()) {
          var p = d.value,
            f = document.createElement("td");
          if ("Fast" === p || "Slow" === p) f.setAttribute("alt", p), f.appendChild(document.createTextNode(p)), f.classList.add("traffic-legend-text");else {
            f.classList.add("traffic-legend-colors"), f.setAttribute("aria-label", "Traffic Legend"), f.setAttribute("role", "img");
            try {
              n = void 0;
              for (var _ = __values$j(p), m = _.next(); !m.done; m = _.next()) {
                var g = m.value,
                  y = document.createElement("div");
                y.classList.add(g), f.appendChild(y);
              }
            } catch (e) {
              n = {
                error: e
              };
            } finally {
              try {
                m && !m.done && (i = _.return) && i.call(_);
              } finally {
                if (n) throw n.error;
              }
            }
          }
          u.appendChild(f);
          var v = buildAccessibleTooltip(p instanceof Array ? "Traffic Legend" : p);
          u.appendChild(v), positionTooltip(v, f);
        }
      } catch (e) {
        r = {
          error: e
        };
      } finally {
        try {
          d && !d.done && (e = h.return) && e.call(h);
        } finally {
          if (r) throw r.error;
        }
      }
      return a.appendChild(u), o.appendChild(a), this.syncHiddenState = function (e) {
        "style" === e.dataType && ((e = t.getTraffic()).flow && "none" !== e.flow ? o.classList.remove("hidden") : o.classList.add("hidden"));
      }, this.syncHiddenState({
        dataType: "style"
      }), t.events.add("styledata", this.syncHiddenState), o;
    }, e;
  }(ControlBase),
  HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(e) {
  return this.__data__.set(e, HASH_UNDEFINED), this;
}
function setCacheHas$1(e) {
  return this.__data__.has(e);
}
var MapCache = _MapCache,
  setCacheAdd = setCacheAdd$1,
  setCacheHas = setCacheHas$1;
function SetCache$1(e) {
  var t = -1,
    r = null == e ? 0 : e.length;
  for (this.__data__ = new MapCache(); ++t < r;) this.add(e[t]);
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd, SetCache$1.prototype.has = setCacheHas;
function arraySome$1(e, t) {
  for (var r = -1, n = null == e ? 0 : e.length; ++r < n;) if (t(e[r], r, e)) return !0;
  return !1;
}
function cacheHas$1(e, t) {
  return e.has(t);
}
var SetCache = SetCache$1,
  arraySome = arraySome$1,
  cacheHas = cacheHas$1,
  COMPARE_PARTIAL_FLAG$3 = 1,
  COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays$2(e, t, r, n, i, o) {
  var a = r & COMPARE_PARTIAL_FLAG$3,
    s = e.length,
    l = t.length;
  if (s != l && !(a && s < l)) return !1;
  var l = o.get(e),
    c = o.get(t);
  if (l && c) return l == t && c == e;
  var u = -1,
    h = !0,
    d = r & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  for (o.set(e, t), o.set(t, e); ++u < s;) {
    var p,
      f = e[u],
      _ = t[u];
    if (void 0 !== (p = n ? a ? n(_, f, u, t, e, o) : n(f, _, u, e, t, o) : p)) {
      if (p) continue;
      h = !1;
      break;
    }
    if (d) {
      if (!arraySome(t, function (e, t) {
        if (!cacheHas(d, t) && (f === e || i(f, e, r, n, o))) return d.push(t);
      })) {
        h = !1;
        break;
      }
    } else if (f !== _ && !i(f, _, r, n, o)) {
      h = !1;
      break;
    }
  }
  return o.delete(e), o.delete(t), h;
}
var _equalArrays = equalArrays$2;
function mapToArray$1(e) {
  var r = -1,
    n = Array(e.size);
  return e.forEach(function (e, t) {
    n[++r] = [t, e];
  }), n;
}
function setToArray$1(e) {
  var t = -1,
    r = Array(e.size);
  return e.forEach(function (e) {
    r[++t] = e;
  }), r;
}
var Uint8Array$1 = _Uint8Array,
  eq = eq_1,
  equalArrays$1 = _equalArrays,
  mapToArray = mapToArray$1,
  setToArray = setToArray$1,
  COMPARE_PARTIAL_FLAG$2 = 1,
  COMPARE_UNORDERED_FLAG = 2,
  boolTag = "[object Boolean]",
  dateTag = "[object Date]",
  errorTag = "[object Error]",
  mapTag = "[object Map]",
  numberTag = "[object Number]",
  regexpTag = "[object RegExp]",
  setTag = "[object Set]",
  stringTag = "[object String]",
  symbolTag = "[object Symbol]",
  arrayBufferTag = "[object ArrayBuffer]",
  dataViewTag = "[object DataView]",
  symbolProto = _Symbol ? _Symbol.prototype : void 0,
  symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag$1(e, t, r, n, i, o, a) {
  switch (r) {
    case dataViewTag:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
      e = e.buffer, t = t.buffer;
    case arrayBufferTag:
      return e.byteLength == t.byteLength && o(new Uint8Array$1(e), new Uint8Array$1(t)) ? !0 : !1;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+e, +t);
    case errorTag:
      return e.name == t.name && e.message == t.message;
    case regexpTag:
    case stringTag:
      return e == t + "";
    case mapTag:
      var s = mapToArray;
    case setTag:
      s = s || setToArray;
      if (e.size != t.size && !(n & COMPARE_PARTIAL_FLAG$2)) return !1;
      var l = a.get(e);
      if (l) return l == t;
      n |= COMPARE_UNORDERED_FLAG, a.set(e, t);
      l = equalArrays$1(s(e), s(t), n, i, o, a);
      return a.delete(e), l;
    case symbolTag:
      if (symbolValueOf) return symbolValueOf.call(e) == symbolValueOf.call(t);
  }
  return !1;
}
var _equalByTag = equalByTag$1,
  getAllKeys = _getAllKeys,
  COMPARE_PARTIAL_FLAG$1 = 1,
  objectProto$1 = Object.prototype,
  hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects$1(e, t, r, n, i, o) {
  var a = r & COMPARE_PARTIAL_FLAG$1,
    s = getAllKeys(e),
    l = s.length;
  if (l != getAllKeys(t).length && !a) return !1;
  for (var c = l; c--;) {
    var u = s[c];
    if (!(a ? u in t : hasOwnProperty$1.call(t, u))) return !1;
  }
  var h = o.get(e),
    d = o.get(t);
  if (h && d) return h == t && d == e;
  for (var p = !0, f = (o.set(e, t), o.set(t, e), a); ++c < l;) {
    var _,
      m = e[u = s[c]],
      g = t[u];
    if (!(void 0 === (_ = n ? a ? n(g, m, u, t, e, o) : n(m, g, u, e, t, o) : _) ? m === g || i(m, g, r, n, o) : _)) {
      p = !1;
      break;
    }
    f = f || "constructor" == u;
  }
  return p && !f && (h = e.constructor) != (d = t.constructor) && "constructor" in e && "constructor" in t && !("function" == typeof h && h instanceof h && "function" == typeof d && d instanceof d) && (p = !1), o.delete(e), o.delete(t), p;
}
var Stack = _Stack,
  equalArrays = _equalArrays,
  equalByTag = _equalByTag,
  equalObjects = equalObjects$1,
  getTag = _getTag,
  isArray$1 = isArray_1,
  isBuffer = isBufferExports,
  isTypedArray = isTypedArray_1,
  COMPARE_PARTIAL_FLAG = 1,
  argsTag = "[object Arguments]",
  arrayTag = "[object Array]",
  objectTag = "[object Object]",
  objectProto = Object.prototype,
  hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep$1(e, t, r, n, i, o) {
  var a = isArray$1(e),
    s = isArray$1(t),
    l = a ? arrayTag : getTag(e),
    s = s ? arrayTag : getTag(t),
    c = (l = l == argsTag ? objectTag : l) == objectTag,
    u = (s = s == argsTag ? objectTag : s) == objectTag,
    s = l == s;
  if (s && isBuffer(e)) {
    if (!isBuffer(t)) return !1;
    c = !(a = !0);
  }
  if (s && !c) return o = o || new Stack(), a || isTypedArray(e) ? equalArrays(e, t, r, n, i, o) : equalByTag(e, t, l, r, n, i, o);
  if (!(r & COMPARE_PARTIAL_FLAG)) {
    a = c && hasOwnProperty.call(e, "__wrapped__"), l = u && hasOwnProperty.call(t, "__wrapped__");
    if (a || l) return i(a ? e.value() : e, l ? t.value() : t, r, n, o = o || new Stack());
  }
  return s && (o = o || new Stack(), equalObjects(e, t, r, n, i, o));
}
var baseIsEqualDeep = baseIsEqualDeep$1,
  isObjectLike$1 = isObjectLike_1;
function baseIsEqual$1(e, t, r, n, i) {
  return e === t || (null == e || null == t || !isObjectLike$1(e) && !isObjectLike$1(t) ? e != e && t != t : baseIsEqualDeep(e, t, r, n, baseIsEqual$1, i));
}
var baseIsEqual = baseIsEqual$1;
function isEqual(e, t) {
  return baseIsEqual(e, t);
}
var isEqual$1 = getDefaultExportFromCjs(isEqual);
function commonjsRequire(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var AreaUnits,
  DistanceUnits,
  TimeUnits,
  SpeedUnits,
  AccelerationUnits,
  uuidRandom = {
    exports: {}
  },
  _nodeResolve_empty = {},
  _nodeResolve_empty$1 = Object.freeze({
    __proto__: null,
    default: _nodeResolve_empty
  }),
  require$$0 = getAugmentedNamespace(_nodeResolve_empty$1),
  uuidRandomExports = (!function (e) {
    for (var t, r, n = 0, i = [], o = 0; o < 256; o++) i[o] = (o + 256).toString(16).substr(1);
    function a() {
      e = 16, (!t || s.BUFFER_SIZE < n + e) && (n = 0, t = s.randomBytes(s.BUFFER_SIZE));
      var e = t.slice(n, n += e);
      return e[6] = 15 & e[6] | 64, e[8] = 63 & e[8] | 128, e;
    }
    function s() {
      var e = a();
      return i[e[0]] + i[e[1]] + i[e[2]] + i[e[3]] + "-" + i[e[4]] + i[e[5]] + "-" + i[e[6]] + i[e[7]] + "-" + i[e[8]] + i[e[9]] + "-" + i[e[10]] + i[e[11]] + i[e[12]] + i[e[13]] + i[e[14]] + i[e[15]];
    }
    s.BUFFER_SIZE = 4096, s.bin = a, s.clearBuffer = function () {
      t = null, n = 0;
    }, s.test = function (e) {
      return "string" == typeof e && /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e);
    }, "undefined" != typeof crypto ? r = crypto : "undefined" != typeof window && void 0 !== window.msCrypto && (r = window.msCrypto), "function" == typeof commonjsRequire ? (r = r || require$$0, e.exports = s) : "undefined" != typeof window && (window.uuid = s), s.randomBytes = function () {
      if (r) {
        if (r.randomBytes) return r.randomBytes;
        if (r.getRandomValues) return "function" != typeof Uint8Array.prototype.slice ? function (e) {
          e = new Uint8Array(e);
          return r.getRandomValues(e), Array.from(e);
        } : function (e) {
          e = new Uint8Array(e);
          return r.getRandomValues(e), e;
        };
      }
      return function (e) {
        for (var t = [], r = 0; r < e; r++) t.push(Math.floor(256 * Math.random()));
        return t;
      };
    }();
  }(uuidRandom), uuidRandom.exports),
  uuid = getDefaultExportFromCjs(uuidRandomExports),
  Feature = function () {
    function i(e, t, r, n) {
      this.type = "Feature", this.type = i.TYPE, this.properties = t || {}, this.id = r, this.geometry = e, this.bbox = n;
    }
    return i.TYPE = "Feature", i;
  }(),
  __extends$15 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  Pixel = function (r) {
    function s(e, t) {
      return r.call(this, e, t) || this;
    }
    return __extends$15(s, r), s.fromData = function (r) {
      var n = NaN,
        i = NaN,
        o = new Set(["y"]),
        a = new Set(["x"]);
      return Object.keys(r).forEach(function (e) {
        var t = e.toLowerCase();
        isNaN(n) && o.has(t) && "number" == typeof r[e] ? n = r[e] : isNaN(i) && a.has(t) && "number" == typeof r[e] && (i = r[e]);
      }), isNaN(n) || isNaN(i) ? null : new s(n, i);
    }, s.getX = function (e) {
      return 0 < e.length ? e[0] : NaN;
    }, s.getY = function (e) {
      return 1 < e.length ? e[1] : NaN;
    }, s.getDestination = function (e, t, r) {
      return new s(s.getX(e) + r * Math.cos((t + 270) * Math.PI / 180), s.getY(e) + r * Math.sin((t + 270) * Math.PI / 180));
    }, s.getDistance = function (e, t) {
      var r = s.getX(e) - s.getX(t),
        e = s.getY(e) - s.getY(t);
      return Math.sqrt(r * r + e * e);
    }, s.getHeading = function (e, t) {
      var r = s.getX(t) - s.getX(e),
        e = s.getY(e) - s.getY(t);
      return 180 * (2.5 * Math.PI - Math.atan2(e, r)) / Math.PI % 360;
    }, s;
  }(Array),
  Point = function () {
    function t(e) {
      this.type = "Point", this.type = t.TYPE, this.coordinates = e;
    }
    return t.TYPE = "Point", t;
  }(),
  __read$f = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  __values$i = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  EARTH_RADIUS_SEMI_MAJOR_AXIS = 6378137,
  PI_BY_180 = Math.PI / 180,
  INV_PI_BY_180 = 180 / Math.PI,
  POWERS_OF_10 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9],
  WEBMERCATOR_MAXLAT = 85.0511;
function _toRadians(e) {
  return e * PI_BY_180;
}
function _toDegrees(e) {
  return e * INV_PI_BY_180;
}
function _clip(e, t, r) {
  return Math.min(Math.max(e, t), r);
}
function _haversineDistance(e, t) {
  var r = _toRadians(t[1] - e[1]),
    n = _toRadians(t[0] - e[0]),
    r = Math.pow(Math.sin(r / 2), 2) + Math.cos(_toRadians(e[1])) * Math.cos(_toRadians(t[1])) * Math.pow(Math.sin(n / 2), 2),
    e = 2 * Math.atan2(Math.sqrt(r), Math.sqrt(1 - r));
  return Math.round(EARTH_RADIUS_SEMI_MAJOR_AXIS * e * 100) / 100;
}
function _normalizeDistanceUnit(e) {
  if (e) switch (e.toLowerCase()) {
    case "feet":
    case "foot":
    case "ft":
      return DistanceUnits.feet;
    case "kilometers":
    case "kilometer":
    case "kilometres":
    case "kilometre":
    case "km":
    case "kms":
      return DistanceUnits.kilometers;
    case "miles":
    case "mile":
    case "mi":
      return DistanceUnits.miles;
    case "nauticalmiles":
    case "nauticalmile":
    case "nms":
    case "nm":
      return DistanceUnits.nauticalMiles;
    case "yards":
    case "yard":
    case "yds":
    case "yrd":
    case "yrds":
      return DistanceUnits.yards;
    default:
      return DistanceUnits.meters;
  }
  return DistanceUnits.meters;
}
function _normalizeAccelerationUnit(e) {
  if (e) switch (e.toLowerCase()) {
    case "milespersecondsquared":
    case "milepersecondsquared":
    case "mi/s^2":
    case "mi/s2":
      return AccelerationUnits.milesPerSecondSquared;
    case "kilometerspersecondsquared":
    case "kilometrespersecondsquared":
    case "kilometerpersecondsquared":
    case "kilometrepersecondsquared":
    case "km/s^2":
    case "km/s2":
      return AccelerationUnits.kilometersPerSecondSquared;
    case "knotspersecond":
    case "knotpersecond":
    case "knts/s":
    case "kn/s":
    case "kt/s":
      return AccelerationUnits.knotsPerSecond;
    case "standardgravity":
    case "g":
      return AccelerationUnits.standardGravity;
    case "feetpersecondsquared":
    case "footpersecondsquared":
    case "ft/s^2":
    case "ft/s2":
      return AccelerationUnits.feetPerSecondSquared;
    case "yardspersecondsquared":
    case "yardpersecondsquared":
    case "yds/s^2":
    case "yds/s2":
    case "yd/s^2":
    case "yd/s2":
      return AccelerationUnits.yardsPerSecondSquared;
    case "milesperhoursecond":
    case "mileperhoursecond":
    case "milesperhourseconds":
    case "mileperhourseconds":
    case "mi/h/s":
      return AccelerationUnits.milesPerHourSecond;
    case "kilometersperhoursecond":
    case "kilometrespersoursecond":
    case "kilometerperhoursecond":
    case "kilometrepersoursecond":
    case "kilometersperhourssecond":
    case "kilometrespersourssecond":
    case "kilometerperhourssecond":
    case "kilometrepersourssecond":
    case "kmhs":
    case "km/h/s":
      return AccelerationUnits.kilometersPerHourSecond;
    default:
      return AccelerationUnits.metersPerSecondSquared;
  }
  return AccelerationUnits.metersPerSecondSquared;
}
function _normalizeAreaUnits(e) {
  if (e) switch (e) {
    case "acres":
    case "ac":
      return AreaUnits.acres;
    case "hectares":
    case "ha":
      return AreaUnits.hectares;
    case "squareFeet":
    case "ft^2":
    case "ft2":
      return AreaUnits.squareFeet;
    case "squareYards":
    case "squareYard":
    case "yds^2":
    case "yds2":
    case "yd^2":
    case "yd2":
      return AreaUnits.squareYards;
    case "squareKilometers":
    case "squareKilometres":
    case "squareKilometer":
    case "squareKilometre":
    case "km^2":
    case "km2":
      return AreaUnits.squareKilometers;
    case "squareMiles":
    case "squareMile":
    case "mi^2":
    case "mi2":
      return AreaUnits.squareMiles;
    default:
      return AreaUnits.squareMeters;
  }
  return AreaUnits.squareMeters;
}
function _normalizeSpeedUnit(e) {
  if (e) switch (e.toLowerCase()) {
    case "feetpersecond":
    case "footsecond":
    case "ftps":
    case "ft/s":
      return SpeedUnits.feetPerSecond;
    case "milesperhour":
    case "mileperhour":
    case "mph":
    case "mi/hr":
    case "mi/h":
      return SpeedUnits.milesPerHour;
    case "knots":
    case "knot":
    case "knts":
    case "knt":
    case "kn":
    case "kt":
      return SpeedUnits.knots;
    case "mach":
    case "m":
      return SpeedUnits.mach;
    case "kilometersperhour":
    case "kilometresperhour":
    case "kmperhour":
    case "kmph":
    case "km/hr":
    case "km/h":
      return SpeedUnits.kilometersPerHour;
    default:
      return SpeedUnits.metersPerSecond;
  }
  return SpeedUnits.metersPerSecond;
}
function _normalizeTimeUnit(e) {
  if (e) switch (e.toLowerCase()) {
    case "milliseconds":
    case "ms":
      return TimeUnits.ms;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
      return TimeUnits.minutes;
    case "hours":
    case "hour":
    case "hr":
    case "h":
      return TimeUnits.hours;
    case "days":
    case "day":
    case "d":
      return TimeUnits.days;
    default:
      return TimeUnits.seconds;
  }
  return TimeUnits.seconds;
}
function _calculatePolygonArea(e) {
  var t = 0;
  if (e && 0 < e.length) for (var t = Math.abs(_calculatePolygonRingArea(e[0])), r = 1, n = e.length; r < n; r++) t -= Math.abs(_calculatePolygonRingArea(e[r]));
  return t;
}
function _calculatePolygonRingArea(e) {
  var t = 0;
  if (3 <= e.length) {
    for (var r = void 0, n = void 0, i = 0, o = e.length; i < o; i++) t += (_toRadians(e[i === o - 2 ? (r = o - 2, n = o - 1, 0) : i === o - 1 ? (r = o - 1, n = 0, 1) : (n = (r = i) + 1, i + 2)][0]) - _toRadians(e[r][0])) * Math.sin(_toRadians(e[n][1]));
    t = t * EARTH_RADIUS_SEMI_MAJOR_AXIS * EARTH_RADIUS_SEMI_MAJOR_AXIS / 2;
  }
  return t;
}
function _cross(e, t, r) {
  return (e[0] - r[0]) * (t[1] - r[1]) - (e[1] - r[1]) * (t[0] - r[0]);
}
function _closestPointOnPath(e, t, r) {
  if (2 <= r.length) {
    for (var n, i, o, a = 1 / 0, s = null, l = mercatorPositionsToPixels(r, 22), c = 0, u = l.length - 1; c < u; c++) i = _closestPixelOnLineSegment(t, l[c], l[c + 1]), (n = Pixel.getDistance(t, i)) < a && (a = n, s = i);
    if (s) return o = mercatorPixelsToPositions([s], 22)[0], new Feature(new Point(o), {
      distance: getDistanceTo(e, o)
    });
  } else if (1 === r.length) return new Feature(new Point(r[0]), {
    distance: getDistanceTo(e, r[0])
  });
  return null;
}
function _closestPixelOnLineSegment(e, t, r) {
  var n, i;
  return t[0] === r[0] && t[1] === r[1] || (i = e[0] - t[0], e = e[1] - t[1], (e = ((n = r[0] - t[0]) * i + (i = r[1] - t[1]) * e) / (n * n + i * i)) < 0) ? t : 1 < e ? r : [t[0] + n * e, t[1] + i * e];
}
function _precision(e, t) {
  var r;
  return !isNaN(e) && "number" == typeof t && 0 <= t && (r = void 0, r = t < POWERS_OF_10.length ? POWERS_OF_10[t] : Math.pow(10, t), e = Math.round(e * r) / r), e;
}
function boundingBoxToPolygon(e) {
  var t = normalizeLongitude(BoundingBox.getWest(e)),
    r = normalizeLongitude(BoundingBox.getEast(e)),
    n = normalizeLatitude(BoundingBox.getNorth(e)),
    i = normalizeLatitude(BoundingBox.getSouth(e)),
    e = BoundingBox.getCenter(e),
    i = [[t, n], [t, i], [e[0], i], [r, i], [r, n], [e[0], n], [t, n]];
  return new Polygon([i]);
}
function convertDistance(e, t, r, n) {
  switch (_normalizeDistanceUnit(t)) {
    case DistanceUnits.meters:
      e /= 1e3;
      break;
    case DistanceUnits.feet:
      e /= 3280.8399;
      break;
    case DistanceUnits.miles:
      e /= .62137119;
      break;
    case DistanceUnits.yards:
      e /= 1093.6133;
      break;
    case DistanceUnits.nauticalMiles:
      e /= .5399568;
      break;
    case DistanceUnits.kilometers:
  }
  switch (_normalizeDistanceUnit(r)) {
    case DistanceUnits.meters:
      e *= 1e3;
      break;
    case DistanceUnits.feet:
      e *= 3280.8399;
      break;
    case DistanceUnits.miles:
      e *= .62137119;
      break;
    case DistanceUnits.yards:
      e *= 1093.6133;
      break;
    case DistanceUnits.nauticalMiles:
      e *= .5399568;
      break;
    case DistanceUnits.kilometers:
  }
  return "number" == typeof n && 0 <= n && (t = Math.pow(10, n), e = Math.round(e * t) / t), e;
}
function getCardinalSpline(e, t, r, n) {
  if (!e || e.length <= 2) return l;
  "number" != typeof t && (t = .5), ("number" != typeof r || r <= 0) && (r = 15);
  var i,
    o,
    a,
    s = e.length,
    l = e.slice(0),
    c = (n ? (Position.areEqual(l[0], l[s - 1]) && (l.pop(), s--), l.unshift(e[s - 1]), l.push(e[0]), l.push(e[1]), s++) : (l.unshift(e[0]), l.push(e[s - 1])), []);
  c.push([1, 0, 0, 0]);
  for (var u = 1; u < r - 1; u++) c.push([2 * (a = (i = u / r) * (o = i * i)) - 3 * o + 1, -2 * a + 3 * o, a - 2 * o + i, a - o]);
  c.push([0, 1, 0, 0]);
  for (var h, d, p, f, _, m, g = [], u = 1; u < s; u++) for (h = t * (l[u + 1][0] - l[u - 1][0]), d = t * (l[u + 1][1] - l[u - 1][1]), p = t * (l[u + 2][0] - l[u][0]), f = t * (l[u + 2][1] - l[u][1]), i = 0; i < r; i++) m = (_ = c[i])[0] * l[u][0] + _[1] * l[u + 1][0] + _[2] * h + _[3] * p, _ = _clip(_[0] * l[u][1] + _[1] * l[u + 1][1] + _[2] * d + _[3] * f, -85, 85), g.push([m, _]);
  return g;
}
function getDestination(e, t, r, n) {
  n = n || "meters", e = getPosition(e);
  var n = getEarthRadius(n),
    i = _toRadians(e[1]),
    e = _toRadians(e[0]),
    t = _toRadians(t),
    r = r / n,
    n = Math.asin(Math.sin(i) * Math.cos(r) + Math.cos(i) * Math.sin(r) * Math.cos(t)),
    e = e + Math.atan2(Math.sin(t) * Math.sin(r) * Math.cos(i), Math.cos(r) - Math.sin(i) * Math.sin(n)),
    t = _clip(normalizeLatitude(_toDegrees(n)), -85, 85);
  return [normalizeLongitude(_toDegrees(e)), t];
}
function getDistanceTo(e, t, r) {
  e = _haversineDistance(e = getPosition(e), t = getPosition(t));
  return "meters" === r ? e : convertDistance(e, "meters", r || "meters");
}
function getEarthRadius(e) {
  e = _normalizeDistanceUnit(e);
  return convertDistance(EARTH_RADIUS_SEMI_MAJOR_AXIS, DistanceUnits.meters, e);
}
function _constructGeodesic(e, t, r) {
  for (var n = [], i = _toRadians(e[1]), o = _toRadians(e[0]), a = _toRadians(t[1]), s = _toRadians(t[0]), l = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin((i - a) / 2), 2) + Math.cos(i) * Math.cos(a) * Math.pow(Math.sin((o - s) / 2), 2))), c = 0; c <= r; c++) {
    var u = c / r,
      h = Math.sin((1 - u) * l) / Math.sin(l),
      u = Math.sin(u * l) / Math.sin(l),
      d = h * Math.cos(i) * Math.cos(o) + u * Math.cos(a) * Math.cos(s),
      p = h * Math.cos(i) * Math.sin(o) + u * Math.cos(a) * Math.sin(s),
      h = h * Math.sin(i) + u * Math.sin(a),
      u = Math.atan2(h, Math.sqrt(Math.pow(d, 2) + Math.pow(p, 2))),
      h = Math.atan2(p, d),
      u = _clip(_toDegrees(u), -85, 85),
      h = _toDegrees(h);
    n.push([h, u]);
  }
  return n;
}
function getPathDenormalizedAtAntimerian(e) {
  return (Array.isArray(e) ? e : e.coordinates).reduce(function (e, t) {
    var r = 0 < e.length ? e[e.length - 1] : null;
    return r && 180 < Math.abs(t[0] - r[0]) ? (r = r[0] < 0 ? t[0] - 360 : t[0] + 360, e.push([r, t[1]])) : e.push(t), e;
  }, []);
}
function getPathSplitByAntimeridian(e) {
  for (var t, r, n, i, o, a = Array.isArray(e) ? e : e.coordinates, s = [], l = [], c = 0; c < a.length; c++) s.push(a[c]), c + 1 >= a.length || (t = (r = __read$f(a[c], 2))[0], r = r[1], i = (o = __read$f(a[c + 1], 2))[0], o = o[1], 180 < Math.abs(i - t) && (n = 0 < t ? 180 : -180, i = Math.abs((0 < t ? i + 360 : i - 360) - t), o = r + (o - r) * (Math.abs(n - t) / i), s.push([n, o]), l.push(s), s = [[-n, o]]));
  return l.push(s), l;
}
function getGeodesicPath(e, t) {
  (!t || t <= 0) && (t = 15), Array.isArray(e) ? r = e : e.type && "LineString" === e.type && (r = e.coordinates);
  for (var r, n = r.length - 1, i = [], o = 0; o < n; o++) i = i.concat(_constructGeodesic(r[o], r[o + 1], t));
  return getPathDenormalizedAtAntimerian(i);
}
function getGeodesicPaths(e, t) {
  (!t || t <= 0) && (t = 15), Array.isArray(e) ? r = e : e.type && "LineString" === e.type && (r = e.coordinates);
  for (var r, n = r.length - 1, i = [], o = [], a = 0; a < n; a++) for (var s, l, c, u, h, d = _constructGeodesic(r[a], r[a + 1], t), p = 0; p < d.length; p++) i.push(d[p]), p + 1 >= d.length || (s = (l = __read$f(d[p], 2))[0], l = l[1], u = (h = __read$f(d[p + 1], 2))[0], h = h[1], 180 < Math.abs(u - s) && (c = 0 < s ? 180 : -180, u = Math.abs((0 < s ? u + 360 : u - 360) - s), h = l + (h - l) * (Math.abs(c - s) / u), i.push([c, h]), o.push(i), i = [[-c, h]]));
  return o.push(i), o;
}
function getHeading(e, t) {
  var r, n;
  return e = getPosition(e), t = getPosition(t), e && 2 <= e.length && t && 2 <= t.length ? (n = _toRadians(e[1]), r = _toRadians(t[1]), t = _toRadians(t[0] - e[0]), e = Math.sin(t) * Math.cos(r), n = Math.cos(n) * Math.sin(r) - Math.sin(n) * Math.cos(r) * Math.cos(t), (_toDegrees(Math.atan2(e, n)) + 360) % 360) : NaN;
}
function getLengthOfPath(e, t) {
  var r,
    n = 0;
  Array.isArray(e) ? r = e : e.type && "LineString" === e.type && (r = e.coordinates);
  for (var i = 0, o = r.length - 1; i < o; i++) n += _haversineDistance(r[i], r[i + 1]);
  return convertDistance(n, "meters", t || "meters");
}
function getPositionAlongPath(e, t, r) {
  r = r || "meters";
  var n,
    i = 0;
  if (Array.isArray(e) ? n = e : e.type && "LineString" === e.type && (n = e.coordinates), 2 <= n.length) {
    for (var o, a, s = n.length, l = 1; l < s; l++) {
      if (t <= i + (a = getDistanceTo(n[l - 1], n[l], r))) return o = getHeading(n[l - 1], n[l]), getDestination(n[l - 1], o, t - i, r);
      i += a;
    }
    return i <= t ? n[s - 1] : n[0];
  }
  return null;
}
function _constructRegularPolygonPath(e, t, r, n, i) {
  n = n || "meters", i = i || 0, e = getPosition(e);
  for (var o = [], a = 360 / r, s = 0; s <= r; s++) o.push(getDestination(e, (s * a + i) % 360, t, n));
  return o;
}
function getRegularPolygonPath(e, t, r, n, i) {
  return getPathDenormalizedAtAntimerian(_constructRegularPolygonPath(e, t, r, n, i));
}
function getRegularPolygonPaths(e, t, r, n, i) {
  return getPathSplitByAntimeridian(_constructRegularPolygonPath(e, t, r, n, i));
}
function interpolate(e, t, r) {
  r = void 0 === r ? .5 : r;
  var n = getDistanceTo(e = getPosition(e), t = getPosition(t), "kilometers");
  return getDestination(e, getHeading(e, t), n * r, "kilometers");
}
function normalizeLatitude(e) {
  return 90 < e ? 180 < (e = (e + 90) % 360) ? 90 - (e - 180) : e - 90 : e < -90 ? (e = (e - 90) % 360) < -180 ? -90 - (e + 180) : e + 90 : e;
}
function normalizeLongitude(e) {
  return 180 < e ? (e + 180) % 360 - 180 : e < -180 ? (e - 180) % 360 + 180 : e;
}
function rotatePositions(e, t, r) {
  if (0 === r) return Object.assign({}, e);
  t = getPosition(t);
  for (var n, i, o = [], a = 0, s = e.length; a < s; a++) n = getDistanceTo(t, e[a]), i = getHeading(t, e[a]), o.push(getDestination(t, i + r, n));
  return o;
}
function getPixelHeading(e, t) {
  e = getPosition(e), t = getPosition(t);
  var e = __read$f(mercatorPositionsToPixels([e, t], 21), 2),
    t = e[0],
    e = e[1],
    r = e[0] - t[0],
    t = t[1] - e[1];
  return (2.5 * Math.PI - Math.atan2(t, r)) * INV_PI_BY_180 % 360;
}
function mercatorPixelsToPositions(e, t) {
  for (var r, n, i = 512 * Math.pow(2, t), o = [], a = 0, s = e.length; a < s; a++) r = e[a][0] / i - .5, n = .5 - e[a][1] / i, o.push([360 * r, 90 - 360 * Math.atan(Math.exp(2 * -n * Math.PI)) / Math.PI]);
  return o;
}
function mercatorPositionsToPixels(e, t) {
  for (var r, n, i = 512 * Math.pow(2, t), o = [], a = 0, s = e.length; a < s; a++) n = Math.sin(e[a][1] * Math.PI / 180), r = (e[a][0] + 180) / 360, n = .5 - Math.log((1 + n) / (1 - n)) / (4 * Math.PI), o.push([Math.round(r * i), Math.round(n * i)]);
  return o;
}
function convertAcceleration(e, t, r, n) {
  switch (_normalizeAccelerationUnit(t)) {
    case AccelerationUnits.kilometersPerHourSecond:
      e /= 3.6;
      break;
    case AccelerationUnits.milesPerHourSecond:
      e /= 2.236936292054;
      break;
    case AccelerationUnits.knotsPerSecond:
      e /= 1.943844492441;
      break;
    case AccelerationUnits.standardGravity:
      e /= .1019716212978;
      break;
    case AccelerationUnits.kilometersPerSecondSquared:
      e /= .001;
      break;
    case AccelerationUnits.milesPerSecondSquared:
      e /= .000621371192;
      break;
    case AccelerationUnits.feetPerSecondSquared:
      e /= 3.280839895012;
      break;
    case AccelerationUnits.yardsPerSecondSquared:
      e /= 1.093613298338;
      break;
    case AccelerationUnits.metersPerSecondSquared:
  }
  switch (_normalizeAccelerationUnit(r)) {
    case AccelerationUnits.kilometersPerHourSecond:
      e *= 3.6;
      break;
    case AccelerationUnits.milesPerHourSecond:
      e *= 2.236936292054;
      break;
    case AccelerationUnits.knotsPerSecond:
      e *= 1.943844492441;
      break;
    case AccelerationUnits.standardGravity:
      e *= .1019716212978;
      break;
    case AccelerationUnits.kilometersPerSecondSquared:
      e *= .001;
      break;
    case AccelerationUnits.milesPerSecondSquared:
      e *= .000621371192;
      break;
    case AccelerationUnits.feetPerSecondSquared:
      e *= 3.280839895012;
      break;
    case AccelerationUnits.yardsPerSecondSquared:
      e *= 1.093613298338;
      break;
    case AccelerationUnits.metersPerSecondSquared:
  }
  return _precision(e, n);
}
function convertArea(e, t, r, n) {
  switch (_normalizeAreaUnits(t)) {
    case AreaUnits.acres:
      e *= 4046.8564224;
      break;
    case AreaUnits.hectares:
      e *= 1e4;
      break;
    case AreaUnits.squareFeet:
      e *= .09290304;
      break;
    case AreaUnits.squareKilometers:
      e *= 1e6;
      break;
    case AreaUnits.squareMiles:
      e *= 259e4;
      break;
    case AreaUnits.squareYards:
      e *= .83612736;
      break;
    case AreaUnits.squareMeters:
  }
  switch (_normalizeAreaUnits(r)) {
    case AreaUnits.acres:
      e /= 4046.8564224;
      break;
    case AreaUnits.hectares:
      e /= 1e4;
      break;
    case AreaUnits.squareFeet:
      e /= .09290304;
      break;
    case AreaUnits.squareKilometers:
      e /= 1e6;
      break;
    case AreaUnits.squareMiles:
      e /= 259e4;
      break;
    case AreaUnits.squareYards:
      e /= .83612736;
      break;
    case AreaUnits.squareMeters:
  }
  return _precision(e, n);
}
function convertSpeed(e, t, r, n) {
  switch (_normalizeSpeedUnit(t)) {
    case SpeedUnits.feetPerSecond:
      e *= 1.09728;
      break;
    case SpeedUnits.milesPerHour:
      e *= 1.6093;
      break;
    case SpeedUnits.knots:
      e *= 1.852;
      break;
    case SpeedUnits.metersPerSecond:
      e *= 3.6;
      break;
    case SpeedUnits.mach:
      e *= 1234.8;
      break;
    case SpeedUnits.kilometersPerHour:
  }
  switch (_normalizeSpeedUnit(r)) {
    case SpeedUnits.feetPerSecond:
      e /= 1.09728;
      break;
    case SpeedUnits.milesPerHour:
      e /= 1.6093;
      break;
    case SpeedUnits.knots:
      e /= 1.852;
      break;
    case SpeedUnits.metersPerSecond:
      e /= 3.6;
      break;
    case SpeedUnits.mach:
      e /= 1234.8;
      break;
    case SpeedUnits.kilometersPerHour:
  }
  return _precision(e, n);
}
function convertTimespan(e, t, r, n) {
  switch (_normalizeTimeUnit(t)) {
    case TimeUnits.ms:
      e /= 1e3;
      break;
    case TimeUnits.hours:
      e *= 3600;
      break;
    case TimeUnits.minutes:
      e *= 60;
      break;
    case TimeUnits.days:
      e *= 86400;
      break;
    case TimeUnits.seconds:
  }
  switch (_normalizeTimeUnit(r)) {
    case TimeUnits.ms:
      e *= 1e3;
      break;
    case TimeUnits.hours:
      e /= 3600;
      break;
    case TimeUnits.minutes:
      e /= 60;
      break;
    case TimeUnits.days:
      e /= 86400;
      break;
    case TimeUnits.seconds:
  }
  return _precision(e, n);
}
function getAcceleration(e, t, r, n, i, o, a, s) {
  t = convertDistance(t, i, DistanceUnits.meters), i = convertTimespan(r, o, TimeUnits.seconds);
  return convertAcceleration(2 * (t - convertSpeed(e, n, SpeedUnits.metersPerSecond) * i) / (i * i), AccelerationUnits.metersPerSecondSquared, a, s);
}
function getAccelerationFromSpeeds(e, t, r, n, i, o, a) {
  e = convertSpeed(e, n, SpeedUnits.metersPerSecond);
  return convertAcceleration((convertSpeed(t, n, SpeedUnits.metersPerSecond) - e) / convertTimespan(r, i, TimeUnits.seconds), AccelerationUnits.metersPerSecondSquared, o, a);
}
function getAccelerationFromFeatures(e, t, r, n, i, o, a) {
  if ("string" == typeof r && "Feature" === e.type && "Point" === e.geometry.type && "Feature" === t.type && "Point" === t.geometry.type) {
    r = getTimespan(e.properties[r], t.properties[r], TimeUnits.seconds);
    if (!isNaN(r)) {
      var s = 0;
      if (n && "string" == typeof n) {
        var l = e.properties[n],
          n = t.properties[n];
        if ("number" == typeof l && (s = l, "number" == typeof n)) return getAccelerationFromSpeeds(l, n, r, i, TimeUnits.seconds, o, a);
      }
      return getAcceleration(s, getDistanceTo(e.geometry.coordinates, t.geometry.coordinates, DistanceUnits.meters), r, i, DistanceUnits.meters, TimeUnits.seconds, o, a);
    }
  }
  return NaN;
}
function getArea(e, t, r) {
  if (e) {
    var n = 0;
    switch ((e = e instanceof Shape ? e.toJson() : e).type) {
      case "Feature":
        var i = e;
        if (i.geometry) return getArea(i.geometry, t, r);
        break;
      case "Polygon":
        i = e;
        i.coordinates && (n = _calculatePolygonArea(i.coordinates));
        break;
      case "MultiPolygon":
        var o = e;
        if (o.coordinates) for (var a = 0, s = o.coordinates.length; a < s; a++) n += _calculatePolygonArea(o.coordinates[a]);
    }
    return convertArea(n, AreaUnits.squareMeters, t, r);
  }
  return 0;
}
function getSpeed(e, t, r, n, i, o) {
  e = getPosition(e), t = getPosition(t);
  return e && t ? (r = convertTimespan(r, n, TimeUnits.seconds), convertSpeed(getDistanceTo(e, t, DistanceUnits.meters) / r, SpeedUnits.metersPerSecond, i, o)) : 0;
}
function getSpeedFromFeatures(e, t, r, n, i) {
  if ("string" == typeof r && "Feature" === e.type && "Point" === e.geometry.type && "Feature" === t.type && "Point" === t.geometry.type) {
    r = getTimespan(e.properties[r], t.properties[r], TimeUnits.seconds);
    if (!isNaN(r)) return convertSpeed(getDistanceTo(e.geometry.coordinates, t.geometry.coordinates, DistanceUnits.meters) / r, SpeedUnits.metersPerSecond, n, i);
  }
  return NaN;
}
function getTimespan(e, t, r, n) {
  e = parseTimestamp(e), t = parseTimestamp(t);
  return null != e && null != t ? convertTimespan(t.getTime() - e.getTime(), TimeUnits.ms, r, n) : NaN;
}
function getTravelDistance(e, t, r, n, i, o, a, s) {
  t = convertTimespan(t, i, TimeUnits.seconds);
  i = (r = convertSpeed(r, o, SpeedUnits.metersPerSecond)) * t;
  return "number" == typeof n && (i += .5 * convertAcceleration(n, a, AccelerationUnits.metersPerSecondSquared) * t * t), convertDistance(i, DistanceUnits.meters, e, s);
}
function parseTimestamp(e) {
  if ("[object Date]" === Object.prototype.toString.call(e)) return e;
  if ("string" == typeof e) {
    var t = Date.parse(e);
    if (!isNaN(t)) return new Date(t);
    if (0 <= e.indexOf("Date(")) return t = (t = 0) < (e = e.replace("/Date(", "").replace(")/", "")).indexOf("+") ? parseInt(e.substr(0, e.indexOf("+")), 10) : 0 < e.indexOf("-") ? parseInt(e.substr(0, e.indexOf("-")), 10) : parseInt(e, 10), new Date(t);
  } else if ("number" == typeof e) return new Date(e);
  return null;
}
function getConvexHull(e) {
  var t,
    r,
    n = getPositions(e).map(function (e) {
      return [normalizeLongitude(e[0]), normalizeLatitude(e[1])];
    }),
    i = (n.sort(function (e, t) {
      return e[0] === t[0] ? e[1] - t[1] : e[0] - t[0];
    }), []);
  try {
    for (var o = __values$i(n), a = o.next(); !a.done; a = o.next()) {
      for (var s = a.value; 2 <= i.length && _cross(i[i.length - 2], i[i.length - 1], s) <= 0;) i.pop();
      i.push(s);
    }
  } catch (e) {
    t = {
      error: e
    };
  } finally {
    try {
      a && !a.done && (r = o.return) && r.call(o);
    } finally {
      if (t) throw t.error;
    }
  }
  for (var l = [], c = n.length - 1; 0 <= c; c--) {
    for (; 2 <= l.length && _cross(l[l.length - 2], l[l.length - 1], n[c]) <= 0;) l.pop();
    l.push(n[c]);
  }
  return new Polygon([i.concat(l)]);
}
function getPositions(e) {
  var t = [],
    r = null,
    n = null;
  if (Array.isArray(e) && 0 < e.length) {
    if (Array.isArray(e[0]) && "number" == typeof e[0][0]) t = e;else for (var i = e.length, o = 0; o < i; o++) t = t.concat(getPositions(e[o]));
  } else if (e.type) switch (e.type) {
    case "Point":
      t = [e.coordinates];
      break;
    case "LineString":
      t = e.coordinates;
      break;
    case "Polygon":
      r = e.coordinates;
      break;
    case "MultiPoint":
      t = e.coordinates;
      break;
    case "MultiLineString":
      r = e.coordinates;
      break;
    case "MultiPolygon":
      n = e.coordinates;
      break;
    case "Feature":
      var a = e,
        t = Shape._isCircle(a) ? Shape._getCirclePositions(a) : getPositions(a.geometry);
      break;
    case "FeatureCollection":
      t = getPositions(e.features);
      break;
    case "GeometryCollection":
      t = getPositions(e.geometries);
  } else if (e instanceof Shape) return getPositions(e.toJson());
  if (r) for (i = r.length, o = 0; o < i; o++) t = t.concat(r[o]);else if (n) for (var s = n.length, o = 0; o < s; o++) for (var l = n[o].length, c = 0; c < l; c++) t = t.concat(n[o][c]);
  return t;
}
function getPosition(e) {
  if (Array.isArray(e) && "number" == typeof e[0]) return e;
  if (e.type) {
    if ("Point" === e.type) return e.coordinates;
    if ("Feature" === e.type && "Point" === e.geometry.type) return e.geometry.coordinates;
  } else if (e instanceof Shape && "Point" === e.getType()) return e.getCoordinates();
  return null;
}
function getPositionsAlongPath(e, t) {
  if (t < 2) return [];
  for (var r = [], n = getLengthOfPath(e, DistanceUnits.meters) / (t - 1), i = 0; i < t; i++) {
    var o = getPositionAlongPath(e, n * i, DistanceUnits.meters);
    null != o && r.push(o);
  }
  return r;
}
function getPointWithHeadingAlongPath(e, t, r) {
  r = r || "meters";
  var n,
    i = 0;
  if (Array.isArray(e) ? n = e : e.type && "LineString" === e.type && (n = e.coordinates), 2 <= n.length) {
    for (var o, a, s, l = n.length, c = 1; c < l; c++) {
      if (t <= i + (s = getDistanceTo(n[c - 1], n[c], r))) return o = getHeading(n[c - 1], n[c]), a = getDestination(n[c - 1], o, t - i, r), new Feature(new Point(a), {
        heading: o
      });
      i += s;
    }
    return i <= t ? new Feature(new Point(n[l - 1]), {
      heading: getHeading(n[l - 2], n[l - 1])
    }) : new Feature(new Point(n[0]), {
      heading: getHeading(n[0], n[1])
    });
  }
  return null;
}
function getPointsWithHeadingsAlongPath(e, t) {
  if (t <= 0) return [];
  for (var r = [], n = getLengthOfPath(e, DistanceUnits.meters) / (t - 1), i = 0; i < t; i++) {
    var o = getPointWithHeadingAlongPath(e, n * i, DistanceUnits.meters);
    null != o && r.push(o);
  }
  return r;
}
function getClosestPointOnGeometry(e, t, r, n) {
  var i = getPosition(e),
    o = mercatorPositionsToPixels([i], 22)[0],
    a = null,
    s = 1 / 0;
  switch ((t = t instanceof Shape ? t.toJson() : t).type) {
    case "Feature":
      return getClosestPointOnGeometry(e, t.geometry, r);
    case "Point":
      p = [[t.coordinates]];
      break;
    case "MultiPoint":
      for (var l, c = t.coordinates, u = 0, h = c.length; u < h; u++) (l = getDistanceTo(i, c[u])) < s && (s = l, a = new Feature(new Point(c[u]), {
        distance: l
      }));
      break;
    case "LineString":
      p = [t.coordinates];
      break;
    case "Polygon":
    case "MultiLineString":
      p = t.coordinates;
      break;
    case "MultiPolygon":
      var d = t.coordinates;
      if (0 < d.length) for (var p = d[0], u = 1, h = d.length; u < h; u++) p = p.concat(d[u]);
  }
  if (p) for (var f, u = 0, h = p.length; u < h; u++) (f = _closestPointOnPath(i, o, p[u])) && f.properties.distance < s && (s = f.properties.distance, a = f);
  return a && (a.properties.distance = convertDistance(a.properties.distance, "meters", r, n)), a;
}
!function (e) {
  e.squareMeters = "squareMeters", e.acres = "acres", e.hectares = "hectares", e.squareFeet = "squareFeet", e.squareKilometers = "squareKilometers", e.squareMiles = "squareMiles", e.squareYards = "squareYards";
}(AreaUnits = AreaUnits || {}), function (e) {
  e.meters = "meters", e.kilometers = "kilometers", e.feet = "feet", e.miles = "miles", e.nauticalMiles = "nauticalMiles", e.yards = "yards";
}(DistanceUnits = DistanceUnits || {}), function (e) {
  e.seconds = "seconds", e.hours = "hours", e.ms = "ms", e.minutes = "minutes", e.days = "days";
}(TimeUnits = TimeUnits || {}), function (e) {
  e.metersPerSecond = "metersPerSecond", e.kilometersPerHour = "kilometersPerHour", e.feetPerSecond = "feetPerSecond", e.milesPerHour = "milesPerHour", e.knots = "knots", e.mach = "mach";
}(SpeedUnits = SpeedUnits || {}), function (e) {
  e.milesPerSecondSquared = "milesPerSecondSquared", e.kilometersPerSecondSquared = "kilometersPerSecondSquared", e.knotsPerSecond = "knotsPerSecond", e.standardGravity = "standardGravity", e.feetPerSecondSquared = "feetPerSecondSquared", e.yardsPerSecondSquared = "yardsPerSecondSquared", e.milesPerHourSecond = "milesPerHourSecond", e.kilometersPerHourSecond = "kilometersPerHourSecond", e.metersPerSecondSquared = "metersPerSecondSquared";
}(AccelerationUnits = AccelerationUnits || {});
var __extends$14 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  Position = function (n) {
    function o(e, t, r) {
      return r ? n.call(this, e, t, r) || this : n.call(this, e, t) || this;
    }
    return __extends$14(o, n), o.fromPosition = function (e) {
      return 2 === e.length ? new o(e[0], e[1]) : 2 < e.length ? new o(e[0], e[1], e[2]) : null;
    }, o.areEqual = function (e, t, r) {
      var n, i;
      return void 0 === r && (r = 6), !!(e && 2 <= e.length && t && 2 <= t.length) && (r = Math.pow(10, r), i = normalizeLatitude(e[1]), n = normalizeLatitude(t[1]), e = normalizeLongitude(e[0]), t = normalizeLongitude(t[0]), 0 == Math.round((i - n) * r) / r) && (0 == (i = Math.round((e - t) * r) / r) || 360 == i);
    }, o.fromLatLng = function (i, e, t) {
      var o,
        a,
        s,
        l,
        c,
        u,
        r = [];
      return "number" == typeof i ? (r.push(i), "number" == typeof e && r.push(e), "number" == typeof t && r.push(t)) : Array.isArray(i) ? 2 <= i.length && "number" == typeof i[0] && "number" == typeof i[1] && (3 <= i.length && "number" == typeof i[2] ? r.push(i[0], i[1], i[2]) : r.push(i[0], i[1])) : "object" == typeof i && (o = ["lat", "latitude", "y"], a = ["lng", "longitude", "lon", "x"], s = ["elv", "elevation", "alt", "altitude", "z"], u = c = l = NaN, Object.keys(i).forEach(function (e, t, r) {
        var n = e.toLowerCase();
        isNaN(l) && 0 <= o.indexOf(n) && "number" == typeof i[e] ? l = i[e] : isNaN(c) && 0 <= a.indexOf(n) && "number" == typeof i[e] ? c = i[e] : isNaN(u) && 0 <= s.indexOf(n) && "number" == typeof i[e] && (u = i[e]);
      }), isNaN(l) || isNaN(c) || (r.push(c, l), isNaN(u)) || r.push(u)), 2 <= r.length ? r : null;
    }, o.fromLatLngs = function (e) {
      var t = [];
      if (Array.isArray(e)) for (var r = 0, n = e.length; r < n; r++) {
        var i = o.fromLatLng(e[r]);
        i && t.push(i);
      }
      return t;
    }, o._getDimensions = function (e) {
      for (var t = 0; Array.isArray(e);) e = e[0], t++;
      return "number" == typeof e && t--, t;
    }, o;
  }(Array),
  Polygon = function () {
    function r(e, t) {
      this.type = "Polygon", this.type = r.TYPE, 1 === Position._getDimensions(e) ? this.coordinates = [e] : this.coordinates = e, this.bbox = t;
    }
    return r.TYPE = "Polygon", r;
  }(),
  __extends$13 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __values$h = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  Shape = function (a) {
    function s(e, t, r) {
      var n,
        i,
        o = a.call(this) || this;
      return "Feature" === e.type ? (i = cloneDeep$1((n = e).geometry), r = n.properties ? cloneDeep$1(n.properties) : {}, t = null == n.id || "" === n.id ? uuid() : n.id) : (i = cloneDeep$1(e), t = null == t || "" === t ? uuid() : t, r = r ? cloneDeep$1(r) : {}), r[s._shapeIdPropName] = t, o.data = new Feature(i, r, t), o._handleCircle(), o;
    }
    return __extends$13(s, a), s.prototype.addProperty = function (e, t) {
      isEqual$1(this.data.properties[e], t) || (this.data.properties[e] = cloneDeep$1(t), "subType" !== e && "radius" !== e || this._handleCircle(), this.dataSource && this.dataSource._updateSource(), this._invokeEvent("shapechanged", this));
    }, s.prototype.getBounds = function () {
      var t,
        e,
        r,
        n,
        i,
        o = this.getCoordinates(),
        a = this.getType();
      if ("Point" === a) i = this.circlePolygon ? (s = this.circlePolygon.geometry.coordinates, BoundingBox.fromPositions(s[0])) : new BoundingBox(s = o, s);else if ("MultiPoint" === a || "LineString" === a) {
        var s = o;
        i = BoundingBox.fromPositions(s);
      } else if ("Polygon" === a) {
        s = o;
        i = BoundingBox.fromPositions(s[0]);
      } else if ("MultiLineString" === a) {
        s = o;
        try {
          for (var l = __values$h(s), c = l.next(); !c.done; c = l.next()) {
            var u = c.value;
            i = BoundingBox.merge(i, BoundingBox.fromPositions(u));
          }
        } catch (e) {
          t = {
            error: e
          };
        } finally {
          try {
            c && !c.done && (e = l.return) && e.call(l);
          } finally {
            if (t) throw t.error;
          }
        }
      } else if ("MultiPolygon" === a) {
        s = o;
        try {
          for (var h = __values$h(s), d = h.next(); !d.done; d = h.next()) {
            var p = d.value;
            i = BoundingBox.merge(i, BoundingBox.fromPositions(p[0]));
          }
        } catch (e) {
          r = {
            error: e
          };
        } finally {
          try {
            d && !d.done && (n = h.return) && n.call(h);
          } finally {
            if (r) throw r.error;
          }
        }
      }
      return i;
    }, s.prototype.getCoordinates = function () {
      return cloneDeep$1(this.data.geometry.coordinates);
    }, s.prototype.getCircleCoordinates = function () {
      return this.circlePolygon ? cloneDeep$1(this.circlePolygon.geometry.coordinates[0]) : null;
    }, s.prototype.getId = function () {
      return this.data.id;
    }, s.prototype.getProperties = function () {
      return cloneDeep$1(this.data.properties);
    }, s.prototype.getType = function () {
      return this.data.geometry.type;
    }, s.prototype.isCircle = function () {
      return s._isCircle(this.data);
    }, s.prototype.isRectangle = function () {
      return s._isRectangle(this.data);
    }, s.prototype.setCoordinates = function (e) {
      e = "Polygon" === this.getType() && 1 === Position._getDimensions(e) ? [e] : e;
      isEqual$1(this.data.geometry.coordinates, e) || (this.data.geometry.coordinates = cloneDeep$1(e), this._handleCircle(), this.dataSource && this.dataSource._updateSource(), this._invokeEvent("shapechanged", this));
    }, s.prototype.setProperties = function (e) {
      e[s._shapeIdPropName] = this.data.id, isEqual$1(this.data.properties, e) || (this.data.properties = cloneDeep$1(e), this._handleCircle(), this.dataSource && this.dataSource._updateSource(), this._invokeEvent("shapechanged", this));
    }, s.prototype.toJson = function () {
      return JSON.parse(JSON.stringify(this.data));
    }, s.prototype._toJson = function () {
      return this.circlePolygon || this.data;
    }, s.prototype._setDataSource = function (e) {
      void 0 === e || null == e ? delete this.dataSource : this.dataSource = e;
    }, s.prototype._handleCircle = function () {
      var e;
      this.isCircle() ? (e = s._getCirclePositions(this.data), this.circlePolygon = new Feature(new Polygon([e]), this.data.properties, this.data.id), this.data.properties.subType = "Circle") : delete this.circlePolygon;
    }, s._isCircle = function (e) {
      return e && e.geometry && "Point" === e.geometry.type && e.geometry.coordinates && e.properties && "string" == typeof e.properties.subType && "circle" === e.properties.subType.toLowerCase() && "number" == typeof e.properties.radius;
    }, s._isRectangle = function (e) {
      if ("Polygon" === e.geometry.type && e.geometry.coordinates && "string" == typeof e.properties.subType && "rectangle" === e.properties.subType.toLowerCase()) {
        e = e.geometry.coordinates;
        if (1 === e.length) {
          e = e[0];
          if (5 === e.length) return e[0][0] === e[4][0] && e[0][1] === e[4][1];
          if (4 === e.length) return !0;
        }
      }
      return !1;
    }, s._getCirclePositions = function (e) {
      return getRegularPolygonPath(e.geometry.coordinates, e.properties.radius, 72, "meters");
    }, s._shapeIdPropName = "_azureMapsShapeId", s;
  }(EventEmitter),
  __extends$12 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __values$g = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  BoundingBox = function (i) {
    function g(e, t) {
      var r,
        n = this;
      return e && t ? n = (r = e)[2] && t[2] ? i.call(this, r[0], r[1], r[2] || 0, t[0], t[1], t[2] || 0) || this : i.call(this, r[0], r[1], t[0], t[1]) || this : e && (r = e) && (4 === r.length ? n = i.call(this, r[0], r[1], r[2], r[3]) || this : 6 <= r.length && (n = i.call(this, r[0], r[1], r[2], r[3], r[4], r[5]) || this)), n;
    }
    return __extends$12(g, i), g.fromBoundingBox = function (e) {
      var t = g.getWest(e),
        r = g.getSouth(e),
        n = g.getEast(e),
        e = g.getNorth(e);
      return new g([t, r, n, e]);
    }, g.fromDimensions = function (e, t, r) {
      var n = e[0],
        e = e[1],
        i = Math.min(Math.max(e + r / 2, -85.5), 85.5),
        e = Math.min(Math.max(e - r / 2, -85.5), 85.5),
        r = normalizeLongitude(n + t / 2);
      return new g([normalizeLongitude(n - t / 2), e, r, i]);
    }, g.fromEdges = function (e, t, r, n) {
      return new g([e, t, r, n]);
    }, g.containsPosition = function (e, t) {
      var r = g.getCenter(e),
        n = Math.abs(r[1] - t[1]),
        r = Math.abs(r[0] - t[0]),
        t = (180 < r && (r = 360 - r), g.getHeight(e)),
        e = g.getWidth(e);
      return n <= t / 2 + 1e-8 && r <= e / 2 + 1e-8;
    }, g.containsBoundingBox = function (e, t) {
      var r = e && 4 === e.length,
        n = t && 4 === t.length;
      return !(!r || !n) && g.getWest(e) < g.getWest(t) && g.getWest(t) < g.getEast(e) && g.getWest(e) < g.getEast(t) && g.getEast(t) < g.getEast(e) && g.getSouth(e) < g.getSouth(t) && g.getSouth(t) < g.getNorth(e) && g.getSouth(e) < g.getNorth(t) && g.getNorth(t) < g.getNorth(e);
    }, g.crossesAntimeridian = function (e) {
      return normalizeLongitude(g.getEast(e)) - normalizeLongitude(g.getWest(e)) < 0 || g.isBoundingBoxWithSixOrMoreElementsLargerThanGlobe(e) || g.isBoundingBoxWithLessThanSixElementsLargerThanGlobe(e);
    }, g.getCenter = function (e) {
      var t = normalizeLongitude(g.getEast(e)),
        r = normalizeLongitude(g.getWest(e)),
        r = (t < r && (t += 360), normalizeLongitude((r + t) / 2)),
        t = normalizeLatitude(g.getSouth(e)),
        e = normalizeLatitude(g.getNorth(e));
      return [r, normalizeLatitude((t + e) / 2)];
    }, g.getHeight = function (e) {
      e = normalizeLatitude(g.getNorth(e)) - normalizeLatitude(g.getSouth(e));
      return isNaN(e) ? 0 : e;
    }, g.getWidth = function (e) {
      e = normalizeLongitude(g.getEast(e)) - normalizeLongitude(g.getWest(e));
      return isNaN(e) ? 0 : e < 0 ? e + 360 : e;
    }, g.getSouthWest = function (e) {
      var t = this.getSouth(e),
        e = this.getWest(e);
      return isNaN(t) || isNaN(e) ? null : [e, t];
    }, g.getNorthEast = function (e) {
      var t = this.getNorth(e),
        e = this.getEast(e);
      return isNaN(t) || isNaN(e) ? null : [e, t];
    }, g.getNorthWest = function (e) {
      var t = this.getNorth(e),
        e = this.getWest(e);
      return isNaN(t) || isNaN(e) ? null : [e, t];
    }, g.getSouthEast = function (e) {
      var t = this.getSouth(e),
        e = this.getEast(e);
      return isNaN(t) || isNaN(e) ? null : [e, t];
    }, g.getSouth = function (e) {
      return e && 4 <= e.length ? Number(e[1]) : NaN;
    }, g.getWest = function (e) {
      return e && 4 <= e.length ? Number(e[0]) : NaN;
    }, g.getNorth = function (e) {
      if (e) {
        if (4 === e.length) return Number(e[3]);
        if (6 === e.length) return Number(e[4]);
      }
      return NaN;
    }, g.getEast = function (e) {
      if (e) {
        if (4 === e.length) return Number(e[2]);
        if (6 === e.length) return Number(e[3]);
      }
      return NaN;
    }, g.intersect = function (e, t) {
      var r = g.getCenter(e),
        n = g.getCenter(t),
        i = Math.abs(r[1] - n[1]),
        r = Math.abs(r[0] - n[0]),
        n = (180 < r && (r = 360 - r), g.getHeight(e)),
        e = g.getWidth(e),
        o = g.getHeight(t),
        t = g.getWidth(t);
      return i <= n / 2 + o / 2 && r <= e / 2 + t / 2;
    }, g.merge = function (e, t) {
      var r = e && 4 === e.length,
        n = t && 4 === t.length;
      if (r && !n) return e;
      if (n && !r) return t;
      if (!r && !n) return null;
      for (var r = Math.max(normalizeLatitude(g.getNorth(e)), normalizeLatitude(g.getNorth(t))), n = Math.min(normalizeLatitude(g.getSouth(e)), normalizeLatitude(g.getSouth(t))), i = [e, t], o = [], a = 0, a = 0; a < i.length; a++) {
        var s = i[a],
          l = normalizeLongitude(g.getWest(s)),
          c = normalizeLongitude(g.getEast(s));
        g.crossesAntimeridian(s) ? (o.push([l, 180]), o.push([-180, c])) : o.push([l, c]);
      }
      o.sort(function (e, t) {
        return e[0] === t[0] ? e[1] - t[1] : e[0] - t[0];
      });
      var u = [],
        h = o[0];
      for (a = 1; a < o.length;) {
        var d = o[a];
        h[1] >= d[0] ? h[1] = Math.max(h[1], d[1]) : (u.push(h), h = d), a++;
      }
      u.push(h);
      var p = u.length,
        f = u[0][0] + 360 - u[p - 1][1],
        _ = [u[p - 1][1], u[0][0]];
      for (a = 1; a < p; a++) {
        var m = u[a][0] - u[a - 1][1];
        f < m && (f = m, _ = [u[a - 1][1], u[a][0]]);
      }
      return new g([_[1], n], [_[0], r]);
    }, g.fromPositions = function (e) {
      for (var t, r, n = NaN, i = NaN, o = NaN, a = NaN, s = e.length, l = new Array(s), c = 0; s--;) (r = e[s]) && 2 <= r.length && (t = normalizeLatitude(r[1]), n = isNaN(n) ? t : Math.max(n, t), i = isNaN(i) ? t : Math.min(i, t), l[c++] = normalizeLongitude(r[0]));
      if (c) {
        l.length = c, l.sort(function (e, t) {
          return e - t;
        });
        for (var u = l[0] + 360 - l[c - 1], h = 0, s = 1; s < c; s++) {
          var d = l[s] - l[s - 1];
          u < d && (u = d, h = s);
        }
        o = l[h], a = l[(h || c) - 1];
      }
      return isNaN(o) || isNaN(i) || isNaN(a) || isNaN(n) ? null : new g([o, i, a, n]);
    }, g.fromLatLngs = function (e) {
      return g.fromPositions(Position.fromLatLngs(e));
    }, g.fromData = function (e) {
      var t,
        r,
        n = null;
      if (Array.isArray(e) && 0 < e.length) {
        try {
          for (var i = __values$g(e), o = i.next(); !o.done; o = i.next()) {
            var a,
              s = o.value;
            null != (a = g.fromData(s)) && (n = null === n ? a : g.merge(n, a));
          }
        } catch (e) {
          t = {
            error: e
          };
        } finally {
          try {
            o && !o.done && (r = i.return) && r.call(i);
          } finally {
            if (t) throw t.error;
          }
        }
        return n;
      }
      if (e instanceof Shape) return e.getBounds();
      if (e && e.type) {
        var l = e;
        if (l.bbox && 4 === l.bbox.length) return l.bbox;
        switch (l.type) {
          case "FeatureCollection":
            return g.fromData(l.features);
          case "Feature":
            return Shape._isCircle(l) ? g.fromPositions(Shape._getCirclePositions(l)) : g.fromData(l.geometry);
          case "GeometryCollection":
            return g.fromData(l.geometries);
          case "Point":
            var c = l.coordinates;
            if (c && 2 <= c.length) return [c[0], c[1], c[0], c[1]];
            break;
          case "LineString":
          case "MultiPoint":
            return g.fromPositions(l.coordinates);
          case "Polygon":
          case "MultiLineString":
            var u = l.coordinates;
            if (u && 0 < u.length) {
              for (var h = 0, d = u.length; h < d; h++) null != (a = g.fromPositions(u[h])) && (n = null === n ? a : g.merge(n, a));
              if (null != n) return n;
            }
            break;
          case "MultiPolygon":
            var p = l.coordinates;
            if (p && 0 < p.length) {
              for (h = 0, d = p.length; h < d; h++) for (var f = 0, _ = p[h].length; f < _; f++) null != (a = g.fromPositions(p[h][f])) && (n = null === n ? a : g.merge(n, a));
              return n;
            }
        }
      }
      return null;
    }, g.splitOnAntimeridian = function (e) {
      var t,
        r,
        n,
        i,
        o,
        a,
        s = [];
      return g.isBoundingBoxWithSixOrMoreElementsLargerThanGlobe(e) ? [[-180, e[1], e[2], 180, e[4], e[5]]] : g.isBoundingBoxWithLessThanSixElementsLargerThanGlobe(e) ? [[-180, e[1], 180, e[3]]] : (g.crossesAntimeridian(e) ? (a = t = void 0, r = normalizeLongitude(g.getWest(e)), n = normalizeLongitude(g.getEast(e)), i = normalizeLatitude(g.getNorth(e)), o = normalizeLatitude(g.getSouth(e)), a = 6 <= e.length ? (t = [r, o, e[2], 180, i, e[5]], [-180, o, e[2], n, i, e[5]]) : (t = [r, o, 180, i], [-180, o, n, i]), s.push(t, a)) : s.push(e), s);
    }, g.isBoundingBoxWithSixOrMoreElementsLargerThanGlobe = function (e) {
      return 6 <= e.length && 360 < e[3] - e[0];
    }, g.isBoundingBoxWithLessThanSixElementsLargerThanGlobe = function (e) {
      return e.length < 6 && 360 < e[2] - e[0];
    }, g;
  }(Array),
  FeatureCollection = function () {
    function r(e, t) {
      this.type = "FeatureCollection", this.type = r.TYPE, this.features = e, this.bbox = t;
    }
    return r.TYPE = "FeatureCollection", r;
  }(),
  GeometryCollection = function () {
    function t(e) {
      this.type = "GeometryCollection", this.type = t.TYPE, this.geometries = e;
    }
    return t.TYPE = "GeometryCollection", t;
  }(),
  LineString = function () {
    function r(e, t) {
      this.type = "LineString", this.type = r.TYPE, this.coordinates = e, this.bbox = t;
    }
    return r.TYPE = "LineString", r;
  }(),
  MultiLineString = function () {
    function r(e, t) {
      this.type = "MultiLineString", this.type = r.TYPE, this.coordinates = e, this.bbox = t;
    }
    return r.TYPE = "MultiLineString", r;
  }(),
  MultiPoint = function () {
    function r(e, t) {
      this.type = "MultiPoint", this.type = r.TYPE, this.coordinates = e, this.bbox = t;
    }
    return r.TYPE = "MultiPoint", r;
  }(),
  MultiPolygon = function () {
    function r(e, t) {
      this.type = "MultiPolygon", this.type = r.TYPE, this.coordinates = e, this.bbox = t;
    }
    return r.TYPE = "MultiPolygon", r;
  }(),
  __extends$11 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  MercatorPoint = function (n) {
    function a(e, t, r) {
      return n.call(this, e, t, r || 0) || this;
    }
    return __extends$11(a, n), a.fromPosition = function (e) {
      return 2 <= e.length ? new a((180 + e[0]) / 360, a._latToMercatorY(e[1]), 3 <= e.length ? a._altitudeToMercatorZ(e[2], e[1]) : 0) : [0, 0, 0];
    }, a.fromPositions = function (e) {
      for (var t = [], r = 0, n = e.length; r < n; r++) t.push(this.fromPosition(e[r]));
      return t;
    }, a.toFloat32Array = function (e) {
      for (var t = new Float32Array(3 * e.length), r = 0, n = e.length; r < n; r++) {
        var i = 3 * r,
          o = e[r];
        t[i] = (180 + o[0]) / 360, t[1 + i] = a._latToMercatorY(o[1]), t[2 + i] = 3 <= o.length ? a._altitudeToMercatorZ(o[2], o[1]) : 0;
      }
      return t;
    }, a.toPosition = function (e) {
      var t;
      return 2 <= e.length ? (t = 360 / Math.PI * Math.atan(Math.exp((180 - 360 * e[1]) * Math.PI / 180)) - 90, new Position(360 * e[0] - 180, t, 3 <= e.length ? a._mercatorZToAltitude(e[2], e[1]) : 0)) : [0, 0, 0];
    }, a.toPositions = function (e) {
      for (var t = [], r = 0, n = e.length; r < n; r++) t.push(this.toPosition(e[r]));
      return t;
    }, a.mercatorScale = function (e) {
      return 1 / Math.cos(e * Math.PI / 180);
    }, a.meterInMercatorUnits = function (e) {
      return 1 / a.earthCircumference * a.mercatorScale(a._latToMercatorY(e));
    }, a._circumferenceAtLatitude = function (e) {
      return a.earthCircumference * Math.cos(e * Math.PI / 180);
    }, a._altitudeToMercatorZ = function (e, t) {
      return e / a._circumferenceAtLatitude(t);
    }, a._mercatorZToAltitude = function (e, t) {
      return e * a._circumferenceAtLatitude(a._latToMercatorY(t));
    }, a._latToMercatorY = function (e) {
      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e * Math.PI / 360))) / 360;
    }, a.earthCircumference = 2 * Math.PI * getEarthRadius(), a;
  }(Array),
  index$4 = Object.freeze({
    __proto__: null,
    BoundingBox: BoundingBox,
    Feature: Feature,
    FeatureCollection: FeatureCollection,
    GeometryCollection: GeometryCollection,
    LineString: LineString,
    MercatorPoint: MercatorPoint,
    MultiLineString: MultiLineString,
    MultiPoint: MultiPoint,
    MultiPolygon: MultiPolygon,
    Point: Point,
    Polygon: Polygon,
    Position: Position
  });
function getAddedSquaresAP(e, t) {
  return e * e + t * t;
}
function getSqDistAP(e, t) {
  return getAddedSquaresAP(e[0] - t[0], e[1] - t[1]);
}
function getSqSegDistAP(e, t, r) {
  var n,
    i = t[0],
    t = t[1],
    o = r[0] - i,
    a = r[1] - t;
  return 0 == o && 0 == a || (1 < (n = ((e[0] - i) * o + (e[1] - t) * a) / getAddedSquaresAP(o, a)) ? (i = r[0], t = r[1]) : 0 < n && (i += o * n, t += a * n)), getAddedSquaresAP(e[0] - i, e[1] - t);
}
function simplifyRadialDistAP(e, t) {
  for (var r, n = e[0], i = [n], o = 1, a = e.length; o < a; o++) getSqDistAP(r = e[o], n) > t && (i.push(r), n = r);
  return n !== r && i.push(r), i;
}
function simplifyDPStepAP(e, t, r, n, i) {
  for (var o, a = n, s = t + 1; s < r; s++) {
    var l = getSqSegDistAP(e[s], e[t], e[r]);
    a < l && (o = s, a = l);
  }
  n < a && (1 < o - t && simplifyDPStepAP(e, t, o, n, i), i.push(e[o]), 1 < r - o) && simplifyDPStepAP(e, o, r, n, i);
}
function simplifyDouglasPeuckerAP(e, t) {
  var r = e.length - 1,
    n = [e[0]];
  return simplifyDPStepAP(e, 0, r, t, n), n.push(e[r]), n;
}
function SimplifyAP(e, t, r) {
  return void 0 === t && (t = 1), void 0 === r && (r = !1), e.length <= 2 || (t = t * t, e = simplifyDouglasPeuckerAP(e = r ? e : simplifyRadialDistAP(e, t), t)), e;
}
var SimplifyAP_1 = SimplifyAP;
function simplify(e, t) {
  return SimplifyAP_1(e, t, !0);
}
var __values$f = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  AffineTransform = function () {
    function r(e, t) {
      this.M = r._calculateAffineTransform(e, t), this.inverseM = r._calculateAffineTransform(t, e);
    }
    return r.prototype.toTarget = function (e, t) {
      return this.transformArray(e, this.M, t);
    }, r.prototype.toSource = function (e, t) {
      return this.transformArray(e, this.inverseM, t);
    }, r.prototype.transformArray = function (e, t, r) {
      var n, i;
      if (e && Array.isArray(e) && Array.isArray(e[0])) {
        var o = [];
        try {
          for (var a = __values$f(e), s = a.next(); !s.done; s = a.next()) {
            var l = s.value;
            o.push(this.transform(l, t, r));
          }
        } catch (e) {
          n = {
            error: e
          };
        } finally {
          try {
            s && !s.done && (i = a.return) && i.call(a);
          } finally {
            if (n) throw n.error;
          }
        }
        return o;
      }
      return null;
    }, r.prototype.transform = function (e, t, r) {
      var n = e[0] * t[0][3] + e[1] * t[1][3] + t[2][3],
        e = e[0] * t[0][4] + e[1] * t[1][4] + t[2][4];
      return "number" == typeof r && 0 <= r ? [_precision(n, r), _precision(e, r)] : [_precision(n, 6), _precision(e, 6)];
    }, r._calculateAffineTransform = function (e, t) {
      if (e.length !== t.length || e.length < 1) throw new Error("Error: source and target arrays must have the same length.");
      var r = Math.min(e[0].length, t[0].length),
        n = r + 1;
      if (e.length < r) throw new Error("Erorr: At least " + r + " reference points required.");
      for (var i = [], o = [], a = 0; a < n; a++) {
        o[a] = [];
        for (var s = 0; s < n; s++) {
          s < r && (i[s] = 0);
          for (var l = o[a][s] = 0; l < e.length; l++) s < r && (i[s] += a < r ? e[l][a] * t[l][s] : t[l][s]), o[a][s] += r <= a && r <= s ? 1 : r <= a ? e[l][s] : r <= s ? e[l][a] : e[l][a] * e[l][s];
        }
        o[a] = o[a].concat(i);
      }
      if (this._gaussJordanElimination(o)) return o;
      throw new Error("Error: Singular matrix. Points are likely coplanar.");
    }, r._gaussJordanElimination = function (e) {
      for (var t, r = e.length, n = 2 * r - 1, i = 0; i < r; i++) {
        for (var o = i, a = i + 1; a < r; a++) Math.abs(e[a][i]) > Math.abs(e[o][i]) && (o = a);
        if (t = e[o], e[o] = e[i], e[i] = t, Math.abs(e[i][i]) <= 1e-12) return !1;
        for (var s = i + 1; s < r; s++) for (var l = e[s][i] / e[i][i], c = i; c < n; c++) e[s][c] -= e[i][c] * l;
      }
      for (i = r - 1; -1 < i; i--) {
        l = e[i][i];
        for (a = 0; a < i; a++) for (var u = n - 1; i - 1 < u; u--) e[a][u] -= e[i][u] * e[a][i] / l;
        e[i][i] /= l;
        for (var h = r; h < n; h++) e[i][h] /= l;
      }
      return !0;
    }, r;
  }(),
  index$3 = Object.freeze({
    __proto__: null,
    get AccelerationUnits() {
      return AccelerationUnits;
    },
    AffineTransform: AffineTransform,
    get AreaUnits() {
      return AreaUnits;
    },
    get DistanceUnits() {
      return DistanceUnits;
    },
    get SpeedUnits() {
      return SpeedUnits;
    },
    get TimeUnits() {
      return TimeUnits;
    },
    WEBMERCATOR_MAXLAT: WEBMERCATOR_MAXLAT,
    _precision: _precision,
    boundingBoxToPolygon: boundingBoxToPolygon,
    convertAcceleration: convertAcceleration,
    convertArea: convertArea,
    convertDistance: convertDistance,
    convertSpeed: convertSpeed,
    convertTimespan: convertTimespan,
    getAcceleration: getAcceleration,
    getAccelerationFromFeatures: getAccelerationFromFeatures,
    getAccelerationFromSpeeds: getAccelerationFromSpeeds,
    getArea: getArea,
    getCardinalSpline: getCardinalSpline,
    getClosestPointOnGeometry: getClosestPointOnGeometry,
    getConvexHull: getConvexHull,
    getDestination: getDestination,
    getDistanceTo: getDistanceTo,
    getEarthRadius: getEarthRadius,
    getGeodesicPath: getGeodesicPath,
    getGeodesicPaths: getGeodesicPaths,
    getHeading: getHeading,
    getLengthOfPath: getLengthOfPath,
    getPathDenormalizedAtAntimerian: getPathDenormalizedAtAntimerian,
    getPathSplitByAntimeridian: getPathSplitByAntimeridian,
    getPixelHeading: getPixelHeading,
    getPointWithHeadingAlongPath: getPointWithHeadingAlongPath,
    getPointsWithHeadingsAlongPath: getPointsWithHeadingsAlongPath,
    getPosition: getPosition,
    getPositionAlongPath: getPositionAlongPath,
    getPositions: getPositions,
    getPositionsAlongPath: getPositionsAlongPath,
    getRegularPolygonPath: getRegularPolygonPath,
    getRegularPolygonPaths: getRegularPolygonPaths,
    getSpeed: getSpeed,
    getSpeedFromFeatures: getSpeedFromFeatures,
    getTimespan: getTimespan,
    getTravelDistance: getTravelDistance,
    interpolate: interpolate,
    mercatorPixelsToPositions: mercatorPixelsToPositions,
    mercatorPositionsToPixels: mercatorPositionsToPixels,
    normalizeLatitude: normalizeLatitude,
    normalizeLongitude: normalizeLongitude,
    parseTimestamp: parseTimestamp,
    rotatePositions: rotatePositions,
    simplify: simplify
  }),
  __extends$10 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  ZoomControlOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.zoomDelta = 1, e.style = ControlStyle.light, e;
    }
    return __extends$10(e, t), e;
  }(Options),
  __extends$$ = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  ZoomControl = function (r) {
    function n(e) {
      var t = r.call(this) || this;
      return t.container = null, t.zoomInButton = null, t.zoomOutButton = null, t.zoomChanged = function (e) {
        return t.updateZoomButtonsState();
      }, t.minZoomChanged = function (e) {
        return t.updateZoomButtonsState();
      }, t.maxZoomChanged = function (e) {
        return t.updateZoomButtonsState();
      }, t.options = new ZoomControlOptions().merge(e), t;
    }
    return __extends$$(n, r), n.prototype.onAdd = function (e) {
      this.container = this.buildContainer(e, this.options.style, "Zoom Control"), this.container.style.flexDirection = "column", this.zoomInButton = this.constructZoomInButton(e), this.zoomOutButton = this.constructZoomOutButton(e);
      var t = buildAccessibleTooltip("Zoom In"),
        r = buildAccessibleTooltip("Zoom Out");
      return this.container.appendChild(this.zoomInButton), this.container.appendChild(t), this.container.appendChild(this.zoomOutButton), this.container.appendChild(r), positionTooltip(t, this.zoomInButton), positionTooltip(r, this.zoomOutButton), e.events.add("zoom", this.zoomChanged), e.events.add("minzoomchanged", this.minZoomChanged), e.events.add("maxzoomchanged", this.maxZoomChanged), this.map = e, this.container;
    }, n.prototype.onRemove = function () {
      r.prototype.onRemove.call(this), this.map && (this.map.events.remove("zoom", this.zoomChanged), this.map.events.remove("minzoomchanged", this.minZoomChanged), this.map.events.remove("maxzoomchanged", this.maxZoomChanged), this.map = null), this.container && (this.container.remove(), this.container = null, this.zoomInButton = null, this.zoomOutButton = null);
    }, n.prototype.updateZoomButtonsState = function () {
      var e = this.map.getCamera().zoom >= this.map._getMap().getMaxZoom(),
        t = BoundingBox.getSouth(this.map.getCamera().bounds) <= -WEBMERCATOR_MAXLAT && BoundingBox.getNorth(this.map.getCamera().bounds) >= WEBMERCATOR_MAXLAT,
        t = this.map.getCamera().zoom <= this.map._getMap().getMinZoom() || t;
      this.zoomInButton && this.zoomInButton.disabled != e && (this.zoomInButton.disabled = e, this.zoomInButton.setAttribute("aria-label", e ? "Zoom In disabled" : "Zoom In")), this.zoomOutButton && this.zoomOutButton.disabled != t && (this.zoomOutButton.disabled = t, this.zoomOutButton.setAttribute("aria-label", e ? "Zoom Out disabled" : "Zoom Out"));
    }, n.prototype.constructZoomInButton = function (t) {
      var r = this,
        e = document.createElement("button");
      return e.classList.add("azure-maps-control-button"), e.classList.add("zoom-in"), e.setAttribute("aria-label", "Zoom In"), e.setAttribute("alt", "Zoom In"), e.setAttribute("type", "button"), e.addEventListener("click", function () {
        var e;
        t.setCamera({
          maxBounds: null == (e = t._getMap().getMaxBounds()) ? void 0 : e.toArray().flat(),
          zoom: t.getCamera().zoom + r.options.zoomDelta,
          duration: n.ZOOM_DURATION_MS,
          type: "ease"
        }, !0);
      }), e;
    }, n.prototype.constructZoomOutButton = function (t) {
      var r = this,
        e = document.createElement("button");
      return e.classList.add("azure-maps-control-button"), e.classList.add("zoom-out"), e.setAttribute("aria-label", "Zoom Out"), e.setAttribute("alt", "Zoom Out"), e.setAttribute("type", "button"), e.addEventListener("click", function () {
        var e;
        t.setCamera({
          maxBounds: null == (e = t._getMap().getMaxBounds()) ? void 0 : e.toArray().flat(),
          zoom: t.getCamera().zoom - r.options.zoomDelta,
          duration: n.ZOOM_DURATION_MS,
          type: "ease"
        }, !0);
      }), e;
    }, n.ZOOM_DURATION_MS = 200, n;
  }(ControlBase),
  index$2 = Object.freeze({
    __proto__: null,
    CompassControl: CompassControl,
    ControlBase: ControlBase,
    PitchControl: PitchControl,
    ScaleControl: ScaleControl,
    StyleControl: StyleControl,
    TrafficControl: TrafficControl,
    TrafficLegendControl: TrafficLegendControl,
    ZoomControl: ZoomControl
  }),
  baseClone = _baseClone,
  CLONE_DEEP_FLAG = 1,
  CLONE_SYMBOLS_FLAG = 4;
function cloneDeepWith(e, t) {
  return baseClone(e, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, t = "function" == typeof t ? t : void 0);
}
var cloneDeepWith$1 = getDefaultExportFromCjs(cloneDeepWith),
  AccessibleIndicator = function () {
    function r(e) {
      var t = this;
      this.attach = function (e) {
        t.map !== e && (t.map && t.detachFromCurrentMap(), t.map = e, t.map.indicators._getCollectionDiv().appendChild(t.element), t.map.indicators.add(t));
      }, this.remove = function () {
        t.detachFromCurrentMap(), t.element.remove();
      }, this.getElement = function () {
        return t.element;
      }, this.detachFromCurrentMap = function () {
        t.map && (t.map.indicators.remove(t), delete t.map);
      }, this.element = document.createElement("div"), this.element.setAttribute("tabindex", "0"), this.element.setAttribute("role", "option"), null != e && e.setSize && this.element.setAttribute("aria-setsize", e.setSize.toString()), null != e && e.positionInSet && this.element.setAttribute("aria-posinset", e.positionInSet.toString()), this.element.setAttribute("aria-label", "data point"), this.element.classList.add(r.Css.hidden);
    }
    return r.Css = {
      hidden: "hidden-accessible-element"
    }, r;
  }(),
  __extends$_ = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  DataSourceOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.buffer = 128, e.maxZoom = 18, e.cluster = !1, e.clusterRadius = 50, e.clusterMaxZoom = void 0, e.clusterProperties = void 0, e.lineMetrics = !1, e.tolerance = .375, e.clusterMinPoints = 2, e.generateId = !1, e.promoteId = void 0, e.filter = void 0, e;
    }
    return __extends$_(e, t), e;
  }(Options),
  __extends$Z = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  Source = function (r) {
    function e(e) {
      var t = r.call(this) || this;
      return t.id = e || uuid(), t;
    }
    return __extends$Z(e, r), e.prototype.getId = function () {
      return this.id;
    }, e.prototype._setMap = function (e, t) {
      var r;
      void 0 === t && (t = !0), null == e || void 0 === e ? (r = this.map, delete this.map, t && (this._invokeEvent("sourceremoved", this), r) && r.events.invoke("sourceremoved", this)) : (this.map = e, t && (this._invokeEvent("sourceadded", this), this.map.events.invoke("sourceadded", this)));
    }, e;
  }(EventEmitter),
  __extends$Y = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __values$e = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  DataSource = function (r) {
    function e(e, t) {
      e = r.call(this, e) || this;
      return e.requestId = void 0, e.options = new DataSourceOptions().merge(cloneDeep$1(t)), e.shapes = [], e.shapesMap = new Dictionary(), e;
    }
    return __extends$Y(e, r), e.prototype.add = function (e, t) {
      this._addNoUpdate(e, t), this._updateSource();
    }, e.prototype.clear = function () {
      this._clearNoUpdate(), this._updateSource();
    }, e.prototype.dispose = function () {
      this.options = null, this.shapes = null, this.shapesMap = null, this.map = null;
    }, e.prototype.getClusterExpansionZoom = function (t) {
      var i = this;
      return new Promise(function (r, n) {
        var e;
        i.map ? (e = i.map._getMap().getSource(i.getId())) && "geojson" === e.type && e.getClusterExpansionZoom(t, function (e, t) {
          e ? n(e) : "number" == typeof t && r(t);
        }) : n("The DataSource hasn't been added to a map.");
      });
    }, e.prototype.getClusterChildren = function (t) {
      var i = this;
      return new Promise(function (r, n) {
        var e;
        i.map ? (e = i.map._getMap().getSource(i.getId())) && "geojson" === e.type && e.getClusterChildren(t, function (e, t) {
          e ? n(e) : t && r(i.map.sources._mapFeaturesToShapes(t, !1, i));
        }) : n("The DataSource hasn't been added to a map.");
      });
    }, e.prototype.getClusterLeaves = function (t, i, o) {
      var a = this;
      return new Promise(function (r, n) {
        var e;
        a.map ? (e = a.map._getMap().getSource(a.getId())) && "geojson" === e.type && e.getClusterLeaves(t, i, o, function (e, t) {
          e ? n(e) : t && r(a.map.sources._mapFeaturesToShapes(t, !1, a));
        }) : n("The DataSource hasn't been added to a map.");
      });
    }, e.prototype.getOptions = function () {
      return cloneDeep$1(this.options);
    }, e.prototype.getShapes = function () {
      return Array.from(this.shapes);
    }, e.prototype.importDataFromUrl = function (e) {
      var t = this;
      return fetch(e, {
        method: "GET",
        mode: "cors"
      }).then(function (e) {
        if (e.ok) return e.json();
        throw new Error("HTTP ".concat(e.status, ": ").concat(e.statusText));
      }).then(function (e) {
        t.add(e);
      });
    }, e.prototype.getShapeById = function (e) {
      return this.shapes[this.shapesMap.get(e)] || null;
    }, e.prototype.remove = function (e) {
      var t,
        r,
        e = Array.isArray(e) ? e : [e];
      try {
        for (var n = __values$e(e), i = n.next(); !i.done; i = n.next()) {
          var o = i.value;
          "number" == typeof o ? this._removeByIndex(o) : this._removeById(o);
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n);
        } finally {
          if (t) throw t.error;
        }
      }
      this._updateSource();
    }, e.prototype.removeById = function (e) {
      var t,
        r,
        e = Array.isArray(e) ? e : [e];
      try {
        for (var n = __values$e(e), i = n.next(); !i.done; i = n.next()) {
          var o = i.value;
          this._removeById(o);
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n);
        } finally {
          if (t) throw t.error;
        }
      }
      this._updateSource();
    }, e.prototype.setOptions = function (e) {
      e = new DataSourceOptions().merge(this.options, cloneDeep$1(e));
      isEqual$1(this.options, e) || (this._invokeEvent("datasourceupdated", this), this.options = e, this.map && this.map._rebuildStyle());
    }, e.prototype.setShapes = function (e) {
      this._clearNoUpdate(), this.add(e);
    }, e.prototype.toJson = function () {
      return new FeatureCollection(this.shapes.map(function (e) {
        return e.toJson();
      }));
    }, e.prototype._toJson = function () {
      return new FeatureCollection(this.shapes.map(function (e) {
        return e._toJson();
      }));
    }, e.prototype._buildSource = function () {
      var e = {
        type: "geojson",
        data: this._toJson(),
        maxzoom: this.options.maxZoom,
        cluster: this.options.cluster,
        clusterRadius: this.options.clusterRadius,
        tolerance: this.options.tolerance,
        lineMetrics: this.options.lineMetrics,
        clusterProperties: this.options.clusterProperties,
        buffer: this.options.buffer,
        clusterMinPoints: this.options.clusterMinPoints,
        generateId: this.options.generateId,
        promoteId: this.options.promoteId,
        filter: this.options.filter
      };
      return "number" == typeof this.options.clusterMaxZoom && (e.clusterMaxZoom = this.options.clusterMaxZoom), e;
    }, e.prototype._isDeepEqual = function (e) {
      var t;
      return this.constructor === e.constructor && (t = this._buildSource(), e = e._buildSource(), t.type === e.type) && t.maxzoom === e.maxzoom && t.cluster === e.cluster && t.clusterRadius === e.clusterRadius && t.tolerance === e.tolerance && t.lineMetrics === e.lineMetrics && JSON.stringify(t.clusterProperties) === JSON.stringify(e.clusterProperties) && t.buffer === e.buffer && t.clusterMinPoints === e.clusterMinPoints && t.generateId === e.generateId && t.promoteId === e.promoteId && t.filter === e.filter;
    }, e.prototype._addNoUpdate = function (e, t) {
      var r;
      e instanceof Shape ? (this._addToSources(e, t), r = [e]) : Array.isArray(e) ? (r = e.map(function (e) {
        return e instanceof Shape ? e : new Shape(e);
      }), this._addToSources(r, t)) : "FeatureCollection" === e.type ? (r = e.features.map(function (e) {
        return new Shape(e);
      }), this._addToSources(r, t)) : "GeometryCollection" === e.type ? (r = e.geometries.map(function (e) {
        return new Shape(e);
      }), this._addToSources(r, t)) : (e = new Shape(e), this._addToSources(e, t), r = [e]), this._invokeEvent("dataadded", r);
    }, e.prototype._clearNoUpdate = function () {
      var e = this.shapes;
      this.shapes = [], this.shapesMap = new Dictionary(), e && 0 < e.length && this._invokeEvent("dataremoved", e);
    }, e.prototype._updateSource = function () {
      var e = this;
      void 0 === this.requestId && (this.requestId = requestAnimationFrame(function () {
        e._updateMboxSource(), e.requestId = void 0;
      }));
    }, e.prototype._addToSources = function (e, t) {
      var r, n, i, o;
      if (e = Array.isArray(e) ? e : [e], "number" != typeof t) try {
        for (var a = __values$e(e), s = a.next(); !s.done; s = a.next()) {
          var l = s.value;
          this.shapes.push(l), this.shapesMap.set(l.getId(), this.shapes.length - 1);
        }
      } catch (e) {
        r = {
          error: e
        };
      } finally {
        try {
          s && !s.done && (n = a.return) && n.call(a);
        } finally {
          if (r) throw r.error;
        }
      } else for (var c = e.length - 1; 0 <= c; c--) this.shapes.splice(t, 0, e[c]), this._updateShapesMap(t);
      try {
        for (var u = __values$e(e), h = u.next(); !h.done; h = u.next()) (l = h.value)._setDataSource(this);
      } catch (e) {
        i = {
          error: e
        };
      } finally {
        try {
          h && !h.done && (o = u.return) && o.call(u);
        } finally {
          if (i) throw i.error;
        }
      }
    }, e.prototype._removeById = function (e) {
      var e = e instanceof Shape ? e.getId() : "string" == typeof e || "number" == typeof e ? e : e.id,
        t = this.shapes[this.shapesMap.get(e)];
      t && (t._setDataSource(null), this.shapes.splice(this.shapesMap.get(e), 1), this._updateShapesMap(this.shapesMap.get(e)), this.shapesMap.delete(e), this._invokeEvent("dataremoved", [t]));
    }, e.prototype._removeByIndex = function (e) {
      var t;
      if (e >= this.shapes.length) throw new Error("The specified remove index '".concat(e, "' ") + "is greater than the maximum possible index '".concat(this.shapes.length - 1, "'"));
      t = this.shapes[e], this.shapesMap.delete(t.getId()), t._setDataSource(null), this.shapes.splice(e, 1), this._updateShapesMap(e), this._invokeEvent("dataremoved", [t]);
    }, e.prototype._updateShapesMap = function (e) {
      for (var t = e; t < this.shapes.length; t++) this.shapesMap.set(this.shapes[t].getId(), t);
    }, e.prototype._updateMboxSource = function () {
      var e;
      this.map && this.map._getMap() && (e = this.map._getMap().getSource(this.getId())) && "geojson" === e.type && e.setData(this._toJson());
    }, e;
  }(Source),
  __extends$X = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  VectorTileSourceOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.bounds = void 0, e.minZoom = 0, e.maxZoom = 22, e.isTMS = !1, e.tiles = void 0, e.url = void 0, e;
    }
    return __extends$X(e, t), e;
  }(Options),
  __extends$W = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  VectorTileSource = function (r) {
    function e(e, t) {
      e = r.call(this, e) || this;
      return e.options = new VectorTileSourceOptions().merge(cloneDeep$1(t)), e;
    }
    return __extends$W(e, r), e.prototype.getOptions = function () {
      return cloneDeep$1(this.options);
    }, e.prototype.getShape = function (e, t) {
      return this.map._getMap().querySourceFeatures(this.getId(), {
        sourceLayer: e,
        filter: t
      });
    }, e.prototype._buildSource = function () {
      var e = {
        type: "vector"
      };
      return this.options.bounds && (e.bounds = this.options.bounds), this.options.tiles ? (e.tiles = this.options.tiles, e.minzoom = this.options.minZoom, e.maxzoom = this.options.maxZoom) : this.options.url && (e.url = this.options.url), this.options.isTMS && (e.scheme = "tms"), e;
    }, e.prototype._isDeepEqual = function (e) {
      var t, r;
      return this.constructor === e.constructor && (t = this._buildSource(), r = e._buildSource(), t.type === r.type) && t.url === r.url && (void 0 === t.tiles && void 0 === r.tiles || t.tiles && r.tiles && t.tiles.length === r.tiles.length && t.tiles.every(function (e, t) {
        return e === r.tiles[t];
      })) && t.minzoom === r.minzoom && t.maxzoom === r.maxzoom && t.bounds === r.bounds && t.attribution === r.attribution && t.promoteId === r.promoteId && t.scheme === r.scheme;
    }, e;
  }(Source),
  __extends$V = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  CanvasSource = function (n) {
    function e(e, t, r) {
      e = n.call(this, e) || this;
      return e.source = t, e;
    }
    return __extends$V(e, n), e.prototype._isDeepEqual = function (e) {
      var t;
      return this.constructor === e.constructor && (t = this.source, e = e.source, t.type === e.type) && t.canvas === e.canvas && JSON.stringify(t.coordinates) === JSON.stringify(e.coordinates) && t.animate === e.animate;
    }, e.prototype._buildSource = function () {
      return this.source;
    }, e;
  }(Source),
  __extends$U = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  UnknownSource = function (n) {
    function e(e, t, r) {
      e = n.call(this, e) || this;
      return e.source = t, e;
    }
    return __extends$U(e, n), e.prototype._isDeepEqual = function (e) {
      var t;
      return this.constructor === e.constructor && (t = this.source, e = e.source, t.type === e.type);
    }, e.prototype._buildSource = function () {
      return this.source;
    }, e;
  }(Source),
  __extends$T = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  ImageSource = function (n) {
    function e(e, t, r) {
      e = n.call(this, e) || this;
      return e.source = t, e;
    }
    return __extends$T(e, n), e.prototype._isDeepEqual = function (e) {
      var t;
      return this.constructor === e.constructor && (t = this.source, e = e.source, t.type === e.type) && JSON.stringify(t.coordinates) === JSON.stringify(e.coordinates) && t.url === e.url;
    }, e.prototype._buildSource = function () {
      return this.source;
    }, e;
  }(Source),
  __extends$S = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  VideoSource = function (n) {
    function e(e, t, r) {
      e = n.call(this, e) || this;
      return e.source = t, e;
    }
    return __extends$S(e, n), e.prototype._isDeepEqual = function (e) {
      var t;
      return this.constructor === e.constructor && (t = this.source, e = e.source, t.type === e.type) && JSON.stringify(t.coordinates) === JSON.stringify(e.coordinates) && t.urls === e.urls;
    }, e.prototype._buildSource = function () {
      return this.source;
    }, e;
  }(Source),
  __extends$R = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  RasterTileSourceOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.tileSize = 512, e;
    }
    return __extends$R(e, t), e;
  }(VectorTileSourceOptions),
  __extends$Q = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  ElevationTileSourceOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.encoding = void 0, e;
    }
    return __extends$Q(e, t), e;
  }(RasterTileSourceOptions),
  __extends$P = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __assign$c = window && window.__assign || function () {
    return (__assign$c = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      return e;
    }).apply(this, arguments);
  },
  ElevationTileSource = function (r) {
    function e(e, t) {
      e = r.call(this, e) || this;
      return e.options = new ElevationTileSourceOptions().merge(cloneDeep$1(t)), e;
    }
    return __extends$P(e, r), e.prototype.getOptions = function () {
      return cloneDeep$1(this.options);
    }, e.prototype._buildSource = function () {
      return __assign$c({
        type: "raster-dem",
        bounds: this.options.bounds,
        minzoom: this.options.minZoom,
        maxzoom: this.options.maxZoom,
        tileSize: this.options.tileSize,
        encoding: this.options.encoding
      }, this.options.tiles ? {
        tiles: this.options.tiles
      } : {
        url: this.options.url
      });
    }, e.prototype._isDeepEqual = function (e) {
      return this.constructor === e.constructor && (e = e.getOptions(), this.options.url === e.url) && this.options.tiles === e.tiles && this.options.bounds === e.bounds && this.options.minZoom === e.minZoom && this.options.maxZoom === e.maxZoom && this.options.tileSize === e.tileSize && this.options.encoding === e.encoding;
    }, e;
  }(Source),
  index$1 = Object.freeze({
    __proto__: null,
    CanvasSource: CanvasSource,
    DataSource: DataSource,
    ElevationTileSource: ElevationTileSource,
    ImageSource: ImageSource,
    Source: Source,
    UnknownSource: UnknownSource,
    VectorTileSource: VectorTileSource,
    VideoSource: VideoSource
  }),
  __extends$O = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  Layer = function (r) {
    function e(e) {
      var t = r.call(this) || this;
      return t.id = e || uuid(), t;
    }
    return __extends$O(e, r), e.prototype.getId = function () {
      return this.id;
    }, e.prototype.getMap = function () {
      return this.map || null;
    }, e.prototype.onAdd = function (e) {
      this.map = e, this._invokeEvent("layeradded", this), this.map.events.invoke("layeradded", this);
    }, e.prototype.onRemove = function () {
      var e = this.map;
      delete this.map, this._invokeEvent("layerremoved", this), e && e.events.invoke("layerremoved", this);
    }, e._isMBoxEvent = function (e) {
      return !this.LayerEvents.hasOwnProperty(e);
    }, e.prototype._updateBaseProperties = function (e, t) {
      this._updateFilter(e.filter, t.filter), this._updateZoomRange(e.minZoom, t.minZoom, e.maxZoom, t.maxZoom), this._updateLayoutProperty("visibility", e.visible, t.visible, e.visible ? "visible" : "none");
    }, e.prototype._updateFilter = function (e, t) {
      isEqual$1(e, t) || this.map._getMap().setFilter(this.id, e);
    }, e.prototype._updatePaintProperty = function (e, t, r, n) {
      isEqual$1(t, r) || this.map._getMap().setPaintProperty(this.id, e, n || t);
    }, e.prototype._updateLayoutProperty = function (e, t, r, n) {
      isEqual$1(t, r) || this.map._getMap().setLayoutProperty(this.id, e, n || t);
    }, e.prototype._updateZoomRange = function (e, t, r, n) {
      e === t && n === r || this.map._getMap().setLayerZoomRange(this.id, e, r);
    }, e.LayerEvents = {
      layeradded: void 0,
      layerremoved: void 0,
      focusin: void 0,
      focusout: void 0
    }, e;
  }(EventEmitter),
  __extends$N = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  LayerOptions$1 = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.filter = void 0, e.minZoom = 0, e.maxZoom = 24, e.visible = !0, e;
    }
    return __extends$N(e, t), e._cloneCustomizer = function (e) {
      if (e instanceof Source) return e;
    }, e;
  }(Options),
  __extends$M = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  BubbleLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.source = void 0, e.sourceLayer = void 0, e.color = "#1A73AA", e.blur = 0, e.opacity = 1, e.strokeColor = "#FFFFFF", e.strokeOpacity = 1, e.strokeWidth = 2, e.pitchAlignment = "viewport", e.radius = 8, e.createIndicators = !1, e.accessibilityIdKey = void 0, e;
    }
    return __extends$M(e, t), e;
  }(LayerOptions$1),
  __extends$L = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __awaiter$6 = window && window.__awaiter || function (e, a, s, l) {
    return new (s = s || Promise)(function (r, t) {
      function n(e) {
        try {
          o(l.next(e));
        } catch (e) {
          t(e);
        }
      }
      function i(e) {
        try {
          o(l.throw(e));
        } catch (e) {
          t(e);
        }
      }
      function o(e) {
        var t;
        e.done ? r(e.value) : ((t = e.value) instanceof s ? t : new s(function (e) {
          e(t);
        })).then(n, i);
      }
      o((l = l.apply(e, a || [])).next());
    });
  },
  __generator$6 = window && window.__generator || function (n, i) {
    var o,
      a,
      s,
      l = {
        label: 0,
        sent: function () {
          if (1 & s[0]) throw s[1];
          return s[1];
        },
        trys: [],
        ops: []
      },
      c = {
        next: e(0),
        throw: e(1),
        return: e(2)
      };
    return "function" == typeof Symbol && (c[Symbol.iterator] = function () {
      return this;
    }), c;
    function e(r) {
      return function (e) {
        var t = [r, e];
        if (o) throw new TypeError("Generator is already executing.");
        for (; l = c && t[c = 0] ? 0 : l;) try {
          if (o = 1, a && (s = 2 & t[0] ? a.return : t[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, t[1])).done) return s;
          switch (a = 0, (t = s ? [2 & t[0], s.value] : t)[0]) {
            case 0:
            case 1:
              s = t;
              break;
            case 4:
              return l.label++, {
                value: t[1],
                done: !1
              };
            case 5:
              l.label++, a = t[1], t = [0];
              continue;
            case 7:
              t = l.ops.pop(), l.trys.pop();
              continue;
            default:
              if (!(s = 0 < (s = l.trys).length && s[s.length - 1]) && (6 === t[0] || 2 === t[0])) {
                l = 0;
                continue;
              }
              if (3 === t[0] && (!s || t[1] > s[0] && t[1] < s[3])) l.label = t[1];else if (6 === t[0] && l.label < s[1]) l.label = s[1], s = t;else {
                if (!(s && l.label < s[2])) {
                  s[2] && l.ops.pop(), l.trys.pop();
                  continue;
                }
                l.label = s[2], l.ops.push(t);
              }
          }
          t = i.call(n, l);
        } catch (e) {
          t = [6, e], a = 0;
        } finally {
          o = s = 0;
        }
        if (5 & t[0]) throw t[1];
        return {
          value: t[0] ? t[1] : void 0,
          done: !0
        };
      };
    }
  },
  __read$e = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  __spreadArray$b = window && window.__spreadArray || function (e, t, r) {
    if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++) !n && i in t || ((n = n || Array.prototype.slice.call(t, 0, i))[i] = t[i]);
    return e.concat(n || Array.prototype.slice.call(t));
  },
  BubbleLayer = function (i) {
    function e(e, t, r) {
      var n = i.call(this, t) || this;
      return n.accessibleIndicator = [], n._setAccessibleIndicator = function () {
        return __awaiter$6(n, void 0, void 0, function () {
          var t,
            l,
            c,
            u,
            h,
            d,
            p = this;
          return __generator$6(this, function (e) {
            return this.accessibleIndicator.forEach(function (e) {
              return e.remove();
            }), this.accessibleIndicator = [], t = this.map.layers.getRenderedShapes(this.map.getCamera().bounds, this), l = this.options.accessibilityIdKey || (this._getDataSource() ? Shape._shapeIdPropName : void 0), c = function (t, r) {
              var n = t[r],
                i = n instanceof Shape ? n.toJson() : n,
                o = new AccessibleIndicator({
                  positionInSet: r + 1,
                  setSize: t.length
                }),
                a = o.getElement(),
                s = __read$e(p.map.positionsToPixels([p.getFirstCoordinate(i.geometry.coordinates)]), 1)[0];
              return a.addEventListener("focusin", function (e) {
                p.accessibleIndicator.filter(function (e) {
                  return e !== o;
                }).forEach(function (e) {
                  return e.remove();
                }), 0 <= r - 1 && u(o, c(t, r - 1)), r + 1 < t.length && d(c(t, r + 1)), 2 <= r && r == t.length - 1 && h(c(t, 0)), 0 == r && 2 <= t.length && d(c(t, t.length - 1)), void 0 !== l && p.map._getMap().setPaintProperty(p.id, "circle-stroke-color", ["case", ["==", ["get", l], i.properties[l]], "#000000", p.options.strokeColor]);
                e = {
                  target: a,
                  type: "focusin",
                  map: p.map,
                  shape: n,
                  originalEvent: e,
                  pixel: s
                };
                p._invokeEvent("focusin", e);
              }), a.addEventListener("focusout", function (e) {
                void 0 !== l && p.map._getMap().setPaintProperty(p.id, "circle-stroke-color", ["case", ["==", ["get", l], i.properties[l]], p.options.strokeColor, p.options.strokeColor]);
                e = {
                  target: a,
                  type: "focusout",
                  map: p.map,
                  shape: n,
                  originalEvent: e,
                  pixel: s
                };
                p._invokeEvent("focusout", e);
              }), p.accessibleIndicator.push(o), o;
            }, u = function (e, t) {
              t.attach(p.map);
              t = t.getElement(), e = e.getElement();
              e.parentElement.insertBefore(t, e);
            }, h = function (e) {
              e.attach(p.map);
              var e = e.getElement(),
                t = e.parentElement;
              t.insertBefore(e, t.firstElementChild);
            }, d = function (e) {
              e.attach(p.map);
            }, 0 < t.length && d(c(t, 0)), 1 < t.length && d(c(t, t.length - 1)), [2];
          });
        });
      }, n.options = new BubbleLayerOptions().merge(cloneDeepWith$1(r, BubbleLayerOptions._cloneCustomizer)), n.options.source = e || n.options.source, n;
    }
    return __extends$L(e, i), e.prototype.getOptions = function () {
      return cloneDeepWith$1(this.options, BubbleLayerOptions._cloneCustomizer);
    }, e.prototype.getSource = function () {
      return this.options.source;
    }, e.prototype.setOptions = function (e) {
      e = new BubbleLayerOptions().merge(this.options, cloneDeepWith$1(e, BubbleLayerOptions._cloneCustomizer));
      if (this.map) {
        if (e.source !== this.options.source || e.sourceLayer !== this.options.sourceLayer) return this.options = e, void this.map.layers.add(this);
        this._updateBaseProperties(e, this.options), this._updatePaintProperty("circle-blur", e.blur, this.options.blur), this._updatePaintProperty("circle-color", e.color, this.options.color), this._updatePaintProperty("circle-opacity", e.opacity, this.options.opacity), this._updatePaintProperty("circle-radius", e.radius, this.options.radius), this._updatePaintProperty("circle-stroke-color", e.strokeColor, this.options.strokeColor), this._updatePaintProperty("circle-stroke-opacity", e.strokeOpacity, this.options.strokeOpacity), this._updatePaintProperty("circle-stroke-width", e.strokeWidth, this.options.strokeWidth), this._updatePaintProperty("circle-pitch-alignment", e.pitchAlignment, this.options.pitchAlignment);
      }
      this.options = e;
    }, e.prototype.onAdd = function (t) {
      var e,
        r,
        n = this;
      i.prototype.onAdd.call(this, t), this.options.createIndicators && (t.events.addOnce("idle", this._setAccessibleIndicator), t.events.add("moveend", this._setAccessibleIndicator), (e = this._getDataSource()) ? t.events.add("dataadded", e, function () {
        t.events.addOnce("idle", n._setAccessibleIndicator);
      }) : (r = "string" == typeof this.options.source ? this.options.source : this.options.source.getId(), t.events.add("sourcedata", function (e) {
        (null == (e = e.source) ? void 0 : e.getId()) === r && t._getMap().isSourceLoaded(r) && (e = n._getSourceDataEventCacheKey()) !== n.sourceDataEventCacheKey && (n._setAccessibleIndicator(), n.sourceDataEventCacheKey = e);
      })));
    }, e.prototype.onRemove = function () {
      var e;
      this.options.createIndicators && (this.map.events.remove("idle", this._setAccessibleIndicator), this.map.events.remove("moveend", this._setAccessibleIndicator), (e = this._getDataSource()) ? this.map.events.remove("dataadded", e, this._setAccessibleIndicator) : this.map.events.remove("sourcedata", this._setAccessibleIndicator)), i.prototype.onRemove.call(this);
    }, e.prototype._getSourceDataEventCacheKey = function () {
      var e;
      if (this.map) return e = this.map.getServiceOptions().mapConfiguration, __spreadArray$b(__spreadArray$b([], __read$e(this.map.getCamera().bounds), !1), [this.map.getCamera().zoom, this.map.getCamera().pitch, this.map.getStyle().style, e instanceof Object ? e.id : e], !1).join(",");
    }, e.prototype._getDataSource = function () {
      var e = "string" == typeof this.options.source ? this.map.sources.getById(this.options.source) : this.options.source;
      if (e instanceof DataSource) return e;
    }, e.prototype._buildLayers = function () {
      var e = {
        id: this.id,
        type: "circle",
        source: this.options.source instanceof Source ? this.options.source.getId() : this.options.source,
        layout: {
          visibility: this.options.visible ? "visible" : "none"
        },
        paint: {
          "circle-color": this.options.color,
          "circle-blur": this.options.blur,
          "circle-opacity": this.options.opacity,
          "circle-stroke-color": this.options.strokeColor,
          "circle-stroke-opacity": this.options.strokeOpacity,
          "circle-stroke-width": this.options.strokeWidth,
          "circle-pitch-alignment": this.options.pitchAlignment,
          "circle-radius": this.options.radius
        },
        minzoom: this.options.minZoom,
        maxzoom: this.options.maxZoom
      };
      return this.options.filter && (e.filter = this.options.filter), this.options.sourceLayer && (e["source-layer"] = this.options.sourceLayer), [e];
    }, e.prototype._getLayerIds = function () {
      return [this.id];
    }, e.prototype._getSourceIds = function () {
      var e = new Set();
      return this.options.source instanceof Source ? e.add(this.options.source.getId()) : e.add(this.options.source), e;
    }, e.prototype.getFirstCoordinate = function (e) {
      return Array.isArray(e[0]) ? this.getFirstCoordinate(e[0]) : e;
    }, e;
  }(Layer),
  __extends$K = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  HeatMapLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.source = void 0, e.sourceLayer = void 0, e.color = ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0,0, 255,0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"], e.intensity = 1, e.opacity = 1, e.radius = 30, e.weight = 1, e;
    }
    return __extends$K(e, t), e._cloneCustomizer = function (e) {
      if (e instanceof Source) return e;
    }, e;
  }(LayerOptions$1),
  __extends$J = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  HeatMapLayer = function (n) {
    function e(e, t, r) {
      t = n.call(this, t) || this;
      return t.options = new HeatMapLayerOptions().merge(cloneDeepWith$1(r, HeatMapLayerOptions._cloneCustomizer)), t.options.source = e || t.options.source, t;
    }
    return __extends$J(e, n), e.prototype.getOptions = function () {
      return cloneDeepWith$1(this.options, HeatMapLayerOptions._cloneCustomizer);
    }, e.prototype.getSource = function () {
      return this.options.source;
    }, e.prototype.setOptions = function (e) {
      e = new HeatMapLayerOptions().merge(this.options, cloneDeepWith$1(e, HeatMapLayerOptions._cloneCustomizer));
      if (this.map) {
        if (e.source !== this.options.source || e.sourceLayer !== this.options.sourceLayer) return this.options = e, void this.map.layers.add(this);
        this._updateBaseProperties(e, this.options), this._updatePaintProperty("heatmap-color", e.color, this.options.color), this._updatePaintProperty("heatmap-intensity", e.intensity, this.options.intensity), this._updatePaintProperty("heatmap-opacity", e.opacity, this.options.opacity), this._updatePaintProperty("heatmap-radius", e.radius, this.options.radius), this._updatePaintProperty("heatmap-weight", e.weight, this.options.weight);
      }
      this.options = e;
    }, e.prototype._buildLayers = function () {
      var e = {
        id: this.id,
        type: "heatmap",
        source: this.options.source instanceof Source ? this.options.source.getId() : this.options.source,
        layout: {
          visibility: this.options.visible ? "visible" : "none"
        },
        paint: {
          "heatmap-color": this.options.color,
          "heatmap-intensity": this.options.intensity,
          "heatmap-opacity": this.options.opacity,
          "heatmap-radius": this.options.radius,
          "heatmap-weight": this.options.weight
        },
        minzoom: this.options.minZoom,
        maxzoom: this.options.maxZoom
      };
      return this.options.filter && (e.filter = this.options.filter), this.options.sourceLayer && (e["source-layer"] = this.options.sourceLayer), [e];
    }, e.prototype._getLayerIds = function () {
      return [this.id];
    }, e.prototype._getSourceIds = function () {
      var e = new Set();
      return this.options.source instanceof Source ? e.add(this.options.source.getId()) : e.add(this.options.source), e;
    }, e;
  }(Layer),
  __extends$I = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  MediaLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.contrast = 0, e.fadeDuration = 300, e.hueRotation = 0, e.maxBrightness = 1, e.minBrightness = 0, e.opacity = 1, e.saturation = 0, e;
    }
    return __extends$I(e, t), e;
  }(LayerOptions$1),
  __extends$H = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  ImageLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.url = void 0, e.coordinates = void 0, e;
    }
    return __extends$H(e, t), e._cloneCustomizer = function (e) {
      if (e instanceof Source) return e;
    }, e;
  }(MediaLayerOptions),
  __extends$G = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  SourceBuildingLayer = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }
    return __extends$G(e, t), e.prototype._getSourceIds = function () {
      var e = new Set();
      return e.add(this._getSourceId()), e;
    }, e.prototype.onAdd = function (e) {
      t.prototype.onAdd.call(this, e);
    }, e;
  }(Layer),
  __extends$F = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  ImageLayer = function (r) {
    function e(e, t) {
      t = r.call(this, t) || this;
      return t.isLoading = !1, t.options = new ImageLayerOptions().merge(cloneDeepWith$1(e, ImageLayerOptions._cloneCustomizer)), t.img = new Image(), t.reloadImage(), t;
    }
    return __extends$F(e, r), e.prototype.getOptions = function () {
      return cloneDeepWith$1(this.options, ImageLayerOptions._cloneCustomizer);
    }, e.prototype.setOptions = function (e) {
      var t,
        r = new ImageLayerOptions().merge(this.options, cloneDeepWith$1(e, ImageLayerOptions._cloneCustomizer)),
        n = "string" == typeof e.url && e.url !== this.getOptions().url,
        e = void 0 !== e.coordinates && e.coordinates !== this.getOptions().coordinates;
      this.map && (this._updateBaseProperties(r, this.options), this._updatePaintProperty("raster-contrast", r.contrast, this.options.contrast), this._updatePaintProperty("raster-fade-duration", r.fadeDuration, this.options.fadeDuration), this._updatePaintProperty("raster-hue-rotate", r.hueRotation, this.options.hueRotation), this._updatePaintProperty("raster-brightness-max", r.maxBrightness, this.options.maxBrightness), this._updatePaintProperty("raster-opacity", r.opacity, this.options.opacity), this._updatePaintProperty("raster-saturation", r.saturation, this.options.saturation), t = this.map._getMap().getSource(this._getSourceId())) && t.updateImage(r), this.options = r, n ? this.reloadImage() : e && this.updateTransform();
    }, e.prototype.getPositions = function (t) {
      return this.transform.then(function (e) {
        return e.toTarget(t);
      });
    }, e.prototype.getPixels = function (t) {
      return this.transform.then(function (e) {
        return e.toSource(t);
      });
    }, e.getCoordinatesFromRefPoints = function (e, t, r, n) {
      return new AffineTransform(r, n).toTarget([[0, 0], [e, 0], [e, t], [0, t]]);
    }, e.getCoordinatesFromEdges = function (e, t, r, n, i) {
      "number" != typeof i && (i = 0);
      t = [Math.min(n, r), t, Math.max(n, r), e], n = BoundingBox.getCenter(t);
      return rotatePositions([BoundingBox.getNorthWest(t), BoundingBox.getNorthEast(t), BoundingBox.getSouthEast(t), BoundingBox.getSouthWest(t)], n, i);
    }, e.prototype._buildLayers = function () {
      var e = {
        id: this.id,
        type: "raster",
        source: this._getSourceId(),
        layout: {
          visibility: this.options.visible ? "visible" : "none"
        },
        paint: {
          "raster-opacity": this.options.opacity,
          "raster-hue-rotate": this.options.hueRotation,
          "raster-brightness-min": this.options.minBrightness,
          "raster-brightness-max": this.options.maxBrightness,
          "raster-saturation": this.options.saturation,
          "raster-contrast": this.options.contrast,
          "raster-fade-duration": this.options.fadeDuration
        },
        minzoom: this.options.minZoom,
        maxzoom: this.options.maxZoom
      };
      return this.options.filter && (e.filter = this.options.filter), [e];
    }, e.prototype._getLayerIds = function () {
      return [this.id];
    }, e.prototype._buildSource = function () {
      return {
        type: "image",
        url: this.options.url,
        coordinates: this.options.coordinates
      };
    }, e.prototype._getSourceId = function () {
      return "".concat(this.getId(), "-ImageSource");
    }, e.prototype.reloadImage = function () {
      var r = this;
      this.options.url && (this.transform = new Promise(function (t, e) {
        r.img.onload = function () {
          var e = [[0, 0], [r.img.width, 0], [r.img.width, r.img.height], [0, r.img.height]];
          t(new AffineTransform(e, r.options.coordinates)), r.isLoading = !1;
        }, r.img.onerror = r.img.onabort = function () {
          e("Failed to load image");
        }, r.isLoading = !0, r.img.src = r.options.url;
      }));
    }, e.prototype.updateTransform = function () {
      var e;
      this.isLoading || (e = [[0, 0], [this.img.width, 0], [this.img.width, this.img.height], [0, this.img.height]], this.transform = Promise.resolve(new AffineTransform(e, this.options.coordinates)));
    }, e.prototype._getSourceWrapper = function () {
      var e = this._getSourceId(),
        t = this._buildSource();
      return new ImageSource(e, t);
    }, e;
  }(SourceBuildingLayer),
  __extends$E = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  LineLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.source = void 0, e.sourceLayer = void 0, e.lineCap = "round", e.lineJoin = "round", e.blur = 0, e.strokeColor = "#1E90FF", e.strokeDashArray = void 0, e.strokeGradient = void 0, e.offset = 0, e.strokeOpacity = 1, e.translate = new Pixel(0, 0), e.translateAnchor = "map", e.strokeWidth = 2, e;
    }
    return __extends$E(e, t), e;
  }(LayerOptions$1),
  __extends$D = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __assign$b = window && window.__assign || function () {
    return (__assign$b = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      return e;
    }).apply(this, arguments);
  },
  LineLayer = function (n) {
    function e(e, t, r) {
      t = n.call(this, t) || this;
      return t.options = new LineLayerOptions().merge(cloneDeepWith$1(r, LineLayerOptions._cloneCustomizer)), t.options.source = e || t.options.source, t;
    }
    return __extends$D(e, n), e.prototype.getOptions = function () {
      return cloneDeepWith$1(this.options, LineLayerOptions._cloneCustomizer);
    }, e.prototype.getSource = function () {
      return this.options.source;
    }, e.prototype.setOptions = function (e) {
      e = new LineLayerOptions().merge(this.options, cloneDeepWith$1(e, LineLayerOptions._cloneCustomizer));
      if (this.map) {
        if (e.source !== this.options.source || e.sourceLayer !== this.options.sourceLayer) return this.options = e, void this.map.layers.add(this);
        this._updateBaseProperties(e, this.options), this._updatePaintProperty("line-blur", e.blur, this.options.blur), this._updateLayoutProperty("line-cap", e.lineCap, this.options.lineCap), this._updateLayoutProperty("line-join", e.lineJoin, this.options.lineJoin), this._updatePaintProperty("line-offset", e.offset, this.options.offset), this._updatePaintProperty("line-color", e.strokeColor, this.options.strokeColor), this._updatePaintProperty("line-dasharray", e.strokeDashArray, this.options.strokeDashArray), this._updatePaintProperty("line-gradient", e.strokeGradient, this.options.strokeGradient), this._updatePaintProperty("line-opacity", e.strokeOpacity, this.options.strokeOpacity), this._updatePaintProperty("line-width", e.strokeWidth, this.options.strokeWidth), this._updatePaintProperty("line-translate", e.translate, this.options.translate), this._updatePaintProperty("line-translate-anchor", e.translateAnchor, this.options.translateAnchor);
      }
      this.options = e;
    }, e.prototype._buildLayers = function () {
      return [__assign$b(__assign$b(__assign$b(__assign$b({
        id: this.id,
        type: "line"
      }, this.options.sourceLayer && {
        "source-layer": this.options.sourceLayer
      }), {
        source: this.options.source instanceof Source ? this.options.source.getId() : this.options.source,
        layout: {
          visibility: this.options.visible ? "visible" : "none",
          "line-cap": this.options.lineCap,
          "line-join": this.options.lineJoin
        },
        paint: __assign$b(__assign$b(__assign$b({
          "line-blur": this.options.blur,
          "line-color": this.options.strokeColor
        }, this.options.strokeDashArray ? {
          "line-dasharray": this.options.strokeDashArray
        } : {}), this.options.strokeGradient ? {
          "line-gradient": this.options.strokeGradient
        } : {}), {
          "line-offset": this.options.offset,
          "line-opacity": this.options.strokeOpacity,
          "line-translate": this.options.translate,
          "line-translate-anchor": this.options.translateAnchor,
          "line-width": this.options.strokeWidth
        })
      }), this.options.filter && {
        filter: this.options.filter
      }), {
        minzoom: this.options.minZoom,
        maxzoom: this.options.maxZoom
      })];
    }, e.prototype._getLayerIds = function () {
      return [this.id];
    }, e.prototype._getSourceIds = function () {
      var e = new Set();
      return this.options.source instanceof Source ? e.add(this.options.source.getId()) : e.add(this.options.source), e;
    }, e;
  }(Layer),
  __extends$C = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  PolygonExtrusionLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.source = void 0, e.sourceLayer = void 0, e.base = 0, e.fillColor = "#1E90FF", e.height = 0, e.fillOpacity = 1, e.fillPattern = void 0, e.translate = new Pixel(0, 0), e.translateAnchor = "map", e.verticalGradient = !0, e;
    }
    return __extends$C(e, t), e;
  }(LayerOptions$1),
  __extends$B = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __assign$a = window && window.__assign || function () {
    return (__assign$a = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      return e;
    }).apply(this, arguments);
  },
  PolygonExtrusionLayer = function (n) {
    function e(e, t, r) {
      t = n.call(this, t) || this;
      return t.options = new PolygonExtrusionLayerOptions().merge(cloneDeepWith$1(r, PolygonExtrusionLayerOptions._cloneCustomizer)), t.options.source = e || t.options.source, t;
    }
    return __extends$B(e, n), e.prototype.getOptions = function () {
      return cloneDeepWith$1(this.options, PolygonExtrusionLayerOptions._cloneCustomizer);
    }, e.prototype.getSource = function () {
      return this.options.source;
    }, e.prototype.setOptions = function (e) {
      e = new PolygonExtrusionLayerOptions().merge(this.options, cloneDeepWith$1(e, PolygonExtrusionLayerOptions._cloneCustomizer));
      if (this.map) {
        if (e.source !== this.options.source || e.sourceLayer !== this.options.sourceLayer) return this.options = e, void this.map.layers.add(this);
        this._updateBaseProperties(e, this.options), this._updatePaintProperty("fill-extrusion-base", e.base, this.options.base), this._updatePaintProperty("fill-extrusion-color", e.fillColor, this.options.fillColor), this._updatePaintProperty("fill-extrusion-height", e.height, this.options.height), this._updatePaintProperty("fill-extrusion-opacity", e.fillOpacity, this.options.fillOpacity), this._updatePaintProperty("fill-extrusion-pattern", e.fillPattern, this.options.fillPattern), this._updatePaintProperty("fill-extrusion-translate", e.translate, this.options.translate), this._updatePaintProperty("fill-extrusion-translate-anchor", e.translateAnchor, this.options.translateAnchor), this._updatePaintProperty("fill-extrusion-vertical-gradient", e.verticalGradient, this.options.verticalGradient);
      }
      this.options = e;
    }, e.prototype._buildLayers = function () {
      return [__assign$a(__assign$a(__assign$a(__assign$a({
        id: this.id,
        type: "fill-extrusion"
      }, this.options.sourceLayer && {
        "source-layer": this.options.sourceLayer
      }), {
        source: this.options.source instanceof Source ? this.options.source.getId() : this.options.source,
        layout: {
          visibility: this.options.visible ? "visible" : "none"
        },
        paint: __assign$a(__assign$a({
          "fill-extrusion-base": this.options.base,
          "fill-extrusion-height": this.options.height,
          "fill-extrusion-opacity": this.options.fillOpacity
        }, this.options.fillPattern ? {
          "fill-extrusion-pattern": this.options.fillPattern
        } : {
          "fill-extrusion-color": this.options.fillColor
        }), {
          "fill-extrusion-translate": this.options.translate,
          "fill-extrusion-translate-anchor": this.options.translateAnchor,
          "fill-extrusion-vertical-gradient": this.options.verticalGradient
        })
      }), this.options.filter && {
        filter: this.options.filter
      }), {
        minzoom: this.options.minZoom,
        maxzoom: this.options.maxZoom
      })];
    }, e.prototype._getLayerIds = function () {
      return [this.id];
    }, e.prototype._getSourceIds = function () {
      var e = new Set();
      return this.options.source instanceof Source ? e.add(this.options.source.getId()) : e.add(this.options.source), e;
    }, e;
  }(Layer),
  __extends$A = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  PolygonLayerOptions$1 = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.source = void 0, e.sourceLayer = void 0, e.fillColor = "#1E90FF", e.fillOpacity = .5, e.fillPattern = void 0, e.fillAntialias = !0, e;
    }
    return __extends$A(e, t), e;
  }(LayerOptions$1),
  __extends$z = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  PolygonLayer = function (n) {
    function e(e, t, r) {
      t = n.call(this, t) || this;
      return t.options = new PolygonLayerOptions$1().merge(cloneDeepWith$1(r, PolygonLayerOptions$1._cloneCustomizer)), t.options.source = e || t.options.source, t;
    }
    return __extends$z(e, n), e.prototype.getOptions = function () {
      return cloneDeepWith$1(this.options, PolygonLayerOptions$1._cloneCustomizer);
    }, e.prototype.getSource = function () {
      return this.options.source;
    }, e.prototype.setOptions = function (e) {
      e = new PolygonLayerOptions$1().merge(this.options, cloneDeepWith$1(e, PolygonLayerOptions$1._cloneCustomizer));
      if (this.map) {
        if (e.source !== this.options.source || e.sourceLayer !== this.options.sourceLayer) return this.options = e, void this.map.layers.add(this);
        this._updateBaseProperties(e, this.options), this._updatePaintProperty("fill-color", e.fillColor, this.options.fillColor), this._updatePaintProperty("fill-opacity", e.fillOpacity, this.options.fillOpacity), this._updatePaintProperty("fill-pattern", e.fillPattern, this.options.fillPattern), this._updatePaintProperty("fill-antialias", e.fillAntialias, this.options.fillAntialias);
      }
      this.options = e;
    }, e.prototype._buildLayers = function () {
      var e = {
        id: this.id,
        type: "fill",
        source: this.options.source instanceof Source ? this.options.source.getId() : this.options.source,
        layout: {
          visibility: this.options.visible ? "visible" : "none"
        },
        paint: {
          "fill-opacity": this.options.fillOpacity,
          "fill-antialias": this.options.fillAntialias
        },
        minzoom: this.options.minZoom,
        maxzoom: this.options.maxZoom
      };
      return this.options.filter && (e.filter = this.options.filter), this.options.sourceLayer && (e["source-layer"] = this.options.sourceLayer), this.options.fillPattern ? e.paint["fill-pattern"] = this.options.fillPattern : e.paint["fill-color"] = this.options.fillColor, [e];
    }, e.prototype._getLayerIds = function () {
      return [this.id];
    }, e.prototype._getSourceIds = function () {
      var e = new Set();
      return this.options.source instanceof Source ? e.add(this.options.source.getId()) : e.add(this.options.source), e;
    }, e;
  }(Layer),
  __extends$y = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  IconOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.allowOverlap = !1, e.anchor = "bottom", e.ignorePlacement = !1, e.image = "marker-blue", e.offset = new Pixel(0, 0), e.optional = !1, e.padding = 2, e.pitchAlignment = "auto", e.rotation = 0, e.rotationAlignment = "auto", e.size = 1, e.opacity = 1, e;
    }
    return __extends$y(e, t), e;
  }(Options),
  __extends$x = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  TextOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.allowOverlap = !1, e.anchor = "center", e.textField = void 0, e.font = ["StandardFont-Regular"], e.ignorePlacement = !1, e.justify = "center", e.offset = new Pixel(0, 0), e.optional = !1, e.padding = 2, e.pitchAlignment = "auto", e.radialOffset = void 0, e.rotation = 0, e.rotationAlignment = "auto", e.variableAnchor = void 0, e.size = 16, e.color = "#000000", e.haloBlur = 0, e.haloColor = "rgba(0,0,0,0)", e.haloWidth = 0, e.opacity = 1, e;
    }
    return __extends$x(e, t), e;
  }(Options),
  __extends$w = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  SymbolLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.source = void 0, e.sourceLayer = void 0, e.iconOptions = new IconOptions(), e.textOptions = new TextOptions(), e.placement = "point", e.sortKey = void 0, e.zOrder = "auto", e.lineSpacing = 250, e;
    }
    return __extends$w(e, t), e;
  }(LayerOptions$1),
  __extends$v = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __assign$9 = window && window.__assign || function () {
    return (__assign$9 = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      return e;
    }).apply(this, arguments);
  },
  SymbolLayer = function (n) {
    function e(e, t, r) {
      t = n.call(this, t) || this;
      return t.options = new SymbolLayerOptions().merge(cloneDeepWith$1(r, SymbolLayerOptions._cloneCustomizer)), t.options.source = e || t.options.source, t;
    }
    return __extends$v(e, n), e.prototype.getOptions = function () {
      return cloneDeepWith$1(this.options, SymbolLayerOptions._cloneCustomizer);
    }, e.prototype.getSource = function () {
      return this.options.source;
    }, e.prototype.setOptions = function (e) {
      e = new SymbolLayerOptions().merge(this.options, cloneDeepWith$1(e, SymbolLayerOptions._cloneCustomizer));
      if (this.map) {
        if (e.source !== this.options.source || e.sourceLayer !== this.options.sourceLayer) return this.options = e, void this.map.layers.add(this);
        var t = this.options,
          r = e.iconOptions,
          n = t.iconOptions,
          i = e.textOptions,
          o = t.textOptions;
        this._updateBaseProperties(e, t), this._updateLayoutProperty("symbol-spacing", e.lineSpacing, t.lineSpacing), this._updateLayoutProperty("symbol-placement", e.placement, t.placement), this._updateLayoutProperty("symbol-sort-key", e.sortKey, t.sortKey), this._updateLayoutProperty("symbol-z-order", e.zOrder, t.zOrder), this._updateLayoutProperty("icon-allow-overlap", r.allowOverlap, n.allowOverlap), this._updateLayoutProperty("icon-anchor", r.anchor, n.anchor), this._updateLayoutProperty("icon-ignore-placement", r.ignorePlacement, n.ignorePlacement), this._updateLayoutProperty("icon-image", r.image, n.image), this._updateLayoutProperty("icon-offset", r.offset, n.offset), this._updatePaintProperty("icon-opacity", r.opacity, n.opacity), this._updateLayoutProperty("icon-optional", r.optional, n.optional), this._updateLayoutProperty("icon-padding", r.padding, n.padding), this._updateLayoutProperty("icon-pitch-alignment", r.pitchAlignment, n.pitchAlignment), this._updateLayoutProperty("icon-rotate", r.rotation, n.rotation), this._updateLayoutProperty("icon-rotation-alignment", r.rotationAlignment, n.rotationAlignment), this._updateLayoutProperty("icon-size", r.size, n.size), this._updateLayoutProperty("text-allow-overlap", i.allowOverlap, o.allowOverlap), this._updateLayoutProperty("text-anchor", i.anchor, o.anchor), this._updatePaintProperty("text-color", i.color, o.color), this._updateLayoutProperty("text-font", i.font, o.font), this._updateLayoutProperty("text-ignore-placement", i.ignorePlacement, o.ignorePlacement), this._updateLayoutProperty("text-justify", i.justify, o.justify), this._updatePaintProperty("text-halo-blur", i.haloBlur, o.haloBlur), this._updatePaintProperty("text-halo-color", i.haloColor, o.haloColor), this._updatePaintProperty("text-halo-width", i.haloWidth, o.haloWidth), this._updateLayoutProperty("text-offset", i.offset, o.offset), this._updatePaintProperty("text-opacity", i.opacity, o.opacity), this._updateLayoutProperty("text-optional", i.optional, o.optional), this._updateLayoutProperty("text-padding", i.padding, o.padding), this._updateLayoutProperty("text-pitch-alignment", i.pitchAlignment, o.pitchAlignment), this._updateLayoutProperty("text-radial-offset", i.radialOffset, o.radialOffset), this._updateLayoutProperty("text-rotate", i.rotation, o.rotation), this._updateLayoutProperty("text-rotation-alignment", i.rotationAlignment, o.rotationAlignment), this._updateLayoutProperty("text-size", i.size, o.size), this._updateLayoutProperty("text-variable-anchor", i.variableAnchor, o.variableAnchor), this._updateLayoutProperty("text-field", i.textField, o.textField);
      }
      this.options = e;
    }, e.prototype._buildLayers = function () {
      var e = __assign$9(__assign$9(__assign$9(__assign$9({
        id: this.id,
        type: "symbol"
      }, this.options.sourceLayer && {
        "source-layer": this.options.sourceLayer
      }), {
        source: this.options.source instanceof Source ? this.options.source.getId() : this.options.source,
        layout: __assign$9(__assign$9({
          visibility: this.options.visible ? "visible" : "none",
          "symbol-placement": this.options.placement,
          "symbol-spacing": this.options.lineSpacing,
          "symbol-z-order": this.options.zOrder,
          "text-allow-overlap": this.options.textOptions.allowOverlap,
          "text-anchor": this.options.textOptions.anchor
        }, this.options.textOptions.textField && {
          "text-field": this.options.textOptions.textField
        }), {
          "text-font": this.options.textOptions.font,
          "text-ignore-placement": this.options.textOptions.ignorePlacement,
          "text-justify": this.options.textOptions.justify,
          "text-offset": this.options.textOptions.offset,
          "text-optional": this.options.textOptions.optional,
          "text-padding": this.options.textOptions.padding,
          "text-pitch-alignment": this.options.textOptions.pitchAlignment,
          "text-rotate": this.options.textOptions.rotation,
          "text-rotation-alignment": this.options.textOptions.rotationAlignment,
          "text-size": this.options.textOptions.size,
          "icon-allow-overlap": this.options.iconOptions.allowOverlap,
          "icon-anchor": this.options.iconOptions.anchor,
          "icon-ignore-placement": this.options.iconOptions.ignorePlacement,
          "icon-image": this.options.iconOptions.image,
          "icon-offset": this.options.iconOptions.offset,
          "icon-optional": this.options.iconOptions.optional,
          "icon-padding": this.options.iconOptions.padding,
          "icon-pitch-alignment": this.options.iconOptions.pitchAlignment,
          "icon-rotate": this.options.iconOptions.rotation,
          "icon-rotation-alignment": this.options.iconOptions.rotationAlignment,
          "icon-size": this.options.iconOptions.size
        }),
        paint: {
          "text-color": this.options.textOptions.color,
          "text-halo-blur": this.options.textOptions.haloBlur,
          "text-halo-color": this.options.textOptions.haloColor,
          "text-halo-width": this.options.textOptions.haloWidth,
          "text-opacity": this.options.textOptions.opacity,
          "icon-opacity": this.options.iconOptions.opacity
        }
      }), this.options.filter && {
        filter: this.options.filter
      }), {
        minzoom: this.options.minZoom,
        maxzoom: this.options.maxZoom
      });
      return void 0 !== this.options.sortKey && (e.layout["symbol-sort-key"] = this.options.sortKey), void 0 !== this.options.textOptions.radialOffset && (e.layout["text-radial-offset"] = this.options.textOptions.radialOffset), void 0 !== this.options.textOptions.variableAnchor && (e.layout["text-variable-anchor"] = this.options.textOptions.variableAnchor), [e];
    }, e.prototype._getLayerIds = function () {
      return [this.id];
    }, e.prototype._getSourceIds = function () {
      var e = new Set();
      return this.options.source instanceof Source ? e.add(this.options.source.getId()) : e.add(this.options.source), e;
    }, e;
  }(Layer),
  __extends$u = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __assign$8 = window && window.__assign || function () {
    return (__assign$8 = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      return e;
    }).apply(this, arguments);
  },
  FundamentalMapSource = function (n) {
    function e(e, t, r) {
      e = n.call(this, e) || this;
      return e.source = e._modifySource(t, r), e;
    }
    return __extends$u(e, n), e.prototype._buildSource = function () {
      return this.source;
    }, e.prototype._isDeepEqual = function (e) {
      var r, t, n, i;
      return this.constructor === e.constructor && (i = this.source, r = e.source, e = i.type === r.type && i.url === r.url && (void 0 === i.tiles && void 0 === r.tiles || i.tiles && r.tiles && i.tiles.length === r.tiles.length && i.tiles.every(function (e, t) {
        return e === r.tiles[t];
      })) && i.minzoom === r.minzoom && i.maxzoom === r.maxzoom && i.bounds === r.bounds && i.attribution === r.attribution, t = "raster" !== i.type || "raster" === i.type && i.type === r.type && i.tileSize === r.tileSize && i.scheme === r.scheme, n = "raster-dem" !== i.type || "raster-dem" === i.type && i.type === r.type && i.tileSize === r.tileSize && i.encoding === r.encoding, i = "vector" !== i.type || "vector" === i.type && i.type === r.type && i.promoteId === r.promoteId && i.scheme === r.scheme, e) && t && n && i;
    }, e.prototype._modifySource = function (e, t) {
      if ("raster" !== e.type && "raster-dem" !== e.type && "vector" !== e.type || !e.tiles) {
        if ("raster" !== e.type && "raster-dem" !== e.type && "vector" !== e.type || !e.url) throw new Error("Source definition must define a TileJSON 'url' or a 'tiles' array.");
        e.url = "string" == typeof e.url ? e.url : new Url({
          domain: constants.domainPlaceHolder,
          path: e.url.path,
          queryParams: __assign$8(__assign$8({}, t), e.url.queryParams)
        }).toString();
      } else {
        var r = e.tiles.map(function (e) {
          return "string" == typeof e ? e : new Url({
            domain: constants.domainPlaceHolder,
            path: e.path,
            queryParams: __assign$8(__assign$8({}, t), e.queryParams)
          }).toString();
        });
        e.tiles = r;
      }
      return e;
    }, e;
  }(Source),
  __extends$t = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  TileLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.bounds = [-180, -85.0511, 180, 85.0511], e.minSourceZoom = 0, e.maxSourceZoom = 22, e.tileSize = 512, e.isTMS = !1, e.subdomains = void 0, e.tileUrl = void 0, e;
    }
    return __extends$t(e, t), e;
  }(MediaLayerOptions),
  __extends$s = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __assign$7 = window && window.__assign || function () {
    return (__assign$7 = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      return e;
    }).apply(this, arguments);
  },
  __values$d = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  TileLayer = function (r) {
    function e(e, t) {
      t = r.call(this, t) || this;
      return e && t.setOptions(e), t;
    }
    return __extends$s(e, r), e.prototype.getOptions = function () {
      return cloneDeepWith$1(this.options, TileLayerOptions._cloneCustomizer);
    }, e.prototype.setOptions = function (e) {
      e = new TileLayerOptions().merge(this.options, cloneDeepWith$1(e, TileLayerOptions._cloneCustomizer));
      if (this.map) {
        if (!isEqual$1(e.bounds, this.options.bounds) || e.isTMS !== this.options.isTMS || e.maxSourceZoom !== this.options.maxSourceZoom || e.minSourceZoom !== this.options.minSourceZoom || !isEqual$1(e.subdomains, this.options.subdomains) || e.tileSize !== this.options.tileSize || e.tileUrl !== this.options.tileUrl) return this.options = e, void this.map.layers.add(this);
        this._updateBaseProperties(e, this.options), this._updatePaintProperty("raster-contrast", e.contrast, this.options.contrast), this._updatePaintProperty("raster-fade-duration", e.fadeDuration, this.options.fadeDuration), this._updatePaintProperty("raster-hue-rotate", e.hueRotation, this.options.hueRotation), this._updatePaintProperty("raster-brightness-max", e.maxBrightness, this.options.maxBrightness), this._updatePaintProperty("raster-opacity", e.opacity, this.options.opacity), this._updatePaintProperty("raster-saturation", e.saturation, this.options.saturation);
      }
      this.options = e;
    }, e.prototype._setOptionsNoUpdate = function (e) {
      this.options = new TileLayerOptions().merge(this.options, cloneDeepWith$1(e, TileLayerOptions._cloneCustomizer));
    }, e.prototype._buildLayers = function () {
      return [__assign$7(__assign$7({
        id: this.id,
        type: "raster",
        source: this._getSourceId(),
        layout: {
          visibility: this.options.visible ? "visible" : "none"
        },
        paint: {
          "raster-contrast": this.options.contrast,
          "raster-fade-duration": this.options.fadeDuration,
          "raster-hue-rotate": this.options.hueRotation,
          "raster-brightness-max": this.options.maxBrightness,
          "raster-brightness-min": this.options.minBrightness,
          "raster-opacity": this.options.opacity,
          "raster-saturation": this.options.saturation
        }
      }, this.options.filter && {
        filter: this.options.filter
      }), {
        minzoom: this.options.minZoom,
        maxzoom: this.options.maxZoom
      })];
    }, e.prototype._getLayerIds = function () {
      return [this.id];
    }, e.prototype._buildSource = function () {
      var t, e;
      if (this.options.tileUrl) {
        if (-1 === this.options.tileUrl.indexOf("{")) return {
          type: "raster",
          url: this.options.tileUrl
        };
        if (-1 !== this.options.tileUrl.indexOf("{subdomain}")) {
          if (!(this.options.subdomains && 0 < this.options.subdomains.length)) throw new Error("The {subdomain} placeholder was included in the tileUrl but no subdomains were specified");
          var r = [];
          try {
            for (var n = __values$d(this.options.subdomains), i = n.next(); !i.done; i = n.next()) {
              var o = i.value;
              r.push(this.options.tileUrl.replace(/{subdomain}/g, o));
            }
          } catch (e) {
            t = {
              error: e
            };
          } finally {
            try {
              i && !i.done && (e = n.return) && e.call(n);
            } finally {
              if (t) throw t.error;
            }
          }
          e = r;
        } else e = [this.options.tileUrl];
      }
      return __assign$7({
        type: "raster",
        bounds: this.options.bounds,
        maxzoom: this.options.maxSourceZoom,
        minzoom: this.options.minSourceZoom,
        scheme: this.options.isTMS ? "tms" : "xyz",
        tileSize: this.options.tileSize
      }, e && {
        tiles: e
      });
    }, e.prototype._getSourceId = function () {
      return "".concat(this.getId(), "-RasterSource");
    }, e.prototype._getSourceWrapper = function () {
      var e = this._getSourceId(),
        t = this._buildSource();
      return new FundamentalMapSource(e, {
        name: e,
        tiles: t.tiles,
        type: t.type,
        url: t.url
      });
    }, e;
  }(SourceBuildingLayer),
  __extends$r = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  WebGLLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.renderer = void 0, e;
    }
    return __extends$r(e, t), e;
  }(LayerOptions$1),
  __extends$q = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  WebGLLayer = function (n) {
    function e(e, t) {
      var r = n.call(this, e) || this;
      return r._onStyleChange = function () {
        var e, t;
        r.map._getMap().getLayer(r.id) || (e = r.map, t = null == (t = r.map.layers._getUserLayers().find(function (e) {
          return e.layer.getId() == r.id;
        })) ? void 0 : t.before, e.layers.remove(r), e.layers.add(r, t));
      }, r.options = new WebGLLayerOptions().merge(cloneDeepWith$1(t, WebGLLayerOptions._cloneCustomizer)), r.source = new DataSource(), r;
    }
    return __extends$q(e, n), e.prototype.getOptions = function () {
      return cloneDeepWith$1(this.options, WebGLLayerOptions._cloneCustomizer);
    }, e.prototype.setOptions = function (e) {
      e = new WebGLLayerOptions().merge(this.options, cloneDeepWith$1(e, WebGLLayerOptions._cloneCustomizer));
      this.map && this.map.triggerRepaint(), this.options = e;
    }, e.prototype.onAdd = function (e) {
      var t, r;
      n.prototype.onAdd.call(this, e), this.map.events.add("stylechanged", this._onStyleChange), this.options.renderer && this.glContext && null != (r = (t = this.options.renderer).onAdd) && r.call(t, e, this.glContext);
    }, e.prototype.onRemove = function () {
      var e, t;
      this.options.renderer && this.glContext && null != (t = (e = this.options.renderer).onRemove) && t.call(e, this.map, this.glContext), this.map.events.remove("stylechanged", this._onStyleChange), this.glContext = null, n.prototype.onRemove.call(this);
    }, e.prototype._buildLayers = function () {
      var i = this;
      if (this.options.renderer) return [{
        id: this.id,
        type: "custom",
        renderingMode: this.options.renderer.renderingMode,
        onAdd: function (e, t) {
          i.glContext = t;
        },
        onRemove: function (e, t) {},
        prerender: function (e, t) {
          var r, n;
          i._shouldRender() && null != (n = (r = i.options.renderer).prerender) && n.call(r, e, t);
        },
        render: function (e, t) {
          i._shouldRender() && i.options.renderer.render(e, t);
        }
      }];
      throw new Error("Cannot build the WebGL layer because renderer was not set.");
    }, e.prototype._getLayerIds = function () {
      return [this.id];
    }, e.prototype._getSourceIds = function () {
      return new Set().add(this.source.getId());
    }, e.prototype._shouldRender = function () {
      var e;
      return !!this.map && (e = this.map.getCamera().zoom, this.options.visible) && this.options.minZoom <= e && this.options.maxZoom > e;
    }, e;
  }(Layer),
  index = Object.freeze({
    __proto__: null,
    BubbleLayer: BubbleLayer,
    HeatMapLayer: HeatMapLayer,
    ImageLayer: ImageLayer,
    Layer: Layer,
    LineLayer: LineLayer,
    PolygonExtrusionLayer: PolygonExtrusionLayer,
    PolygonLayer: PolygonLayer,
    SymbolLayer: SymbolLayer,
    TileLayer: TileLayer,
    WebGLLayer: WebGLLayer
  }),
  Html = function () {
    function e() {}
    return e.convertHtmlString = function (e) {
      var t;
      return "string" == typeof e ? ((t = document.createElement("div")).innerHTML = e, t) : e;
    }, e.parseWithFilter = function (e, t, r, n) {
      var i = this;
      if (void 0 === t && (t = function (e) {
        return !0;
      }), void 0 === r && (r = function (e) {
        return e;
      }), void 0 === n && (n = function () {
        return document.createElement("div");
      }), "string" == typeof e) {
        var o = new DOMParser().parseFromString(e, "text/html").body;
        if (0 == o.children.length) return r(o.innerHTML);
        var a,
          o = 1 == o.children.length && 1 == o.childNodes.length ? o.children[0] : (a = n(), Array.from(o.childNodes).map(function (e) {
            return a.append(e);
          }), a);
      } else o = e;
      return Array.from(o.children).forEach(function (e) {
        return i.parseWithFilter(e, t, r);
      }), t(o) ? r(o) : (o.parentNode && o.parentNode.removeChild(o), null);
    }, e;
  }(),
  isObjectLike = isObjectLike_1,
  isPlainObject$1 = isPlainObject_1;
function isElement(e) {
  return isObjectLike(e) && 1 === e.nodeType && !isPlainObject$1(e);
}
var isElement$1 = getDefaultExportFromCjs(isElement),
  __extends$p = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  PopupOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.anchor = "none", e.draggable = !1, e.closeButton = !0, e.content = document.createElement("span"), e.fillColor = "#FFFFFF", e.pixelOffset = new Pixel(0, 0), e.position = new Position(0, 0), e.showPointer = !0, e;
    }
    return __extends$p(e, t), e._cloneCustomizer = function (e) {
      if (isElement$1(e)) return e;
    }, e;
  }(Options),
  __extends$o = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __read$d = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  Popup = function (t) {
    function i(e) {
      var r = t.call(this) || this;
      return r.attach = function (e) {
        r.map !== e && (r.map && r.remove(), r.map = e, r.marker = r._createMarker(r.options), r.marker.addTo(r.map._getMap()), r.map.popups._getCollectionDiv().appendChild(r.containerDiv), r.map.popups.add(r));
      }, r.open = function (e) {
        if (!e && !r.map) throw new Error("Must specify a map to open on or attach to a map in advance");
        r.attach(e || r.map), r.containerDiv.classList.remove(i.Css.hidden), r.map.events.add("move", r._onMove), r._onMove(), r._invokeEvent("open", {
          target: r,
          type: "open"
        });
      }, r.close = function () {
        r.map && r.map.events.remove("move", r._onMove), r.containerDiv.classList.add(i.Css.hidden), r._invokeEvent("close", {
          target: r,
          type: "close"
        });
      }, r.remove = function () {
        r.map && (r.marker.remove(), r.containerDiv.classList.remove(r.autoAnchor || r.options.anchor), r.map.events.remove("move", r._onMove), r.map.popups.remove(r), delete r.map, delete r.marker, delete r.autoAnchor);
      }, r.isOpen = function () {
        return r.map && !r.containerDiv.classList.contains(i.Css.hidden);
      }, r._onMove = function () {
        var e = r._getAutoAnchor(r.map, r.options);
        e !== r.autoAnchor && (r._replaceMarker(r.map, r.options, e), r.map.events.add("move", r._onMove));
      }, r._onDown = function (e) {
        r.map.popups._addDraggedPopup(r);
        var t = __read$d(r.map.positionsToPixels([r.options.position]), 1)[0];
        "mousedown" === e.type ? r.dragOffset = [t[0] - e.clientX, t[1] - e.clientY] : "touchstart" === e.type && (r.dragOffset = [t[0] - e.touches[0].clientX, t[1] - e.touches[0].clientY]);
      }, r._onDragStart = function (e) {
        e.preventDefault();
      }, r.options = new PopupOptions().merge(cloneDeepWith$1(e, PopupOptions._cloneCustomizer)), r.containerDiv = r._createContainerDiv(r.options), r.contentDiv = r._createContentDiv(r.options), r.containerDiv.appendChild(r.contentDiv), r.options.showPointer && (r.arrowDiv = r._createArrowDiv(), r.containerDiv.appendChild(r.arrowDiv)), r.options.closeButton && (r.closeBtn = r._createCloseButton(), r.contentDiv.appendChild(r.closeBtn), e = buildAccessibleTooltip("close"), r.contentDiv.appendChild(e), positionTooltip(e, r.closeBtn, !0)), r;
    }
    return __extends$o(i, t), i.prototype.setPopupOptions = function (e) {
      this.setOptions(e);
    }, i.prototype.setOptions = function (e) {
      var t,
        e = new PopupOptions().merge(this.options, cloneDeepWith$1(e, PopupOptions._cloneCustomizer));
      e.content !== this.options.content ? (this.htmlContent.remove(), this.htmlContent = this._createHtmlContent(e), this.contentDiv.prepend(this.htmlContent)) : e.draggable !== this.options.draggable && this._setDraggable(this.htmlContent, e.draggable), e.closeButton && !this.closeBtn ? (this.closeBtn = this._createCloseButton(), this.contentDiv.appendChild(this.closeBtn), t = buildAccessibleTooltip("close"), this.contentDiv.appendChild(t), positionTooltip(t, this.closeBtn, !0)) : !e.closeButton && this.closeBtn && (this.contentDiv.removeChild(this.closeBtn), delete this.closeBtn), e.showPointer && !this.arrowDiv ? (this.arrowDiv = this._createArrowDiv(), this.containerDiv.appendChild(this.arrowDiv)) : !e.showPointer && this.arrowDiv && (this.containerDiv.removeChild(this.arrowDiv), delete this.arrowDiv), e.fillColor !== this.options.fillColor && (this.containerDiv.style.borderColor = e.fillColor, this.contentDiv.style.backgroundColor = e.fillColor), this.marker && (e.anchor !== this.options.anchor ? "none" === this.options.anchor ? (this.autoAnchor !== e.anchor && this._replaceMarker(this.map, e), this.map.events.remove("move", this._onMove), delete this.autoAnchor) : (this._replaceMarker(this.map, e), "none" === e.anchor && this.map.events.add("move", this._onMove)) : (isEqual$1(e.position, this.options.position) || this.marker.setLngLat(e.position), isEqual$1(e.pixelOffset, this.options.pixelOffset) || this.marker.setOffset(e.pixelOffset))), this.options = e;
    }, i.prototype.getPopupOptions = function () {
      return this.getOptions();
    }, i.prototype.getOptions = function () {
      return cloneDeepWith$1(this.options, PopupOptions._cloneCustomizer);
    }, i.prototype.getPopupContainer = function () {
      return this.containerDiv;
    }, i.prototype._dragToPixel = function (e) {
      this.dragging || (this.dragging = !0, this.contentDiv.style.pointerEvents = "none", this._invokeEvent("dragstart", {
        type: "dragstart",
        target: this
      }));
      e = [e[0] + this.dragOffset[0], e[1] + this.dragOffset[1]], e = __read$d(this.map.pixelsToPositions([e]), 1)[0];
      this.options.position = e, this.marker.setLngLat(this.options.position), this._invokeEvent("drag", {
        type: "drag",
        target: this
      });
    }, i.prototype._onUp = function () {
      this.dragging && (this.contentDiv.style.pointerEvents = "", this._invokeEvent("dragend", {
        type: "dragend",
        target: this
      }), "none" === this.options.anchor) && this._onMove(), delete this.dragOffset, delete this.dragging;
    }, i.prototype._createContainerDiv = function (e) {
      var t = this,
        r = document.createElement("div"),
        n = (r.classList.add(i.Css.container), r.classList.add(i.Css.hidden), r.style.borderColor = e.fillColor, r.setAttribute("role", "dialog"), r.setAttribute("aria-label", "Map Information Window"), !1);
      return r.addEventListener("keydown", function (e) {
        "Tab" !== e.key && "Escape" !== e.key && "Esc" !== e.key || (n = !0);
      }), r.addEventListener("keyup", function (e) {
        "Tab" !== e.key && "Escape" !== e.key && "Esc" !== e.key || (n = !1);
      }), r.addEventListener("focusin", function (e) {
        t.map && !t.isOpen() && (t.open(t.map), e.target instanceof HTMLElement) && e.target.focus();
      }), r.addEventListener("focusout", function (e) {
        n && e.relatedTarget instanceof Node && !r.contains(e.relatedTarget) && (n = !1, t.isOpen()) && t.close();
      }), r;
    }, i.prototype._createContentDiv = function (e) {
      var t = document.createElement("div");
      return t.classList.add(i.Css.content), t.style.backgroundColor = e.fillColor, t.setAttribute("tabindex", "0"), this.htmlContent = this._createHtmlContent(e), t.appendChild(this.htmlContent), t;
    }, i.prototype._createArrowDiv = function () {
      var e = document.createElement("div");
      return e.classList.add(i.Css.arrow), e;
    }, i.prototype._createCloseButton = function () {
      var e = document.createElement("button");
      return e.addEventListener("click", this.close), e.classList.add(i.Css.close), e.setAttribute("aria-label", "close"), e.setAttribute("tabindex", "0"), e.innerHTML = "&times;", e;
    }, i.prototype._createHtmlContent = function (e) {
      var t = Html.convertHtmlString(e.content);
      return e.draggable && this._setDraggable(t, e.draggable), t;
    }, i.prototype._createMarker = function (e, t) {
      var r = this.marker ? this.marker.getLngLat() : e.position,
        t = ("none" === e.anchor ? (this.autoAnchor = t || "bottom", this.containerDiv.classList.add(this.autoAnchor), new maplibregl.Marker({
          anchor: this.autoAnchor,
          element: this.containerDiv,
          offset: e.pixelOffset
        })) : (this.containerDiv.classList.add(e.anchor), new maplibregl.Marker({
          anchor: e.anchor,
          element: this.containerDiv,
          offset: e.pixelOffset
        }))).setLngLat(r);
      return t;
    }, i.prototype._getAutoAnchor = function (e, t) {
      var r,
        n,
        i = this.containerDiv.offsetWidth,
        o = this.containerDiv.offsetHeight,
        a = [];
      return (n = this.marker ? (r = (n = e._getMap().project(this.marker.getLngLat())).x, n.y) : (n = __read$d(e.positionsToPixels([t.position]), 1), r = (t = __read$d(n[0], 2))[0], t[1])) < o ? a.push("top") : n > e.getCanvas().offsetHeight - o && a.push("bottom"), r < i / 2 ? a.push("left") : r > e.getCanvas().offsetWidth - i / 2 && a.push("right"), 0 < a.length ? a.join("-") : "bottom";
    }, i.prototype._replaceMarker = function (e, t, r) {
      var n = this.containerDiv.nextElementSibling;
      this.marker.remove(), this.containerDiv.classList.remove(this.autoAnchor || this.options.anchor), this.marker = this._createMarker(t, r), this.marker.addTo(e._getMap()), e.popups._getCollectionDiv().insertBefore(this.containerDiv, n || null);
    }, i.prototype._setDraggable = function (e, t) {
      t ? (e.addEventListener("mousedown", this._onDown), e.addEventListener("touchstart", this._onDown), e.addEventListener("dragstart", this._onDragStart)) : (e.removeEventListener("mousedown", this._onDown), e.removeEventListener("touchstart", this._onDown), e.removeEventListener("dragstart", this._onDragStart));
    }, i.Css = {
      arrow: "popup-arrow",
      close: "popup-close",
      container: "popup-container",
      content: "popup-content-container",
      hidden: "hidden-accessible-element"
    }, i;
  }(EventEmitter),
  __extends$n = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  HtmlMarkerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.anchor = "bottom", e.color = "#1A73AA", e.draggable = !1, e.htmlContent = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24.5 36.5" id="marker_'.concat(uuid(), '" width="24.5" height="36.5" display="block"><path d="M12.25.25a12.2543,12.2543,0,0,0-12,12.4937c0,6.4436,6.4879,12.1093,11.059,22.5641.5493,1.2563,1.3327,1.2563,1.882,0C17.7621,24.8529,24.25,19.1857,24.25,12.7437A12.2543,12.2543,0,0,0,12.25.25Z"   fill="{color}" stroke="{secondaryColor}" stroke-width="0.5"/><text style="font-family: Arial, Helvetica, sans-serif; font-size: 14px; fill: white;" text-anchor="middle" x="12" y="18">{text}</text></svg>'), e.pixelOffset = new Pixel(0, 0), e.position = new Position(0, 0), e.popup = void 0, e.secondaryColor = "white", e.text = void 0, e.visible = !0, e;
    }
    return __extends$n(e, t), e._cloneCustomizer = function (e) {
      if (e instanceof Popup || isElement$1(e)) return e;
    }, e;
  }(Options),
  __extends$m = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  HtmlMarker = function (r) {
    function n(e) {
      var t = r.call(this) || this;
      return t._onDrag = function () {
        var e = t.marker.getLngLat().wrap();
        t.options.position = new Position(e.lng, e.lat), t._invokeEvent("drag", {
          type: "drag",
          target: t
        });
      }, t._onDragStart = function () {
        t._invokeEvent("dragstart", {
          type: "dragstart",
          target: t
        });
      }, t._onDragEnd = function () {
        t._invokeEvent("dragend", {
          type: "dragend",
          target: t
        });
      }, t._bubbleElementEvent = function (e) {
        t._invokeEvent(e.type, {
          type: e.type,
          target: t
        });
      }, t._onEleDragStart = function (e) {
        e.preventDefault();
      }, t.options = new HtmlMarkerOptions().merge(cloneDeepWith$1(e, HtmlMarkerOptions._cloneCustomizer)), t._buildMarker(t.options), t;
    }
    return __extends$m(n, r), n.prototype.getOptions = function () {
      return cloneDeepWith$1(this.options, HtmlMarkerOptions._cloneCustomizer);
    }, n.prototype.getElement = function () {
      return this.marker.getElement();
    }, n.prototype.setOptions = function (e) {
      e = new HtmlMarkerOptions().merge(this.options, cloneDeepWith$1(e, HtmlMarkerOptions._cloneCustomizer));
      isEqual$1(e.htmlContent, this.options.htmlContent) && e.anchor === this.options.anchor ? ("string" != typeof e.htmlContent || e.color === this.options.color && e.text === this.options.text && e.secondaryColor === this.options.secondaryColor || (this.element.innerHTML = this._getSubbedHtmlString(e) || ""), e.draggable !== this.options.draggable && (this._setDraggable(e.draggable), this.marker.setDraggable(e.draggable)), isEqual$1(e.pixelOffset, this.options.pixelOffset) || this.marker.setOffset(e.pixelOffset), isEqual$1(e.position, this.options.position) || this.marker.setLngLat(e.position), e.visible !== this.options.visible && (e.visible ? this.element.classList.remove(n.hiddenClass) : this.element.classList.add(n.hiddenClass))) : (this.marker.remove(), this._buildMarker(e), this.map && (this.marker.addTo(this.map._getMap()), this._getCollectionContainer().appendChild(this.element))), this.options = e;
    }, n.prototype.togglePopup = function () {
      if (this.options.popup) if (this.options.popup.isOpen()) this.options.popup.close();else {
        if (!this.map) throw new Error("The marker must be added to a map before calling togglePopup().");
        this.options.popup.setOptions({
          position: this.options.position
        }), this.options.popup.open(this.map);
      }
    }, n.prototype._addToMap = function (e, t) {
      this.map && this.map !== e && this._removeFromMap(), t && (this.options.position = cloneDeep$1(t), this.marker.setLngLat(this.options.position)), this.map !== e && (this.map = e, this.marker.addTo(e._getMap()), this._getCollectionContainer().appendChild(this.element));
    }, n.prototype._removeFromMap = function () {
      this.map && (this.marker.remove(), delete this.map);
    }, n.prototype._getId = function () {
      if (this.element) return ("string" == typeof this.options.htmlContent ? this.element.firstChild : this.element).id;
    }, n.prototype._buildMarker = function (e) {
      var t;
      "string" == typeof e.htmlContent ? (t = this._getSubbedHtmlString(e) || "", this.element = Html.convertHtmlString(t)) : this.element = e.htmlContent, this.element.classList.add(n.containerClass), e.draggable && this._setDraggable(!0), e.visible || this.element.classList.add(n.hiddenClass), this.marker = new maplibregl.Marker({
        element: this.element,
        offset: e.pixelOffset,
        draggable: e.draggable,
        anchor: e.anchor
      }).setLngLat(e.position), this.marker.on("drag", this._onDrag), this.marker.on("dragstart", this._onDragStart), this.marker.on("dragend", this._onDragEnd), this.element.addEventListener("click", this._bubbleElementEvent), this.element.addEventListener("dblclick", this._bubbleElementEvent), this.element.addEventListener("contextmenu", this._bubbleElementEvent), this.element.addEventListener("keydown", this._bubbleElementEvent), this.element.addEventListener("keypress", this._bubbleElementEvent), this.element.addEventListener("keyup", this._bubbleElementEvent), this.element.addEventListener("mousedown", this._bubbleElementEvent), this.element.addEventListener("mouseenter", this._bubbleElementEvent), this.element.addEventListener("mouseleave", this._bubbleElementEvent), this.element.addEventListener("mousemove", this._bubbleElementEvent), this.element.addEventListener("mouseout", this._bubbleElementEvent), this.element.addEventListener("mouseover", this._bubbleElementEvent), this.element.addEventListener("mouseup", this._bubbleElementEvent);
    }, n.prototype._getSubbedHtmlString = function (e) {
      return "string" == typeof e.htmlContent ? e.htmlContent.replace(/{color}/gi, e.color || "").replace(/{secondaryColor}/gi, e.secondaryColor || "").replace(/{text}/gi, e.text || "") : null;
    }, n.prototype._getCollectionContainer = function () {
      var e = this.map.getCanvasContainer().querySelector(".".concat(n.collectionContainerClass));
      return e || ((e = document.createElement("div")).classList.add(n.collectionContainerClass), this.map.getCanvasContainer().appendChild(e)), e;
    }, n.prototype._setDraggable = function (e) {
      e ? this.element.addEventListener("dragstart", this._onEleDragStart) : this.element.removeEventListener("dragstart", this._onEleDragStart);
    }, n.collectionContainerClass = "marker-collection-container", n.hiddenClass = "hidden-accessible-element", n.containerClass = "marker-container", n;
  }(EventEmitter),
  supported = isSupported$1;
function isSupported$1(e) {
  return !notSupportedReason(e);
}
function notSupportedReason(e) {
  return isBrowser() ? isArraySupported() ? isFunctionSupported() ? isObjectSupported() ? isJSONSupported() ? isWorkerSupported() ? isUint8ClampedArraySupported() ? isArrayBufferSupported() ? isCanvasGetImageDataSupported() ? isWebGLSupportedCached(e && e.failIfMajorPerformanceCaveat) ? isNotIE() ? void 0 : "insufficient ECMAScript 6 support" : "insufficient WebGL support" : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support" : "not a browser";
}
function isBrowser() {
  return "undefined" != typeof window && "undefined" != typeof document;
}
function isArraySupported() {
  return Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray;
}
function isFunctionSupported() {
  return Function.prototype && Function.prototype.bind;
}
function isObjectSupported() {
  return Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions;
}
function isJSONSupported() {
  return "JSON" in window && "parse" in JSON && "stringify" in JSON;
}
function isWorkerSupported() {
  if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
  var t,
    e,
    r = new Blob([""], {
      type: "text/javascript"
    }),
    r = URL.createObjectURL(r);
  try {
    e = new Worker(r), t = !0;
  } catch (e) {
    t = !1;
  }
  return e && e.terminate(), URL.revokeObjectURL(r), t;
}
function isUint8ClampedArraySupported() {
  return "Uint8ClampedArray" in window;
}
function isArrayBufferSupported() {
  return ArrayBuffer.isView;
}
function isCanvasGetImageDataSupported() {
  var e = document.createElement("canvas"),
    t = (e.width = e.height = 1, e.getContext("2d"));
  return !!t && (t = t.getImageData(0, 0, 1, 1)) && t.width === e.width;
}
var isWebGLSupportedCache = {};
function isWebGLSupportedCached(e) {
  return void 0 === isWebGLSupportedCache[e] && (isWebGLSupportedCache[e] = isWebGLSupported(e)), isWebGLSupportedCache[e];
}
function getWebGLContext(e) {
  var t = document.createElement("canvas"),
    r = Object.create(isSupported$1.webGLContextAttributes);
  return r.failIfMajorPerformanceCaveat = e, t.getContext("webgl", r) || t.getContext("experimental-webgl", r);
}
function isWebGLSupported(e) {
  var t,
    e = getWebGLContext(e);
  if (!e) return !1;
  try {
    t = e.createShader(e.VERTEX_SHADER);
  } catch (e) {
    return !1;
  }
  return !(!t || e.isContextLost()) && (e.shaderSource(t, "void main() {}"), e.compileShader(t), !0 === e.getShaderParameter(t, e.COMPILE_STATUS));
}
function isNotIE() {
  return !document.documentMode;
}
isSupported$1.webGLContextAttributes = {
  antialias: !1,
  alpha: !0,
  stencil: !0,
  depth: !0
};
var AuthenticationType,
  defaultView,
  CultureCode = function () {
    function e() {}
    return e.parse = function (e) {
      var t = (e = e.toLowerCase()).lastIndexOf("-");
      return -1 !== t ? {
        code: e,
        language: e.substring(0, t),
        region: e.substring(t + 1)
      } : {
        code: e,
        language: e
      };
    }, e;
  }(),
  localeIndex = {
    localizationsPath: "locs/mapcontrol/2019-3-12",
    sensitiveUserRegions: ["il", "kr", "pk", "in", "cn", "ar", "bh", "eg", "jo", "sa", "kw", "om", "qa", "ma", "ae"],
    locales: {
      defaultLanguage: {
        defaultRegion: {
          code: "NGT",
          strings: "en/resource.json"
        },
        latn: {
          code: "NGT-Latn",
          strings: "en/resource.json"
        }
      },
      ar: {
        defaultRegion: {
          code: "ar",
          strings: "ar-sa/resource.json"
        }
      },
      bg: {
        defaultRegion: {
          code: "bg-BG",
          strings: "bg-bg/resource.json"
        }
      },
      cs: {
        defaultRegion: {
          code: "cs-CZ",
          strings: "cs-cz/resource.json"
        }
      },
      da: {
        defaultRegion: {
          code: "da-DK",
          strings: "da-dk/resource.json"
        }
      },
      de: {
        defaultRegion: {
          code: "de-DE",
          strings: "de-de/resource.json"
        }
      },
      el: {
        defaultRegion: {
          code: "el-GR",
          strings: "el-gr/resource.json"
        }
      },
      en: {
        defaultRegion: {
          code: "en",
          strings: "en/resource.json"
        },
        us: {
          code: "en-US",
          strings: "en/resource.json"
        },
        au: {
          code: "en-AU",
          strings: "en/resource.json"
        },
        gb: {
          code: "en-GB",
          strings: "en/resource.json"
        },
        nz: {
          code: "en-NZ",
          strings: "en/resource.json"
        }
      },
      es: {
        defaultRegion: {
          code: "es-ES",
          strings: "es-es/resource.json"
        },
        mx: {
          code: "es-MX",
          strings: "es-mx/resource.json"
        }
      },
      fi: {
        defaultRegion: {
          code: "fi-FI",
          strings: "fi-fi/resource.json"
        }
      },
      fr: {
        defaultRegion: {
          code: "fr-FR",
          strings: "fr-fr/resource.json"
        }
      },
      hu: {
        defaultRegion: {
          code: "hu-HU",
          strings: "hu-hu/resource.json"
        }
      },
      id: {
        defaultRegion: {
          code: "id-ID",
          strings: "id-id/resource.json"
        }
      },
      it: {
        defaultRegion: {
          code: "it-IT",
          strings: "it-it/resource.json"
        }
      },
      ko: {
        defaultRegion: {
          code: "ko-KR",
          strings: "ko-kr/resource.json"
        }
      },
      lt: {
        defaultRegion: {
          code: "lt-LT",
          strings: "lt-lt/resource.json"
        }
      },
      ms: {
        defaultRegion: {
          code: "ms-MY",
          strings: "ms-my/resource.json"
        }
      },
      nb: {
        defaultRegion: {
          code: "nb-NO",
          strings: "nb-no/resource.json"
        }
      },
      nl: {
        defaultRegion: {
          code: "nl-NL",
          strings: "nl-nl/resource.json"
        }
      },
      pl: {
        defaultRegion: {
          code: "pl-PL",
          strings: "pl-pl/resource.json"
        }
      },
      pt: {
        defaultRegion: {
          code: "pt-PT",
          strings: "pt-pt/resource.json"
        },
        br: {
          code: "pt-BR",
          strings: "pt-br/resource.json"
        }
      },
      ru: {
        defaultRegion: {
          code: "ru-RU",
          strings: "ru-ru/resource.json"
        }
      },
      sk: {
        defaultRegion: {
          code: "sk-SK",
          strings: "sk-sk/resource.json"
        }
      },
      sl: {
        defaultRegion: {
          code: "sl-SL",
          strings: "sl-sl/resource.json"
        }
      },
      sv: {
        defaultRegion: {
          code: "sv-SE",
          strings: "sv-se/resource.json"
        }
      },
      th: {
        defaultRegion: {
          code: "th-TH",
          strings: "th-th/resource.json"
        }
      },
      tr: {
        defaultRegion: {
          code: "tr-TR",
          strings: "tr-tr/resource.json"
        }
      },
      zh: {
        defaultRegion: {
          code: "zh",
          strings: "en/resource.json"
        }
      },
      "zh-hans": {
        defaultRegion: {
          code: "zh-Hans",
          strings: "zh-cn/resource.json"
        },
        cn: {
          code: "zh-Hans-CN",
          strings: "zh-cn/resource.json"
        }
      },
      "zh-hant": {
        defaultRegion: {
          code: "zh-Hant",
          strings: "en/resource.json"
        },
        tw: {
          code: "zh-Hant-TW",
          strings: "zh-tw/resource.json"
        }
      }
    }
  },
  LocalizedStrings = function () {
    this.Unknown = "Unknown", this.Accident = "Accident", this.Fog = "Fog", this.Danger = "Danger", this.Rain = "Rain", this.Ice = "Ice", this.Jam = "Jam", this.LaneClosed = "Lane Closed", this.RoadClosed = "Road Closed", this.RoadWorks = "Road Works", this.Wind = "Wind", this.Flood = "Flood", this.Detour = "Detour";
  },
  Localizer = function () {
    function e() {}
    return e.getCode = function (e) {
      var t = CultureCode.parse(e);
      return -1 === localeIndex.sensitiveUserRegions.indexOf(t.region) ? this.getLocaleData(t).code : e;
    }, e.getStrings = function (e) {
      e = this.getLocaleData(e);
      return localeIndex.locales.defaultLanguage.defaultRegion.code === e.code ? new Promise(function (e) {
        e(new LocalizedStrings());
      }) : new Url({
        domain: env.staticAssetsDomain,
        path: "".concat(localeIndex.localizationsPath, "/").concat(e.strings)
      }).get().then(function (e) {
        return e;
      }, function () {
        return new LocalizedStrings();
      });
    }, e.getLocaleData = function (e) {
      if ("string" == typeof e && (e = CultureCode.parse(e)), localeIndex.locales[e.code]) return localeIndex.locales[e.code].defaultRegion;
      var t;
      if (localeIndex.locales[e.language]) t = localeIndex.locales[e.language];else {
        if (-1 !== e.language.indexOf("-")) return this.getLocaleData(e.language);
        t = localeIndex.locales.defaultLanguage;
      }
      return e.region && t[e.region] ? t[e.region] : t.defaultRegion;
    }, e;
  }(),
  UserAgent = function () {
    function e() {}
    return e.getEdgeOrIEVersion = function () {
      var e = window.navigator.userAgent,
        t = e.indexOf("MSIE ");
      return 0 < t ? parseInt(e.substring(t + 5, e.indexOf(".", t)), 10) : 0 < e.indexOf("Trident/") ? (t = e.indexOf("rv:"), parseInt(e.substring(t + 3, e.indexOf(".", t)), 10)) : 0 < (t = e.indexOf("Edge/")) ? parseInt(e.substring(t + 5, e.indexOf(".", t)), 10) : -1;
    }, e.isEdgeOrIE = function () {
      return -1 !== this.getEdgeOrIEVersion();
    }, e.isIE = function () {
      var e = this.getEdgeOrIEVersion();
      return -1 !== e && e <= 11;
    }, e;
  }(),
  __extends$l = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __read$c = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  __spreadArray$a = window && window.__spreadArray || function (e, t, r) {
    if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++) !n && i in t || ((n = n || Array.prototype.slice.call(t, 0, i))[i] = t[i]);
    return e.concat(n || Array.prototype.slice.call(t));
  },
  AuthenticationOptions = (!function (e) {
    e.subscriptionKey = "subscriptionKey", e.aad = "aad", e.anonymous = "anonymous", e.sas = "sas";
  }(AuthenticationType = AuthenticationType || {}), function (n) {
    function e() {
      var e = null !== n && n.apply(this, arguments) || this;
      return e.authType = void 0, e.subscriptionKey = void 0, e.clientId = void 0, e.aadAppId = void 0, e.aadTenant = void 0, e.aadInstance = void 0, e.getToken = void 0, e.sasToken = void 0, e.authContext = void 0, e;
    }
    return __extends$l(e, n), e.prototype.setSubscriptionKey = function (e) {
      this.authType = AuthenticationType.subscriptionKey, this.subscriptionKey = e;
    }, e.prototype.setAadProperties = function (e, t, r, n, i) {
      this.authType = AuthenticationType.aad, this.authContext = i || this.authContext, this.aadInstance = n || this.aadInstance, this.clientId = e, this.aadAppId = t, this.aadTenant = r;
    }, e.prototype.setTokenCallbackFunction = function (e) {
      this.authType = AuthenticationType.anonymous, this.getToken = e;
    }, e.prototype.setSasCallbackFunction = function (e) {
      this.authType = AuthenticationType.sas, this.getToken = e;
    }, e.prototype.merge = function () {
      for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
      var r = n.prototype.merge.apply(this, __spreadArray$a([], __read$c(e), !1));
      return r.authType === AuthenticationType.subscriptionKey ? r.authContext = r.aadAppId = r.getToken = void 0 : r.authType === AuthenticationType.aad ? r.subscriptionKey = r.getToken = void 0 : r.authType === AuthenticationType.anonymous ? r.subscriptionKey = r.authContext = r.aadAppId = void 0 : r.authType === AuthenticationType.sas && (r.authContext = r.subscriptionKey = r.aadAppId = void 0), r;
    }, e;
  }(Options)),
  defaultLanguage = "NGT",
  defaultSessionId = uuid(),
  defaultDomain = env.domain,
  defaultStaticAssetsDomain = env.staticAssetsDomain,
  defaultStyleDefinitionsPath = env.stylePath,
  defaultStyleDefinitionsVersion = env.styleDefinitionsVersion,
  defaultStyleAPIVersion = constants.styleApiVersion,
  defaultAuthOptions = new AuthenticationOptions(),
  hasSetView = !1,
  hasSetDomain = !1,
  hasSetStyleDefinitionsPath = !1,
  hasSetStyleDefinitionsVersion = !1,
  hasWorkerCount = !1,
  hasMaxParallelImageRequests = !1,
  hasSetLanguage = !1,
  hasSetSessionId = !1,
  hasSetAuthenticationOptions = !1;
function getAuthenticationOptions() {
  return Object.assign({}, defaultAuthOptions);
}
function getStaticAssetsDomain() {
  return defaultStaticAssetsDomain;
}
function getDomain() {
  return defaultDomain;
}
function getStyleDefinitionsPath() {
  return defaultStyleDefinitionsPath;
}
function getStyleDefinitionsVersion() {
  return defaultStyleDefinitionsVersion;
}
function getStyleAPIVersion() {
  return defaultStyleAPIVersion;
}
function getWorkerCount() {
  return maplibregl.workerCount;
}
function getMaxParallelImageRequests() {
  return maplibregl.maxParallelImageRequests;
}
function getLanguage() {
  return defaultLanguage;
}
function getSessionId() {
  return defaultSessionId;
}
function getSubscriptionKey() {
  return defaultAuthOptions.authType === AuthenticationType.subscriptionKey ? defaultAuthOptions.subscriptionKey : void 0;
}
function getUserRegion() {
  return defaultView;
}
function getView() {
  return defaultView;
}
function getVersion() {
  return Version$1.getFullVersion();
}
function isSupported(e) {
  var t = !UserAgent.isIE();
  return t = t && supported({
    failIfMajorPerformanceCaveat: e
  }) && null !== document.createElement("canvas").getContext("webgl2");
}
function setAuthenticationOptions(e) {
  defaultAuthOptions = new AuthenticationOptions().merge(defaultAuthOptions, e), hasSetAuthenticationOptions = !0;
}
function setDomain(e) {
  defaultDomain = e, hasSetDomain = !0;
}
function setStyleDefinitionsPath(e) {
  defaultStyleDefinitionsPath = e, hasSetStyleDefinitionsPath = !0;
}
function setStyleDefinitionsVersion(e) {
  defaultStyleDefinitionsVersion = e, hasSetStyleDefinitionsVersion = !0;
}
function setStyleAPIVersion(e) {
  defaultStyleAPIVersion = e;
}
function setWorkerCount(e) {
  0 < e && (maplibregl.workerCount = e, hasWorkerCount = !0);
}
function setMaxParallelImageRequests(e) {
  0 < e && (maplibregl.maxParallelImageRequests = e, hasMaxParallelImageRequests = !0);
}
function setLanguage(e) {
  defaultLanguage = Localizer.getCode(e), hasSetLanguage = !0;
}
function setSessionId(e) {
  defaultSessionId = e, hasSetSessionId = !0;
}
function setSubscriptionKey(e) {
  defaultAuthOptions.setSubscriptionKey(e), hasSetAuthenticationOptions = !0;
}
function setUserRegion(e) {
  defaultView = e, hasSetView = !0;
}
function setView(e) {
  defaultView = e, hasSetView = !0;
}
function addImageTemplate(e, t, r) {
  !r && imageTemplates[e.toLowerCase()] || (imageTemplates[e.toLowerCase()] = t);
}
function getImageTemplate(e, t) {
  if (t = Math.abs(t || 1), "string" == typeof e && imageTemplates[e.toLowerCase()]) {
    for (var r = imageTemplates[e.toLowerCase()], n = /calc\(([0-9.]+)[px]*\s*\*\s*\{scale\}\)/gi, i = r, o = n.exec(r); o;) i = i.replace(o[0], parseFloat(o[1]) * t + ""), o = n.exec(r);
    return i = i.replace("{scale}", t + "");
  }
  throw new Error("Invalid templateName.");
}
function getAllImageTemplateNames() {
  return Object.keys(imageTemplates);
}
function prewarm() {
  maplibregl.prewarm();
}
function clearPrewarmedResources() {
  maplibregl.clearPrewarmedResources();
}
function _hasSetAuthenticationOptions() {
  return hasSetAuthenticationOptions;
}
function _hasSetDomain() {
  return hasSetDomain;
}
function _hasSetStyleDefinitionsPath() {
  return hasSetStyleDefinitionsPath;
}
function _hasSetStyleDefinitionsVersion() {
  return hasSetStyleDefinitionsVersion;
}
function _hasWorkerCount() {
  return hasWorkerCount;
}
function _hasMaxParallelImageRequests() {
  return hasMaxParallelImageRequests;
}
function _hasSetLanguage() {
  return hasSetLanguage;
}
function _hasSetSessionId() {
  return hasSetSessionId;
}
function _hasSetView() {
  return hasSetView;
}
function _getAssetDomain() {
  return env.domain;
}
function _getDomain() {
  return getDomain();
}
var imageTemplates = {
    marker: '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 26 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:1"/><text x="12.5" y="17.5" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "marker-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 27 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:2"/><text x="12.5" y="18.5" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "marker-circle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 27 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:1"/><circle cx="12.5" cy="12.5" r="9" fill="{secondaryColor}"/><text x="12" y="17.5" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
    pin: '<svg xmlns="http://www.w3.org/2000/svg" width="calc(24 * {scale})" height="calc(28 * {scale})" viewBox="0 0 24 28"><path d="m11.988 16.615a5.15 5.15 0 0 1-2.268-.525 4.909 4.909 0 0 1-2.805-4.442 5.019 5.019 0 0 1 5.072-4.936h.012a5.03 5.03 0 0 1 5.085 4.961 4.907 4.907 0 0 1-.549 2.224 5.114 5.114 0 0 1-4.548 2.718zm0-8.06a3.173 3.173 0 0 0-3.226 3.099 3.081 3.081 0 0 0 1.77 2.782 3.299 3.299 0 0 0 4.365-1.386 3.049 3.049 0 0 0 .342-1.381 3.184 3.184 0 0 0-3.239-3.114h-.012z" fill="{secondaryColor}"/><path d="m11.999.922a10.908 10.908 0 0 0-11.076 10.732 10.639 10.639 0 0 0 4.418 8.598l6.658 6.464 6.658-6.463a10.537 10.537 0 0 0 2.198-15.041 11.182 11.182 0 0 0-8.856-4.289zm1.873 14.341a4.221 4.221 0 0 1-5.589-1.789 3.945 3.945 0 0 1-.445-1.8 4.164 4.164 0 0 1 8.323-.037 4.028 4.028 0 0 1-2.289 3.626Z" fill="{color}"/><path d="m11.999 28-7.256-7.044a11.611 11.611 0 0 1-4.743-9.303 11.844 11.844 0 0 1 11.988-11.652.102 .102 0 0 1 .02 0 12.164 12.164 0 0 1 9.577 4.647 11.357 11.357 0 0 1 2.299 8.614 11.521 11.521 0 0 1-4.63 7.695zm-.01-26.157a9.997 9.997 0 0 0-10.143 9.812 9.769 9.769 0 0 0 4.04 7.853l.099.083 6.014 5.838 6.113-5.922a9.7 9.7 0 0 0 3.945-6.505 9.533 9.533 0 0 0-1.933-7.229 10.305 10.305 0 0 0-8.116-3.931h-.021zm.021 14.772a5.11 5.11 0 0 1-4.547-2.718 4.868 4.868 0 0 1 .932-5.743 5.118 5.118 0 0 1 3.58-1.46h.024a5.031 5.031 0 0 1 5.084 4.938 4.92 4.92 0 0 1-2.805 4.457h0a5.152 5.152 0 0 1-2.269.525zm-.011-8.079h-.015a3.277 3.277 0 0 0-2.295.933 3.029 3.029 0 0 0-.587 3.58 3.297 3.297 0 0 0 4.364 1.386h0a3.092 3.092 0 0 0 1.772-2.795 3.185 3.185 0 0 0-3.239-3.105z" fill="{secondaryColor}"/><text x="12" y="17" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
    "pin-round": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(25 * {scale})" height="calc(25 * {scale})" viewBox="0 0 25 25"><g transform="translate(0 1)"><circle cx="12.25" cy="11.5833" r="11" fill="{color}"/><path d="m12.25 23.583a12 12 0 1 1 12-12 12 12 0 0 1-12 12zm0-22a10 10 0 1 0 10 10 10 10 0 0 0-10-10z" fill="{secondaryColor}"/><circle cx="12.25" cy="11.5833" r="4.2386" fill="{secondaryColor}"/></g><text x="12.5" y="17" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
    "marker-flat": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(42.8 * {scale})"  viewBox="0 0 1600 2570"><g fill="{color}"><path d="M691 2419c-409-575-641-1086-683-1504-10-106-10-136 5-224 31-188 105-330 241-458 129-124 270-190 453-214 69-9 113-10 182-1 373 46 655 326 703 698 40 308-120 801-424 1309-134 224-348 535-369 535-4 0-53-63-108-141z"/></g><g fill="rgba(0,0,0,0.15)" style="transform:scale(-1,1);transform-origin:center"><path d="M691 2419c-407-571-639-1083-682-1498-14-139-3-249 37-371 69-208 254-402 459-481 68-27 217-59 271-59h24v160 180 940 635c0 349-2 635-5 635-2 0-49-63-104-141z"/></g><circle cx="800" cy="800" r="600" fill="{secondaryColor}"/><text x="800" y="1100" style="font-size:800px;fill:#000;text-anchor:middle">{text}</text></svg>',
    "marker-arrow": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(25.47 * {scale})" height="calc(35.18 * {scale})" viewBox="0 0 4330 5980"><g fill="{color}"><path d="m2080 5969c-49-20-93-63-115-113-25-55-1928-5486-1953-5573-40-138 67-282 210-283 36 0 246 73 987 345 518 190 947 345 955 345 8 0 438-155 955-345 615-226 954-345 979-345 87 0 165 47 204 123 46 91 107-95-957 2942-537 1535-986 2805-997 2823-11 18-43 46-72 62-41 24-62 30-111 29-33 0-71-5-85-10z"/></g><g fill="{secondaryColor}"><path d="m2200 1600c-36 10-83 2-484-84-243-53-451-94-461-91-11 4-22 18-25 31-5 19 114 371 436 1292 244 697 448 1273 454 1281 19 24 50 30 71 12z"/><path d="m2200 1600c-36 10-83 2-484-84-243-53-451-94-461-91-11 4-22 18-25 31-5 19 114 371 436 1292 244 697 448 1273 454 1281 19 24 50 30 71 12z" style="transform:scale(-1,1);transform-origin:center"/></g><g fill="rgba(0,0,0,0.2)" ><path d="m2165 685c8 0 438-155 955-345 615-226 954-345 979-345 87 0 165 47 204 123 46 91 107-95-957 2942-537 1535-986 2805-997 2823-11 18-43 46-72 62-41 24-62 30-111 29z"/></g><text x="2165" y="3300" style="font-size:2500px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "marker-ball-pin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15.67 * {scale})" height="calc(33.33 * {scale})" viewBox="0 0 235 452"><g transform="translate(-135 10)"><path fill="{secondaryColor}" d="m256 442 0 0c-13 0-18-11-18-24l-6-323c0-13 11-24 24-24h0c13 0 24 11 24 24l-6 323c0 13-5 24-18 24z"/><circle style="fill:{color};stroke-width:10;stroke:{secondaryColor}" cx="256" cy="112" r="111"/><ellipse transform="matrix(0.834 0.5518 -0.5518 0.834 65.7916 -97.18)" fill="rgba(255,255,255,0.3)" cx="194.399" cy="60.749" rx="19.076" ry="32.428"/></g><text x="117.5" y="160" style="font-size:160px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "marker-square": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(26.67 * {scale})" height="calc(32.27 * {scale})" viewBox="0 0 2000 2420"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="M845 2152c-22-37-58-95-80-129-22-35-62-99-90-143l-50-80-312 0-313 0 0-900 0-900 900 0 900 0 0 900 0 900-313 0-313 0-34 58c-19 31-38 59-42 60-5 2-8 8-8 12 0 9-69 123-88 145-5 6-11 15-13 21-16 39-77 123-89 124-8 0-33-31-55-68z"/></g><text x="1000" y="1300" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "marker-square-cluster": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(33.33 * {scale})" height="calc(38.8 * {scale})" viewBox="0 0 2500 2910"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="m866 2652c-17-31-37-68-46-82-9-14-32-54-51-90-19-36-50-92-70-125l-36-60-332-3-331-2 0-905 0-905 660 0 660 0 0-38c0-71 50-196 102-258 71-85 189-164 244-164 12 0 26-4 29-10 8-13 222-13 230 0 3 6 17 10 30 10 25 0 117 45 154 76 130 107 191 232 191 392 0 155-63 284-190 386-36 29-129 76-150 76-11 0-22 5-25 10-3 6-31 10-61 10l-54 0 0 660 0 660-332 2-332 3-29 50c-17 28-48 84-70 125-22 41-47 86-56 100-9 14-30 51-46 83-17 32-36 57-45 57-8 0-28-25-44-58z"/></g><text x="1650" y="900" style="font-size:1000px;fill:#fff">+</text><text x="1000" y="1800" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "marker-square-rounded": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(26.8 * {scale})" height="calc(32.27 * {scale})" viewBox="0 0 2010 2410"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="M856 2155c-20-30-36-59-36-65 0-5-4-10-10-10-5 0-10-5-10-11 0-5-18-37-40-69-22-32-40-64-40-69 0-6-4-11-10-11-5 0-10-5-10-10 0-6-15-33-32-60l-33-50-127 0c-74 0-129-4-133-10-3-5-17-10-30-10-25 0-116-45-155-76-87-69-142-151-178-265-15-46-17-1075-2-1084 5-3 10-17 10-30 0-13 5-27 10-30 6-3 10-13 10-22 0-22 83-135 122-168 57-46 62-50 112-75l50-25 585 0 586 0 63 34c84 46 169 133 212 218l35 68 0 565 0 565-28 59c-32 69-100 157-139 180-15 9-33 22-40 29-23 22-99 57-123 57-13 0-27 5-30 10-4 6-60 10-135 10l-128 0-128 205c-84 136-133 205-144 205-10 0-33-24-54-55z"/></g><text x="1000" y="1300" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "marker-square-rounded-cluster": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(33.33 * {scale})" height="calc(32.13 * {scale})" viewBox="0 0 2500 2900"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="m874 2669c-9-18-26-49-37-68-11-20-30-55-43-78-13-24-36-64-51-90-14-27-38-69-52-95l-26-48-142 0c-84 0-144-4-148-10-3-5-17-10-30-10-25 0-118-46-154-76-91-76-136-142-175-254-13-38-16-119-16-554 0-358 3-520 12-545 40-125 106-219 195-278 127-84 116-83 646-83l467 0 0-42c0-46 11-87 45-163 54-121 169-220 306-264 46-14 232-14 278 0 165 53 284 175 340 350 19 61 14 204-10 273-32 91-94 178-169 240-38 31-130 76-155 76-13 0-27 5-30 10-3 6-28 10-56 10l-49 0 0 462c0 446-1 464-21 522-32 91-94 178-169 240-38 31-130 76-155 76-13 0-27 5-30 10-4 6-65 10-149 10-138 0-143 1-154 23-12 23-62 114-112 202-16 28-44 79-63 115-42 77-67 88-93 39z"/></g><text x="1650" y="900" style="font-size:1000px;fill:#fff">+</text><text x="1000" y="1800" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    flag: '<svg xmlns="http://www.w3.org/2000/svg" width="calc(23.5 * {scale})" height="calc(40 * {scale})" viewBox="34 28 198 308"><path style="stroke:{secondaryColor};stroke-width:15;stroke-linecap:round;" d="M42 327l0 -291"/><path style="fill:{color};stroke:{secondaryColor};stroke-width:10;stroke-linejoin:round;" d="M49 50c70 30 104 28 178 2-21 42-21 74 0 116-72 25-101 25-178 0l0-118z"/><text x="130" y="165" style="font-size:100px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "flag-triangle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(35.33 * {scale})" viewBox="0 0 40.5 53"><g transform="translate(-31 -20)"><path fill="{secondaryColor}" d="M34.7,73.3V48.4l34.6-10.1c0.7-0.2,1.2-0.8,1.2-1.5s-0.4-1.4-1-1.7L33.7,20.5c-0.5-0.2-1.1-0.2-1.6,0.2 c-0.5,0.3-0.7,0.8-0.7,1.4v51.2H34.7z"/><polygon points="34.7,24.5 66,36.5 34.7,45 34.7,10" fill="{color}"/></g><text x="11" y="21" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "rounded-square": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(34 * {scale})" height="calc(34 * {scale})" viewBox="0 0 34 34"><g transform="translate(2 2)"><rect x="0" y="0" rx="8" ry="8" width="30" height="30" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17" y="22" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "rounded-square-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(38 * {scale})" height="calc(38 * {scale})" viewBox="0 0 38 38"><g transform="translate(4 4)"><rect x="0" y="0" rx="8" ry="8" width="30" height="30" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19" y="24" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    triangle: '<svg xmlns="http://www.w3.org/2000/svg" width="calc(36 * {scale})" height="calc(36 * {scale})" viewBox="0 0 36 36"><g transform="translate(2 2)"><polygon points="16,0 32,32 0,32 16,0" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17.5" y="30" style="font-size:12px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "triangle-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 40 40"><g transform="translate(4 4)"><polygon points="16,0 32,32 0,32 16,0" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19.5" y="32" style="font-size:12px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    hexagon: '<svg xmlns="http://www.w3.org/2000/svg" width="calc(35 * {scale})" height="calc(40 * {scale})" viewBox="0 0 35 40"><g transform="translate(2 2)"><path d="M31 9 15.5 0 0 9 0 27 15.5 36 31 27 31 9Z" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17.5" y="25" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "hexagon-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(39 * {scale})" height="calc(44 * {scale})" viewBox="0 0 39 44"><g transform="translate(4 4)"><path d="M31 9 15.5 0 0 9 0 27 15.5 36 31 27 31 9Z" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19.5" y="27" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "hexagon-rounded": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 1100 1100"><g transform="translate(50 50)"><path style="stroke:{secondaryColor};stroke-width:50;fill:{color}" d="M881 210 561 25c-33-19-88-19-121 0L119 210c-33 19-61 67-61 105v370c0 39 27 86 61 105l321 185c33 19 88 19 122 0l321-185c33-19 61-67 61-105V315C942 276 915 229 881 210z"/></g><text x="550" y="700" style="font-size:400px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "hexagon-rounded-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 1200 1200"><g transform="translate(100 100)"><path style="stroke:{secondaryColor};stroke-width:100;fill:{color}" d="M881 210 561 25c-33-19-88-19-121 0L119 210c-33 19-61 67-61 105v370c0 39 27 86 61 105l321 185c33 19 88 19 122 0l321-185c33-19 61-67 61-105V315C942 276 915 229 881 210z"/></g><text x="600" y="750" style="font-size:400px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "triangle-arrow-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(28 * {scale})" viewBox="0 0 28 28"><g transform="translate(2 2)"><polygon points="12,0 0,24 12,17 24,24" stroke-width="2" stroke="{secondaryColor}" fill="{color}"/></g><text x="14" y="17" style="font-size:8px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "triangle-arrow-left": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(28 * {scale})" viewBox="0 0 28 28"><g transform="translate(2 2)"><polygon points="24,12 0,0 7,12 0,24" stroke-width="2" stroke="{secondaryColor}" fill="{color}"/></g><text x="14" y="16.5" style="font-size:8px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    "arrow-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(12.16 * {scale})" height="calc(30.1 * {scale})" viewBox="0 0 902 364"><g fill="{color}" transform="matrix(0,2.4,-2.4,0,897,-930)"><polygon points="902,222 233,222 233,364 0,182 233,0 233,141 902,141 902,222"/></g><text x="450" y="700" style="font-size:900px;fill:#000;text-anchor:middle">{text}</text></svg>',
    "arrow-up-thin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(33.33 * {scale})" viewBox="0 0 12 25"><g transform="translate(-136.91823 -751.91998)"><path fill="{color}" d="m148.271 760.71c-1.641-.547-3.186-1.47-4.633-2.769l0 18.07-1.675 0 0-18.07c-1.447 1.299-2.986 2.222-4.616 2.769l0-1.231c2.325-1.596 4.006-3.812 5.043-6.65l.838 0c1.037 2.838 2.718 5.055 5.043 6.65l0 1.231z"/></g><text x="6" y="20" style="font-size:10px;fill:#000;text-anchor:middle">{text}</text></svg>',
    car: '<svg xmlns="http://www.w3.org/2000/svg" width="calc(21.93 * {scale})" height="calc(40.9 * {scale})" viewBox="0 0 6580 12270"><g transform="translate(0 12270) rotate(-90)"><path fill="{secondaryColor}" d="M7045 6566c-42-13-105-44-105-51 0-2 23-105 50-228 28-123 50-230 50-236 0-8-241-11-907-11-855 0-1145 6-1513 30-85 6-189 13-230 15-41 3-133 10-205 15-286 21-430 32-705 50-953 63-1459 18-2335-205-304-77-746-209-799-238-131-72-221-408-285-1062-34-345-42-532-48-1130-16-1557 108-2532 336-2649 32-17 469-149 676-205 409-110 819-191 1205-238 116-14 224-18 540-18 395 1 494 5 1140 50 1124 79 1224 82 2496 78l641-3-53-237c-29-131-52-238-51-239 1-1 31-14 66-29 56-23 76-26 142-23 67 3 83 7 120 33 23 17 50 41 61 55 10 14 51 117 91 230l73 205 674 3 675 2 90-39c98-43 198-72 315-93 122-21 829-18 990 5 321 45 626 143 849 270 293 168 516 378 704 662 266 402 416 893 467 1527 15 174 8 882-9 998-6 41-18 127-27 190-69 502-253 969-523 1325-79 105-262 284-381 374-189 142-355 229-574 300-336 110-526 139-952 148-457 9-685-23-887-124l-47-24-678-6-678-6-64 179c-79 224-92 253-121 284-67 70-177 97-274 66zm-2752-5073c-23-2-64-2-90 0-26 2-7 3 42 3 50 0 71-1 48-3zm395 0c-21-2-55-2-75 0-21 2-4 4 37 4 41 0 58-2 38-4z"/><path fill="{color}" d="M7043 6498c-13-6-23-19-23-28 0-9 23-117 50-240 28-123 50-230 50-237 0-22-2126-13-2465 10-132 10-400 28-595 42-661 47-824 55-1160 62-435 7-656-8-1040-73-415-70-865-183-1447-365-168-53-272-556-325-1569-16-319-16-1311 0-1630 45-872 129-1366 257-1518 22-26 51-39 172-77 557-177 1122-310 1563-369 271-36 351-40 690-40 361 1 463 6 1165 54 1122 78 1288 83 2337 79 460-2 840-7 843-11 4-4-17-117-47-252l-55-245 39-16c76-30 180-8 224 47 10 13 54 124 98 246l79 222 709 0 709 0 47-24c74-37 219-83 322-101 122-22 606-32 802-16 374 29 658 102 933 238 124 62 271 155 361 230l61 51 6 100c19 278 103 497 247 643 88 89 173 136 278 152l70 11 41 131c116 369 159 673 168 1170 10 584-38 984-167 1397l-40 126-70 12c-193 33-348 175-441 405-56 139-89 302-89 445 0 43-3 47-58 91-290 235-644 384-1068 450-191 29-796 39-974 16-135-18-263-54-368-102l-75-35-701 0-701 0-79 223c-82 232-102 267-163 293-38 16-138 17-170 2zm-2023-820c332-15 1155-12 1835 6 308 8 563 12 566 8 4-4 10-21 13-38 7-30 6-31-92-77-518-244-1197-396-2112-474-295-25-1282-25-1579 0-231 20-473 46-479 51-6 7 49 110 93 171 160 226 416 335 855 365 142 10 539 5 900-12zm3304-263c525-111 899-887 934-1935 19-557-37-1023-172-1435-186-563-521-900-896-899-81 0-158 14-525 92-426 91-431 92-540 146-195 96-287 207-306 368-12 104-11 2985 1 3078 22 170 135 291 365 389 49 21 191 55 480 115 226 47 419 87 430 89 45 10 164 6 229-8zm-5570-485c112-43 197-156 216-291 12-83 13-2623 1-2706-23-158-125-273-270-304-44-9-100-1-542 75-272 47-514 91-539 98-266 68-487 424-594 958-56 280-70 548-40 800 56 484 207 878 414 1081 115 114 122 116 702 218 277 49 524 90 550 90 26 1 72-8 102-19zm2111-3440c1023-44 1884-213 2462-486l113-53-7-33c-3-18-8-35-10-37-2-3-236 1-521 7-993 24-1271 26-1708 11-541-18-1128-18-1249-1-377 56-588 181-734 437-32 55-41 79-32 84 12 8 246 32 491 51 356 28 815 36 1195 20z"/></g><text x="3250" y="8250" style="font-size:3000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
    checker: '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(16 * {scale})" viewBox="0 0 16 16"><pattern id="p" x="0" y="0" width="16" height="16" patternUnits="userSpaceOnUse"><rect fill="{color}" x="0" width="8" height="8" y="0"/><rect fill="{color}" x="8" width="8" height="8" y="8"/></pattern><rect x="0" y="0" width="16" height="16" fill="{secondaryColor}"/><rect x="0" y="0" width="16" height="16" fill="url(#p)"/></svg>',
    "checker-rotated": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(16 * {scale})" viewBox="0 0 60 60"><rect width="60" height="60" fill="{secondaryColor}"/><rect width="42.42" height="42.42" transform="translate(30 0) rotate(45)" fill="{color}"/></svg>',
    "zig-zag": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15 * {scale})" height="calc(15 * {scale})" viewBox="0 0 120 120"><rect x="0" y="0" width="120" height="120" fill="{secondaryColor}"/><polygon fill="{color}" points="120 120 60 120 90 90 120 60 120 0 120 0 60 60 0 0 0 60 30 90 60 120 120 120"/></svg>',
    "zig-zag-vertical": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15 * {scale})" height="calc(15 * {scale})" viewBox="0 0 120 120"><rect x="0" y="0" width="120" height="120" fill="{secondaryColor}"/><polygon fill="{color}" points="120 0 120 60 90 30 60 0 0 0 0 0 60 60 0 120 60 120 90 90 120 60 120 0"/></svg>',
    "circles-spaced": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 20 20"><defs><pattern id="p" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="2" stroke="none" fill="{color}"/></pattern></defs><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><rect x="0" y="0" width="100" height="100" fill="url(#p)"/></svg>',
    circles: '<svg xmlns="http://www.w3.org/2000/svg" width="calc(7 * {scale})" height="calc(7 * {scale})" viewBox="0 0 20 20"><defs><pattern id="p" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="6" stroke="none" fill="{color}"/></pattern></defs><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><rect x="0" y="0" width="100" height="100" fill="url(#p)"/></svg>',
    "diagonal-lines-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
    "diagonal-lines-down": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(90 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
    "diagonal-stripes-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
    "diagonal-stripes-down": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g transform="rotate(90 20 20)" fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
    "grid-lines": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(14 * {scale})" height="calc(14 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(45 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g><g fill="{color}" transform="rotate(-45 3 3)"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
    "rotated-grid-lines": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(90 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g><g fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
    "rotated-grid-stripes": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g transform="rotate(90 20 20)" fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g><g fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
    "x-fill": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="45.3" height="45.3" fill="{secondaryColor}"/><g fill="{color}"><path d="M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41-1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20l2.83 2.83-1.41 1.41L20 21.41l-2.83 2.83-1.41-1.41L18.59 20l-2.83-2.83 1.41-1.41L20 18.59z"/></g></svg>',
    dots: '<svg xmlns="http://www.w3.org/2000/svg" width="calc(13 * {scale})" height="calc(13 * {scale})" viewBox="0 0 20 20"><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><g fill="{color}"><circle cx="3" cy="3" r="3"/><circle cx="13" cy="13" r="3"/></g></svg>'
  },
  Media = function () {
    function e() {}
    return e.getHighContrastMode = function () {
      return matchMedia("(-ms-high-contrast: white-on-black)").matches ? "dark" : matchMedia("(-ms-high-contrast: black-on-white)").matches ? "light" : matchMedia("(-ms-high-contrast: active)").matches ? "dark" : matchMedia("(inverted-colors: inverted)").matches ? "invert" : null;
    }, e;
  }(),
  UNDEF_VALUE = void 0,
  NULL_VALUE = null,
  EMPTY = "",
  BOOLEAN = "boolean",
  FUNCTION = "function",
  NUMBER = "number",
  OBJECT = "object",
  PROTOTYPE = "prototype",
  __PROTO__ = "__proto__",
  STRING = "string",
  UNDEFINED = "undefined",
  CONSTRUCTOR = "constructor",
  SYMBOL = "Symbol",
  POLYFILL_TAG = "_polyfill",
  INDEX_OF = "indexOf",
  LENGTH = "length",
  DONE = "done",
  VALUE = "value",
  NAME = "name",
  SLICE = "slice",
  CALL = "call",
  ObjClass$1 = Object,
  ObjProto$1 = ObjClass$1[PROTOTYPE],
  StrCls = String,
  StrProto = StrCls[PROTOTYPE],
  MathCls = Math,
  ArrCls = Array,
  ArrProto = ArrCls[PROTOTYPE];
function safeGet(e, t) {
  try {
    t = e();
  } catch (e) {}
  return t;
}
var PRIMITIVE_TYPES = [STRING, NUMBER, BOOLEAN, UNDEFINED, "symbol", "bigint"];
function _createIs(t) {
  return function (e) {
    return typeof e === t;
  };
}
function _createObjIs(e) {
  var t = "[object " + e + "]";
  return function (e) {
    return !(!e || objToString(e) !== t);
  };
}
function objToString(e) {
  return ObjProto$1.toString[CALL](e);
}
function isUndefined(e) {
  return typeof e === UNDEFINED || e === UNDEFINED;
}
function isNullOrUndefined(e) {
  return e === NULL_VALUE || isUndefined(e);
}
function isStrictNullOrUndefined(e) {
  return e === NULL_VALUE || !isDefined(e);
}
function isDefined(e) {
  return !!e || e !== UNDEF_VALUE;
}
function isPrimitiveType(e) {
  return e !== OBJECT && -1 !== PRIMITIVE_TYPES.indexOf(e);
}
var isString = _createIs(STRING),
  isFunction = _createIs(FUNCTION);
function isObject(e) {
  return !(!e && isNullOrUndefined(e) || !e || typeof e !== OBJECT);
}
var isArray = ArrCls.isArray,
  isDate = _createObjIs("Date"),
  isNumber = _createIs(NUMBER),
  isBoolean = _createIs(BOOLEAN),
  isError = _createObjIs("Error");
function isPromiseLike(e) {
  return !!(e && e.then && isFunction(e.then));
}
function isTruthy(e) {
  return !(!e || safeGet(function () {
    return !(e && 0 + e);
  }, !e));
}
var objGetOwnPropertyDescriptor = ObjClass$1.getOwnPropertyDescriptor;
function objHasOwnProperty(e, t) {
  return e && ObjProto$1.hasOwnProperty[CALL](e, t);
}
var objHasOwn = ObjClass$1.hasOwn || polyObjHasOwn;
function polyObjHasOwn(e, t) {
  return objHasOwnProperty(e, t) || !!objGetOwnPropertyDescriptor(e, t);
}
function objForEachKey(e, t, r) {
  if (e && isObject(e)) for (var n in e) if (objHasOwn(e, n) && -1 === t[CALL](e, n, e[n])) break;
}
function _createKeyValueMap(e, r, n, t) {
  var i = {};
  return objForEachKey(e, function (e, t) {
    i[e] = r ? t : e, i[t] = e;
  }), t(i);
}
function throwError(e) {
  throw new Error(e);
}
function throwTypeError(e) {
  throw new TypeError(e);
}
var _objFreeze = ObjClass$1.freeze;
function _doNothing(e) {
  return e;
}
function _getProto(e) {
  return e[__PROTO__] || NULL_VALUE;
}
var objAssign = ObjClass$1.assign;
function objKeys(e) {
  return isObject(e) && e !== NULL_VALUE || throwTypeError("objKeys called on non-object"), ObjClass$1.keys(e);
}
function objDeepFreeze(e) {
  return _objFreeze && objForEachKey(e, function (e, t) {
    (isArray(t) || isObject(t)) && _objFreeze(t);
  }), objFreeze(e);
}
var objFreeze = _objFreeze || _doNothing,
  objGetPrototypeOf = ObjClass$1.getPrototypeOf || _getProto;
function createEnum(e) {
  return _createKeyValueMap(e, 1, 0, objDeepFreeze);
}
function createEnumKeyMap(e) {
  return _createKeyValueMap(e, 0, 0, objDeepFreeze);
}
function createSimpleMap(e) {
  var r = {};
  return objForEachKey(e, function (e, t) {
    r[e] = t[1], r[t[0]] = t[1];
  }), objDeepFreeze(r);
}
function createTypeMap(e) {
  return createSimpleMap(e);
}
var _globalCfg,
  _slice,
  _wellKnownSymbolMap = createEnumKeyMap({
    asyncIterator: 0,
    hasInstance: 1,
    isConcatSpreadable: 2,
    iterator: 3,
    match: 4,
    matchAll: 5,
    replace: 6,
    search: 7,
    species: 8,
    split: 9,
    toPrimitive: 10,
    toStringTag: 11,
    unscopables: 12
  }),
  asString = StrCls,
  GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
function _getGlobalValue() {
  var e;
  return e = (e = (e = (e = typeof globalThis !== UNDEFINED ? globalThis : e) || typeof self === UNDEFINED ? e : self) || typeof window === UNDEFINED ? e : window) || typeof global === UNDEFINED ? e : global;
}
function _getGlobalConfig() {
  var e;
  return _globalCfg || (e = _getGlobalValue() || {}, _globalCfg = e[GLOBAL_CONFIG_KEY] = e[GLOBAL_CONFIG_KEY] || {}), _globalCfg;
}
function dumpObj(e, t) {
  var r = EMPTY;
  if (isError(e)) r = "{ stack: '" + e.stack + "', message: '" + e.message + "', name: '" + e.name + "'";else try {
    r = JSON.stringify(e, NULL_VALUE, t ? isNumber(t) ? t : 4 : UNDEF_VALUE);
  } catch (e) {
    r = " - " + dumpObj(e, t);
  }
  return objToString(e) + ": " + r;
}
function _throwMissingFunction(e, t) {
  throwTypeError("'" + asString(e) + "' not defined for " + dumpObj(t));
}
function _unwrapInstFunction(t) {
  return _slice = _slice || ArrProto[SLICE], function (e) {
    return e[t].apply(e, _slice[CALL](arguments, 1));
  };
}
function _unwrapFunction(r, e) {
  _slice = _slice || ArrProto[SLICE];
  var n = e && e[r];
  return function (e) {
    var t = e && e[r] || n;
    if (t) return t.apply(e, _slice[CALL](arguments, 1));
    _throwMissingFunction(r, e);
  };
}
function _unwrapFunctionWithPoly(n, e, i) {
  _slice = _slice || ArrProto[SLICE];
  var o = e && e[n];
  return function (e) {
    var t,
      r = e && e[n] || o;
    if (r || i) return t = arguments, (r || i).apply(e, r ? _slice[CALL](t, 1) : t);
    _throwMissingFunction(n, e);
  };
}
function _unwrapProp(t) {
  return function (e) {
    return e[t];
  };
}
var mathMax = MathCls.max,
  strSlice = _unwrapFunction(SLICE, StrProto),
  strSubstring = _unwrapFunction("substring", StrProto),
  strSubstr = _unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr);
function polyStrSubstr(e, t, r) {
  return isNullOrUndefined(e) && throwTypeError("'polyStrSubstr called with invalid " + dumpObj(e)), r < 0 ? EMPTY : ((t = t || 0) < 0 && (t = mathMax(t + e[LENGTH], 0)), isUndefined(r) ? strSlice(e, t) : strSlice(e, t, t + r));
}
function strLeft(e, t) {
  return strSubstring(e, 0, t);
}
var _polySymbols,
  _wellKnownSymbolCache,
  UNIQUE_REGISTRY_ID = "_urid";
function _globalSymbolRegistry() {
  var e;
  return _polySymbols || (e = _getGlobalConfig(), _polySymbols = e.gblSym = e.gblSym || {
    k: {},
    s: {}
  }), _polySymbols;
}
function polyNewSymbol(e) {
  var t = {
    description: asString(e),
    toString: function () {
      return SYMBOL + "(" + e + ")";
    }
  };
  return t[POLYFILL_TAG] = !0, t;
}
function polySymbolFor(e) {
  var t,
    r,
    n = _globalSymbolRegistry();
  return objHasOwn(n.k, e) || (t = polyNewSymbol(e), r = objKeys(n.s).length, t[UNIQUE_REGISTRY_ID] = function () {
    return r + "_" + t.toString();
  }, n.k[e] = t, n.s[t[UNIQUE_REGISTRY_ID]()] = asString(e)), n.k[e];
}
function polyGetKnownSymbol(e) {
  _wellKnownSymbolCache = _wellKnownSymbolCache || {};
  var t,
    e = _wellKnownSymbolMap[e];
  return t = e ? _wellKnownSymbolCache[e] = _wellKnownSymbolCache[e] || polyNewSymbol(SYMBOL + "." + e) : t;
}
var propMap = {
  e: "enumerable",
  c: "configurable",
  v: VALUE,
  w: "writable",
  g: "get",
  s: "set"
};
function _createProp(t) {
  var e,
    r = {};
  return r[propMap.c] = !0, r[propMap.e] = !0, t.l && (r.get = function () {
    return t.l.v;
  }, e = objGetOwnPropertyDescriptor(t.l, "v")) && e.set && (r.set = function (e) {
    t.l.v = e;
  }), objForEachKey(t, function (e, t) {
    r[propMap[e]] = isUndefined(t) ? r[propMap[e]] : t;
  }), r;
}
var _globalLazyTestHooks,
  objDefineProp = ObjClass$1.defineProperty;
function objDefine(e, t, r) {
  return objDefineProp(e, t, _createProp(r));
}
var _fetchLazyTestHooks = function () {
  _globalLazyTestHooks = _getGlobalConfig(), _fetchLazyTestHooks = NULL_VALUE;
};
function getLazy(t) {
  var r = {};
  return _fetchLazyTestHooks && _fetchLazyTestHooks(), r.b = _globalLazyTestHooks.lzy, objDefineProp(r, "v", {
    configurable: !0,
    get: function () {
      var e = t();
      return _globalLazyTestHooks.lzy || (objDefineProp(r, "v", {
        value: e
      }), r.b && delete r.b), _globalLazyTestHooks.lzy && r.b !== _globalLazyTestHooks.lzy && (r.b = _globalLazyTestHooks.lzy), e;
    }
  }), r;
}
function safeGetLazy(e, t) {
  return getLazy(function () {
    return safeGet(e, t);
  });
}
var _cachedGlobal,
  _cachedWindow,
  _cachedDocument,
  _cachedNavigator,
  _cachedHistory,
  _isWebWorker,
  _isNode,
  _symbol,
  _symbolFor,
  _iterSymbol,
  WINDOW = "window";
function lazySafeGetInst(e) {
  return safeGetLazy(function () {
    return getInst(e) || UNDEF_VALUE;
  }, UNDEF_VALUE);
}
function getGlobal(e) {
  return (_cachedGlobal = !_cachedGlobal || !1 === e || _globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedGlobal.b ? safeGetLazy(_getGlobalValue, NULL_VALUE) : _cachedGlobal).v;
}
function getInst(e, t) {
  t = _cachedGlobal && !1 !== t ? _cachedGlobal.v : getGlobal(t);
  return t && t[e] ? t[e] : e === WINDOW && _cachedWindow ? _cachedWindow.v : NULL_VALUE;
}
function hasDocument() {
  return !!getDocument();
}
function getDocument() {
  return (_cachedDocument = !_cachedDocument || _globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedDocument.b ? lazySafeGetInst("document") : _cachedDocument).v;
}
function hasWindow() {
  return !!getWindow();
}
function getWindow() {
  return (_cachedWindow = !_cachedWindow || _globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedWindow.b ? lazySafeGetInst(WINDOW) : _cachedWindow).v;
}
function hasNavigator() {
  return !!getNavigator();
}
function getNavigator() {
  return (_cachedNavigator = !_cachedNavigator || _globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedNavigator.b ? lazySafeGetInst("navigator") : _cachedNavigator).v;
}
function hasHistory() {
  return !!getHistory();
}
function getHistory() {
  return (_cachedHistory = !_cachedHistory || _globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedHistory.b ? lazySafeGetInst("history") : _cachedHistory).v;
}
function isNode() {
  return (_isNode = _isNode || safeGetLazy(function () {
    return !(!process || !(process.versions || {}).node);
  }, !1)).v;
}
function isWebWorker() {
  return (_isWebWorker = _isWebWorker || safeGetLazy(function () {
    return !!(self && self instanceof WorkerGlobalScope);
  }, !1)).v;
}
function _getSymbolValue(e) {
  return safeGetLazy(function () {
    return _symbol.v ? _symbol.v[e] : UNDEF_VALUE;
  }, UNDEF_VALUE);
}
function hasSymbol() {
  return !!getSymbol();
}
function getSymbol() {
  var e = !_symbol || _globalLazyTestHooks && _globalLazyTestHooks.lzy && !_symbol.b;
  return e && (_symbol = lazySafeGetInst(SYMBOL)), _symbolFor && !e || (_symbolFor = _getSymbolValue("for")), _symbol.v;
}
function getKnownSymbol(e, t) {
  var r = _wellKnownSymbolMap[e];
  return _symbol && (!_globalLazyTestHooks.lzy || _symbol.b) || getSymbol(), _symbol.v ? _symbol.v[r || e] : polyGetKnownSymbol(e);
}
function newSymbol(e, t) {
  return _symbol && (!_globalLazyTestHooks.lzy || _symbol.b) || getSymbol(), _symbol.v ? _symbol.v(e) : polyNewSymbol(e);
}
function symbolFor(e) {
  return _symbolFor && (!_globalLazyTestHooks.lzy || _symbol.b) || getSymbol(), (_symbolFor.v || polySymbolFor)(e);
}
function isIterator(e) {
  return !!e && isFunction(e.next);
}
function isIterable(e) {
  return !isStrictNullOrUndefined(e) && isFunction(e[getKnownSymbol(3)]);
}
function iterForOf(t, e, r) {
  if (t && (isIterator(t) || (t = t[(_iterSymbol = _iterSymbol || getLazy(function () {
    return getKnownSymbol(3);
  })).v] ? t[_iterSymbol.v]() : null), isIterator(t))) {
    var n = void 0,
      i = void 0;
    try {
      for (var o = 0; !(i = t.next())[DONE] && -1 !== e[CALL](r || t, i[VALUE], o, t);) o++;
    } catch (e) {
      n = {
        e: e
      }, t.throw && (i = null, t.throw(n));
    } finally {
      try {
        i && !i[DONE] && t.return && t.return(i);
      } finally {
        if (n) throw n.e;
      }
    }
  }
}
var fnApply = _unwrapInstFunction("apply");
function arrAppend(t, e) {
  return !isUndefined(e) && t && (isArray(e) ? fnApply(t.push, t, e) : isIterator(e) || isIterable(e) ? iterForOf(e, function (e) {
    t.push(e);
  }) : t.push(e)), t;
}
function arrForEach(e, t, r) {
  if (e) for (var n = e[LENGTH] >>> 0, i = 0; i < n && !(i in e && -1 === t[CALL](e, e[i], i, e)); i++);
}
var _isProtoArray,
  _unsupportedError,
  arrIndexOf = _unwrapFunction(INDEX_OF, ArrProto),
  arrMap = _unwrapFunction("map", ArrProto),
  arrSlice = _unwrapFunction(SLICE, ArrProto),
  arrReduce = _unwrapFunction("reduce", ArrProto),
  objCreate = ObjClass$1.create || polyObjCreate;
function polyObjCreate(e) {
  if (!e) return {};
  var t = typeof e;
  if (t !== OBJECT && t !== FUNCTION) throw new TypeError("Prototype must be an Object or function: " + dumpObj(e));
  function r() {}
  return r[PROTOTYPE] = e, new r();
}
function objSetPrototypeOf(e, t) {
  return (ObjClass$1.setPrototypeOf || function (r, e) {
    (_isProtoArray = _isProtoArray || getLazy(function () {
      var e = {};
      return e[__PROTO__] = [], e instanceof Array;
    })).v ? r[__PROTO__] = e : objForEachKey(e, function (e, t) {
      return r[e] = t;
    });
  })(e, t);
}
function _createCustomError(e, t, r) {
  function n() {
    this.constructor = t, _safeDefineName(this, e);
  }
  return _safeDefineName(t, e), (t = objSetPrototypeOf(t, r))[PROTOTYPE] = r === NULL_VALUE ? objCreate(r) : (n[PROTOTYPE] = r[PROTOTYPE], new n()), t;
}
function _safeSetName(e, t) {
  try {
    t && (e[NAME] = t);
  } catch (e) {}
}
function _safeDefineName(e, t) {
  try {
    objDefine(e, NAME, {
      v: t,
      c: !0,
      e: !1
    });
  } catch (e) {}
}
function createCustomError(r, n, e) {
  var i = Error,
    o = i[PROTOTYPE][NAME],
    a = Error.captureStackTrace;
  return _createCustomError(r, function () {
    try {
      _safeSetName(i, r);
      var e,
        t = fnApply(i, this, arrSlice(arguments)) || this;
      return t !== this && (e = objGetPrototypeOf(this)) !== objGetPrototypeOf(t) && objSetPrototypeOf(t, e), a && a(t, this[CONSTRUCTOR]), n && n(t, arguments), t;
    } finally {
      _safeSetName(i, o);
    }
  }, i);
}
function throwUnsupported(e) {
  throw new (_unsupportedError = _unsupportedError || createCustomError("UnsupportedError"))(e);
}
function utcNow() {
  return (Date.now || polyUtcNow)();
}
function polyUtcNow() {
  return new Date().getTime();
}
function _createTrimFn(t) {
  return function (e) {
    return isNullOrUndefined(e) && throwTypeError("strTrim called [" + dumpObj(e) + "]"), e = e && e.replace ? e.replace(t, EMPTY) : e;
  };
}
var _fnToString,
  _objCtrFnString,
  _gblWindow,
  polyStrTrim = _createTrimFn(/^\s+|(?=\s)\s+$/g),
  strTrim = _unwrapFunctionWithPoly("trim", StrProto, polyStrTrim);
function isPlainObject(e) {
  if (!e || typeof e !== OBJECT) return !1;
  var t = !1;
  if (e !== (_gblWindow = _gblWindow || !hasWindow() || getWindow())) {
    _objCtrFnString || (_fnToString = Function[PROTOTYPE].toString, _objCtrFnString = _fnToString[CALL](ObjClass$1));
    try {
      var r = objGetPrototypeOf(e);
      t = (t = !r) || (r = objHasOwnProperty(r, CONSTRUCTOR) ? r[CONSTRUCTOR] : r) && typeof r === FUNCTION && _fnToString[CALL](r) === _objCtrFnString;
    } catch (e) {}
  }
  return t;
}
var _defaultDeepCopyHandler = function (e) {
    return e.value && plainObjDeepCopyHandler(e), !0;
  },
  defaultDeepCopyHandlers = [arrayDeepCopyHandler, plainObjDeepCopyHandler, functionDeepCopyHandler, dateDeepCopyHandler];
function _getSetVisited(e, t, r, n) {
  var i;
  return arrForEach(e, function (e) {
    if (e.k === t) return i = e, -1;
  }), i || (i = {
    k: t,
    v: t
  }, e.push(i), n(i)), i.v;
}
function _deepCopy(r, e, n, t) {
  var i = n.handler,
    t = n.path ? t ? n.path.concat(t) : n.path : [],
    o = {
      handler: n.handler,
      src: n.src,
      path: t
    },
    a = typeof e,
    s = !1,
    l = !1,
    c = (e && a === OBJECT ? s = isPlainObject(e) : l = e === NULL_VALUE || isPrimitiveType(a), {
      type: a,
      isPrim: l,
      isPlain: s,
      value: e,
      result: e,
      path: t,
      origin: n.src,
      copy: function (e, t) {
        return _deepCopy(r, e, t ? o : n, t);
      },
      copyTo: function (e, t) {
        return _copyProps(r, e, t, o);
      }
    });
  return c.isPrim ? i && i[CALL](n, c) ? c.result : e : _getSetVisited(r, e, t, function (t) {
    objDefine(c, "result", {
      g: function () {
        return t.v;
      },
      s: function (e) {
        t.v = e;
      }
    });
    for (var e = 0, r = i; !(r || (e < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[e++] : _defaultDeepCopyHandler))[CALL](n, c);) r = NULL_VALUE;
  });
}
function _copyProps(e, t, r, n) {
  if (!isNullOrUndefined(r)) for (var i in r) t[i] = _deepCopy(e, r[i], n, i);
  return t;
}
function objCopyProps(e, t, r) {
  return _copyProps([], e, t, {
    handler: r,
    src: t,
    path: []
  });
}
function objDeepCopy(e, t) {
  return _deepCopy([], e, {
    handler: t,
    src: e
  });
}
function arrayDeepCopyHandler(e) {
  var t,
    r = e.value;
  return !!isArray(r) && ((t = e.result = []).length = r.length, e.copyTo(t, r), !0);
}
function dateDeepCopyHandler(e) {
  var t = e.value;
  return !!isDate(t) && (e.result = new Date(t.getTime()), !0);
}
function functionDeepCopyHandler(e) {
  return e.type === FUNCTION;
}
function plainObjDeepCopyHandler(e) {
  var t,
    r = e.value;
  return !(!r || !e.isPlain || (t = e.result = {}, e.copyTo(t, r), 0));
}
function _doExtend(t, e) {
  return arrForEach(e, function (e) {
    objCopyProps(t, e);
  }), t;
}
function deepExtend(e, t, r, n, i, o, a) {
  return _doExtend(objDeepCopy(e) || {}, arrSlice(arguments));
}
function objExtend$1(e, t, r, n, i, o, a) {
  return _doExtend(e || {}, arrSlice(arguments));
}
var _perf,
  getLength = _unwrapProp(LENGTH);
function getPerformance() {
  return (_perf = !_perf || !_perf.b && _globalLazyTestHooks && _globalLazyTestHooks.lzy ? lazySafeGetInst("performance") : _perf).v;
}
var strSplit = _unwrapFunction("split", StrProto);
function setValueByKey(t, e, r) {
  var n;
  t && e && (n = (e = strSplit(e, ".")).pop(), arrForEach(e, function (e) {
    isNullOrUndefined(t[e]) && (t[e] = {}), t = t[e];
  }), t[n] = r);
}
var strEndsWith = _unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith);
function polyStrEndsWith(e, t, r) {
  isString(e) || throwTypeError("'" + dumpObj(e) + "' is not a string");
  var t = isString(t) ? t : asString(t),
    n = t[LENGTH],
    i = e[LENGTH],
    r = !isUndefined(r) && r < i ? r : i;
  return strSubstring(e, r - n, r) === t;
}
var strIndexOf = _unwrapFunction(INDEX_OF, StrProto),
  REF = "ref",
  UNREF = "un" + REF,
  HAS_REF = "hasRef",
  ENABLED = "enabled";
function _createTimerHandler(e, t, r) {
  function n() {
    return s = !1, l && l[UNREF] && l[UNREF](), a;
  }
  function i() {
    return l = t(l), s || n(), a;
  }
  function o() {
    l && r(l), l = NULL_VALUE;
  }
  var a,
    s = !0,
    l = e ? t(NULL_VALUE) : NULL_VALUE,
    e = {
      cancel: o,
      refresh: i
    };
  return e[HAS_REF] = function () {
    return l && l[HAS_REF] ? l[HAS_REF]() : s;
  }, e[REF] = function () {
    return s = !0, l && l[REF] && l[REF](), a;
  }, e[UNREF] = n, e[ENABLED] = !1, objDefineProp(a = e, ENABLED, {
    get: function () {
      return !!l;
    },
    set: function (e) {
      !e && l && o(), e && !l && i();
    }
  }), {
    h: a,
    dn: function () {
      l = NULL_VALUE;
    }
  };
}
function _createTimeoutWith(t, e, r, n) {
  var i = isArray(r),
    o = i ? r.length : 0,
    a = (0 < o ? r[0] : i ? UNDEF_VALUE : r) || setTimeout,
    s = (1 < o ? r[1] : UNDEF_VALUE) || clearTimeout,
    l = n[0],
    c = (n[0] = function () {
      c.dn(), fnApply(l, t, arrSlice(arguments));
    }, _createTimerHandler(e, function (e) {
      if (e) {
        if (e.refresh) return e.refresh(), e;
        fnApply(s, t, [e]);
      }
      return fnApply(a, t, n);
    }, function (e) {
      fnApply(s, t, [e]);
    }));
  return c.h;
}
function scheduleTimeout(e, t) {
  return _createTimeoutWith(this, !0, UNDEF_VALUE, arrSlice(arguments));
}
function createTimeout(e, t) {
  return _createTimeoutWith(this, !1, UNDEF_VALUE, arrSlice(arguments));
}
var aggregationErrorType,
  createEnumStyle = createEnum,
  createValueMap = createTypeMap,
  _DYN_TO_LOWER_CASE$2 = "toLowerCase",
  _DYN_BLK_VAL = "blkVal",
  _DYN_LENGTH$5 = "length",
  _DYN_RD_ONLY = "rdOnly",
  _DYN_NOTIFY = "notify",
  _DYN_WARN_TO_CONSOLE = "warnToConsole",
  _DYN_THROW_INTERNAL = "throwInternal",
  _DYN_SET_DF = "setDf",
  _DYN_WATCH = "watch",
  _DYN_LOGGER = "logger",
  _DYN_APPLY = "apply",
  _DYN_PUSH$1 = "push",
  _DYN_SPLICE = "splice",
  _DYN_HDLR = "hdlr",
  _DYN_CANCEL = "cancel",
  _DYN_INITIALIZE = "initialize",
  _DYN_IDENTIFIER = "identifier",
  _DYN_IS_INITIALIZED = "isInitialized",
  _DYN_GET_PLUGIN = "getPlugin",
  _DYN_POLL_INTERNAL_LOGS = "pollInternalLogs",
  _DYN_NAME$3 = "name",
  _DYN_TIME = "time",
  _DYN_PROCESS_NEXT = "processNext",
  _DYN_GET_PROCESS_TEL_CONT0 = "getProcessTelContext",
  _DYN_GET_NOTIFY_MGR = "getNotifyMgr",
  _DYN_ADD_NOTIFICATION_LIS1 = "addNotificationListener",
  _DYN_REMOVE_NOTIFICATION_2 = "removeNotificationListener",
  _DYN_ENABLED = "enabled",
  _DYN_STOP_POLLING_INTERNA3 = "stopPollingInternalLogs",
  _DYN_UNLOAD = "unload",
  _DYN_ON_COMPLETE = "onComplete",
  _DYN_VERSION$1 = "version",
  _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole",
  _DYN_CREATE_NEW$1 = "createNew",
  _DYN_TEARDOWN = "teardown",
  _DYN_MESSAGE_ID = "messageId",
  _DYN_MESSAGE$2 = "message",
  _DYN_IS_ASYNC = "isAsync",
  _DYN_DIAG_LOG$2 = "diagLog",
  _DYN__DO_TEARDOWN = "_doTeardown",
  _DYN_UPDATE$1 = "update",
  _DYN_GET_NEXT = "getNext",
  _DYN_SET_NEXT_PLUGIN = "setNextPlugin",
  _DYN_USER_AGENT = "userAgent",
  _DYN_SPLIT$1 = "split",
  _DYN_NODE_TYPE = "nodeType",
  _DYN_REPLACE = "replace",
  _DYN_LOG_INTERNAL_MESSAGE = "logInternalMessage",
  _DYN_TYPE = "type",
  _DYN_HANDLER = "handler",
  _DYN_IS_CHILD_EVT = "isChildEvt",
  _DYN_GET_CTX = "getCtx",
  _DYN_SET_CTX = "setCtx",
  _DYN_COMPLETE = "complete",
  _DYN_TRACE_ID$2 = "traceId",
  _DYN_SPAN_ID$1 = "spanId",
  _DYN_TRACE_FLAGS$1 = "traceFlags";
function throwAggregationError(e, t) {
  aggregationErrorType = aggregationErrorType || createCustomError("AggregationError", function (e, t) {
    1 < t[_DYN_LENGTH$5] && (e.errors = t[1]);
  });
  var r = e ;
  throw arrForEach(t, function (e, t) {
    r += "\n".concat(t, " > ").concat(dumpObj(e));
  }), new aggregationErrorType(r, t || []);
}
var _a$a,
  strShimFunction = "function",
  strShimObject = "object",
  strShimUndefined = "undefined",
  strShimPrototype = "prototype",
  ObjClass = Object,
  ObjProto = ObjClass[strShimPrototype],
  strHasOwnProperty = ((getGlobal() || {}).Symbol, (getGlobal() || {}).Reflect, "hasOwnProperty"),
  __objAssignFnImpl = function (e) {
    for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) ObjProto[strHasOwnProperty].call(t, i) && (e[i] = t[i]);
    return e;
  },
  __assignFn = objAssign || __objAssignFnImpl,
  extendStaticsFn = function (e, t) {
    return (extendStaticsFn = ObjClass.setPrototypeOf || ({
      __proto__: []
    } instanceof Array ? function (e, t) {
      e.__proto__ = t;
    } : function (e, t) {
      for (var r in t) t[strHasOwnProperty](r) && (e[r] = t[r]);
    }))(e, t);
  };
function __extendsFn(e, t) {
  function r() {
    this.constructor = e;
  }
  typeof t !== strShimFunction && null !== t && throwTypeError("Class extends value " + String(t) + " is not a constructor or null"), extendStaticsFn(e, t), e[strShimPrototype] = null === t ? objCreate(t) : (r[strShimPrototype] = t[strShimPrototype], new r());
}
function __spreadArrayFn(e, t) {
  for (var r = 0, n = t.length, i = e.length; r < n; r++, i++) e[i] = t[r];
  return e;
}
var Constructor = "constructor",
  Prototype = "prototype",
  strFunction = "function",
  DynInstFuncTable = "_dynInstFuncs",
  DynProxyTag = "_isDynProxy",
  DynClassName = "_dynClass",
  DynClassNamePrefix = "_dynCls$",
  DynInstChkTag = "_dynInstChk",
  DynAllowInstChkTag = DynInstChkTag,
  DynProtoDefaultOptions = "_dfOpts",
  UnknownValue = "_unknown_",
  str__Proto = "__proto__",
  DynProtoBaseProto = "_dyn" + str__Proto,
  DynProtoGlobalSettings = "__dynProto$Gbl",
  DynProtoCurrent = "_dynInstProto",
  strUseBaseInst = "useBaseInst",
  strSetInstFuncs = "setInstFuncs",
  Obj = Object,
  _objGetPrototypeOf = Obj.getPrototypeOf,
  _objGetOwnProps = Obj.getOwnPropertyNames,
  _gbl = getGlobal(),
  _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
    o: ((_a$a = {})[strSetInstFuncs] = !0, _a$a[strUseBaseInst] = !0, _a$a),
    n: 1e3
  });
function _isObjectOrArrayPrototype(e) {
  return e && (e === Obj[Prototype] || e === Array[Prototype]);
}
function _isObjectArrayOrFunctionPrototype(e) {
  return _isObjectOrArrayPrototype(e) || e === Function[Prototype];
}
function _getObjProto$1(e) {
  if (e) {
    if (_objGetPrototypeOf) return _objGetPrototypeOf(e);
    var t = e[str__Proto] || e[Prototype] || (e[Constructor] ? e[Constructor][Prototype] : null),
      r = e[DynProtoBaseProto] || t;
    objHasOwnProperty(e, DynProtoBaseProto) || (delete e[DynProtoCurrent], r = e[DynProtoBaseProto] = e[DynProtoCurrent] || e[DynProtoBaseProto], e[DynProtoCurrent] = t);
  }
  return r;
}
function _forEachProp(e, t) {
  var r = [];
  if (_objGetOwnProps) r = _objGetOwnProps(e);else for (var n in e) "string" == typeof n && objHasOwnProperty(e, n) && r.push(n);
  if (r && 0 < r.length) for (var i = 0; i < r.length; i++) t(r[i]);
}
function _isDynamicCandidate(e, t, r) {
  return t !== Constructor && typeof e[t] === strFunction && (r || objHasOwnProperty(e, t)) && t !== str__Proto && t !== Prototype;
}
function _throwTypeError(e) {
  throwTypeError("DynamicProto: " + e);
}
function _getInstanceFuncs(t) {
  var r = objCreate(null);
  return _forEachProp(t, function (e) {
    !r[e] && _isDynamicCandidate(t, e, !1) && (r[e] = t[e]);
  }), r;
}
function _hasVisited(e, t) {
  for (var r = e.length - 1; 0 <= r; r--) if (e[r] === t) return !0;
  return !1;
}
function _getBaseFuncs(e, t, r, o) {
  function n(e, t, r) {
    var n,
      i = t[r];
    return i[DynProxyTag] && o && !1 !== (n = e[DynInstFuncTable] || {})[DynAllowInstChkTag] && (i = (n[t[DynClassName]] || {})[r] || i), function () {
      return i.apply(e, arguments);
    };
  }
  for (var i = objCreate(null), a = (_forEachProp(r, function (e) {
      i[e] = n(t, r, e);
    }), _getObjProto$1(e)), s = []; a && !_isObjectArrayOrFunctionPrototype(a) && !_hasVisited(s, a);) _forEachProp(a, function (e) {
    !i[e] && _isDynamicCandidate(a, e, !_objGetPrototypeOf) && (i[e] = n(t, a, e));
  }), s.push(a), a = _getObjProto$1(a);
  return i;
}
function _getInstFunc(e, t, r, n) {
  var i = null;
  if (e && objHasOwnProperty(r, DynClassName)) {
    var o = e[DynInstFuncTable] || objCreate(null);
    if ((i = (o[r[DynClassName]] || objCreate(null))[t]) || _throwTypeError("Missing [" + t + "] " + strFunction), !i[DynInstChkTag] && !1 !== o[DynAllowInstChkTag]) {
      for (var a = !objHasOwnProperty(e, t), s = _getObjProto$1(e), l = []; a && s && !_isObjectArrayOrFunctionPrototype(s) && !_hasVisited(l, s);) {
        var c = s[t];
        if (c) {
          a = c === n;
          break;
        }
        l.push(s), s = _getObjProto$1(s);
      }
      try {
        a && (e[t] = i), i[DynInstChkTag] = 1;
      } catch (e) {
        o[DynAllowInstChkTag] = !1;
      }
    }
  }
  return i;
}
function _getProtoFunc(e, t, r) {
  var n = t[e];
  return typeof (n = n === r ? _getObjProto$1(t)[e] : n) !== strFunction && _throwTypeError("[" + e + "] is not a " + strFunction), n;
}
function _populatePrototype(i, e, o, a, t) {
  var r, s;
  _isObjectOrArrayPrototype(i) || _isObjectOrArrayPrototype(r = o[DynInstFuncTable] = o[DynInstFuncTable] || objCreate(null)) || (s = r[e] = r[e] || objCreate(null), !1 !== r[DynAllowInstChkTag] && (r[DynAllowInstChkTag] = !!t), _isObjectOrArrayPrototype(s)) || _forEachProp(o, function (e) {
    function t() {
      return (_getInstFunc(this, n, r, t) || _getProtoFunc(n, r, t)).apply(this, arguments);
    }
    var r, n;
    _isDynamicCandidate(o, e, !1) && o[e] !== a[e] && (s[e] = o[e], delete o[e], objHasOwnProperty(i, e) && (!i[e] || i[e][DynProxyTag]) || (i[e] = (r = i, n = e, t[DynProxyTag] = 1, t)));
  });
}
function _checkPrototype(e, t) {
  if (_objGetPrototypeOf) {
    for (var r = [], n = _getObjProto$1(t); n && !_isObjectArrayOrFunctionPrototype(n) && !_hasVisited(r, n);) {
      if (n === e) return !0;
      r.push(n), n = _getObjProto$1(n);
    }
    return !1;
  }
  return !0;
}
function _getObjName(e, t) {
  return objHasOwnProperty(e, Prototype) ? e.name || t || UnknownValue : ((e || {})[Constructor] || {}).name || t || UnknownValue;
}
function dynamicProto(e, t, r, n) {
  objHasOwnProperty(e, Prototype) || _throwTypeError("theClass is an invalid class definition.");
  var i = e[Prototype],
    o = (_checkPrototype(i, t) || _throwTypeError("[" + _getObjName(e) + "] not in hierarchy of [" + _getObjName(t) + "]"), null),
    e = (objHasOwnProperty(i, DynClassName) ? o = i[DynClassName] : (o = DynClassNamePrefix + _getObjName(e, "_") + "$" + _gblInst.n, _gblInst.n++, i[DynClassName] = o), dynamicProto[DynProtoDefaultOptions]),
    a = !!e[strUseBaseInst],
    s = (a && n && void 0 !== n[strUseBaseInst] && (a = !!n[strUseBaseInst]), _getInstanceFuncs(t)),
    r = (r(t, _getBaseFuncs(i, t, s, a)), !!_objGetPrototypeOf && !!e[strSetInstFuncs]);
  _populatePrototype(i, o, t, s, !1 !== (r = r && n ? !!n[strSetInstFuncs] : r));
}
function doAwaitResponse(e, t) {
  return doAwait(e, function (e) {
    return t ? t({
      value: e,
      rejected: !1
    }) : e;
  }, function (e) {
    return t ? t({
      rejected: !0,
      reason: e
    }) : e;
  });
}
function doAwait(e, t, r, n) {
  var i = e;
  return isPromiseLike(e) ? (t || r) && (i = e.then(t, r)) : t && (i = t(e)), i;
}
dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
var _hasInitEvent,
  STRING_STATES = ["pending", "resolving", "resolved", "rejected"],
  DISPATCH_EVENT = "dispatchEvent";
function emitEvent(e, t, r, n) {
  var i = getDocument(),
    n = (_hasInitEvent = _hasInitEvent || safeGetLazy(function () {
      var e;
      return !!(e = i && i.createEvent ? i.createEvent("Event") : e) && e.initEvent;
    }, null)).v ? i.createEvent("Event") : n ? new Event(t) : {};
  r && r(n), _hasInitEvent.v && n.initEvent(t, !1, !0), n && e[DISPATCH_EVENT] ? e[DISPATCH_EVENT](n) : (r = e["on" + t]) ? r(n) : (e = getInst("console")) && (e.error || e.log)(t, dumpObj(n));
}
var _hasPromiseRejectionEvent,
  STR_PROMISE = "Promise",
  NODE_UNHANDLED_REJECTION = "unhandledRejection",
  UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase(),
  _unhandledRejectionTimeout = 10;
function dumpFnObj(e) {
  return isFunction(e) ? e.toString() : dumpObj(e);
}
function _createPromise(e, t, r) {
  function n(i, o) {
    return p = !0, f && f.cancel(), f = null, e(function (r, n) {
      d.push(function () {
        try {
          var e = 2 === u ? i : o,
            t = isUndefined(e) ? l : isFunction(e) ? e(l) : e;
          isPromiseLike(t) ? t.then(r, n) : (!e && 3 === u ? n : r)(t);
        } catch (e) {
          n(e);
        }
      }), h && a();
    }, c);
  }
  function i() {
    return STRING_STATES[u];
  }
  function a() {
    var e;
    0 < d.length && (e = d.slice(), d = [], p = !0, t(e), f && f.cancel(), f = null);
  }
  function o(t, r) {
    return function (e) {
      u === r && (2 === t && isPromiseLike(e) ? (u = 1, e.then(o(2, 1), o(3, 1))) : (u = t, h = !0, l = e, a(), p || 3 !== t || (f = f || scheduleTimeout(s, _unhandledRejectionTimeout))));
    };
  }
  function s() {
    p || (isNode() ? process.emit(NODE_UNHANDLED_REJECTION, l, _) : emitEvent(getWindow() || getGlobal(), UNHANDLED_REJECTION, function (e) {
      return objDefine(e, "promise", {
        g: function () {
          return _;
        }
      }), e.reason = l, e;
    }, !!_hasPromiseRejectionEvent.v));
  }
  var l,
    c = arrSlice(arguments, 3),
    u = 0,
    h = !1,
    d = [],
    p = !1,
    f = null,
    _ = (_hasPromiseRejectionEvent = _hasPromiseRejectionEvent || lazySafeGetInst(STR_PROMISE + "RejectionEvent"), {
      then: n,
      catch: function (e) {
        return n(void 0, e);
      },
      finally: function (t) {
        var e = t,
          r = t;
        return isFunction(t) && (e = function (e) {
          return t && t(), e;
        }, r = function (e) {
          throw t && t(), e;
        }), n(e, r);
      }
    }),
    m = (objDefineProp(_, "state", {
      get: i
    }), hasSymbol() && (_[getKnownSymbol(11)] = "IPromise"), _.toString = function () {
      return "IPromise " + i() + (h ? " - " + dumpFnObj(l) : "");
    }, isFunction(r) || throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(r)), o(3, 0));
  try {
    r.call(_, o(2, 0), m);
  } catch (e) {
    m(e);
  }
  return _;
}
function _createAllPromise(r) {
  return function (e) {
    var t = arrSlice(arguments, 1);
    return r(function (r, n) {
      try {
        var i = [],
          o = 1;
        arrForEach(e, function (e, t) {
          e && (o++, doAwait(e, function (e) {
            i[t] = e, 0 == --o && r(i);
          }, n));
        }), 0 === --o && r(i);
      } catch (e) {
        n(e);
      }
    }, t);
  };
}
var _isPromiseSupported,
  _promiseCreator,
  _processPendingItems = function (e) {
    arrForEach(e, function (e) {
      try {
        e();
      } catch (e) {}
    });
  };
function timeoutItemProcessor(e) {
  var t = isNumber(e) ? e : 0;
  return function (e) {
    scheduleTimeout(function () {
      _processPendingItems(e);
    }, t);
  };
}
function createAsyncPromise(e, t) {
  return _createPromise(createAsyncPromise, timeoutItemProcessor(t), e, t);
}
function createNativePromise(e, t) {
  var r = (_isPromiseSupported = _isPromiseSupported || lazySafeGetInst(STR_PROMISE)).v;
  if (!r) return createAsyncPromise(e);
  isFunction(e) || throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpObj(e));
  var n = 0;
  r = new r(function (t, r) {
    e(function (e) {
      n = 2, t(e);
    }, function (e) {
      n = 3, r(e);
    });
  });
  return objDefineProp(r, "state", {
    get: function () {
      return STRING_STATES[n];
    }
  }), r;
}
function createPromise(e, t) {
  return (_promiseCreator = _promiseCreator || getLazy(function () {
    return createNativePromise;
  })).v.call(this, e, t);
}
var createAllPromise = _createAllPromise(createPromise),
  UNDEFINED_VALUE$2 = void 0,
  STR_EMPTY = "",
  STR_CHANNELS = "channels",
  STR_CORE = "core",
  STR_CREATE_PERF_MGR = "createPerfMgr",
  STR_DISABLED = "disabled",
  STR_EXTENSION_CONFIG = "extensionConfig",
  STR_EXTENSIONS = "extensions",
  STR_PROCESS_TELEMETRY = "processTelemetry",
  STR_PRIORITY = "priority",
  STR_EVENTS_SENT = "eventsSent",
  STR_EVENTS_DISCARDED = "eventsDiscarded",
  STR_EVENTS_SEND_REQUEST = "eventsSendRequest",
  STR_PERF_EVENT = "perfEvent",
  STR_GET_PERF_MGR = "getPerfMgr",
  STR_DOMAIN = "domain",
  STR_PATH = "path",
  STR_NOT_DYNAMIC_ERROR = "Not dynamic - ",
  strGetPrototypeOf = "getPrototypeOf",
  rCamelCase = /-([a-z])/g,
  rNormalizeInvalid = /([^\w\d_$])/g,
  rLeadingNumeric = /^(\d+[\w\d_$])/,
  _getObjProto = Object[strGetPrototypeOf];
function isNotNullOrUndefined(e) {
  return !isNullOrUndefined(e);
}
function normalizeJsName(e) {
  return e = e && isString(e) ? (e = (e = e[_DYN_REPLACE](rCamelCase, function (e, t) {
    return t.toUpperCase();
  }))[_DYN_REPLACE](rNormalizeInvalid, "_"))[_DYN_REPLACE](rLeadingNumeric, function (e, t) {
    return "_" + t;
  }) : e;
}
function strContains(e, t) {
  return !(!e || !t) && -1 !== strIndexOf(e, t);
}
function toISOString(e) {
  return e && e.toISOString() || "";
}
function getExceptionName(e) {
  return isError(e) ? e[_DYN_NAME$3] : STR_EMPTY;
}
function setValue(e, t, r, n, i) {
  var o = r;
  return !e || (o = e[t]) === r || i && !i(o) || n && !n(r) || (e[t] = o = r), o;
}
function getSetValue(e, t, r) {
  var n;
  return e ? !(n = e[t]) && isNullOrUndefined(n) && (n = isUndefined(r) ? {} : r, e[t] = n) : n = isUndefined(r) ? {} : r, n;
}
function _createProxyFunction(e, t) {
  var r = null,
    n = null;
  return isFunction(e) ? r = e : n = e, function () {
    var e = arguments;
    if (n = r ? r() : n) return n[t][_DYN_APPLY](n, e);
  };
}
function proxyAssign(r, n, i) {
  if (r && n && isObject(r) && isObject(n)) for (var e in n) !function (t) {
    var e;
    isString(t) && (e = n[t], isFunction(e) ? i && !i(t, !0, n, r) || (r[t] = _createProxyFunction(n, t)) : i && !i(t, !1, n, r) || (objHasOwn(r, t) && delete r[t], objDefine(r, t, {
      g: function () {
        return n[t];
      },
      s: function (e) {
        n[t] = e;
      }
    })));
  }(e);
  return r;
}
function proxyFunctionAs(e, t, r, n, i) {
  e && t && r && ((e[t] = _createProxyFunction(r, n)));
}
function proxyFunctions(t, r, e, n) {
  return t && r && isObject(t) && isArray(e) && arrForEach(e, function (e) {
    isString(e) && proxyFunctionAs(t, e, r, e);
  }), t;
}
function createClassFromInterface(e) {
  return function () {
    var r = this;
    e && objForEachKey(e, function (e, t) {
      r[e] = t;
    });
  };
}
function optimizeObject(e) {
  return e = e && objAssign ? ObjClass(objAssign({}, e)) : e;
}
function objExtend(e, t, r, n, i, o) {
  var a = arguments,
    s = a[0] || {},
    l = a[_DYN_LENGTH$5],
    c = !1,
    u = 1;
  for (0 < l && isBoolean(s) && (c = s, s = a[u] || {}, u++), isObject(s) || (s = {}); u < l; u++) {
    var h,
      d,
      p,
      f,
      _ = a[u],
      m = isArray(_),
      g = isObject(_);
    for (h in _) (m && h in _ || g && objHasOwn(_, h)) && (d = _[h], p = void 0, c && d && ((p = isArray(d)) || isPlainObject(d)) && (f = s[h], p ? isArray(f) || (f = []) : isPlainObject(f) || (f = {}), d = objExtend(c, f, d)), void 0 !== d) && (s[h] = d);
  }
  return s;
}
function isFeatureEnabled(e, t) {
  var r = !1,
    t = t && t.featureOptIn && t.featureOptIn[e];
  return r = e && t ? 3 == (e = t.mode) || 1 == e : r;
}
var strDocumentMode = "documentMode",
  strLocation = "location",
  strConsole = "console",
  strJSON = "JSON",
  strCrypto = "crypto",
  strMsCrypto = "msCrypto",
  strReactNative = "ReactNative",
  strMsie = "msie",
  strTrident = "trident/",
  strXMLHttpRequest = "XMLHttpRequest",
  _isTrident = null,
  _navUserAgentCheck = null,
  _enableMocks = !1,
  _useXDomainRequest = null,
  _beaconsSupported = null;
function _hasProperty(e, t) {
  var r,
    n = !1;
  if (e) {
    try {
      (n = t in e) || (r = e[strShimPrototype]) && (n = t in r);
    } catch (e) {}
    if (!n) try {
      n = !isUndefined(new e()[t]);
    } catch (e) {}
  }
  return n;
}
function getLocation(e) {
  if (e && _enableMocks) {
    e = getInst("__mockLocation");
    if (e) return e;
  }
  return typeof location === strShimObject && location ? location : getInst(strLocation);
}
function getConsole() {
  return typeof console !== strShimUndefined ? console : getInst(strConsole);
}
function hasJSON() {
  return Boolean(typeof JSON === strShimObject && JSON || null !== getInst(strJSON));
}
function getJSON() {
  return hasJSON() ? JSON || getInst(strJSON) : null;
}
function getCrypto() {
  return getInst(strCrypto);
}
function getMsCrypto() {
  return getInst(strMsCrypto);
}
function isReactNative() {
  var e = getNavigator();
  return !(!e || !e.product) && e.product === strReactNative;
}
function isIE() {
  var e = getNavigator();
  return !e || e[_DYN_USER_AGENT] === _navUserAgentCheck && null !== _isTrident || (e = ((_navUserAgentCheck = e[_DYN_USER_AGENT]) || STR_EMPTY)[_DYN_TO_LOWER_CASE$2](), _isTrident = strContains(e, strMsie) || strContains(e, strTrident)), _isTrident;
}
function getIEVersion(e) {
  var t = ((e = (e = void 0 === e ? null : e) ? e : (t = getNavigator() || {}) ? (t.userAgent || STR_EMPTY)[_DYN_TO_LOWER_CASE$2]() : STR_EMPTY) || STR_EMPTY)[_DYN_TO_LOWER_CASE$2]();
  if (strContains(t, strMsie)) return e = getDocument() || {}, Math.max(parseInt(t[_DYN_SPLIT$1](strMsie)[1]), e[strDocumentMode] || 0);
  if (strContains(t, strTrident)) {
    e = parseInt(t[_DYN_SPLIT$1](strTrident)[1]);
    if (e) return e + 4;
  }
  return null;
}
function isBeaconsSupported(e) {
  return _beaconsSupported = null !== _beaconsSupported && !1 !== e ? _beaconsSupported : hasNavigator() && Boolean(getNavigator().sendBeacon);
}
function isFetchSupported(e) {
  var t = !1;
  try {
    var t = !!getInst("fetch"),
      r = getInst("Request");
    t && e && r && (t = _hasProperty(r, "keepalive"));
  } catch (e) {}
  return t;
}
function useXDomainRequest() {
  return _useXDomainRequest = null === _useXDomainRequest && (_useXDomainRequest = typeof XDomainRequest !== strShimUndefined) && isXhrSupported() ? _useXDomainRequest && !_hasProperty(getInst(strXMLHttpRequest), "withCredentials") : _useXDomainRequest;
}
function isXhrSupported() {
  var e = !1;
  try {
    e = !!getInst(strXMLHttpRequest);
  } catch (e) {}
  return e;
}
function dispatchEvent(e, t) {
  return !!(e && e.dispatchEvent && t) && (e.dispatchEvent(t), !0);
}
function createCustomDomEvent(e, t) {
  var r,
    n = null,
    t = {
      detail: t || null
    };
  return isFunction(CustomEvent) ? n = new CustomEvent(e, t) : (r = getDocument()) && r.createEvent && (n = r.createEvent("CustomEvent")).initCustomEvent(e, !0, !0, t), n;
}
function sendCustomEvent(e, t, r) {
  var n = getGlobal();
  if (n && n.CustomEvent) try {
    return dispatchEvent(n, createCustomDomEvent(e, {
      cfg: t || null,
      customDetails: r || null
    }));
  } catch (e) {}
  return !1;
}
var UInt32Mask = 4294967296,
  MaxUInt32 = 4294967295,
  SEED1 = 123456789,
  SEED2 = 987654321,
  _mwcSeeded = !1,
  _mwcW = SEED1,
  _mwcZ = SEED2;
function _mwcSeed(e) {
  e < 0 && (e >>>= 0), _mwcW = SEED1 + e & MaxUInt32, _mwcZ = SEED2 - e & MaxUInt32, _mwcSeeded = !0;
}
function _autoSeedMwc() {
  try {
    var e = 2147483647 & utcNow();
    _mwcSeed((Math.random() * UInt32Mask ^ e) + e);
  } catch (e) {}
}
function randomValue(e) {
  return 0 < e ? Math.floor(random32() / MaxUInt32 * (e + 1)) >>> 0 : 0;
}
function random32(e) {
  var t = 0,
    r = getCrypto() || getMsCrypto();
  return 0 === (t = r && r.getRandomValues ? r.getRandomValues(new Uint32Array(1))[0] & MaxUInt32 : t) && isIE() && (_mwcSeeded || _autoSeedMwc(), t = mwcRandom32() & MaxUInt32), 0 === t && (t = Math.floor(UInt32Mask * Math.random() | 0)), (t >>>= 0), t;
}
function mwcRandom32(e) {
  var t = ((_mwcZ = 36969 * (65535 & _mwcZ) + (_mwcZ >> 16) & MaxUInt32) << 16) + (65535 & (_mwcW = 18e3 * (65535 & _mwcW) + (_mwcW >> 16) & MaxUInt32)) >>> 0 & MaxUInt32 | 0;
  return (t >>>= 0), t;
}
function newId(e) {
  void 0 === e && (e = 22);
  for (var t = random32() >>> 0, r = 0, n = STR_EMPTY; n[_DYN_LENGTH$5] < e;) r++, n += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(63 & t), t >>>= 6, 5 === r && (t = (random32() << 2 & 4294967295 | 3 & t) >>> 0, r = 0);
  return n;
}
var version$2 = "3.0.7",
  instanceName = "." + newId(6),
  _dataUid = 0;
function _canAcceptData(e) {
  return 1 === e[_DYN_NODE_TYPE] || 9 === e[_DYN_NODE_TYPE] || !+e[_DYN_NODE_TYPE];
}
function _getCache(e, t) {
  var r = t[e.id];
  if (!r) {
    r = {};
    try {
      _canAcceptData(t) && objDefine(t, e.id, {
        e: !1,
        v: r
      });
    } catch (e) {}
  }
  return r;
}
function createUniqueNamespace(e, t) {
  return normalizeJsName(e + _dataUid++ + ((t = void 0 === t ? !1 : t) ? "." + version$2 : STR_EMPTY) + instanceName);
}
function createElmNodeData(e) {
  var o = {
    id: createUniqueNamespace("_aiData-" + (e || STR_EMPTY) + "." + version$2),
    accept: function (e) {
      return _canAcceptData(e);
    },
    get: function (e, t, r, n) {
      var i = e[o.id];
      return i ? i[normalizeJsName(t)] : (n && ((i = _getCache(o, e))[normalizeJsName(t)] = r), r);
    },
    kill: function (e, t) {
      if (e && e[t]) try {
        delete e[t];
      } catch (e) {}
    }
  };
  return o;
}
function _isConfigDefaults(e) {
  return e && isObject(e) && (e.isVal || e.fb || objHasOwn(e, "v") || objHasOwn(e, "mrg") || objHasOwn(e, "ref") || e.set);
}
function _getDefault(e, t, r) {
  var n,
    i = r.dfVal || isDefined;
  if (t && r.fb) {
    var o = r.fb;
    isArray(o) || (o = [o]);
    for (var a = 0; a < o[_DYN_LENGTH$5]; a++) {
      var s = o[a],
        l = t[s];
      if (i(l) ? n = l : e && (i(l = e.cfg[s]) && (n = l), e.set(e.cfg, asString(s), l)), i(n)) break;
    }
  }
  return n = !i(n) && i(r.v) ? r.v : n;
}
function _resolveDefaultValue(r, n, e) {
  var i,
    t = e;
  return (t = e && _isConfigDefaults(e) ? _getDefault(r, n, e) : t) && (_isConfigDefaults(t) && (t = _resolveDefaultValue(r, n, t)), isArray(t) ? (i = [])[_DYN_LENGTH$5] = t[_DYN_LENGTH$5] : isPlainObject(t) && (i = {}), i) && (objForEachKey(t, function (e, t) {
    t && _isConfigDefaults(t) && (t = _resolveDefaultValue(r, n, t)), i[e] = t;
  }), t = i), t;
}
function _applyDefaultValue(r, e, t, n) {
  var i,
    o,
    a,
    s,
    l,
    c,
    u = n,
    u = _isConfigDefaults(u) ? (i = u.isVal, o = u.set, l = u[_DYN_RD_ONLY], h = u[_DYN_BLK_VAL], a = u.mrg, !(s = u.ref) && isUndefined(s) && (s = !!a), _getDefault(r, e, u)) : n,
    n = (h && r[_DYN_BLK_VAL](e, t), !0),
    h = e[t];
  !h && isNullOrUndefined(h) || (c = h, n = !1, i && c !== u && !i(c) && (c = u, n = !0), o && (n = (c = o(c, u, e)) === u)), n ? c = u && _resolveDefaultValue(r, e, u) : (isPlainObject(c) || isArray(u)) && a && u && (isPlainObject(u) || isArray(u)) && objForEachKey(u, function (e, t) {
    _applyDefaultValue(r, c, e, t);
  }), r.set(e, t, c), s && r.ref(e, t), l && r[_DYN_RD_ONLY](e, t);
}
var CFG_HANDLER_LINK = symbolFor("[[ai_dynCfg_1]]"),
  BLOCK_DYNAMIC = symbolFor("[[ai_blkDynCfg_1]]"),
  FORCE_DYNAMIC = symbolFor("[[ai_frcDynCfg_1]]");
function _cfgDeepCopy(e) {
  var r;
  if (e && (isArray(e) ? (r = [])[_DYN_LENGTH$5] = e[_DYN_LENGTH$5] : isPlainObject(e) && (r = {}), r)) return objForEachKey(e, function (e, t) {
    r[e] = _cfgDeepCopy(t);
  }), r;
  return e;
}
function getDynamicConfigHandler(e) {
  if (e) {
    var t = e[CFG_HANDLER_LINK] || e;
    if (t.cfg && (t.cfg === e || t.cfg[CFG_HANDLER_LINK] === t)) return t;
  }
  return null;
}
function blockDynamicConversion(e) {
  if (e && (isPlainObject(e) || isArray(e))) try {
    e[BLOCK_DYNAMIC] = !0;
  } catch (e) {}
  return e;
}
function _canMakeDynamic(e, t, r) {
  var n = !1;
  return n = !r || e[t.blkVal] || (n = r[FORCE_DYNAMIC]) || r[BLOCK_DYNAMIC] ? n : isPlainObject(r) || isArray(r);
}
function throwInvalidAccess(e) {
  throwTypeError("InvalidAccess:" + e);
}
var arrayMethodsToPatch = ["push", "pop", "shift", "unshift", "splice"],
  _throwDynamicError = function (e, t, r, n) {
    e && e[_DYN_THROW_INTERNAL](3, 108, "".concat(r, " [").concat(t, "] failed - ") + dumpObj(n));
  };
function _patchArray(i, o, a) {
  isArray(o) && arrForEach(arrayMethodsToPatch, function (e) {
    var n = o[e];
    o[e] = function () {
      for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
      var r = n[_DYN_APPLY](this, e);
      return _makeDynamicObject(i, o, a, "Patching"), r;
    };
  });
}
function _getOwnPropGetter(e, t) {
  e = objGetOwnPropertyDescriptor(e, t);
  return e && e.get;
}
function _createDynamicProperty(n, i, o, a) {
  var s = {
      n: o,
      h: [],
      trk: function (e) {
        e && e.fn && (-1 === arrIndexOf(s.h, e) && s.h[_DYN_PUSH$1](e), n.trk(e, s));
      },
      clr: function (e) {
        e = arrIndexOf(s.h, e);
        -1 !== e && s.h[_DYN_SPLICE](e, 1);
      }
    },
    l = !0,
    c = !1;
  function u() {
    l && (c = c || _canMakeDynamic(u, n, a), a && !a[CFG_HANDLER_LINK] && c && (a = _makeDynamicObject(n, a, o, "Converting")), l = !1);
    var e = n.act;
    return e && s.trk(e), a;
  }
  u[n.prop] = {
    chng: function () {
      n.add(s);
    }
  }, objDefine(i, s.n, {
    g: u,
    s: function (t) {
      if (a !== t) {
        u[n.ro] && !n.upd && throwInvalidAccess("[" + o + "] is read-only:" + dumpObj(i)), l && (c = c || _canMakeDynamic(u, n, a), l = !1);
        var e,
          r = c && u[n.rf];
        if (c) if (r) {
          objForEachKey(a, function (e) {
            a[e] = t ? t[e] : UNDEFINED_VALUE$2;
          });
          try {
            objForEachKey(t, function (e, t) {
              _setDynamicProperty(n, a, e, t);
            }), t = a;
          } catch (e) {
            _throwDynamicError((n.hdlr || {})[_DYN_LOGGER], o, "Assigning", e), c = !1;
          }
        } else a && a[CFG_HANDLER_LINK] && objForEachKey(a, function (e) {
          var e = _getOwnPropGetter(a, e);
          e && (e = e[n.prop]) && e.chng();
        });
        t !== a && (e = t && _canMakeDynamic(u, n, t), !r && e && (t = _makeDynamicObject(n, t, o, "Converting")), a = t, c = e), n.add(s);
      }
    }
  });
}
function _setDynamicProperty(e, t, r, n) {
  var i;
  return t && ((i = _getOwnPropGetter(t, r)) && !!i[e.prop] ? t[r] = n : _createDynamicProperty(e, t, r, n)), t;
}
function _setDynamicPropertyState(t, e, r, n) {
  if (e) {
    var i = _getOwnPropGetter(e, r),
      o = i && !!i[t.prop],
      a = n && n[0],
      s = n && n[1],
      n = n && n[2];
    if (!o) {
      if (n) try {
        blockDynamicConversion(e);
      } catch (e) {
        _throwDynamicError((t.hdlr || {})[_DYN_LOGGER], r, "Blocking", e);
      }
      try {
        _setDynamicProperty(t, e, r, e[r]), i = _getOwnPropGetter(e, r);
      } catch (e) {
        _throwDynamicError((t.hdlr || {})[_DYN_LOGGER], r, "State", e);
      }
    }
    a && (i[t.rf] = a), s && (i[t.ro] = s), n && (i[t.blkVal] = !0);
  }
  return e;
}
function _makeDynamicObject(r, n, t, i) {
  try {
    objForEachKey(n, function (e, t) {
      _setDynamicProperty(r, n, e, t);
    }), n[CFG_HANDLER_LINK] || (objDefineProp(n, CFG_HANDLER_LINK, {
      get: function () {
        return r[_DYN_HDLR];
      }
    }), _patchArray(r, n, t));
  } catch (e) {
    _throwDynamicError((r.hdlr || {})[_DYN_LOGGER], t, i, e);
  }
  return n;
}
var symPrefix = "[[ai_",
  symPostfix = "]]";
function _createState(i) {
  var o,
    e = newSymbol(symPrefix + "get" + i.uid + symPostfix),
    t = newSymbol(symPrefix + "ro" + i.uid + symPostfix),
    r = newSymbol(symPrefix + "rf" + i.uid + symPostfix),
    n = newSymbol(symPrefix + "blkVal" + i.uid + symPostfix),
    a = newSymbol(symPrefix + "dtl" + i.uid + symPostfix),
    s = null,
    l = null;
  function c(t, e) {
    var r = o.act;
    try {
      (o.act = t) && t[a] && (arrForEach(t[a], function (e) {
        e.clr(t);
      }), t[a] = []), e({
        cfg: i.cfg,
        set: i.set.bind(i),
        setDf: i[_DYN_SET_DF].bind(i),
        ref: i.ref.bind(i),
        rdOnly: i[_DYN_RD_ONLY].bind(i)
      });
    } catch (e) {
      var n = i[_DYN_LOGGER];
      throw n && n[_DYN_THROW_INTERNAL](1, 107, dumpObj(e)), e;
    } finally {
      o.act = r || null;
    }
  }
  function u() {
    if (s) {
      var e = s,
        r = (s = null, l && l[_DYN_CANCEL](), l = null, []);
      if (arrForEach(e, function (t) {
        if (t && (t[a] && (arrForEach(t[a], function (e) {
          e.clr(t);
        }), t[a] = null), t.fn)) try {
          c(t, t.fn);
        } catch (e) {
          r[_DYN_PUSH$1](e);
        }
      }), s) try {
        u();
      } catch (e) {
        r[_DYN_PUSH$1](e);
      }
      0 < r[_DYN_LENGTH$5] && throwAggregationError("Watcher error(s): ", r);
    }
  }
  return (e = {
    prop: e,
    ro: t,
    rf: r
  })[_DYN_BLK_VAL] = n, e[_DYN_HDLR] = i, e.add = function (e) {
    if (e && 0 < e.h[_DYN_LENGTH$5]) {
      s = s || [], l = l || scheduleTimeout(function () {
        l = null, u();
      }, 0);
      for (var t = 0; t < e.h[_DYN_LENGTH$5]; t++) {
        var r = e.h[t];
        r && -1 === arrIndexOf(s, r) && s[_DYN_PUSH$1](r);
      }
    }
  }, e[_DYN_NOTIFY] = u, e.use = c, e.trk = function (e, t) {
    e && (e = e[a] = e[a] || [], -1 === arrIndexOf(e, t)) && e[_DYN_PUSH$1](t);
  }, o = e;
}
function _createAndUseHandler(e, t) {
  var r = {
    fn: t,
    rm: function () {
      r.fn = null, t = e = null;
    }
  };
  return e.use(r, t), r;
}
function _createDynamicHandler(n, e, t) {
  var i,
    o,
    r = getDynamicConfigHandler(e);
  return r || (r = createUniqueNamespace("dyncfg", !0), (e = {
    uid: null,
    cfg: t = e && !1 !== t ? e : _cfgDeepCopy(e)
  })[_DYN_LOGGER] = n, e[_DYN_NOTIFY] = function () {
    i[_DYN_NOTIFY]();
  }, e.set = function (e, t, r) {
    try {
      e = _setDynamicProperty(i, e, t, r);
    } catch (e) {
      _throwDynamicError(n, t, "Setting value", e);
    }
    return e[t];
  }, e[_DYN_SET_DF] = function (r, e) {
    return e && objForEachKey(e, function (e, t) {
      _applyDefaultValue(o, r, e, t);
    }), r;
  }, e[_DYN_WATCH] = function (e) {
    return _createAndUseHandler(i, e);
  }, e.ref = function (e, t) {
    return _setDynamicPropertyState(i, e, t, ((e = {})[0] = !0, e))[t];
  }, e[_DYN_RD_ONLY] = function (e, t) {
    return _setDynamicPropertyState(i, e, t, ((e = {})[1] = !0, e))[t];
  }, e[_DYN_BLK_VAL] = function (e, t) {
    return _setDynamicPropertyState(i, e, t, ((e = {})[2] = !0, e))[t];
  }, e._block = function (r, n) {
    i.use(null, function (e) {
      var t = i.upd;
      try {
        isUndefined(n) || (i.upd = n), r(e);
      } finally {
        i.upd = t;
      }
    });
  }, objDefine(o = e, "uid", {
    c: !1,
    e: !1,
    w: !1,
    v: r
  }), _makeDynamicObject(i = _createState(o), t, "config", "Creating"), o);
}
function _logInvalidAccess(e, t) {
  e ? (e[_DYN_WARN_TO_CONSOLE](t), e[_DYN_THROW_INTERNAL](2, 108, t)) : throwInvalidAccess(t);
}
function createDynamicConfig(e, t, r, n) {
  r = _createDynamicHandler(r, e || {}, n);
  return t && r[_DYN_SET_DF](r.cfg, t), r;
}
function onConfigChange(e, t, r) {
  var n = e[CFG_HANDLER_LINK] || e;
  return (!n.cfg || n.cfg !== e && n.cfg[CFG_HANDLER_LINK] !== n ? (_logInvalidAccess(r, STR_NOT_DYNAMIC_ERROR + dumpObj(e)), createDynamicConfig(e, null, r)) : n)[_DYN_WATCH](t);
}
function runTargetUnload(e, t) {
  if (e && e[_DYN_UNLOAD]) return e[_DYN_UNLOAD](t);
}
function doUnloadAll(e, t, r) {
  var n;
  return r || (n = createPromise(function (e) {
    r = e;
  })), e && 0 < getLength(e) ? doAwaitResponse(runTargetUnload(e[0], t), function () {
    doUnloadAll(arrSlice(e, 1), t, r);
  }) : r(), n;
}
var ChannelControllerPriority = 500;
function _stringToBoolOrDefault(e, t, r) {
  return !e && isNullOrUndefined(e) ? t : isBoolean(e) ? e : "true" === asString(e)[_DYN_TO_LOWER_CASE$2]();
}
function cfgDfMerge(e) {
  return {
    mrg: !0,
    v: e
  };
}
function cfgDfSet(e, t) {
  return {
    set: e,
    v: t
  };
}
function cfgDfValidate(e, t, r) {
  return {
    fb: r,
    isVal: e,
    v: t
  };
}
function cfgDfBoolean(e, t) {
  return {
    fb: t,
    set: _stringToBoolOrDefault,
    v: !!e
  };
}
function cfgDfString(e) {
  return {
    isVal: isString,
    v: asString(STR_EMPTY)
  };
}
var _debugListener,
  _a$9,
  listenerFuncs = [STR_EVENTS_SENT, STR_EVENTS_DISCARDED, STR_EVENTS_SEND_REQUEST, STR_PERF_EVENT],
  _aiNamespace = null;
function _listenerProxyFunc(r, n) {
  return function () {
    var e = arguments,
      t = getDebugExt(n);
    t && (t = t.listener) && t[r] && t[r][_DYN_APPLY](t, e);
  };
}
function _getExtensionNamespace() {
  var e = getInst("Microsoft");
  return _aiNamespace = e ? e.ApplicationInsights : _aiNamespace;
}
function getDebugExt(e) {
  var t = _aiNamespace;
  return (t = t || !0 === e.disableDbgExt ? t : _aiNamespace || _getExtensionNamespace()) ? t.ChromeDbgExt : null;
}
function getDebugListener(e) {
  if (!_debugListener) {
    _debugListener = {};
    for (var t = 0; t < listenerFuncs[_DYN_LENGTH$5]; t++) _debugListener[listenerFuncs[t]] = _listenerProxyFunc(listenerFuncs[t], e);
  }
  return _debugListener;
}
var STR_WARN_TO_CONSOLE = "warnToConsole",
  AiNonUserActionablePrefix = "AI (Internal): ",
  AiUserActionablePrefix = "AI: ",
  AIInternalMessagePrefix = "AITR_",
  defaultValues$3 = {
    loggingLevelConsole: 0,
    loggingLevelTelemetry: 1,
    maxMessageLimit: 25,
    enableDebug: !1
  },
  _logFuncs = ((_a$9 = {})[0] = null, _a$9[1] = "errorToConsole", _a$9[2] = STR_WARN_TO_CONSOLE, _a$9[3] = "debugToConsole", _a$9);
function _sanitizeDiagnosticText(e) {
  return e ? '"' + e[_DYN_REPLACE](/\"/g, STR_EMPTY) + '"' : STR_EMPTY;
}
function _logToConsole(e, t) {
  var r,
    n = getConsole();
  n && (r = "log", n[e] && (r = e), isFunction(n[r])) && n[r](t);
}
var _InternalLogMessage = function () {
  function e(e, t, r, n) {
    void 0 === r && (r = !1);
    this[_DYN_MESSAGE_ID] = e, this[_DYN_MESSAGE$2] = (r ? AiUserActionablePrefix : AiNonUserActionablePrefix) + e;
    r = STR_EMPTY, hasJSON() && (r = getJSON().stringify(n)), e = (t ? " message:" + _sanitizeDiagnosticText(t) : STR_EMPTY) + (n ? " props:" + _sanitizeDiagnosticText(r) : STR_EMPTY);
    this[_DYN_MESSAGE$2] += e;
  }
  return e.dataType = "MessageData", e;
}();
function safeGetLogger(e, t) {
  return (e || {})[_DYN_LOGGER] || new DiagnosticLogger(t);
}
var _a$8,
  _b$2,
  DiagnosticLogger = function () {
    function e(n) {
      this.identifier = "DiagnosticLogger", this.queue = [];
      var l,
        i,
        c,
        u,
        t,
        h = 0,
        d = {};
      dynamicProto(e, this, function (o) {
        function a(e, t) {
          var r, n;
          c <= h || (n = !0, r = AIInternalMessagePrefix + t[_DYN_MESSAGE_ID], d[r] ? n = !1 : d[r] = !0, n && (e <= i && (o.queue[_DYN_PUSH$1](t), h++, s(1 === e ? "error" : "warn", t)), h === c) && (n = new _InternalLogMessage(23, r = "Internal events throttle limit per PageView reached for this app.", !1), o.queue[_DYN_PUSH$1](n), 1 === e ? o.errorToConsole(r) : o[_DYN_WARN_TO_CONSOLE](r)));
        }
        function s(e, t) {
          var r = getDebugExt(n || {});
          r && r[_DYN_DIAG_LOG$2] && r[_DYN_DIAG_LOG$2](e, t);
        }
        t = onConfigChange(createDynamicConfig(n || {}, defaultValues$3, o).cfg, function (e) {
          e = e.cfg;
          l = e[_DYN_LOGGING_LEVEL_CONSOL4], i = e.loggingLevelTelemetry, c = e.maxMessageLimit, u = e.enableDebug;
        }), o.consoleLoggingLevel = function () {
          return l;
        }, o[_DYN_THROW_INTERNAL] = function (e, t, r, n, i) {
          t = new _InternalLogMessage(t, r, i = void 0 === i ? !1 : i, n);
          if (u) throw dumpObj(t);
          r = _logFuncs[e] || STR_WARN_TO_CONSOLE;
          isUndefined(t[_DYN_MESSAGE$2]) ? s("throw" + (1 === e ? "Critical" : "Warning"), t) : (i ? (n = +t[_DYN_MESSAGE_ID], !d[n] && e <= l && (o[r](t[_DYN_MESSAGE$2]), d[n] = !0)) : e <= l && o[r](t[_DYN_MESSAGE$2]), a(e, t));
        }, o.debugToConsole = function (e) {
          _logToConsole("debug", e), s("warning", e);
        }, o[_DYN_WARN_TO_CONSOLE] = function (e) {
          _logToConsole("warn", e), s("warning", e);
        }, o.errorToConsole = function (e) {
          _logToConsole("error", e), s("error", e);
        }, o.resetInternalMessageCount = function () {
          h = 0, d = {};
        }, o[_DYN_LOG_INTERNAL_MESSAGE] = a, o[_DYN_UNLOAD] = function (e) {
          t && t.rm(), t = null;
        };
      });
    }
    return e.__ieDyn = 1, e;
  }();
function _getLogger(e) {
  return e || new DiagnosticLogger();
}
function _throwInternal(e, t, r, n, i, o) {
  void 0 === o && (o = !1), _getLogger(e)[_DYN_THROW_INTERNAL](t, r, n, i, o);
}
function _warnToConsole(e, t) {
  _getLogger(e)[_DYN_WARN_TO_CONSOLE](t);
}
function _logInternalMessage(e, t, r) {
  _getLogger(e)[_DYN_LOG_INTERNAL_MESSAGE](t, r);
}
var _doc,
  strToGMTString = "toGMTString",
  strToUTCString = "toUTCString",
  strCookie = "cookie",
  strExpires = "expires",
  strIsCookieUseDisabled = "isCookieUseDisabled",
  strDisableCookiesUsage = "disableCookiesUsage",
  strConfigCookieMgr = "_ckMgr",
  _supportsCookies = null,
  _allowUaSameSite = null,
  _parsedCookieValue = null,
  _cookieCache = {},
  _globalCookieConfig = {},
  rootDefaultConfig = ((_a$8 = {
    cookieCfg: cfgDfMerge(((_b$2 = {})[STR_DOMAIN] = {
      fb: "cookieDomain",
      dfVal: isNotNullOrUndefined
    }, _b$2.path = {
      fb: "cookiePath",
      dfVal: isNotNullOrUndefined
    }, _b$2.enabled = UNDEFINED_VALUE$2, _b$2.ignoreCookies = UNDEFINED_VALUE$2, _b$2.blockedCookies = UNDEFINED_VALUE$2, _b$2)),
    cookieDomain: UNDEFINED_VALUE$2,
    cookiePath: UNDEFINED_VALUE$2
  })[strDisableCookiesUsage] = UNDEFINED_VALUE$2, _a$8);
function _getDoc() {
  _doc = _doc || getLazy(function () {
    return getDocument();
  });
}
function _gblCookieMgr(e, t) {
  var r = createCookieMgr[strConfigCookieMgr] || _globalCookieConfig[strConfigCookieMgr];
  return r || (r = createCookieMgr[strConfigCookieMgr] = createCookieMgr(e, t), _globalCookieConfig[strConfigCookieMgr] = r), r;
}
function _isMgrEnabled(e) {
  return !e || e.isEnabled();
}
function _isIgnoredCookie(e, t) {
  return !!(t && e && isArray(e.ignoreCookies)) && -1 !== arrIndexOf(e.ignoreCookies, t);
}
function _isBlockedCookie(e, t) {
  return !!(t && e && isArray(e.blockedCookies) && -1 !== arrIndexOf(e.blockedCookies, t)) || _isIgnoredCookie(e, t);
}
function _isCfgEnabled(e, t) {
  var r,
    t = t[_DYN_ENABLED];
  return isNullOrUndefined(t) && (r = void 0, isUndefined(e[strIsCookieUseDisabled]) || (r = !e[strIsCookieUseDisabled]), t = r = isUndefined(e[strDisableCookiesUsage]) ? r : !e[strDisableCookiesUsage]), t;
}
function safeGetCookieMgr(e, t) {
  var n;
  return e ? n = e.getCookieMgr() : t , n = n || _gblCookieMgr(t, (e || {})[_DYN_LOGGER]);
}
function createCookieMgr(r, i) {
  r = createDynamicConfig(r || _globalCookieConfig, null, i).cfg, t = onConfigChange(r, function (e) {
    e[_DYN_SET_DF](e.cfg, rootDefaultConfig), c = e.ref(e.cfg, "cookieCfg"), u = c[STR_PATH] || "/", h = c[STR_DOMAIN], n = !1 !== _isCfgEnabled(r, c), o = c.getCookie || _getCookieValue, d = c.setCookie || _setCookieValue, a = c.delCookie || _setCookieValue;
  }, i), (e = {
    isEnabled: function () {
      var e = !1 !== _isCfgEnabled(r, c) && n && areCookiesSupported(i),
        t = _globalCookieConfig[strConfigCookieMgr];
      return e = e && t && p !== t ? _isMgrEnabled(t) : e;
    },
    setEnabled: function (e) {
      n = !1 !== e, c[_DYN_ENABLED] = e;
    },
    set: function (e, t, r, n, i) {
      var o,
        a,
        s,
        l = !1;
      return _isMgrEnabled(p) && !_isBlockedCookie(c, e) && (o = {}, a = strTrim(t || STR_EMPTY), -1 !== (s = strIndexOf(a, ";")) && (a = strTrim(strLeft(t, s)), o = _extractParts(strSubstring(t, s + 1))), setValue(o, STR_DOMAIN, n || h, isTruthy, isUndefined), isNullOrUndefined(r) || (t = isIE(), isUndefined(o[strExpires]) && 0 < (s = utcNow() + 1e3 * r) && ((n = new Date()).setTime(s), setValue(o, strExpires, _formatDate(n, t ? strToGMTString : strToUTCString) || _formatDate(n, t ? strToGMTString : strToUTCString) || STR_EMPTY, isTruthy)), t) || setValue(o, "max-age", STR_EMPTY + r, null, isUndefined), (s = getLocation()) && "https:" === s.protocol && (setValue(o, "secure", null, null, isUndefined), _allowUaSameSite = null === _allowUaSameSite ? !uaDisallowsSameSiteNone((getNavigator() || {})[_DYN_USER_AGENT]) : _allowUaSameSite) && setValue(o, "SameSite", "None", null, isUndefined), setValue(o, STR_PATH, i || u, null, isUndefined), d(e, _formatCookieValue(a, o)), l = !0), l;
    },
    get: function (e) {
      var t = STR_EMPTY;
      return t = _isMgrEnabled(p) && !_isIgnoredCookie(c, e) ? o(e) : t;
    },
    del: function (e, t) {
      var r = !1;
      return r = _isMgrEnabled(p) ? p.purge(e, t) : r;
    },
    purge: function (e, t) {
      var r,
        n = !1;
      return areCookiesSupported(i) && ((r = {})[STR_PATH] = t || "/", r[strExpires] = "Thu, 01 Jan 1970 00:00:01 GMT", t = r, isIE() || (t["max-age"] = "0"), a(e, _formatCookieValue(STR_EMPTY, t)), n = !0), n;
    }
  })[_DYN_UNLOAD] = function (e) {
    t && t.rm(), t = null;
  };
  var e,
    c,
    u,
    h,
    t,
    n,
    o,
    d,
    a,
    p = e;
  return p[strConfigCookieMgr] = p;
}
function areCookiesSupported(t) {
  if (null === _supportsCookies) {
    _supportsCookies = !1, _doc || _getDoc();
    try {
      var e = _doc.v || {};
      _supportsCookies = void 0 !== e[strCookie];
    } catch (e) {
      _throwInternal(t, 2, 68, "Cannot access document.cookie - " + getExceptionName(e), {
        exception: dumpObj(e)
      });
    }
  }
  return _supportsCookies;
}
function _extractParts(e) {
  var r = {};
  return e && e[_DYN_LENGTH$5] && arrForEach(strTrim(e)[_DYN_SPLIT$1](";"), function (e) {
    var t;
    (e = strTrim(e || STR_EMPTY)) && (-1 === (t = strIndexOf(e, "=")) ? r[e] = null : r[strTrim(strLeft(e, t))] = strTrim(strSubstring(e, t + 1)));
  }), r;
}
function _formatDate(e, t) {
  return isFunction(e[t]) ? e[t]() : null;
}
function _formatCookieValue(e, t) {
  var r = e || STR_EMPTY;
  return objForEachKey(t, function (e, t) {
    r += "; " + e + (isNullOrUndefined(t) ? STR_EMPTY : "=" + t);
  }), r;
}
function _getCookieValue(e) {
  var t,
    r = STR_EMPTY;
  return _doc || _getDoc(), _doc.v && (t = _doc.v[strCookie] || STR_EMPTY, _parsedCookieValue !== t && (_cookieCache = _extractParts(t), _parsedCookieValue = t), r = strTrim(_cookieCache[e] || STR_EMPTY)), r;
}
function _setCookieValue(e, t) {
  _doc || _getDoc(), _doc.v && (_doc.v[strCookie] = e + "=" + t);
}
function uaDisallowsSameSiteNone(e) {
  return !(!isString(e) || !strContains(e, "CPU iPhone OS 12") && !strContains(e, "iPad; CPU OS 12") && !(strContains(e, "Macintosh; Intel Mac OS X 10_14") && strContains(e, "Version/") && strContains(e, "Safari")) && (!strContains(e, "Macintosh; Intel Mac OS X 10_14") || !strEndsWith(e, "AppleWebKit/605.1.15 (KHTML, like Gecko)")) && !strContains(e, "Chrome/5") && !strContains(e, "Chrome/6") && (!strContains(e, "UnrealEngine") || strContains(e, "Chrome")) && !strContains(e, "UCBrowser/12") && !strContains(e, "UCBrowser/11"));
}
var defaultValues$2 = {
  perfEvtsSendAll: !1
};
function _runListeners(e, t, r, n) {
  arrForEach(e, function (e) {
    if (e && e[t]) if (r) scheduleTimeout(function () {
      return n(e);
    }, 0);else try {
      n(e);
    } catch (e) {}
  });
}
var NotificationManager = function () {
    function t(e) {
      this.listeners = [];
      var r,
        i = [],
        o = createDynamicConfig(e, defaultValues$2)[_DYN_WATCH](function (e) {
          r = !!e.cfg.perfEvtsSendAll;
        });
      dynamicProto(t, this, function (e) {
        objDefine(e, "listeners", {
          g: function () {
            return i;
          }
        }), e[_DYN_ADD_NOTIFICATION_LIS1] = function (e) {
          i[_DYN_PUSH$1](e);
        }, e[_DYN_REMOVE_NOTIFICATION_2] = function (e) {
          for (var t = arrIndexOf(i, e); -1 < t;) i[_DYN_SPLICE](t, 1), t = arrIndexOf(i, e);
        }, e[STR_EVENTS_SENT] = function (t) {
          _runListeners(i, STR_EVENTS_SENT, !0, function (e) {
            e[STR_EVENTS_SENT](t);
          });
        }, e[STR_EVENTS_DISCARDED] = function (t, r) {
          _runListeners(i, STR_EVENTS_DISCARDED, !0, function (e) {
            e[STR_EVENTS_DISCARDED](t, r);
          });
        }, e[STR_EVENTS_SEND_REQUEST] = function (t, r) {
          _runListeners(i, STR_EVENTS_SEND_REQUEST, r, function (e) {
            e[STR_EVENTS_SEND_REQUEST](t, r);
          });
        }, e[STR_PERF_EVENT] = function (t) {
          !t || !r && t[_DYN_IS_CHILD_EVT]() || _runListeners(i, STR_PERF_EVENT, !1, function (e) {
            t[_DYN_IS_ASYNC] ? scheduleTimeout(function () {
              return e[STR_PERF_EVENT](t);
            }, 0) : e[STR_PERF_EVENT](t);
          });
        }, e[_DYN_UNLOAD] = function (t) {
          function r() {
            o && o.rm(), o = null, i = [];
          }
          var n;
          if (_runListeners(i, "unload", !1, function (e) {
            e = e[_DYN_UNLOAD](t);
            e && (n = n || [])[_DYN_PUSH$1](e);
          }), n) return createPromise(function (e) {
            return doAwaitResponse(createAllPromise(n), function () {
              r(), e();
            });
          });
          r();
        };
      });
    }
    return t.__ieDyn = 1, t;
  }(),
  strExecutionContextKey = "ctx",
  strParentContextKey = "ParentContextKey",
  strChildrenContextKey = "ChildrenContextKey",
  _defaultPerfManager = null,
  PerfEvent = function () {
    function o(e, t, r) {
      var n,
        i = this;
      i.start = utcNow(), i[_DYN_NAME$3] = e, i[_DYN_IS_ASYNC] = r, i[_DYN_IS_CHILD_EVT] = function () {
        return !1;
      }, isFunction(t) && objDefine(i, "payload", {
        g: function () {
          return !n && isFunction(t) && (n = t(), t = null), n;
        }
      }), i[_DYN_GET_CTX] = function (e) {
        return e ? (e === o[strParentContextKey] || e === o[strChildrenContextKey] ? i : i[strExecutionContextKey] || {})[e] : null;
      }, i[_DYN_SET_CTX] = function (e, t) {
        e && (e === o[strParentContextKey] ? (i[e] || (i[_DYN_IS_CHILD_EVT] = function () {
          return !0;
        }), i[e] = t) : e === o[strChildrenContextKey] ? i[e] = t : (i[strExecutionContextKey] = i[strExecutionContextKey] || {})[e] = t);
      }, i[_DYN_COMPLETE] = function () {
        var e = 0,
          t = i[_DYN_GET_CTX](o[strChildrenContextKey]);
        if (isArray(t)) for (var r = 0; r < t[_DYN_LENGTH$5]; r++) {
          var n = t[r];
          n && (e += n[_DYN_TIME]);
        }
        i[_DYN_TIME] = utcNow() - i.start, i.exTime = i[_DYN_TIME] - e, i[_DYN_COMPLETE] = function () {};
      };
    }
    return o.ParentContextKey = "parent", o.ChildrenContextKey = "childEvts", o;
  }(),
  PerfManager = function () {
    function e(t) {
      this.ctx = {}, dynamicProto(e, this, function (r) {
        r.create = function (e, t, r) {
          return new PerfEvent(e, t, r);
        }, r.fire = function (e) {
          e && (e[_DYN_COMPLETE](), t) && isFunction(t[STR_PERF_EVENT]) && t[STR_PERF_EVENT](e);
        }, r[_DYN_SET_CTX] = function (e, t) {
          e && ((r[strExecutionContextKey] = r[strExecutionContextKey] || {})[e] = t);
        }, r[_DYN_GET_CTX] = function (e) {
          return (r[strExecutionContextKey] || {})[e];
        };
      });
    }
    return e.__ieDyn = 1, e;
  }(),
  doPerfActiveKey = "CoreUtils.doPerf";
function doPerf(e, t, r, n, i) {
  if (e) if (e = e[STR_GET_PERF_MGR] ? e[STR_GET_PERF_MGR]() : e) {
    var o,
      a = void 0,
      s = e[_DYN_GET_CTX](doPerfActiveKey);
    try {
      if (a = e.create(t(), n, i)) return s && a[_DYN_SET_CTX] && (a[_DYN_SET_CTX](PerfEvent[strParentContextKey], s), s[_DYN_GET_CTX]) && s[_DYN_SET_CTX] && ((o = s[_DYN_GET_CTX](PerfEvent[strChildrenContextKey])) || (o = [], s[_DYN_SET_CTX](PerfEvent[strChildrenContextKey], o)), o[_DYN_PUSH$1](a)), e[_DYN_SET_CTX](doPerfActiveKey, a), r(a);
    } catch (e) {
      a && a[_DYN_SET_CTX] && a[_DYN_SET_CTX]("exception", e);
    } finally {
      a && e.fire(a), e[_DYN_SET_CTX](doPerfActiveKey, s);
    }
  }
  return r();
}
function getGblPerfMgr() {
  return _defaultPerfManager;
}
function generateW3CId() {
  for (var e, t = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"], r = STR_EMPTY, n = 0; n < 4; n++) r += t[15 & (e = random32())] + t[e >> 4 & 15] + t[e >> 8 & 15] + t[e >> 12 & 15] + t[e >> 16 & 15] + t[e >> 20 & 15] + t[e >> 24 & 15] + t[e >> 28 & 15];
  var i = t[8 + (3 & random32()) | 0];
  return strSubstr(r, 0, 8) + strSubstr(r, 9, 4) + "4" + strSubstr(r, 13, 3) + i + strSubstr(r, 16, 3) + strSubstr(r, 19, 12);
}
var DEFAULT_VERSION = "00",
  INVALID_VERSION = "ff",
  INVALID_TRACE_ID = "00000000000000000000000000000000",
  INVALID_SPAN_ID = "0000000000000000";
function _isValid(e, t, r) {
  return !(!e || e[_DYN_LENGTH$5] !== t || e === r || !e.match(/^[\da-f]*$/i));
}
function _formatValue(e, t, r) {
  return _isValid(e, t) ? e : r;
}
function _formatFlags(e) {
  for (var t = (e = isNaN(e) || e < 0 || 255 < e ? 1 : e).toString(16); t[_DYN_LENGTH$5] < 2;) t = "0" + t;
  return t;
}
function createTraceParent(e, t, r, n) {
  var i = {};
  return i[_DYN_VERSION$1] = _isValid(n, 2, INVALID_VERSION) ? n : DEFAULT_VERSION, i[_DYN_TRACE_ID$2] = isValidTraceId(e) ? e : generateW3CId(), i[_DYN_SPAN_ID$1] = isValidSpanId(t) ? t : strLeft(generateW3CId(), 16), i.traceFlags = 0 <= r && r <= 255 ? r : 1, i;
}
function isValidTraceId(e) {
  return _isValid(e, 32, INVALID_TRACE_ID);
}
function isValidSpanId(e) {
  return _isValid(e, 16, INVALID_SPAN_ID);
}
function formatTraceParent(e) {
  var t, r;
  return e ? (_isValid(t = _formatFlags(e[_DYN_TRACE_FLAGS$1]), 2) || (t = "01"), r = e[_DYN_VERSION$1] || DEFAULT_VERSION, "".concat((r = "00" !== r && "ff" !== r ? DEFAULT_VERSION : r).toLowerCase(), "-").concat(_formatValue(e.traceId, 32, INVALID_TRACE_ID).toLowerCase(), "-").concat(_formatValue(e.spanId, 16, INVALID_SPAN_ID).toLowerCase(), "-").concat(t.toLowerCase())) : "";
}
var pluginStateData = createElmNodeData("plugin");
function _getPluginState(e) {
  return pluginStateData.get(e, "state", {}, !0);
}
function initializePlugins(r, n) {
  for (var e = [], t = null, i = r[_DYN_GET_NEXT](); i;) {
    var o,
      a,
      s = i[_DYN_GET_PLUGIN]();
    s && (t && t[_DYN_SET_NEXT_PLUGIN] && s[STR_PROCESS_TELEMETRY] && t[_DYN_SET_NEXT_PLUGIN](s), a = !!(o = _getPluginState(s))[_DYN_IS_INITIALIZED], (a = s[_DYN_IS_INITIALIZED] ? s[_DYN_IS_INITIALIZED]() : a) || e[_DYN_PUSH$1](s), t = s, i = i[_DYN_GET_NEXT]());
  }
  arrForEach(e, function (e) {
    var t = r[STR_CORE]();
    e[_DYN_INITIALIZE](r.getCfg(), t, n, r[_DYN_GET_NEXT]()), o = _getPluginState(e), e[STR_CORE] || o[STR_CORE] || (o[STR_CORE] = t), o[_DYN_IS_INITIALIZED] = !0, delete o[_DYN_TEARDOWN];
  });
}
function sortPlugins(e) {
  return e.sort(function (e, t) {
    var r,
      n = 0;
    return t ? (r = t[STR_PROCESS_TELEMETRY], e[STR_PROCESS_TELEMETRY] ? n = r ? e[STR_PRIORITY] - t[STR_PRIORITY] : 1 : r && (n = -1)) : n = e ? 1 : -1, n;
  });
}
function createDistributedTraceContext(t) {
  var r = {};
  return {
    getName: function () {
      return r[_DYN_NAME$3];
    },
    setName: function (e) {
      r[_DYN_NAME$3] = e;
    },
    getTraceId: function () {
      return r[_DYN_TRACE_ID$2];
    },
    setTraceId: function (e) {
      isValidTraceId(e) && (r[_DYN_TRACE_ID$2] = e);
    },
    getSpanId: function () {
      return r[_DYN_SPAN_ID$1];
    },
    setSpanId: function (e) {
      isValidSpanId(e) && (r[_DYN_SPAN_ID$1] = e);
    },
    getTraceFlags: function () {
      return r[_DYN_TRACE_FLAGS$1];
    },
    setTraceFlags: function (e) {
      r[_DYN_TRACE_FLAGS$1] = e;
    }
  };
}
var _a$7,
  strTelemetryPluginChain = "TelemetryPluginChain",
  strHasRunFlags = "_hasRun",
  strGetTelCtx = "_getTelCtx",
  _chainId = 0;
function _getNextProxyStart(e, t, r) {
  for (; e;) {
    if (e[_DYN_GET_PLUGIN]() === r) return e;
    e = e[_DYN_GET_NEXT]();
  }
  return createTelemetryProxyChain([r], t.config || {}, t);
}
function _createInternalContext(e, o, r, t) {
  var n = null,
    i = [],
    a = (o = o || createDynamicConfig({}, null, r[_DYN_LOGGER]), null !== t && (n = t ? _getNextProxyStart(e, r, t) : e), {
      _next: function () {
        var e = n;
        {
          var t;
          n = e ? e[_DYN_GET_NEXT]() : null, e || (t = i) && 0 < t[_DYN_LENGTH$5] && (arrForEach(t, function (e) {
            try {
              e.func.call(e.self, e.args);
            } catch (e) {
              _throwInternal(r[_DYN_LOGGER], 2, 73, "Unexpected Exception during onComplete - " + dumpObj(e));
            }
          }), i = []);
        }
        return e;
      },
      ctx: {
        core: function () {
          return r;
        },
        diagLog: function () {
          return safeGetLogger(r, o.cfg);
        },
        getCfg: function () {
          return o.cfg;
        },
        getExtCfg: function (e, t) {
          var n = s(e, !0);
          t && objForEachKey(t, function (e, t) {
            var r;
            !isNullOrUndefined(n[e]) || !(r = o.cfg[e]) && isNullOrUndefined(r) || (n[e] = r), _applyDefaultValue(o, n, e, t);
          });
          return o[_DYN_SET_DF](n, t);
        },
        getConfig: function (e, t, r) {
          void 0 === r && (r = !1);
          var n,
            e = s(e, !1),
            i = o.cfg;
          !e || !e[t] && isNullOrUndefined(e[t]) ? !i[t] && isNullOrUndefined(i[t]) || (n = i[t]) : n = e[t];
          return n || !isNullOrUndefined(n) ? n : r;
        },
        hasNext: function () {
          return !!n;
        },
        getNext: function () {
          return n;
        },
        setNext: function (e) {
          n = e;
        },
        iterate: function (e) {
          for (; t = a._next();) {
            var t = t[_DYN_GET_PLUGIN]();
            t && e(t);
          }
        },
        onComplete: function (e, t) {
          for (var r = [], n = 2; n < arguments.length; n++) r[n - 2] = arguments[n];
          e && i[_DYN_PUSH$1]({
            func: e,
            self: isUndefined(t) ? a.ctx : t,
            args: r
          });
        }
      }
    });
  function s(e, t) {
    var r,
      n = null,
      i = o.cfg;
    return i && e && (r = i[STR_EXTENSION_CONFIG], i[STR_EXTENSION_CONFIG] = r = !r && t ? {} : r, r = o.ref(i, STR_EXTENSION_CONFIG)) && (n = r[e], r[e] = n = !n && t ? {} : n, n = o.ref(r, e)), n;
  }
  return a;
}
function createProcessTelemetryContext(e, t, r, n) {
  var i = createDynamicConfig(t),
    o = _createInternalContext(e, i, r, n),
    a = o.ctx;
  return a[_DYN_PROCESS_NEXT] = function (e) {
    var t = o._next();
    return t && t[STR_PROCESS_TELEMETRY](e, a), !t;
  }, a[_DYN_CREATE_NEW$1] = function (e, t) {
    return createProcessTelemetryContext((e = isArray(e = void 0 === e ? null : e) ? createTelemetryProxyChain(e, i.cfg, r, t) : e) || a[_DYN_GET_NEXT](), i.cfg, r, t);
  }, a;
}
function createProcessTelemetryUnloadContext(e, r, t) {
  var n = createDynamicConfig(r.config),
    i = _createInternalContext(e, n, r, t),
    o = i.ctx;
  return o[_DYN_PROCESS_NEXT] = function (e) {
    var t = i._next();
    return t && t[_DYN_UNLOAD](o, e), !t;
  }, o[_DYN_CREATE_NEW$1] = function (e, t) {
    return createProcessTelemetryUnloadContext((e = isArray(e = void 0 === e ? null : e) ? createTelemetryProxyChain(e, n.cfg, r, t) : e) || o[_DYN_GET_NEXT](), r, t);
  }, o;
}
function createProcessTelemetryUpdateContext(e, r, t) {
  var n = createDynamicConfig(r.config),
    i = _createInternalContext(e, n, r, t).ctx;
  return i[_DYN_PROCESS_NEXT] = function (t) {
    return i.iterate(function (e) {
      isFunction(e[_DYN_UPDATE$1]) && e[_DYN_UPDATE$1](i, t);
    });
  }, i[_DYN_CREATE_NEW$1] = function (e, t) {
    return createProcessTelemetryUpdateContext((e = isArray(e = void 0 === e ? null : e) ? createTelemetryProxyChain(e, n.cfg, r, t) : e) || i[_DYN_GET_NEXT](), r, t);
  }, i;
}
function createTelemetryProxyChain(e, t, r, n) {
  var i,
    o = null,
    a = !n;
  return isArray(e) && 0 < e[_DYN_LENGTH$5] && (i = null, arrForEach(e, function (e) {
    (a = a || n !== e ? a : !0) && e && isFunction(e[STR_PROCESS_TELEMETRY]) && (e = createTelemetryPluginProxy(e, t, r), o = o || e, i && i._setNext(e), i = e);
  })), n && !o ? createTelemetryProxyChain([n], t, r) : o;
}
function createTelemetryPluginProxy(l, t, n) {
  var c = null,
    i = isFunction(l[STR_PROCESS_TELEMETRY]),
    o = isFunction(l[_DYN_SET_NEXT_PLUGIN]),
    u = l ? l[_DYN_IDENTIFIER] + "-" + l[STR_PRIORITY] + "-" + _chainId++ : "Unknown-0-" + _chainId++,
    a = {
      getPlugin: function () {
        return l;
      },
      getNext: function () {
        return c;
      },
      processTelemetry: function (r, e) {
        s(e = e || function () {
          var e;
          l && isFunction(l[strGetTelCtx]) && (e = l[strGetTelCtx]());
          e = e || createProcessTelemetryContext(a, t, n);
          return e;
        }(), function (e) {
          var t;
          return !(!l || !i || (t = _getPluginState(l))[_DYN_TEARDOWN] || t[STR_DISABLED] || (o && l[_DYN_SET_NEXT_PLUGIN](c), l[STR_PROCESS_TELEMETRY](r, e), 0));
        }, "processTelemetry", function () {
          return {
            item: r
          };
        }, !r.sync) || e[_DYN_PROCESS_NEXT](r);
      },
      unload: function (n, i) {
        s(n, function () {
          var e,
            t,
            r = !1;
          return l && (e = _getPluginState(l), t = l[STR_CORE] || e[STR_CORE], !l || t && t !== n.core() || e[_DYN_TEARDOWN] || (e[STR_CORE] = null, e[_DYN_TEARDOWN] = !0, e[_DYN_IS_INITIALIZED] = !1, l[_DYN_TEARDOWN] && !0 === l[_DYN_TEARDOWN](n, i) && (r = !0))), r;
        }, "unload", function () {}, i[_DYN_IS_ASYNC]) || n[_DYN_PROCESS_NEXT](i);
      },
      update: function (n, i) {
        s(n, function () {
          var e,
            t,
            r = !1;
          return l && (e = _getPluginState(l), t = l[STR_CORE] || e[STR_CORE], !l || t && t !== n.core() || e[_DYN_TEARDOWN] || l[_DYN_UPDATE$1] && !0 === l[_DYN_UPDATE$1](n, i) && (r = !0)), r;
        }, "update", function () {}, !1) || n[_DYN_PROCESS_NEXT](i);
      },
      _id: u,
      _setNext: function (e) {
        c = e;
      }
    };
  function s(r, e, n, t, i) {
    var o = !1,
      a = l ? l[_DYN_IDENTIFIER] : strTelemetryPluginChain,
      s = (s = r[strHasRunFlags]) || (r[strHasRunFlags] = {});
    return r.setNext(c), l && doPerf(r[STR_CORE](), function () {
      return a + ":" + n;
    }, function () {
      s[u] = !0;
      try {
        var t = c ? c._id : STR_EMPTY;
        t && (s[t] = !1), o = e(r);
      } catch (e) {
        t = !c || s[c._id];
        t && (o = !0), c && t || _throwInternal(r[_DYN_DIAG_LOG$2](), 1, 73, "Plugin [" + a + "] failed during " + n + " - " + dumpObj(e) + ", run flags: " + dumpObj(s));
      }
    }, t, i), o;
  }
  return objFreeze(a);
}
function createUnloadHandlerContainer() {
  var n = [];
  return {
    add: function (e) {
      e && n[_DYN_PUSH$1](e);
    },
    run: function (t, r) {
      arrForEach(n, function (e) {
        try {
          e(t, r);
        } catch (e) {
          _throwInternal(t[_DYN_DIAG_LOG$2](), 2, 73, "Unexpected error calling unload handler - " + dumpObj(e));
        }
      }), n = [];
    }
  };
}
function createUnloadHookContainer() {
  var r = [];
  return {
    run: function (t) {
      var e = r;
      r = [], arrForEach(e, function (e) {
        try {
          (e.rm || e.remove).call(e);
        } catch (e) {
          _throwInternal(t, 2, 73, "Unloading:" + dumpObj(e));
        }
      });
    },
    add: function (e) {
      e && arrAppend(r, e);
    }
  };
}
var strGetPlugin = "getPlugin",
  defaultValues$1 = ((_a$7 = {})[STR_EXTENSION_CONFIG] = {
    isVal: isNotNullOrUndefined,
    v: {}
  }, _a$7),
  BaseTelemetryPlugin = function () {
    function e() {
      var i,
        o,
        c,
        u,
        h,
        a = this;
      function t(e) {
        var t,
          e = e = void 0 === e ? null : e;
        return e || (t = o || createProcessTelemetryContext(null, {}, a[STR_CORE]), e = c && c[strGetPlugin] ? t[_DYN_CREATE_NEW$1](null, c[strGetPlugin]) : t[_DYN_CREATE_NEW$1](null, c)), e;
      }
      function s(e, t, r) {
        createDynamicConfig(e, defaultValues$1, safeGetLogger(t)), !r && t && (r = t[_DYN_GET_PROCESS_TEL_CONT0]()[_DYN_GET_NEXT]());
        var n = c;
        c && c[strGetPlugin] && (n = c[strGetPlugin]()), a[STR_CORE] = t, o = createProcessTelemetryContext(r, e, t, n);
      }
      function d() {
        i = !1, a[STR_CORE] = null, c = o = null, h = createUnloadHookContainer(), u = createUnloadHandlerContainer();
      }
      d(), dynamicProto(e, a, function (l) {
        l[_DYN_INITIALIZE] = function (e, t, r, n) {
          s(e, t, n), i = !0;
        }, l[_DYN_TEARDOWN] = function (e, t) {
          var r,
            n,
            i,
            o,
            a = l[STR_CORE];
          if (a && (!e || a === e[STR_CORE]())) return n = !1, i = e || createProcessTelemetryUnloadContext(null, a, c && c[strGetPlugin] ? c[strGetPlugin]() : c), o = t || ((e = {
            reason: 0
          })[_DYN_IS_ASYNC] = !1, e), l[_DYN__DO_TEARDOWN] && !0 === l[_DYN__DO_TEARDOWN](i, o, s) ? r = !0 : s(), r;
          function s() {
            n || (n = !0, u.run(i, t), h.run(i[_DYN_DIAG_LOG$2]()), !0 === r && i[_DYN_PROCESS_NEXT](o), d());
          }
        }, l[_DYN_UPDATE$1] = function (e, t) {
          var r,
            n,
            i,
            o = l[STR_CORE];
          if (o && (!e || o === e[STR_CORE]())) return n = !1, i = e || createProcessTelemetryUpdateContext(null, o, c && c[strGetPlugin] ? c[strGetPlugin]() : c), l._doUpdate && !0 === l._doUpdate(i, t || {
            reason: 0
          }, a) ? r = !0 : a(), r;
          function a() {
            n || (n = !0, s(i.getCfg(), i.core(), i[_DYN_GET_NEXT]()));
          }
        }, proxyFunctionAs(l, "_addUnloadCb", function () {
          return u;
        }, "add"), proxyFunctionAs(l, "_addHook", function () {
          return h;
        }, "add"), objDefine(l, "_unloadHooks", {
          g: function () {
            return h;
          }
        });
      }), a[_DYN_DIAG_LOG$2] = function (e) {
        return t(e)[_DYN_DIAG_LOG$2]();
      }, a[_DYN_IS_INITIALIZED] = function () {
        return i;
      }, a.setInitialized = function (e) {
        i = e;
      }, a[_DYN_SET_NEXT_PLUGIN] = function (e) {
        c = e;
      }, a[_DYN_PROCESS_NEXT] = function (e, t) {
        t ? t[_DYN_PROCESS_NEXT](e) : c && isFunction(c[STR_PROCESS_TELEMETRY]) && c[STR_PROCESS_TELEMETRY](e, null);
      }, a._getTelCtx = t;
    }
    return e.__ieDyn = 1, e;
  }();
function _addInitializer(r, e, t) {
  var n = {
    id: e,
    fn: t
  };
  return arrAppend(r, n), {
    remove: function () {
      arrForEach(r, function (e, t) {
        if (e.id === n.id) return r[_DYN_SPLICE](t, 1), -1;
      });
    }
  };
}
function _runInitializers(e, t, r) {
  for (var n = !1, i = e[_DYN_LENGTH$5], o = 0; o < i; ++o) {
    var a = e[o];
    if (a) try {
      if (!1 === a.fn[_DYN_APPLY](null, [t])) {
        n = !0;
        break;
      }
    } catch (e) {
      _throwInternal(r, 2, 64, "Telemetry initializer failed: " + getExceptionName(e), {
        exception: dumpObj(e)
      }, !0);
    }
  }
  return !n;
}
var _a$6,
  TelemetryInitializerPlugin = function (r) {
    function o() {
      var t,
        n,
        e = r.call(this) || this;
      function i() {
        t = 0, n = [];
      }
      return e.identifier = "TelemetryInitializerPlugin", e.priority = 199, i(), dynamicProto(o, e, function (r, e) {
        r.addTelemetryInitializer = function (e) {
          return _addInitializer(n, t++, e);
        }, r[STR_PROCESS_TELEMETRY] = function (e, t) {
          _runInitializers(n, e, (t || r)[_DYN_DIAG_LOG$2]()) && r[_DYN_PROCESS_NEXT](e, t);
        }, r[_DYN__DO_TEARDOWN] = function () {
          i();
        };
      }), e;
    }
    return __extendsFn(o, r), o.__ieDyn = 1, o;
  }(BaseTelemetryPlugin),
  strValidationError = "Plugins must provide initialize method",
  strNotificationManager = "_notificationManager",
  strSdkUnloadingError = "SDK is still unloading...",
  strSdkNotInitialized = "SDK is not initialized",
  defaultConfig = objDeepFreeze(((_a$6 = {
    cookieCfg: {}
  })[STR_EXTENSIONS] = {
    rdOnly: !0,
    ref: !0,
    v: []
  }, _a$6[STR_CHANNELS] = {
    rdOnly: !0,
    ref: !0,
    v: []
  }, _a$6[STR_EXTENSION_CONFIG] = {
    ref: !0,
    v: {}
  }, _a$6[STR_CREATE_PERF_MGR] = UNDEFINED_VALUE$2, _a$6.loggingLevelConsole = 0, _a$6.diagnosticLogInterval = UNDEFINED_VALUE$2, _a$6));
function _createPerfManager(e, t) {
  return new PerfManager(t);
}
function _validateExtensions(n, i, e) {
  var o = [],
    a = [],
    s = {};
  return arrForEach(e, function (e) {
    (isNullOrUndefined(e) || isNullOrUndefined(e[_DYN_INITIALIZE])) && throwError(strValidationError);
    var t = e[STR_PRIORITY],
      r = e[_DYN_IDENTIFIER];
    e && t && (isNullOrUndefined(s[t]) ? s[t] = r : _warnToConsole(n, "Two extensions have same priority #" + t + " - " + s[t] + ", " + r)), (!t || t < i ? o : a)[_DYN_PUSH$1](e);
  }), (e = {})[STR_CORE] = o, e[STR_CHANNELS] = a, e;
}
function _isPluginPresent(t, e) {
  var r = !1;
  return arrForEach(e, function (e) {
    if (e === t) return r = !0, -1;
  }), r;
}
function _deepMergeConfig(r, n, e, i) {
  e && objForEachKey(e, function (e, t) {
    i && isPlainObject(t) && isPlainObject(n[e]) && _deepMergeConfig(r, n[e], t, i), i && isPlainObject(t) && isPlainObject(n[e]) ? _deepMergeConfig(r, n[e], t, i) : r.set(n, e, t);
  });
}
function _findWatcher(e, r) {
  var n = null,
    i = -1;
  return arrForEach(e, function (e, t) {
    if (e.w === r) return n = e, i = t, -1;
  }), {
    i: i,
    l: n
  };
}
function _addDelayedCfgListener(t, r) {
  var e = _findWatcher(t, r).l;
  return e || t[_DYN_PUSH$1](e = {
    w: r,
    rm: function () {
      var e = _findWatcher(t, r);
      -1 !== e.i && t[_DYN_SPLICE](e.i, 1);
    }
  }), e;
}
function _registerDelayedCfgListener(r, e, n) {
  arrForEach(e, function (e) {
    var t = onConfigChange(r, e.w, n);
    delete e.w, e.rm = function () {
      t.rm();
    };
  });
}
var AppInsightsCore = function () {
    function e() {
      var g, y, v, n, E, b, w, T, S, x, C, A, I, N, P, D, R, O, M, k, L, U, F, B, $, z, Y, H;
      dynamicProto(e, this, function (s) {
        function a(e) {
          return z && z[_DYN_ENABLED] || H || (e || v && 0 < v.queue[_DYN_LENGTH$5]) && (Y || (Y = !0, o(g[_DYN_WATCH](function (e) {
            var e = e.cfg.diagnosticLogInterval,
              t = (e && 0 < e || (e = 1e4), !1);
            z && (t = z[_DYN_ENABLED], z[_DYN_CANCEL]()), (z = createTimeout(f, e)).unref(), z[_DYN_ENABLED] = t;
          }))), z[_DYN_ENABLED] = !0), z;
        }
        function t() {
          function t(e) {
            e && arrForEach(e, function (e) {
              var t;
              e[_DYN_IDENTIFIER] && e[_DYN_VERSION$1] && !r[e.identifier] && (t = e[_DYN_IDENTIFIER] + "=" + e[_DYN_VERSION$1], B[_DYN_PUSH$1](t), r[e.identifier] = e);
            });
          }
          var r = {};
          B = [];
          t(A), C && arrForEach(C, function (e) {
            t(e);
          }), t(x);
        }
        function l() {
          y = !1, (g = createDynamicConfig({}, defaultConfig, s[_DYN_LOGGER])).cfg[_DYN_LOGGING_LEVEL_CONSOL4] = 1, objDefine(s, "config", {
            g: function () {
              return g.cfg;
            },
            s: function (e) {
              s.updateCfg(e, !1);
            }
          }), objDefine(s, "pluginVersionStringArr", {
            g: function () {
              return B || t(), B;
            }
          }), objDefine(s, "pluginVersionString", {
            g: function () {
              return $ || (B || t(), $ = B.join(";")), $ || STR_EMPTY;
            }
          }), objDefine(s, "logger", {
            g: function () {
              return v || (v = new DiagnosticLogger(g.cfg), g[_DYN_LOGGER] = v), v;
            },
            s: function (e) {
              g[_DYN_LOGGER] = e, v !== e && (runTargetUnload(v, !1), v = e);
            }
          }), s[_DYN_LOGGER] = new DiagnosticLogger(g.cfg), F = [];
          var e = s.config[STR_EXTENSIONS] || [];
          e.splice(0, e[_DYN_LENGTH$5]), arrAppend(e, F), N = new TelemetryInitializerPlugin(), runTargetUnload(E, !(n = [])), w = b = E = null, runTargetUnload(T, !1), I = !(x = []), D = createUniqueNamespace("AIBaseCore", !(P = A = C = S = T = null)), R = createUnloadHandlerContainer(), L = k = null, O = createUnloadHookContainer(), B = $ = null, H = !(U = []);
        }
        function c() {
          var e = createProcessTelemetryContext(d(), g.cfg, s);
          return e[_DYN_ON_COMPLETE](a), e;
        }
        function u(e) {
          var t = _validateExtensions(s[_DYN_LOGGER], ChannelControllerPriority, x),
            t = (B = $ = S = null, A = sortPlugins(arrAppend(A = (C || [])[0] || [], t[STR_CHANNELS])), arrAppend(sortPlugins(t[STR_CORE]), A)),
            r = (F = objFreeze(t), s.config[STR_EXTENSIONS] || []),
            r = (r.splice(0, r[_DYN_LENGTH$5]), arrAppend(r, F), c());
          A && 0 < A[_DYN_LENGTH$5] && initializePlugins(r[_DYN_CREATE_NEW$1](A), t), initializePlugins(r, t), e && i(e);
        }
        function h(t) {
          var e = null,
            i = null,
            r = [];
          return arrForEach(F, function (e) {
            if (e[_DYN_IDENTIFIER] === t && e !== N) return i = e, -1;
            e.getChannel && r[_DYN_PUSH$1](e);
          }), !i && 0 < r[_DYN_LENGTH$5] && arrForEach(r, function (e) {
            if (!(i = e.getChannel(t))) return -1;
          }), e = i ? {
            plugin: i,
            setEnabled: function (e) {
              _getPluginState(i)[STR_DISABLED] = !e;
            },
            isEnabled: function () {
              var e = _getPluginState(i);
              return !e[_DYN_TEARDOWN] && !e[STR_DISABLED];
            },
            remove: function (e, t) {
              var r,
                n = [i];
              (r = {
                reason: 1
              })[_DYN_IS_ASYNC] = e = void 0 === e ? !0 : e, p(n, r, function (e) {
                e && u({
                  reason: 32,
                  removed: n
                }), t && t(e);
              });
            }
          } : e;
        }
        function d() {
          var e;
          return S || (e = (F || []).slice(), -1 === arrIndexOf(e, N) && e[_DYN_PUSH$1](N), S = createTelemetryProxyChain(sortPlugins(e), g.cfg, s)), S;
        }
        function p(o, e, t) {
          var r;
          o && 0 < o[_DYN_LENGTH$5] ? ((r = createProcessTelemetryUnloadContext(createTelemetryProxyChain(o, g.cfg, s), s))[_DYN_ON_COMPLETE](function () {
            var n = !1,
              r = [],
              i = (arrForEach(x, function (e, t) {
                _isPluginPresent(e, o) ? n = !0 : r[_DYN_PUSH$1](e);
              }), x = r, B = $ = null, []);
            C && (arrForEach(C, function (e, t) {
              var r = [];
              arrForEach(e, function (e) {
                _isPluginPresent(e, o) ? n = !0 : r[_DYN_PUSH$1](e);
              }), i[_DYN_PUSH$1](r);
            }), C = i), t && t(n), a();
          }), r[_DYN_PROCESS_NEXT](e)) : t(!1);
        }
        function f() {
          var e;
          v && v.queue && (e = v.queue.slice(0), v.queue[_DYN_LENGTH$5] = 0, arrForEach(e, function (e) {
            (t = {})[_DYN_NAME$3] = P || "InternalMessageId: " + e[_DYN_MESSAGE_ID], t.iKey = L, t[_DYN_TIME] = toISOString(new Date()), t.baseType = _InternalLogMessage.dataType, t.baseData = {
              message: e[_DYN_MESSAGE$2]
            };
            var t,
              e = t;
            s.track(e);
          }));
        }
        function _(r, e, n, i) {
          var o = 1,
            t = !1,
            a = null;
          function s() {
            o--, t && 0 === o && (a && a[_DYN_CANCEL](), a = null, e && e(t), e = null);
          }
          return i = i || 5e3, A && 0 < A[_DYN_LENGTH$5] && c()[_DYN_CREATE_NEW$1](A).iterate(function (e) {
            var t;
            e.flush && (o++, t = !1, e.flush(r, function () {
              t = !0, s();
            }, n) || t || (r && null == a ? a = scheduleTimeout(function () {
              a = null, s();
            }, i) : s()));
          }), t = !0, s(), !0;
        }
        function i(e) {
          var t = createProcessTelemetryUpdateContext(d(), s);
          t[_DYN_ON_COMPLETE](a), s._updateHook && !0 === s._updateHook(t, e) || t[_DYN_PROCESS_NEXT](e);
        }
        function m(e) {
          var t = s[_DYN_LOGGER];
          t ? (_throwInternal(t, 2, 73, e), a()) : throwError(e);
        }
        function r(e) {
          var t = s[_DYN_GET_NOTIFY_MGR]();
          t && t[STR_EVENTS_DISCARDED]([e], 2);
        }
        function o(e) {
          O.add(e);
        }
        l(), s._getDbgPlgTargets = function () {
          return [F];
        }, s[_DYN_IS_INITIALIZED] = function () {
          return y;
        }, s[_DYN_INITIALIZE] = function (e, t, r, n) {
          I && throwError(strSdkUnloadingError), s[_DYN_IS_INITIALIZED]() && throwError("Core cannot be initialized more than once"), e = (g = createDynamicConfig(e, defaultConfig, r || s[_DYN_LOGGER], !1)).cfg, o(g[_DYN_WATCH](function (t) {
            L = t.cfg.instrumentationKey;
            var r = t.ref(t.cfg, STR_EXTENSION_CONFIG);
            objForEachKey(r, function (e) {
              t.ref(r, e);
            }), isNullOrUndefined(L) && throwError("Please provide instrumentation key");
          })), (E = n) || s[_DYN_GET_NOTIFY_MGR](), o(g[_DYN_WATCH](function (e) {
            var t = e.cfg.disableDbgExt;
            !0 === t && M && (E[_DYN_REMOVE_NOTIFICATION_2](M), M = null), E && !M && !0 !== t && (M = getDebugListener(e.cfg), E[_DYN_ADD_NOTIFICATION_LIS1](M));
          })), o(g[_DYN_WATCH](function (e) {
            var t = e.cfg.enablePerfMgr;
            t || (w = w && null), t && getSetValue(e.cfg, STR_CREATE_PERF_MGR, _createPerfManager);
          })), s[_DYN_LOGGER] = r;
          n = e[STR_EXTENSIONS];
          (x = [])[_DYN_PUSH$1].apply(x, __spreadArrayFn(__spreadArrayFn([], t, !1), n)), C = e[STR_CHANNELS], u(null), A && 0 !== A[_DYN_LENGTH$5] || throwError("No " + STR_CHANNELS + " available"), C && 1 < C[_DYN_LENGTH$5] && ((r = s[_DYN_GET_PLUGIN]("TeeChannelController")) && r.plugin || _throwInternal(v, 1, 28, "TeeChannel required")), _registerDelayedCfgListener(e, U, v), y = !(U = null), s.releaseQueue(), s[_DYN_POLL_INTERNAL_LOGS]();
        }, s.getChannels = function () {
          var t = [];
          return A && arrForEach(A, function (e) {
            t[_DYN_PUSH$1](e);
          }), objFreeze(t);
        }, s.track = function (e) {
          doPerf(s[STR_GET_PERF_MGR](), function () {
            return "AppInsightsCore:track";
          }, function () {
            null === e && (r(e), throwError("Invalid telemetry item")), !e[_DYN_NAME$3] && isNullOrUndefined(e[_DYN_NAME$3]) && (r(e), throwError("telemetry name required")), e.iKey = e.iKey || L, e[_DYN_TIME] = e[_DYN_TIME] || toISOString(new Date()), e.ver = e.ver || "4.0", !I && s[_DYN_IS_INITIALIZED]() ? c()[_DYN_PROCESS_NEXT](e) : n[_DYN_PUSH$1](e);
          }, function () {
            return {
              item: e
            };
          }, !e.sync);
        }, s[_DYN_GET_PROCESS_TEL_CONT0] = c, s[_DYN_GET_NOTIFY_MGR] = function () {
          return E || (E = new NotificationManager(g.cfg), s[strNotificationManager] = E), E;
        }, s[_DYN_ADD_NOTIFICATION_LIS1] = function (e) {
          s[_DYN_GET_NOTIFY_MGR]()[_DYN_ADD_NOTIFICATION_LIS1](e);
        }, s[_DYN_REMOVE_NOTIFICATION_2] = function (e) {
          E && E[_DYN_REMOVE_NOTIFICATION_2](e);
        }, s.getCookieMgr = function () {
          return T = T || createCookieMgr(g.cfg, s[_DYN_LOGGER]);
        }, s.setCookieMgr = function (e) {
          T !== e && (runTargetUnload(T, !1), T = e);
        }, s[STR_GET_PERF_MGR] = function () {
          return b || w || o(g[_DYN_WATCH](function (e) {
            e.cfg.enablePerfMgr && (e = e.cfg[STR_CREATE_PERF_MGR], isFunction(e)) && (w = e(s, s[_DYN_GET_NOTIFY_MGR]()));
          })), b || w || getGblPerfMgr();
        }, s.setPerfMgr = function (e) {
          b = e;
        }, s.eventCnt = function () {
          return n[_DYN_LENGTH$5];
        }, s.releaseQueue = function () {
          var e;
          y && 0 < n[_DYN_LENGTH$5] && (e = n, n = [], arrForEach(e, function (e) {
            c()[_DYN_PROCESS_NEXT](e);
          }));
        }, s[_DYN_POLL_INTERNAL_LOGS] = function (e) {
          return P = e || null, H = !1, z && z[_DYN_CANCEL](), a(!0);
        }, s[_DYN_STOP_POLLING_INTERNA3] = function () {
          H = !0, z && z[_DYN_CANCEL](), f();
        }, proxyFunctions(s, function () {
          return N;
        }, ["addTelemetryInitializer"]), s[_DYN_UNLOAD] = function (e, t, r) {
          void 0 === e && (e = !0), y || throwError(strSdkNotInitialized), I && throwError(strSdkUnloadingError), (n = {
            reason: 50
          })[_DYN_IS_ASYNC] = e, n.flushComplete = !1;
          var n,
            i,
            o = n,
            a = (e && !t && (i = createPromise(function (e) {
              t = e;
            })), createProcessTelemetryUnloadContext(d(), s));
          return a[_DYN_ON_COMPLETE](function () {
            O.run(s[_DYN_LOGGER]), doUnloadAll([T, E, v], e, function () {
              l(), t && t(o);
            });
          }, s), f(), _(e, function (e) {
            o.flushComplete = e, I = !0, R.run(a, o), s[_DYN_STOP_POLLING_INTERNA3](), a[_DYN_PROCESS_NEXT](o);
          }, 6, r), i;
        }, s[_DYN_GET_PLUGIN] = h, s.addPlugin = function (e, t, r, n) {
          var i, o, a;
          function s() {
            x[_DYN_PUSH$1](e), o.added = [e], u(o), n && n(!0);
          }
          e ? (i = h(e[_DYN_IDENTIFIER])) && !t ? (n && n(!1), m("Plugin [" + e[_DYN_IDENTIFIER] + "] is already loaded!")) : (o = {
            reason: 16
          }, i ? p(a = [i.plugin], {
            reason: 2,
            isAsync: !!r
          }, function (e) {
            e ? (o.removed = a, o.reason |= 32, s()) : n && n(!1);
          }) : s()) : (n && n(!1), m(strValidationError));
        }, s.updateCfg = function (n, e) {
          var t, r;
          void 0 === e && (e = !0), s[_DYN_IS_INITIALIZED]() && (t = {
            reason: 1,
            cfg: g.cfg,
            oldCfg: deepExtend({}, g.cfg),
            newConfig: deepExtend({}, n),
            merge: e
          }, n = t.newConfig, r = g.cfg, n[STR_EXTENSIONS] = r[STR_EXTENSIONS], n[STR_CHANNELS] = r[STR_CHANNELS]), g._block(function (t) {
            var r = t.cfg;
            _deepMergeConfig(t, r, n, e), e || objForEachKey(r, function (e) {
              objHasOwn(n, e) || t.set(r, e, UNDEFINED_VALUE$2);
            }), t[_DYN_SET_DF](r, defaultConfig);
          }, !0), g[_DYN_NOTIFY](), t && i(t);
        }, s.evtNamespace = function () {
          return D;
        }, s.flush = _, s.getTraceCtx = function (e) {
          return k = k || createDistributedTraceContext();
        }, s.setTraceCtx = function (e) {
          k = e || null;
        }, s.addUnloadHook = o, proxyFunctionAs(s, "addUnloadCb", function () {
          return R;
        }, "add"), s.onCfgChange = function (e) {
          var t = y ? onConfigChange(g.cfg, e, s[_DYN_LOGGER]) : _addDelayedCfgListener(U, e);
          return {
            rm: function () {
              t.rm();
            }
          };
        }, s.getWParam = function () {
          return hasDocument() || g.cfg.enableWParam ? 0 : -1;
        };
      });
    }
    return e.__ieDyn = 1, e;
  }(),
  strOnPrefix = "on",
  strAttachEvent = "attachEvent",
  strAddEventHelper = "addEventListener",
  strDetachEvent = "detachEvent",
  strRemoveEventListener = "removeEventListener",
  strEvents = "events",
  strVisibilityChangeEvt = "visibilitychange",
  strPageHide = "pagehide",
  strUnload = "unload",
  strBeforeUnload = "beforeunload",
  strPageHideNamespace = createUniqueNamespace("aiEvtPageHide"),
  rRemoveEmptyNs = (createUniqueNamespace("aiEvtPageShow"), /\.[\.]+/g),
  rRemoveTrailingEmptyNs = /[\.]+$/,
  _guid = 1,
  elmNodeData = createElmNodeData("events"),
  eventNamespace = /^([^.]*)(?:\.(.+)|)/;
function _normalizeNamespace(e) {
  return e && e[_DYN_REPLACE] ? e[_DYN_REPLACE](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY) : e;
}
function _getEvtNamespace(e, t) {
  t && (r = STR_EMPTY, isArray(t) ? (r = STR_EMPTY, arrForEach(t, function (e) {
    (e = _normalizeNamespace(e)) && ("." !== e[0] && (e = "." + e), r += e);
  })) : r = _normalizeNamespace(t), r) && ("." !== r[0] && (r = "." + r), e = (e || STR_EMPTY) + r);
  var r,
    t = eventNamespace.exec(e || STR_EMPTY) || [],
    e = {};
  return e[_DYN_TYPE] = t[1], e.ns = (t[2] || STR_EMPTY).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY)[_DYN_SPLIT$1](".").sort().join("."), e;
}
function _getRegisteredEvents(e, t, r) {
  e = elmNodeData.get(e, strEvents, {}, r = void 0 === r ? !0 : r);
  return e[t] || (e[t] = []);
}
function _doDetach(e, t, r, n) {
  e && t && t[_DYN_TYPE] && (e[strRemoveEventListener] ? e[strRemoveEventListener](t[_DYN_TYPE], r, n) : e[strDetachEvent] && e[strDetachEvent](strOnPrefix + t[_DYN_TYPE], r));
}
function _doAttach(e, t, r, n) {
  var i = !1;
  return e && t && t[_DYN_TYPE] && r && (e[strAddEventHelper] ? (e[strAddEventHelper](t[_DYN_TYPE], r, n), i = !0) : e[strAttachEvent] && (e[strAttachEvent](strOnPrefix + t[_DYN_TYPE], r), i = !0)), i;
}
function _doUnregister(e, t, r, n) {
  for (var i = t[_DYN_LENGTH$5]; i--;) {
    var o = t[i];
    !o || r.ns && r.ns !== o.evtName.ns || n && !n(o) || (_doDetach(e, o.evtName, o[_DYN_HANDLER], o.capture), t[_DYN_SPLICE](i, 1));
  }
}
function _unregisterEvents(r, n, i) {
  var e;
  n[_DYN_TYPE] ? _doUnregister(r, _getRegisteredEvents(r, n[_DYN_TYPE]), n, i) : (objForEachKey(e = elmNodeData.get(r, strEvents, {}), function (e, t) {
    _doUnregister(r, t, n, i);
  }), 0 === objKeys(e)[_DYN_LENGTH$5] && elmNodeData.kill(r, strEvents));
}
function mergeEvtNamespace(e, t) {
  var r = t ? _getEvtNamespace("xx", r = isArray(t) ? [e].concat(t) : [e, t]).ns[_DYN_SPLIT$1](".") : e;
  return r;
}
function eventOn(e, t, r, n, i) {
  void 0 === i && (i = !1);
  var o,
    a = !1;
  if (e) try {
    var s,
      l = _getEvtNamespace(t, n);
    (a = _doAttach(e, l, r, i)) && elmNodeData.accept(e) && ((o = {
      guid: _guid++,
      evtName: l
    })[_DYN_HANDLER] = r, o.capture = i, s = o, _getRegisteredEvents(e, l.type)[_DYN_PUSH$1](s));
  } catch (e) {}
  return a;
}
function eventOff(e, t, r, n, i) {
  if (void 0 === i && (i = !1), e) try {
    var o = _getEvtNamespace(t, n),
      a = !1;
    _unregisterEvents(e, o, function (e) {
      return !((!o.ns || r) && e[_DYN_HANDLER] !== r) && (a = !0);
    }), a || _doDetach(e, o, r, i);
  } catch (e) {}
}
function addEventHandler(e, t, r) {
  var n = !1,
    i = getWindow(),
    i = (i && (n = eventOn(i, e, t, r), n = eventOn(i.body, e, t, r) || n), getDocument());
  return n = i ? eventOn(i, e, t, r) || n : n;
}
function removeEventHandler(e, t, r) {
  var n = getWindow(),
    n = (n && (eventOff(n, e, t, r), eventOff(n.body, e, t, r)), getDocument());
  n && eventOff(n, e, t, r);
}
function _addEventListeners(e, t, r, n) {
  var i = !1;
  return t && e && 0 < e[_DYN_LENGTH$5] && arrForEach(e, function (e) {
    !e || r && -1 !== arrIndexOf(r, e) || (i = addEventHandler(e, t, n) || i);
  }), i;
}
function addEventListeners(e, t, r, n) {
  var i = !1;
  return i = t && e && isArray(e) && !(i = _addEventListeners(e, t, r, n)) && r && 0 < r[_DYN_LENGTH$5] ? _addEventListeners(e, t, null, n) : i;
}
function removeEventListeners(e, t, r) {
  e && isArray(e) && arrForEach(e, function (e) {
    e && removeEventHandler(e, t, r);
  });
}
function addPageUnloadEventListener(e, t, r) {
  return addEventListeners([strBeforeUnload, strUnload, strPageHide], e, t, r);
}
function removePageUnloadEventListener(e, t) {
  removeEventListeners([strBeforeUnload, strUnload, strPageHide], e, t);
}
function addPageHideEventListener(r, e, t) {
  var n = mergeEvtNamespace(strPageHideNamespace, t),
    i = _addEventListeners([strPageHide], r, e, n);
  return i = !(i = e && -1 !== arrIndexOf(e, strVisibilityChangeEvt) ? i : _addEventListeners([strVisibilityChangeEvt], function (e) {
    var t = getDocument();
    r && t && "hidden" === t.visibilityState && r(e);
  }, e, n) || i) && e ? addPageHideEventListener(r, null, t) : i;
}
function removePageHideEventListener(e, t) {
  t = mergeEvtNamespace(strPageHideNamespace, t);
  removeEventListeners([strPageHide], e, t), removeEventListeners([strVisibilityChangeEvt], null, t);
}
var aiInstrumentHooks = "_aiHooks",
  cbNames = ["req", "rsp", "hkErr", "fnErr"];
function _arrLoop(e, t) {
  if (e) for (var r = 0; r < e[_DYN_LENGTH$5] && !t(e[r], r); r++);
}
function _doCallbacks(e, i, o, a, s) {
  0 <= s && s <= 2 && _arrLoop(e, function (t, e) {
    var t = t.cbks,
      r = t[cbNames[s]];
    if (r) {
      i.ctx = function () {
        return a[e] = a[e] || {};
      };
      try {
        r[_DYN_APPLY](i.inst, o);
      } catch (e) {
        r = i.err;
        try {
          var n = t[cbNames[2]];
          n && (i.err = e, n[_DYN_APPLY](i.inst, o));
        } catch (e) {} finally {
          i.err = r;
        }
      }
    }
  });
}
function _createFunctionHook(s) {
  return function () {
    var r = arguments,
      t = s.h,
      n = ((i = {})[_DYN_NAME$3] = s.n, i.inst = this, i.ctx = null, i.set = function (e, t) {
        (r = a([], r))[e] = t, o = a([n], r);
      }, i),
      i = [],
      o = a([n], r);
    function a(t, e) {
      return _arrLoop(e, function (e) {
        t[_DYN_PUSH$1](e);
      }), t;
    }
    n.evt = getInst("event"), _doCallbacks(t, n, o, i, 0);
    var e = s.f;
    if (e) try {
      n.rslt = e[_DYN_APPLY](this, r);
    } catch (e) {
      throw n.err = e, _doCallbacks(t, n, o, i, 3), e;
    }
    return _doCallbacks(t, n, o, i, 1), n.rslt;
  };
}
function _getOwner(e, t, r, n) {
  var i = null;
  return e && (objHasOwnProperty(e, t) ? i = e : r && (i = _getOwner(_getObjProto(e), t, n, !1))), i;
}
function InstrumentProto(e, t, r) {
  return e ? InstrumentFunc(e[strShimPrototype], t, r, !1) : null;
}
function _createInstrumentHook(e, t, r, n) {
  var i = r && r[aiInstrumentHooks],
    e = (i || ((r = _createFunctionHook(i = {
      i: 0,
      n: t,
      f: r,
      h: []
    }))[aiInstrumentHooks] = i, e[t] = r), {
      id: i.i,
      cbks: n,
      rm: function () {
        var r = this.id;
        _arrLoop(i.h, function (e, t) {
          if (e.id === r) return i.h[_DYN_SPLICE](t, 1), 1;
        });
      }
    });
  return i.i++, i.h[_DYN_PUSH$1](e), e;
}
function InstrumentFunc(e, t, r, n, i) {
  if (void 0 === n && (n = !0), e && t && r) {
    e = _getOwner(e, t, n, i);
    if (e) {
      n = e[t];
      if (typeof n === strShimFunction) return _createInstrumentHook(e, t, n, r);
    }
  }
  return null;
}
function InstrumentEvent(e, t, r, n, i) {
  if (e && t && r) {
    n = _getOwner(e, t, n, i) || e;
    if (n) return _createInstrumentHook(n, t, n[t], r);
  }
  return null;
}
var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation",
  SampleRate = "sampleRate",
  ProcessLegacy = "ProcessLegacy",
  HttpMethod = "http.method",
  DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com",
  DEFAULT_BREEZE_PATH = "/v2/track",
  strNotSpecified = "not_specified",
  strIkey = "iKey",
  RequestHeaders = createValueMap({
    requestContextHeader: [0, "Request-Context"],
    requestContextTargetKey: [1, "appId"],
    requestContextAppIdFormat: [2, "appId=cid-v1:"],
    requestIdHeader: [3, "Request-Id"],
    traceParentHeader: [4, "traceparent"],
    traceStateHeader: [5, "tracestate"],
    sdkContextHeader: [6, "Sdk-Context"],
    sdkContextHeaderAppIdRequest: [7, "appId"],
    requestContextHeaderLowerCase: [8, "request-context"]
  }),
  _DYN_SPLIT = "split",
  _DYN_LENGTH$4 = "length",
  _DYN_TO_LOWER_CASE$1 = "toLowerCase",
  _DYN_INGESTIONENDPOINT = "ingestionendpoint",
  _DYN_TO_STRING$2 = "toString",
  _DYN_REMOVE_ITEM = "removeItem",
  _DYN_NAME$2 = "name",
  _DYN_MESSAGE$1 = "message",
  _DYN_COUNT$1 = "count",
  _DYN_PRE_TRIGGER_DATE = "preTriggerDate",
  _DYN_DISABLED = "disabled",
  _DYN_INTERVAL = "interval",
  _DYN_DAYS_OF_MONTH = "daysOfMonth",
  _DYN_DATE = "date",
  _DYN_GET_UTCDATE = "getUTCDate",
  _DYN_STRINGIFY$1 = "stringify",
  _DYN_PATHNAME = "pathname",
  _DYN_CORRELATION_HEADER_E0 = "correlationHeaderExcludePatterns",
  _DYN_EXCEPTIONS = "exceptions",
  _DYN_PARSED_STACK = "parsedStack",
  _DYN_PROPERTIES$1 = "properties",
  _DYN_MEASUREMENTS$1 = "measurements",
  _DYN_SIZE_IN_BYTES = "sizeInBytes",
  _DYN_TYPE_NAME = "typeName",
  _DYN_SEVERITY_LEVEL = "severityLevel",
  _DYN_PROBLEM_GROUP = "problemGroup",
  _DYN_IS_MANUAL = "isManual",
  _DYN__CREATE_FROM_INTERFA1 = "CreateFromInterface",
  _DYN_ASSEMBLY = "assembly",
  _DYN_FILE_NAME = "fileName",
  _DYN_HAS_FULL_STACK = "hasFullStack",
  _DYN_LEVEL = "level",
  _DYN_METHOD$1 = "method",
  _DYN_LINE = "line",
  _DYN_DURATION$1 = "duration",
  _DYN_RECEIVED_RESPONSE = "receivedResponse";
function dataSanitizeKeyAndAddUniqueness(e, t, r) {
  var n = t[_DYN_LENGTH$4],
    i = dataSanitizeKey(e, t);
  if (i[_DYN_LENGTH$4] !== n) {
    for (var o = 0, a = i; void 0 !== r[a];) o++, a = strSubstring(i, 0, 147) + dsPadNumber(o);
    i = a;
  }
  return i;
}
function dataSanitizeKey(e, t) {
  var r;
  return t && 150 < (t = strTrim(asString(t)))[_DYN_LENGTH$4] && (r = strSubstring(t, 0, 150), _throwInternal(e, 2, 57, "name is too long.  It has been truncated to 150 characters.", {
    name: t
  }, !0)), r || t;
}
function dataSanitizeString(e, t, r) {
  var n;
  return void 0 === r && (r = 1024), t && (r = r || 1024, (t = strTrim(asString(t)))[_DYN_LENGTH$4] > r) && (n = strSubstring(t, 0, r), _throwInternal(e, 2, 61, "string value is too long. It has been truncated to " + r + " characters.", {
    value: t
  }, !0)), n || t;
}
function dataSanitizeUrl(e, t) {
  return dataSanitizeInput(e, t, 2048, 66);
}
function dataSanitizeMessage(e, t) {
  var r;
  return t && 32768 < t[_DYN_LENGTH$4] && (r = strSubstring(t, 0, 32768), _throwInternal(e, 2, 56, "message is too long, it has been truncated to 32768 characters.", {
    message: t
  }, !0)), r || t;
}
function dataSanitizeException(e, t) {
  var r, n;
  return t && 32768 < (n = "" + t)[_DYN_LENGTH$4] && (r = strSubstring(n, 0, 32768), _throwInternal(e, 2, 52, "exception is too long, it has been truncated to 32768 characters.", {
    exception: t
  }, !0)), r || t;
}
function dataSanitizeProperties(r, e) {
  var n;
  return e && (n = {}, objForEachKey(e, function (e, t) {
    if (isObject(t) && hasJSON()) try {
      t = getJSON()[_DYN_STRINGIFY$1](t);
    } catch (e) {
      _throwInternal(r, 2, 49, "custom property is not valid", {
        exception: e
      }, !0);
    }
    t = dataSanitizeString(r, t, 8192), e = dataSanitizeKeyAndAddUniqueness(r, e, n), n[e] = t;
  }), e = n), e;
}
function dataSanitizeMeasurements(r, e) {
  var n;
  return e && (n = {}, objForEachKey(e, function (e, t) {
    e = dataSanitizeKeyAndAddUniqueness(r, e, n), n[e] = t;
  }), e = n), e;
}
function dataSanitizeId(e, t) {
  return t && dataSanitizeInput(e, t, 128, 69)[_DYN_TO_STRING$2]();
}
function dataSanitizeInput(e, t, r, n) {
  var i;
  return t && (t = strTrim(asString(t)))[_DYN_LENGTH$4] > r && (i = strSubstring(t, 0, r), _throwInternal(e, 2, n, "input is too long, it has been truncated to " + r + " characters.", {
    data: t
  }, !0)), i || t;
}
function dsPadNumber(e) {
  e = "00" + e;
  return strSubstr(e, e[_DYN_LENGTH$4] - 3);
}
var _document = getDocument() || {},
  _htmlAnchorIdx = 0,
  _htmlAnchorElement = [null, null, null, null, null];
function urlParseUrl(e) {
  var t = _htmlAnchorIdx,
    r = _htmlAnchorElement,
    n = r[t];
  return _document.createElement ? r[t] || (n = r[t] = _document.createElement("a")) : n = {
    host: urlParseHost(e, !0)
  }, n.href = e, ++t >= r[_DYN_LENGTH$4] && (t = 0), _htmlAnchorIdx = t, n;
}
function urlGetAbsoluteUrl(e) {
  var t,
    e = urlParseUrl(e);
  return t = e ? e.href : t;
}
function urlGetCompleteUrl(e, t) {
  return e ? e.toUpperCase() + " " + t : t;
}
function urlParseHost(e, t) {
  e = urlParseFullHost(e, t) || "";
  if (e) {
    t = e.match(/(www\d{0,5}\.)?([^\/:]{1,256})(:\d{1,20})?/i);
    if (null != t && 3 < t[_DYN_LENGTH$4] && isString(t[2]) && 0 < t[2][_DYN_LENGTH$4]) return t[2] + (t[3] || "");
  }
  return e;
}
function urlParseFullHost(e, t) {
  var r = null;
  return e && null != (e = e.match(/(\w{1,150}):\/\/([^\/:]{1,256})(:\d{1,20})?/i)) && 2 < e[_DYN_LENGTH$4] && isString(e[2]) && 0 < e[2][_DYN_LENGTH$4] && (r = e[2] || "", t) && 2 < e[_DYN_LENGTH$4] && (t = (e[1] || "")[_DYN_TO_LOWER_CASE$1](), e = e[3] || "", r += e = "http" === t && ":80" === e || "https" === t && ":443" === e ? "" : e), r;
}
var _internalEndpoints = [DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH, "https://breeze.aimon.applicationinsights.io" + DEFAULT_BREEZE_PATH, "https://dc-int.services.visualstudio.com" + DEFAULT_BREEZE_PATH],
  _correlationIdPrefix = "cid-v1:";
function isInternalApplicationInsightsEndpoint(e) {
  return -1 !== arrIndexOf(_internalEndpoints, e[_DYN_TO_LOWER_CASE$1]());
}
function correlationIdCanIncludeCorrelationHeader(e, t, r) {
  if (!t || e && e.disableCorrelationHeaders) return !1;
  if (e && e[_DYN_CORRELATION_HEADER_E0]) for (var n = 0; n < e.correlationHeaderExcludePatterns[_DYN_LENGTH$4]; n++) if (e[_DYN_CORRELATION_HEADER_E0][n].test(t)) return !1;
  var i = urlParseUrl(t).host[_DYN_TO_LOWER_CASE$1]();
  if (!i || -1 === strIndexOf(i, ":443") && -1 === strIndexOf(i, ":80") || (i = (urlParseFullHost(t, !0) || "")[_DYN_TO_LOWER_CASE$1]()), (!e || !e.enableCorsCorrelation) && i && i !== r) return !1;
  var o,
    r = e && e.correlationHeaderDomains;
  if (r && (arrForEach(r, function (e) {
    e = new RegExp(e.toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
    o = o || e.test(i);
  }), !o)) return !1;
  var a = e && e.correlationHeaderExcludedDomains;
  if (!a || 0 === a[_DYN_LENGTH$4]) return !0;
  for (n = 0; n < a[_DYN_LENGTH$4]; n++) if (new RegExp(a[n].toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*")).test(i)) return !1;
  return i && 0 < i[_DYN_LENGTH$4];
}
function correlationIdGetCorrelationContext(e) {
  if (e) {
    e = correlationIdGetCorrelationContextValue(e, RequestHeaders[1]);
    if (e && e !== _correlationIdPrefix) return e;
  }
}
function correlationIdGetCorrelationContextValue(e, t) {
  if (e) for (var r = e[_DYN_SPLIT](","), n = 0; n < r[_DYN_LENGTH$4]; ++n) {
    var i = r[n][_DYN_SPLIT]("=");
    if (2 === i[_DYN_LENGTH$4] && i[0] === t) return i[1];
  }
}
function AjaxHelperParseDependencyPath(e, t, r, n) {
  var i,
    o,
    a,
    s = n,
    l = n;
  return s = t && 0 < t[_DYN_LENGTH$4] ? (a = (i = urlParseUrl(t)).host, s || (null != i[_DYN_PATHNAME] ? ("/" !== (o = 0 === i.pathname[_DYN_LENGTH$4] ? "/" : i[_DYN_PATHNAME]).charAt(0) && (o = "/" + o), l = i[_DYN_PATHNAME], dataSanitizeString(e, r ? r + " " + o : o)) : dataSanitizeString(e, t))) : a = n, {
    target: a,
    name: s,
    data: l
  };
}
function dateTimeUtilsNow() {
  var e = getPerformance();
  if (e && e.now && e.timing) {
    e = e.now() + e.timing.navigationStart;
    if (0 < e) return e;
  }
  return utcNow();
}
function dateTimeUtilsDuration(e, t) {
  var r = null;
  return r = 0 === e || 0 === t || isNullOrUndefined(e) || isNullOrUndefined(t) ? r : t - e;
}
function createDistributedTraceContextFromTrace(e, t) {
  var r = e || {};
  return {
    getName: function () {
      return r[_DYN_NAME$2];
    },
    setName: function (e) {
      t && t.setName(e), r[_DYN_NAME$2] = e;
    },
    getTraceId: function () {
      return r.traceID;
    },
    setTraceId: function (e) {
      t && t.setTraceId(e), isValidTraceId(e) && (r.traceID = e);
    },
    getSpanId: function () {
      return r.parentID;
    },
    setSpanId: function (e) {
      t && t.setSpanId(e), isValidSpanId(e) && (r.parentID = e);
    },
    getTraceFlags: function () {
      return r.traceFlags;
    },
    setTraceFlags: function (e) {
      t && t.setTraceFlags(e), r.traceFlags = e;
    }
  };
}
var StorageType = createEnumStyle({
    LocalStorage: 0,
    SessionStorage: 1
  }),
  _canUseLocalStorage = void 0,
  _canUseSessionStorage = void 0,
  _storagePrefix = "";
function _getLocalStorageObject() {
  return utlCanUseLocalStorage() ? _getVerifiedStorageObject(StorageType.LocalStorage) : null;
}
function _getVerifiedStorageObject(e) {
  try {
    if (isNullOrUndefined(getGlobal())) return null;
    var t = new Date()[_DYN_TO_STRING$2](),
      r = getInst(e === StorageType.LocalStorage ? "localStorage" : "sessionStorage"),
      n = _storagePrefix + t,
      i = (r.setItem(n, t), r.getItem(n) !== t);
    if (r[_DYN_REMOVE_ITEM](n), !i) return r;
  } catch (e) {}
  return null;
}
function _getSessionStorageObject() {
  return utlCanUseSessionStorage() ? _getVerifiedStorageObject(StorageType.SessionStorage) : null;
}
function utlDisableStorage() {
  _canUseSessionStorage = _canUseLocalStorage = !1;
}
function utlSetStoragePrefix(e) {
  _storagePrefix = e || "";
}
function utlEnableStorage() {
  _canUseLocalStorage = utlCanUseLocalStorage(!0), _canUseSessionStorage = utlCanUseSessionStorage(!0);
}
function utlCanUseLocalStorage(e) {
  return _canUseLocalStorage = !e && void 0 !== _canUseLocalStorage ? _canUseLocalStorage : !!_getVerifiedStorageObject(StorageType.LocalStorage);
}
function utlGetLocalStorage(t, e) {
  var r = _getLocalStorageObject();
  if (null !== r) try {
    return r.getItem(e);
  } catch (e) {
    _canUseLocalStorage = !1, _throwInternal(t, 2, 1, "Browser failed read of local storage. " + getExceptionName(e), {
      exception: dumpObj(e)
    });
  }
  return null;
}
function utlSetLocalStorage(t, e, r) {
  var n = _getLocalStorageObject();
  if (null !== n) try {
    return n.setItem(e, r), !0;
  } catch (e) {
    _canUseLocalStorage = !1, _throwInternal(t, 2, 3, "Browser failed write to local storage. " + getExceptionName(e), {
      exception: dumpObj(e)
    });
  }
  return !1;
}
function utlRemoveStorage(t, e) {
  var r = _getLocalStorageObject();
  if (null !== r) try {
    return r[_DYN_REMOVE_ITEM](e), !0;
  } catch (e) {
    _canUseLocalStorage = !1, _throwInternal(t, 2, 5, "Browser failed removal of local storage item. " + getExceptionName(e), {
      exception: dumpObj(e)
    });
  }
  return !1;
}
function utlCanUseSessionStorage(e) {
  return _canUseSessionStorage = !e && void 0 !== _canUseSessionStorage ? _canUseSessionStorage : !!_getVerifiedStorageObject(StorageType.SessionStorage);
}
function utlGetSessionStorage(t, e) {
  var r = _getSessionStorageObject();
  if (null !== r) try {
    return r.getItem(e);
  } catch (e) {
    _canUseSessionStorage = !1, _throwInternal(t, 2, 2, "Browser failed read of session storage. " + getExceptionName(e), {
      exception: dumpObj(e)
    });
  }
  return null;
}
function utlSetSessionStorage(t, e, r) {
  var n = _getSessionStorageObject();
  if (null !== n) try {
    return n.setItem(e, r), !0;
  } catch (e) {
    _canUseSessionStorage = !1, _throwInternal(t, 2, 4, "Browser failed write to session storage. " + getExceptionName(e), {
      exception: dumpObj(e)
    });
  }
  return !1;
}
function utlRemoveSessionStorage(t, e) {
  var r = _getSessionStorageObject();
  if (null !== r) try {
    return r[_DYN_REMOVE_ITEM](e), !0;
  } catch (e) {
    _canUseSessionStorage = !1, _throwInternal(t, 2, 6, "Browser failed removal of session storage item. " + getExceptionName(e), {
      exception: dumpObj(e)
    });
  }
  return !1;
}
var THROTTLE_STORAGE_PREFIX = "appInsightsThrottle",
  ThrottleMgr = function (e, t) {
    var d,
      p,
      l,
      n,
      f,
      i,
      o,
      r = this,
      _ = !1,
      c = !1;
    function a(e, t, r, n) {
      if (_) {
        if (!function (e) {
          try {
            var t = m(e);
            return randomValue(1e6) <= t.limit.samplingRate;
          } catch (e) {}
          return !1;
        }(e)) return;
        var i = m(e),
          o = E(e),
          a = g(i, d, o),
          s = !1,
          l = 0,
          c = b(e);
        try {
          a && !c ? (l = Math.min(i.limit.maxSendNumber, o[_DYN_COUNT$1] + 1), s = !(o[_DYN_COUNT$1] = 0), f[e] = !0, o[_DYN_PRE_TRIGGER_DATE] = new Date()) : (f[e] = a, o[_DYN_COUNT$1] += 1);
          var u = y(e);
          v(p, u, o);
          for (var h = 0; h < l; h++) _throwInternal(p, r || 1, e, t);
        } catch (e) {}
        return {
          isThrottled: s,
          throttleNum: l
        };
      }
      return n && w(e).push({
        msgID: e,
        message: t,
        severity: r
      }), null;
    }
    function m(e) {
      return l[e] || l[109];
    }
    function s(e, t) {
      var r, n;
      try {
        var i = t || {},
          o = {},
          a = (o[_DYN_DISABLED] = !!i[_DYN_DISABLED], i[_DYN_INTERVAL] || {}),
          s = (c = (null === a ? void 0 : a.daysOfMonth) && 0 < (null === a ? void 0 : a.daysOfMonth[_DYN_LENGTH$4]), o[_DYN_INTERVAL] = function (e) {
            var t = null == (e = e || {}) ? void 0 : e.monthInterval,
              r = null == e ? void 0 : e.dayInterval;
            isNullOrUndefined(t) && isNullOrUndefined(r) && (e.monthInterval = 3, c || (e[_DYN_DAYS_OF_MONTH] = [28], c = !0));
            return e = {
              monthInterval: null == e ? void 0 : e.monthInterval,
              dayInterval: null == e ? void 0 : e.dayInterval,
              daysOfMonth: null == e ? void 0 : e.daysOfMonth
            };
          }(a), {
            samplingRate: (null == (r = i.limit) ? void 0 : r.samplingRate) || 100,
            maxSendNumber: (null == (n = i.limit) ? void 0 : n.maxSendNumber) || 1
          });
        o.limit = s, l[e] = o;
      } catch (e) {}
    }
    function g(e, t, r) {
      var n, i;
      return !(!e || e[_DYN_DISABLED] || !t || !isNotNullOrUndefined(r)) && (t = u(), r = r[_DYN_DATE], n = 1, null != (e = e[_DYN_INTERVAL]) && e.monthInterval && (i = 12 * (t.getUTCFullYear() - r.getUTCFullYear()) + t.getUTCMonth() - r.getUTCMonth(), n = h(e.monthInterval, 0, i)), i = 1, c ? i = arrIndexOf(e[_DYN_DAYS_OF_MONTH], t[_DYN_GET_UTCDATE]()) : null != e && e.dayInterval && (t = Math.floor((t.getTime() - r.getTime()) / 864e5), i = h(e.dayInterval, 0, t)), 0 <= n) && 0 <= i;
    }
    function y(e, t) {
      t = isNotNullOrUndefined(t) ? t : "";
      return e ? THROTTLE_STORAGE_PREFIX + t + "-" + e : null;
    }
    function u(e) {
      try {
        if (!e) return new Date();
        var t = new Date(e);
        if (!isNaN(t.getDate())) return t;
      } catch (e) {}
      return null;
    }
    function v(e, t, r) {
      try {
        return utlSetLocalStorage(e, t, strTrim(JSON[_DYN_STRINGIFY$1](r)));
      } catch (e) {}
    }
    function h(e, t, r) {
      return e <= 0 ? 1 : t <= r && (r - t) % e == 0 ? Math.floor((r - t) / e) + 1 : -1;
    }
    function E(e) {
      try {
        var t,
          r = n[e];
        return r || (t = y(e, i), r = function (e, t, r) {
          try {
            var n,
              i = {
                date: u(),
                count: 0
              };
            return e ? {
              date: u((n = JSON.parse(e))[_DYN_DATE]) || i[_DYN_DATE],
              count: n[_DYN_COUNT$1] || i[_DYN_COUNT$1],
              preTriggerDate: n.preTriggerDate ? u(n[_DYN_PRE_TRIGGER_DATE]) : void 0
            } : (v(t, r, i), i);
          } catch (e) {}
          return null;
        }(utlGetLocalStorage(p, t), p, t), n[e] = r), n[e];
      } catch (e) {}
      return null;
    }
    function b(e) {
      var t,
        r = f[e];
      return isNullOrUndefined(r) && (r = !1, (t = E(e)) && (r = function (e) {
        try {
          var t;
          if (e) return t = new Date(), e.getUTCFullYear() === t.getUTCFullYear() && e.getUTCMonth() === t.getUTCMonth() && e[_DYN_GET_UTCDATE]() === t[_DYN_GET_UTCDATE]();
        } catch (e) {}
        return !1;
      }(t[_DYN_PRE_TRIGGER_DATE])), f[e] = r), f[e];
    }
    function w(e) {
      return isNullOrUndefined((o = o || {})[e]) && (o[e] = []), o[e];
    }
    p = safeGetLogger(e), f = {}, n = {}, o = {}, l = {}, s(109), i = isNotNullOrUndefined(t) ? t : "", e.addUnloadHook(onConfigChange(e.config, function (e) {
      e = e.cfg;
      d = utlCanUseLocalStorage(), objForEachKey(e.throttleMgrCfg || {}, function (e, t) {
        s(parseInt(e), t);
      });
    })), r._getDbgPlgTargets = function () {
      return [o];
    }, r.getConfig = function () {
      return l;
    }, r.canThrottle = function (e) {
      var t = E(e);
      return g(m(e), d, t);
    }, r.isTriggered = b, r.isReady = function () {
      return _;
    }, r.flush = function (e) {
      try {
        var t,
          r = w(e);
        if (r && 0 < r[_DYN_LENGTH$4]) return t = r.slice(0), o[e] = [], arrForEach(t, function (e) {
          a(e.msgID, e[_DYN_MESSAGE$1], e.severity, !1);
        }), !0;
      } catch (e) {}
      return !1;
    }, r.flushAll = function () {
      try {
        var t;
        if (o) return t = !0, objForEachKey(o, function (e) {
          e = r.flush(parseInt(e));
          t = t && e;
        }), t;
      } catch (e) {}
      return !1;
    }, r.onReadyState = function (e, t) {
      return void 0 === t && (t = !0), (_ = !!isNullOrUndefined(e) || e) && t ? r.flushAll() : null;
    }, r.sendMessage = function (e, t, r) {
      return a(e, t, r, !0);
    };
  },
  _FIELDS_SEPARATOR = ";",
  _FIELD_KEY_VALUE_SEPARATOR = "=";
function parseConnectionString(e) {
  var t;
  return e ? (e = e[_DYN_SPLIT](_FIELDS_SEPARATOR), 0 < objKeys(e = arrReduce(e, function (e, t) {
    var r,
      t = t[_DYN_SPLIT](_FIELD_KEY_VALUE_SEPARATOR);
    return 2 === t[_DYN_LENGTH$4] && (r = t[0][_DYN_TO_LOWER_CASE$1](), t = t[1], e[r] = t), e;
  }, {}))[_DYN_LENGTH$4] && (e.endpointsuffix && (t = e.location ? e.location + "." : "", e[_DYN_INGESTIONENDPOINT] = e[_DYN_INGESTIONENDPOINT] || "https://" + t + "dc." + e.endpointsuffix), e[_DYN_INGESTIONENDPOINT] = e[_DYN_INGESTIONENDPOINT] || DEFAULT_BREEZE_ENDPOINT, strEndsWith(e[_DYN_INGESTIONENDPOINT], "/")) && (e[_DYN_INGESTIONENDPOINT] = e[_DYN_INGESTIONENDPOINT].slice(0, -1)), e) : {};
}
var Envelope = function (e, t, r) {
    var n = this;
    this.ver = 1, this.sampleRate = 100, this.tags = {}, this[_DYN_NAME$2] = dataSanitizeString(e, r) || strNotSpecified, this.data = t, this.time = toISOString(new Date()), this.aiDataContract = {
      time: 1,
      iKey: 1,
      name: 1,
      sampleRate: function () {
        return 100 === n.sampleRate ? 4 : 1;
      },
      tags: 1,
      data: 1
    };
  },
  Event$1 = function () {
    function e(e, t, r, n) {
      this.aiDataContract = {
        ver: 1,
        name: 1,
        properties: 0,
        measurements: 0
      };
      this.ver = 2, this[_DYN_NAME$2] = dataSanitizeString(e, t) || strNotSpecified, this[_DYN_PROPERTIES$1] = dataSanitizeProperties(e, r), this[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(e, n);
    }
    return e.envelopeType = "Microsoft.ApplicationInsights.{0}.Event", e.dataType = "EventData", e;
  }(),
  NoMethod = "<no_method>",
  strError = "error",
  strStack = "stack",
  strStackDetails = "stackDetails",
  strErrorSrc = "errorSrc",
  strMessage = "message",
  strDescription = "description";
function _stringify(e, t) {
  var r = e;
  return r && !isString(r) && (JSON && JSON[_DYN_STRINGIFY$1] ? (r = JSON[_DYN_STRINGIFY$1](e), !t || r && "{}" !== r || (r = isFunction(e[_DYN_TO_STRING$2]) ? e[_DYN_TO_STRING$2]() : "" + e)) : r = e + " - (Missing JSON.stringify)"), r || "";
}
function _formatMessage(e, t) {
  var r = e;
  return e && ((r = r && !isString(r) ? e[strMessage] || e[strDescription] || r : r) && !isString(r) && (r = _stringify(r, !0)), e.filename) && (r = r + " @" + (e.filename || "") + ":" + (e.lineno || "?") + ":" + (e.colno || "?")), (r = t && "String" !== t && "Object" !== t && "Error" !== t && -1 === strIndexOf(r || "", t) ? t + ": " + r : r) || "";
}
function _isExceptionDetailsInternal(e) {
  try {
    if (isObject(e)) return "hasFullStack" in e && "typeName" in e;
  } catch (e) {}
  return !1;
}
function _isExceptionInternal(e) {
  try {
    if (isObject(e)) return "ver" in e && "exceptions" in e && "properties" in e;
  } catch (e) {}
  return !1;
}
function _isStackDetails(e) {
  return e && e.src && isString(e.src) && e.obj && isArray(e.obj);
}
function _convertStackObj(e) {
  var e = e || "",
    t = (e = isString(e) ? e : isString(e[strStack]) ? e[strStack] : "" + e)[_DYN_SPLIT]("\n");
  return {
    src: e,
    obj: t
  };
}
function _getOperaStack(e) {
  for (var t = [], r = e[_DYN_SPLIT]("\n"), n = 0; n < r[_DYN_LENGTH$4]; n++) {
    var i = r[n];
    r[n + 1] && (i += "@" + r[n + 1], n++), t.push(i);
  }
  return {
    src: e,
    obj: t
  };
}
function _getStackFromErrorObj(e) {
  var t,
    r = null;
  if (e) try {
    e[strStack] ? r = _convertStackObj(e[strStack]) : e[strError] && e[strError][strStack] ? r = _convertStackObj(e[strError][strStack]) : e.exception && e.exception[strStack] ? r = _convertStackObj(e.exception[strStack]) : _isStackDetails(e) ? r = e : _isStackDetails(e[strStackDetails]) ? r = e[strStackDetails] : getWindow() && getWindow().opera && e[strMessage] ? r = _getOperaStack(e[_DYN_MESSAGE$1]) : e.reason && e.reason[strStack] ? r = _convertStackObj(e.reason[strStack]) : isString(e) ? r = _convertStackObj(e) : (t = e[strMessage] || e[strDescription] || "", isString(e[strErrorSrc]) && (t && (t += "\n"), t += " from " + e[strErrorSrc]), t && (r = _convertStackObj(t)));
  } catch (e) {
    r = _convertStackObj(e);
  }
  return r || {
    src: "",
    obj: null
  };
}
function _formatStackTrace(e) {
  var t = "";
  return e && (e.obj ? arrForEach(e.obj, function (e) {
    t += e + "\n";
  }) : t = e.src || ""), t;
}
function _parseStack(e) {
  e = e.obj;
  if (e && 0 < e[_DYN_LENGTH$4]) {
    var t = [],
      r = 0,
      n = 0;
    arrForEach(e, function (e) {
      var e = e[_DYN_TO_STRING$2]();
      _StackFrame.regex.test(e) && (e = new _StackFrame(e, r++), n += e[_DYN_SIZE_IN_BYTES], t.push(e));
    });
    if (32768 < n) for (var i = 0, o = t[_DYN_LENGTH$4] - 1, a = 0, s = i, l = o; i < o;) {
      if (32768 < (a += t[i][_DYN_SIZE_IN_BYTES] + t[o][_DYN_SIZE_IN_BYTES])) {
        t.splice(s, l - s + 1);
        break;
      }
      s = i, l = o, i++, o--;
    }
  }
  return t;
}
function _getErrorType(e) {
  var t = "";
  if (e && !(t = e.typeName || e[_DYN_NAME$2] || "")) try {
    var r = /function (.{1,200})\(/.exec(e.constructor[_DYN_TO_STRING$2]()),
      t = r && 1 < r[_DYN_LENGTH$4] ? r[1] : "";
  } catch (e) {}
  return t;
}
function _formatErrorCode(e) {
  if (e) try {
    var t, r;
    if (!isString(e)) return t = _getErrorType(e), (r = _stringify(e, !1)) && "{}" !== r || (e[strError] && (t = _getErrorType(e = e[strError])), r = _stringify(e, !0)), 0 !== strIndexOf(r, t) && "String" !== t ? t + ":" + r : r;
  } catch (e) {}
  return "" + (e || "");
}
var Exception = function () {
    function o(e, t, r, n, i, o) {
      this.aiDataContract = {
        ver: 1,
        exceptions: 1,
        severityLevel: 0,
        properties: 0,
        measurements: 0
      };
      var a = this;
      a.ver = 2, _isExceptionInternal(t) ? (a[_DYN_EXCEPTIONS] = t[_DYN_EXCEPTIONS] || [], a[_DYN_PROPERTIES$1] = t[_DYN_PROPERTIES$1], a[_DYN_MEASUREMENTS$1] = t[_DYN_MEASUREMENTS$1], t[_DYN_SEVERITY_LEVEL] && (a[_DYN_SEVERITY_LEVEL] = t[_DYN_SEVERITY_LEVEL]), t.id && (a.id = t.id), t[_DYN_PROBLEM_GROUP] && (a[_DYN_PROBLEM_GROUP] = t[_DYN_PROBLEM_GROUP]), isNullOrUndefined(t[_DYN_IS_MANUAL]) || (a[_DYN_IS_MANUAL] = t[_DYN_IS_MANUAL])) : (a[_DYN_EXCEPTIONS] = [new _ExceptionDetails(e, t, r = r || {})], a[_DYN_PROPERTIES$1] = dataSanitizeProperties(e, r), a[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(e, n), i && (a[_DYN_SEVERITY_LEVEL] = i), o && (a.id = o));
    }
    return o.CreateAutoException = function (e, t, r, n, i, o, a, s) {
      var l = _getErrorType(i || o || e),
        c = {};
      return c[_DYN_MESSAGE$1] = _formatMessage(e, l), c.url = t, c.lineNumber = r, c.columnNumber = n, c.error = _formatErrorCode(i || o || e), c.evt = _formatErrorCode(o || e), c[_DYN_TYPE_NAME] = l, c.stackDetails = _getStackFromErrorObj(a || i || o), c.errorSrc = s, c;
    }, o.CreateFromInterface = function (t, e, r, n) {
      var i = e[_DYN_EXCEPTIONS] && arrMap(e[_DYN_EXCEPTIONS], function (e) {
        return _ExceptionDetails[_DYN__CREATE_FROM_INTERFA1](t, e);
      });
      return new o(t, __assignFn(__assignFn({}, e), {
        exceptions: i
      }), r, n);
    }, o.prototype.toInterface = function () {
      var e = this.exceptions,
        t = this.properties,
        r = this.measurements,
        n = this.severityLevel,
        i = this.problemGroup,
        o = this.id,
        a = this.isManual,
        e = e instanceof Array && arrMap(e, function (e) {
          return e.toInterface();
        }) || void 0,
        s = {
          ver: "4.0"
        };
      return s[_DYN_EXCEPTIONS] = e, s.severityLevel = n, s.properties = t, s.measurements = r, s.problemGroup = i, s.id = o, s.isManual = a, s;
    }, o.CreateSimpleException = function (e, t, r, n, i, o) {
      var a;
      return {
        exceptions: [((a = {})[_DYN_HAS_FULL_STACK] = !0, a.message = e, a.stack = i, a.typeName = t, a)]
      };
    }, o.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception", o.dataType = "ExceptionData", o.formatError = _formatErrorCode, o;
  }(),
  _ExceptionDetails = function () {
    function n(t, e, r) {
      this.aiDataContract = {
        id: 0,
        outerId: 0,
        typeName: 1,
        message: 1,
        hasFullStack: 0,
        stack: 0,
        parsedStack: 2
      };
      var n,
        i,
        o = this;
      _isExceptionDetailsInternal(e) ? (o[_DYN_TYPE_NAME] = e[_DYN_TYPE_NAME], o[_DYN_MESSAGE$1] = e[_DYN_MESSAGE$1], o[strStack] = e[strStack], o[_DYN_PARSED_STACK] = e[_DYN_PARSED_STACK] || [], o[_DYN_HAS_FULL_STACK] = e[_DYN_HAS_FULL_STACK]) : (i = (n = e) && n.evt, isError(n) || (n = n[strError] || i || n), o[_DYN_TYPE_NAME] = dataSanitizeString(t, _getErrorType(n)) || strNotSpecified, o[_DYN_MESSAGE$1] = dataSanitizeMessage(t, _formatMessage(e || n, o[_DYN_TYPE_NAME])) || strNotSpecified, i = e[strStackDetails] || _getStackFromErrorObj(e), o[_DYN_PARSED_STACK] = _parseStack(i), isArray(o[_DYN_PARSED_STACK]) && arrMap(o[_DYN_PARSED_STACK], function (e) {
        e[_DYN_ASSEMBLY] = dataSanitizeString(t, e[_DYN_ASSEMBLY]), e[_DYN_FILE_NAME] = dataSanitizeString(t, e[_DYN_FILE_NAME]);
      }), o[strStack] = dataSanitizeException(t, _formatStackTrace(i)), o.hasFullStack = isArray(o.parsedStack) && 0 < o.parsedStack[_DYN_LENGTH$4], r && (r[_DYN_TYPE_NAME] = r[_DYN_TYPE_NAME] || o[_DYN_TYPE_NAME]));
    }
    return n.prototype.toInterface = function () {
      var e,
        t = this[_DYN_PARSED_STACK] instanceof Array && arrMap(this[_DYN_PARSED_STACK], function (e) {
          return e.toInterface();
        });
      return (e = {
        id: this.id,
        outerId: this.outerId,
        typeName: this[_DYN_TYPE_NAME],
        message: this[_DYN_MESSAGE$1],
        hasFullStack: this[_DYN_HAS_FULL_STACK],
        stack: this[strStack]
      })[_DYN_PARSED_STACK] = t || void 0, e;
    }, n.CreateFromInterface = function (e, t) {
      var r = t[_DYN_PARSED_STACK] instanceof Array && arrMap(t[_DYN_PARSED_STACK], function (e) {
        return _StackFrame[_DYN__CREATE_FROM_INTERFA1](e);
      }) || t[_DYN_PARSED_STACK];
      return new n(e, __assignFn(__assignFn({}, t), {
        parsedStack: r
      }));
    }, n;
  }(),
  _StackFrame = function () {
    function i(e, t) {
      this.aiDataContract = {
        level: 1,
        method: 1,
        assembly: 0,
        fileName: 0,
        line: 0
      };
      var r,
        n = this;
      n[_DYN_SIZE_IN_BYTES] = 0, "string" == typeof e ? (r = e, n[_DYN_LEVEL] = t, n[_DYN_METHOD$1] = NoMethod, n[_DYN_ASSEMBLY] = strTrim(r), n[_DYN_FILE_NAME] = "", n[_DYN_LINE] = 0, (t = r.match(i.regex)) && 5 <= t[_DYN_LENGTH$4] && (n[_DYN_METHOD$1] = strTrim(t[2]) || n[_DYN_METHOD$1], n[_DYN_FILE_NAME] = strTrim(t[4]), n[_DYN_LINE] = parseInt(t[5]) || 0)) : (n[_DYN_LEVEL] = e[_DYN_LEVEL], n[_DYN_METHOD$1] = e[_DYN_METHOD$1], n[_DYN_ASSEMBLY] = e[_DYN_ASSEMBLY], n[_DYN_FILE_NAME] = e[_DYN_FILE_NAME], n[_DYN_LINE] = e[_DYN_LINE], n[_DYN_SIZE_IN_BYTES] = 0), n.sizeInBytes += n.method[_DYN_LENGTH$4], n.sizeInBytes += n.fileName[_DYN_LENGTH$4], n.sizeInBytes += n.assembly[_DYN_LENGTH$4], n[_DYN_SIZE_IN_BYTES] += i.baseSize, n.sizeInBytes += n.level.toString()[_DYN_LENGTH$4], n.sizeInBytes += n.line.toString()[_DYN_LENGTH$4];
    }
    return i.CreateFromInterface = function (e) {
      return new i(e, null);
    }, i.prototype.toInterface = function () {
      return {
        level: this[_DYN_LEVEL],
        method: this[_DYN_METHOD$1],
        assembly: this[_DYN_ASSEMBLY],
        fileName: this[_DYN_FILE_NAME],
        line: this[_DYN_LINE]
      };
    }, i.regex = /^([\s]+at)?[\s]{0,50}([^\@\()]+?)[\s]{0,50}(\@|\()([^\(\n]+):([0-9]+):([0-9]+)(\)?)$/, i.baseSize = 58, i;
  }(),
  DataPoint = function () {
    this.aiDataContract = {
      name: 1,
      kind: 0,
      value: 1,
      count: 0,
      min: 0,
      max: 0,
      stdDev: 0
    }, this.kind = 0;
  },
  Metric = function () {
    function e(e, t, r, n, i, o, a, s, l) {
      this.aiDataContract = {
        ver: 1,
        metrics: 1,
        properties: 0
      };
      this.ver = 2;
      var c = new DataPoint();
      c[_DYN_COUNT$1] = 0 < n ? n : void 0, c.max = isNaN(o) || null === o ? void 0 : o, c.min = isNaN(i) || null === i ? void 0 : i, c[_DYN_NAME$2] = dataSanitizeString(e, t) || strNotSpecified, c.value = r, c.stdDev = isNaN(a) || null === a ? void 0 : a, this.metrics = [c], this[_DYN_PROPERTIES$1] = dataSanitizeProperties(e, s), this[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(e, l);
    }
    return e.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric", e.dataType = "MetricData", e;
  }(),
  strEmpty = "";
function msToTimeSpan(e) {
  (isNaN(e) || e < 0) && (e = 0), e = Math.round(e);
  var t = strEmpty + e % 1e3,
    r = strEmpty + Math.floor(e / 1e3) % 60,
    n = strEmpty + Math.floor(e / 6e4) % 60,
    i = strEmpty + Math.floor(e / 36e5) % 24,
    e = Math.floor(e / 864e5);
  return (0 < e ? e + "." : strEmpty) + (i[_DYN_LENGTH$4] < 2 ? "0" + i : i) + ":" + (n[_DYN_LENGTH$4] < 2 ? "0" + n : n) + ":" + (r[_DYN_LENGTH$4] < 2 ? "0" + r : r) + "." + (1 === t[_DYN_LENGTH$4] ? "00" + t : 2 === t[_DYN_LENGTH$4] ? "0" + t : t);
}
function isCrossOriginError(e, t, r, n, i) {
  return !i && isString(e) && ("Script error." === e || "Script error" === e);
}
var PageView = function () {
    function e(e, t, r, n, i, o, a) {
      this.aiDataContract = {
        ver: 1,
        name: 0,
        url: 0,
        duration: 0,
        properties: 0,
        measurements: 0,
        id: 0
      };
      this.ver = 2, this.id = dataSanitizeId(e, a), this.url = dataSanitizeUrl(e, r), this[_DYN_NAME$2] = dataSanitizeString(e, t) || strNotSpecified, isNaN(n) || (this[_DYN_DURATION$1] = msToTimeSpan(n)), this[_DYN_PROPERTIES$1] = dataSanitizeProperties(e, i), this[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(e, o);
    }
    return e.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview", e.dataType = "PageviewData", e;
  }(),
  RemoteDependencyData = function () {
    function e(e, t, r, n, i, o, a, s, l, c, u, h) {
      void 0 === l && (l = "Ajax"), this.aiDataContract = {
        id: 1,
        ver: 1,
        name: 0,
        resultCode: 0,
        duration: 0,
        success: 0,
        data: 0,
        target: 0,
        type: 0,
        properties: 0,
        measurements: 0,
        kind: 0,
        value: 0,
        count: 0,
        min: 0,
        max: 0,
        stdDev: 0,
        dependencyKind: 0,
        dependencySource: 0,
        commandName: 0,
        dependencyTypeName: 0
      };
      var d = this,
        t = (d.ver = 2, d.id = t, d[_DYN_DURATION$1] = msToTimeSpan(i), d.success = o, d.resultCode = a + "", d.type = dataSanitizeString(e, l), AjaxHelperParseDependencyPath(e, r, s, n));
      d.data = dataSanitizeUrl(e, n) || t.data, d.target = dataSanitizeString(e, t.target), c && (d.target = "".concat(d.target, " | ").concat(c)), d[_DYN_NAME$2] = dataSanitizeString(e, t[_DYN_NAME$2]), d[_DYN_PROPERTIES$1] = dataSanitizeProperties(e, u), d[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(e, h);
    }
    return e.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency", e.dataType = "RemoteDependencyData", e;
  }(),
  Trace = function () {
    function e(e, t, r, n, i) {
      this.aiDataContract = {
        ver: 1,
        message: 1,
        severityLevel: 0,
        properties: 0
      };
      this.ver = 2, this[_DYN_MESSAGE$1] = dataSanitizeMessage(e, t = t || strNotSpecified), this[_DYN_PROPERTIES$1] = dataSanitizeProperties(e, n), this[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(e, i), r && (this[_DYN_SEVERITY_LEVEL] = r);
    }
    return e.envelopeType = "Microsoft.ApplicationInsights.{0}.Message", e.dataType = "MessageData", e;
  }(),
  PageViewPerformance = function () {
    function e(e, t, r, n, i, o, a) {
      this.aiDataContract = {
        ver: 1,
        name: 0,
        url: 0,
        duration: 0,
        perfTotal: 0,
        networkConnect: 0,
        sentRequest: 0,
        receivedResponse: 0,
        domProcessing: 0,
        properties: 0,
        measurements: 0
      };
      var s = this;
      s.ver = 2, s.url = dataSanitizeUrl(e, r), s[_DYN_NAME$2] = dataSanitizeString(e, t) || strNotSpecified, s[_DYN_PROPERTIES$1] = dataSanitizeProperties(e, i), s[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(e, o), a && (s.domProcessing = a.domProcessing, s[_DYN_DURATION$1] = a[_DYN_DURATION$1], s.networkConnect = a.networkConnect, s.perfTotal = a.perfTotal, s[_DYN_RECEIVED_RESPONSE] = a[_DYN_RECEIVED_RESPONSE], s.sentRequest = a.sentRequest);
    }
    return e.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance", e.dataType = "PageviewPerformanceData", e;
  }(),
  Data = function (e, t) {
    this.aiDataContract = {
      baseType: 1,
      baseData: 1
    }, this.baseType = e, this.baseData = t;
  };
function _aiNameFunc(e) {
  var t = "ai." + e + ".";
  return function (e) {
    return t + e;
  };
}
var _aiApplication = _aiNameFunc("application"),
  _aiDevice = _aiNameFunc("device"),
  _aiLocation = _aiNameFunc("location"),
  _aiOperation = _aiNameFunc("operation"),
  _aiSession = _aiNameFunc("session"),
  _aiUser = _aiNameFunc("user"),
  _aiCloud = _aiNameFunc("cloud"),
  _aiInternal = _aiNameFunc("internal"),
  ContextTagKeys = function (e) {
    function t() {
      return e.call(this) || this;
    }
    return __extendsFn(t, e), t;
  }(createClassFromInterface({
    applicationVersion: _aiApplication("ver"),
    applicationBuild: _aiApplication("build"),
    applicationTypeId: _aiApplication("typeId"),
    applicationId: _aiApplication("applicationId"),
    applicationLayer: _aiApplication("layer"),
    deviceId: _aiDevice("id"),
    deviceIp: _aiDevice("ip"),
    deviceLanguage: _aiDevice("language"),
    deviceLocale: _aiDevice("locale"),
    deviceModel: _aiDevice("model"),
    deviceFriendlyName: _aiDevice("friendlyName"),
    deviceNetwork: _aiDevice("network"),
    deviceNetworkName: _aiDevice("networkName"),
    deviceOEMName: _aiDevice("oemName"),
    deviceOS: _aiDevice("os"),
    deviceOSVersion: _aiDevice("osVersion"),
    deviceRoleInstance: _aiDevice("roleInstance"),
    deviceRoleName: _aiDevice("roleName"),
    deviceScreenResolution: _aiDevice("screenResolution"),
    deviceType: _aiDevice("type"),
    deviceMachineName: _aiDevice("machineName"),
    deviceVMName: _aiDevice("vmName"),
    deviceBrowser: _aiDevice("browser"),
    deviceBrowserVersion: _aiDevice("browserVersion"),
    locationIp: _aiLocation("ip"),
    locationCountry: _aiLocation("country"),
    locationProvince: _aiLocation("province"),
    locationCity: _aiLocation("city"),
    operationId: _aiOperation("id"),
    operationName: _aiOperation("name"),
    operationParentId: _aiOperation("parentId"),
    operationRootId: _aiOperation("rootId"),
    operationSyntheticSource: _aiOperation("syntheticSource"),
    operationCorrelationVector: _aiOperation("correlationVector"),
    sessionId: _aiSession("id"),
    sessionIsFirst: _aiSession("isFirst"),
    sessionIsNew: _aiSession("isNew"),
    userAccountAcquisitionDate: _aiUser("accountAcquisitionDate"),
    userAccountId: _aiUser("accountId"),
    userAgent: _aiUser("userAgent"),
    userId: _aiUser("id"),
    userStoreRegion: _aiUser("storeRegion"),
    userAuthUserId: _aiUser("authUserId"),
    userAnonymousUserAcquisitionDate: _aiUser("anonUserAcquisitionDate"),
    userAuthenticatedUserAcquisitionDate: _aiUser("authUserAcquisitionDate"),
    cloudName: _aiCloud("name"),
    cloudRole: _aiCloud("role"),
    cloudRoleVer: _aiCloud("roleVer"),
    cloudRoleInstance: _aiCloud("roleInstance"),
    cloudEnvironment: _aiCloud("environment"),
    cloudLocation: _aiCloud("location"),
    cloudDeploymentUnit: _aiCloud("deploymentUnit"),
    internalNodeName: _aiInternal("nodeName"),
    internalSdkVersion: _aiInternal("sdkVersion"),
    internalAgentVersion: _aiInternal("agentVersion"),
    internalSnippet: _aiInternal("snippet"),
    internalSdkSrc: _aiInternal("sdkSrc")
  }));
function createTelemetryItem(e, t, r, n, i, o) {
  r = dataSanitizeString(n, r) || strNotSpecified, (isNullOrUndefined(e) || isNullOrUndefined(t) || isNullOrUndefined(r)) && throwError("Input doesn't contain all required fields");
  var a,
    n = "",
    s = (e[strIkey] && (n = e[strIkey], delete e[strIkey]), (a = {})[_DYN_NAME$2] = r, a.time = toISOString(new Date()), a.iKey = n, a.ext = o || {}, a.tags = [], a.data = {}, a.baseType = t, a.baseData = e, a);
  return isNullOrUndefined(i) || objForEachKey(i, function (e, t) {
    s.data[e] = t;
  }), s;
}
var Extensions = {
    UserExt: "user",
    DeviceExt: "device",
    TraceExt: "trace",
    WebExt: "web",
    AppExt: "app",
    OSExt: "os",
    SessionExt: "ses",
    SDKExt: "sdk"
  },
  CtxTagKeys = new ContextTagKeys();
function createDomEvent(e) {
  var t,
    r = null;
  return isFunction(Event) ? r = new Event(e) : (t = getDocument()) && t.createEvent && (r = t.createEvent("Event")).initEvent(e, !0, !0), r;
}
var PropertiesPluginIdentifier = "AppInsightsPropertiesPlugin",
  BreezeChannelIdentifier = "AppInsightsChannelPlugin",
  AnalyticsPluginIdentifier = "ApplicationInsightsAnalytics",
  _DYN_TO_STRING$1 = "toString",
  _DYN_IS_STORAGE_USE_DISAB0 = "isStorageUseDisabled",
  _DYN__ADD_HOOK$1 = "_addHook",
  _DYN_CORE$1 = "core",
  _DYN_DATA_TYPE$1 = "dataType",
  _DYN_ENVELOPE_TYPE$1 = "envelopeType",
  _DYN_DIAG_LOG$1 = "diagLog",
  _DYN_TRACK = "track",
  _DYN_TRACK_PAGE_VIEW = "trackPageView",
  _DYN_TRACK_PREVIOUS_PAGE_1 = "trackPreviousPageVisit",
  _DYN_SEND_PAGE_VIEW_INTER2 = "sendPageViewInternal",
  _DYN_START_TIME$1 = "startTime",
  _DYN_PROPERTIES = "properties",
  _DYN_DURATION = "duration",
  _DYN_SEND_PAGE_VIEW_PERFO3 = "sendPageViewPerformanceInternal",
  _DYN_POPULATE_PAGE_VIEW_P4 = "populatePageViewPerformanceEvent",
  _DYN_HREF = "href",
  _DYN_SEND_EXCEPTION_INTER5 = "sendExceptionInternal",
  _DYN_EXCEPTION$1 = "exception",
  _DYN_ERROR = "error",
  _DYN__ONERROR = "_onerror",
  _DYN_ERROR_SRC = "errorSrc",
  _DYN_LINE_NUMBER = "lineNumber",
  _DYN_COLUMN_NUMBER = "columnNumber",
  _DYN_MESSAGE = "message",
  _DYN__CREATE_AUTO_EXCEPTI6 = "CreateAutoException",
  _DYN_ADD_TELEMETRY_INITIA7 = "addTelemetryInitializer",
  _DYN_OVERRIDE_PAGE_VIEW_D8 = "overridePageViewDuration",
  _DYN_AUTO_TRACK_PAGE_VISI9 = "autoTrackPageVisitTime",
  _DYN_IS_BROWSER_LINK_TRAC10 = "isBrowserLinkTrackingEnabled",
  _DYN_LENGTH$3 = "length",
  _DYN_ENABLE_AUTO_ROUTE_TR11 = "enableAutoRouteTracking",
  _DYN_ENABLE_UNHANDLED_PRO12 = "enableUnhandledPromiseRejectionTracking",
  _DYN_AUTO_UNHANDLED_PROMI13 = "autoUnhandledPromiseInstrumented",
  _DYN_GET_ENTRIES_BY_TYPE = "getEntriesByType",
  _DYN_IS_PERFORMANCE_TIMIN14 = "isPerformanceTimingSupported",
  _DYN_GET_PERFORMANCE_TIMI15 = "getPerformanceTiming",
  _DYN_NAVIGATION_START = "navigationStart",
  _DYN_SHOULD_COLLECT_DURAT16 = "shouldCollectDuration",
  _DYN_IS_PERFORMANCE_TIMIN17 = "isPerformanceTimingDataReady",
  _DYN_RESPONSE_START = "responseStart",
  _DYN_REQUEST_START = "requestStart",
  _DYN_LOAD_EVENT_END = "loadEventEnd",
  _DYN_RESPONSE_END = "responseEnd",
  _DYN_CONNECT_END = "connectEnd",
  _DYN_PAGE_VISIT_START_TIM18 = "pageVisitStartTime",
  PageViewManager = function () {
    function e(_, m, t, g) {
      dynamicProto(e, this, function (e) {
        var u,
          n = null,
          i = [],
          h = !1,
          d = !1;
        function p(e) {
          t && t.flush(e, function () {});
        }
        function f(e) {
          i.push(e), function r() {
            n = n || scheduleTimeout(function () {
              n = null;
              var e = i.slice(0),
                t = !1;
              i = [], arrForEach(e, function (e) {
                e() ? t = !0 : i.push(e);
              }), 0 < i[_DYN_LENGTH$3] && r(), t && p(!0);
            }, 100);
          }();
        }
        t && (u = t.logger), e[_DYN_TRACK_PAGE_VIEW] = function (r, n) {
          var e,
            t,
            i,
            o,
            a,
            s,
            l = r.name,
            c = (!isNullOrUndefined(l) && "string" == typeof l || (t = getDocument(), l = r.name = t && t.title || ""), r.uri);
          !isNullOrUndefined(c) && "string" == typeof c || (t = getLocation(), c = r.uri = t && t[_DYN_HREF] || ""), d || ((e = (t = getPerformance()) && t[_DYN_GET_ENTRIES_BY_TYPE] && t[_DYN_GET_ENTRIES_BY_TYPE]("navigation")) && e[0] && !isUndefined(t.timeOrigin) ? (e = e[0].loadEventStart, r[_DYN_START_TIME$1] = new Date(t.timeOrigin + e)) : (t = (n || r[_DYN_PROPERTIES] || {})[_DYN_DURATION] || 0, r[_DYN_START_TIME$1] = new Date(new Date().getTime() - t)), d = !0), g[_DYN_IS_PERFORMANCE_TIMIN14]() ? (i = !1, a = g[_DYN_GET_PERFORMANCE_TIMI15]()[_DYN_NAVIGATION_START], 0 < a && (o = dateTimeUtilsDuration(a, +new Date()), g[_DYN_SHOULD_COLLECT_DURAT16](o) || (o = void 0)), isNullOrUndefined(n) || isNullOrUndefined(n[_DYN_DURATION]) || (s = n[_DYN_DURATION]), !m && isNaN(s) || (isNaN(s) && ((n = n || {})[_DYN_DURATION] = o), _[_DYN_SEND_PAGE_VIEW_INTER2](r, n), p(!0), i = !0), n = n || {}, f(function () {
            var e,
              t = !1;
            try {
              g[_DYN_IS_PERFORMANCE_TIMIN17]() ? (t = !0, e = {
                name: l,
                uri: c
              }, g[_DYN_POPULATE_PAGE_VIEW_P4](e), e.isValid || i ? (i || (n[_DYN_DURATION] = e.durationMs, _[_DYN_SEND_PAGE_VIEW_INTER2](r, n)), h || (_[_DYN_SEND_PAGE_VIEW_PERFO3](e, n), h = !0)) : (n[_DYN_DURATION] = o, _[_DYN_SEND_PAGE_VIEW_INTER2](r, n))) : 0 < a && 6e4 < dateTimeUtilsDuration(a, +new Date()) && (t = !0, i || (n[_DYN_DURATION] = 6e4, _[_DYN_SEND_PAGE_VIEW_INTER2](r, n)));
            } catch (e) {
              _throwInternal(u, 1, 38, "trackPageView failed on page load calculation: " + getExceptionName(e), {
                exception: dumpObj(e)
              });
            }
            return t;
          })) : (_[_DYN_SEND_PAGE_VIEW_INTER2](r, n), p(!0), isWebWorker() || _throwInternal(u, 2, 25, "trackPageView: navigation timing API used for calculation of page duration is not supported in this browser. This page view will be collected without duration and timing info."));
        }, e.teardown = function (e, t) {
          var r;
          n && (n.cancel(), n = null, r = i.slice(0), i = [], arrForEach(r, function (e) {
            e();
          }));
        };
      });
    }
    return e.__ieDyn = 1, e;
  }(),
  MAX_DURATION_ALLOWED = 36e5,
  botAgentNames = ["googlebot", "adsbot-google", "apis-google", "mediapartners-google"];
function _isPerformanceTimingSupported() {
  var e = getPerformance();
  return e && !!e.timing;
}
function _isPerformanceNavigationTimingSupported() {
  var e = getPerformance();
  return e && e.getEntriesByType && 0 < e.getEntriesByType("navigation")[_DYN_LENGTH$3];
}
function _isPerformanceTimingDataReady() {
  var e = getPerformance(),
    e = e ? e.timing : 0;
  return e && 0 < e.domainLookupStart && 0 < e[_DYN_NAVIGATION_START] && 0 < e[_DYN_RESPONSE_START] && 0 < e[_DYN_REQUEST_START] && 0 < e[_DYN_LOAD_EVENT_END] && 0 < e[_DYN_RESPONSE_END] && 0 < e[_DYN_CONNECT_END] && 0 < e.domLoading;
}
function _getPerformanceTiming() {
  return _isPerformanceTimingSupported() ? getPerformance().timing : null;
}
function _getPerformanceNavigationTiming() {
  return _isPerformanceNavigationTimingSupported() ? getPerformance()[_DYN_GET_ENTRIES_BY_TYPE]("navigation")[0] : null;
}
function _shouldCollectDuration() {
  for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
  var r = (getNavigator() || {}).userAgent,
    n = !1;
  if (r) for (var i = 0; i < botAgentNames[_DYN_LENGTH$3]; i++) n = n || -1 !== strIndexOf(r.toLowerCase(), botAgentNames[i]);
  if (n) return !1;
  for (i = 0; i < e[_DYN_LENGTH$3]; i++) if (e[i] < 0 || MAX_DURATION_ALLOWED <= e[i]) return !1;
  return !0;
}
var _a$5,
  PageViewPerformanceManager = function () {
    function t(e) {
      var c = safeGetLogger(e);
      dynamicProto(t, this, function (l) {
        l[_DYN_POPULATE_PAGE_VIEW_P4] = function (e) {
          e.isValid = !1;
          var t = _getPerformanceNavigationTiming(),
            r = _getPerformanceTiming(),
            n = 0,
            i = 0,
            o = 0,
            a = 0,
            s = 0;
          (t || r) && (s = t ? (n = t[_DYN_DURATION], i = 0 === t[_DYN_START_TIME$1] ? t[_DYN_CONNECT_END] : dateTimeUtilsDuration(t[_DYN_START_TIME$1], t[_DYN_CONNECT_END]), o = dateTimeUtilsDuration(t.requestStart, t[_DYN_RESPONSE_START]), a = dateTimeUtilsDuration(t[_DYN_RESPONSE_START], t[_DYN_RESPONSE_END]), dateTimeUtilsDuration(t.responseEnd, t[_DYN_LOAD_EVENT_END])) : (n = dateTimeUtilsDuration(r[_DYN_NAVIGATION_START], r[_DYN_LOAD_EVENT_END]), i = dateTimeUtilsDuration(r[_DYN_NAVIGATION_START], r[_DYN_CONNECT_END]), o = dateTimeUtilsDuration(r.requestStart, r[_DYN_RESPONSE_START]), a = dateTimeUtilsDuration(r[_DYN_RESPONSE_START], r[_DYN_RESPONSE_END]), dateTimeUtilsDuration(r.responseEnd, r[_DYN_LOAD_EVENT_END])), 0 === n ? _throwInternal(c, 2, 10, "error calculating page view performance.", {
            total: n,
            network: i,
            request: o,
            response: a,
            dom: s
          }) : l[_DYN_SHOULD_COLLECT_DURAT16](n, i, o, a, s) ? n < Math.floor(i) + Math.floor(o) + Math.floor(a) + Math.floor(s) ? _throwInternal(c, 2, 8, "client performance math error.", {
            total: n,
            network: i,
            request: o,
            response: a,
            dom: s
          }) : (e.durationMs = n, e.perfTotal = e[_DYN_DURATION] = msToTimeSpan(n), e.networkConnect = msToTimeSpan(i), e.sentRequest = msToTimeSpan(o), e.receivedResponse = msToTimeSpan(a), e.domProcessing = msToTimeSpan(s), e.isValid = !0) : _throwInternal(c, 2, 45, "Invalid page load duration value. Browser perf data won't be sent.", {
            total: n,
            network: i,
            request: o,
            response: a,
            dom: s
          }));
        }, l[_DYN_GET_PERFORMANCE_TIMI15] = _getPerformanceTiming, l[_DYN_IS_PERFORMANCE_TIMIN14] = _isPerformanceTimingSupported, l[_DYN_IS_PERFORMANCE_TIMIN17] = _isPerformanceTimingDataReady, l[_DYN_SHOULD_COLLECT_DURAT16] = _shouldCollectDuration;
      });
    }
    return t.__ieDyn = 1, t;
  }(),
  PageVisitTimeManager = function () {
    function e(i, n) {
      var o = "prevPageVisitData";
      dynamicProto(e, this, function (e) {
        e[_DYN_TRACK_PREVIOUS_PAGE_1] = function (e, t) {
          try {
            var r = function (e, t) {
              var r = null;
              try {
                var n;
                r = function () {
                  var t = null;
                  try {
                    var e, r;
                    utlCanUseSessionStorage() && (e = utcNow(), r = utlGetSessionStorage(i, o)) && hasJSON() && ((t = getJSON().parse(r)).pageVisitTime = e - t[_DYN_PAGE_VISIT_START_TIM18], utlRemoveSessionStorage(i, o));
                  } catch (e) {
                    _warnToConsole(i, "Stop page visit timer failed: " + dumpObj(e)), t = null;
                  }
                  return t;
                }(), utlCanUseSessionStorage() && (null != utlGetSessionStorage(i, o) && throwError("Cannot call startPageVisit consecutively without first calling stopPageVisit"), n = getJSON().stringify(new PageVisitData(e, t)), utlSetSessionStorage(i, o, n));
              } catch (e) {
                _warnToConsole(i, "Call to restart failed: " + dumpObj(e)), r = null;
              }
              return r;
            }(e, t);
            r && n(r.pageName, r.pageUrl, r.pageVisitTime);
          } catch (e) {
            _warnToConsole(i, "Auto track page visit time failed, metric will not be collected: " + dumpObj(e));
          }
        }, objDefine(e, "_logger", {
          g: function () {
            return i;
          }
        }), objDefine(e, "pageVisitTimeTrackingHandler", {
          g: function () {
            return n;
          }
        });
      });
    }
    return e.__ieDyn = 1, e;
  }(),
  PageVisitData = function (e, t) {
    this[_DYN_PAGE_VISIT_START_TIM18] = utcNow(), this.pageName = e, this.pageUrl = t;
  },
  Timing = function (o, e) {
    var a = this,
      s = {};
    a.start = function (e) {
      void 0 !== s[e] && _throwInternal(o, 2, 62, "start was called more than once for this event without calling stop.", {
        name: e,
        key: e
      }, !0), s[e] = +new Date();
    }, a.stop = function (e, t, r, n) {
      var i = s[e];
      isNaN(i) ? _throwInternal(o, 2, 63, "stop was called without a corresponding start.", {
        name: e,
        key: e
      }, !0) : (i = dateTimeUtilsDuration(i, +new Date()), a.action(e, t, i, r, n)), delete s[e], s[e] = void 0;
    };
  },
  strEvent = "event";
function _dispatchEvent(e, t) {
  e && e.dispatchEvent && t && e.dispatchEvent(t);
}
function _getReason(e) {
  var t;
  return e && e.reason ? (t = e.reason, !isString(t) && isFunction(t[_DYN_TO_STRING$1]) ? t[_DYN_TO_STRING$1]() : dumpObj(t)) : e || "";
}
var MinMilliSeconds = 6e4,
  defaultValues = objDeepFreeze(((_a$5 = {
    sessionRenewalMs: cfgDfSet(_chkConfigMilliseconds, 18e5),
    sessionExpirationMs: cfgDfSet(_chkConfigMilliseconds, 864e5),
    disableExceptionTracking: cfgDfBoolean()
  })[_DYN_AUTO_TRACK_PAGE_VISI9] = cfgDfBoolean(), _a$5[_DYN_OVERRIDE_PAGE_VIEW_D8] = cfgDfBoolean(), _a$5[_DYN_ENABLE_UNHANDLED_PRO12] = cfgDfBoolean(), _a$5[_DYN_AUTO_UNHANDLED_PROMI13] = !1, _a$5.samplingPercentage = cfgDfValidate(_chkSampling$1, 100), _a$5[_DYN_IS_STORAGE_USE_DISAB0] = cfgDfBoolean(), _a$5[_DYN_IS_BROWSER_LINK_TRAC10] = cfgDfBoolean(), _a$5[_DYN_ENABLE_AUTO_ROUTE_TR11] = cfgDfBoolean(), _a$5.namePrefix = cfgDfString(), _a$5.enableDebug = cfgDfBoolean(), _a$5.disableFlushOnBeforeUnload = cfgDfBoolean(), _a$5.disableFlushOnUnload = cfgDfBoolean(!1, "disableFlushOnBeforeUnload"), _a$5));
function _chkConfigMilliseconds(e, t) {
  return +(e = (e = e || t) < MinMilliSeconds ? MinMilliSeconds : e);
}
function _chkSampling$1(e) {
  return !isNaN(e) && 0 < e && e <= 100;
}
function _updateStorageUsage(e) {
  isUndefined(e[_DYN_IS_STORAGE_USE_DISAB0]) || (e[_DYN_IS_STORAGE_USE_DISAB0] ? utlDisableStorage : utlEnableStorage)();
}
var AnalyticsPlugin = function (t) {
    function r() {
      var m,
        g,
        y,
        v,
        E,
        b,
        w,
        T,
        S,
        x,
        C,
        A,
        I,
        N,
        P,
        D,
        R,
        O,
        M,
        e = t.call(this) || this;
      return e.identifier = AnalyticsPluginIdentifier, e.priority = 180, e.autoRoutePVDelay = 500, dynamicProto(r, e, function (p, f) {
        var _ = f[_DYN__ADD_HOOK$1];
        function c(e, t, r, n, i) {
          p[_DYN_DIAG_LOG$1]().throwInternal(e, t, r, n, i);
        }
        function r() {
          b = E = v = y = g = m = null;
          var e = getLocation(!(D = N = I = A = C = x = S = T = w = !1));
          R = e && e[_DYN_HREF] || "", P = M = O = null, objDefine(p, "config", {
            g: function () {
              return P;
            }
          });
        }
        r(), p.getCookieMgr = function () {
          return safeGetCookieMgr(p[_DYN_CORE$1]);
        }, p.processTelemetry = function (e, t) {
          p.processNext(e, t);
        }, p.trackEvent = function (e, t) {
          try {
            var r = createTelemetryItem(e, Event$1[_DYN_DATA_TYPE$1], Event$1[_DYN_ENVELOPE_TYPE$1], p[_DYN_DIAG_LOG$1](), t);
            p[_DYN_CORE$1][_DYN_TRACK](r);
          } catch (e) {
            c(2, 39, "trackTrace failed, trace will not be collected: " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
        }, p.startTrackEvent = function (e) {
          try {
            m.start(e);
          } catch (e) {
            c(1, 29, "startTrackEvent failed, event will not be collected: " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
        }, p.stopTrackEvent = function (e, t, r) {
          try {
            m.stop(e, void 0, t, r);
          } catch (e) {
            c(1, 30, "stopTrackEvent failed, event will not be collected: " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
        }, p.trackTrace = function (e, t) {
          try {
            var r = createTelemetryItem(e, Trace[_DYN_DATA_TYPE$1], Trace[_DYN_ENVELOPE_TYPE$1], p[_DYN_DIAG_LOG$1](), t);
            p[_DYN_CORE$1][_DYN_TRACK](r);
          } catch (e) {
            c(2, 39, "trackTrace failed, trace will not be collected: " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
        }, p.trackMetric = function (e, t) {
          try {
            var r = createTelemetryItem(e, Metric[_DYN_DATA_TYPE$1], Metric[_DYN_ENVELOPE_TYPE$1], p[_DYN_DIAG_LOG$1](), t);
            p[_DYN_CORE$1][_DYN_TRACK](r);
          } catch (e) {
            c(1, 36, "trackMetric failed, metric will not be collected: " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
        }, p[_DYN_TRACK_PAGE_VIEW] = function (e, t) {
          try {
            var r = e || {};
            y[_DYN_TRACK_PAGE_VIEW](r, __assignFn(__assignFn(__assignFn({}, r.properties), r.measurements), t)), D && E[_DYN_TRACK_PREVIOUS_PAGE_1](r.name, r.uri);
          } catch (e) {
            c(1, 37, "trackPageView failed, page view will not be collected: " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
        }, p[_DYN_SEND_PAGE_VIEW_INTER2] = function (e, t, r) {
          var n = getDocument(),
            n = (n && (e.refUri = void 0 === e.refUri ? n.referrer : e.refUri), isNullOrUndefined(e[_DYN_START_TIME$1]) && (n = (t || e[_DYN_PROPERTIES] || {})[_DYN_DURATION] || 0, e[_DYN_START_TIME$1] = new Date(new Date().getTime() - n)), createTelemetryItem(e, PageView[_DYN_DATA_TYPE$1], PageView[_DYN_ENVELOPE_TYPE$1], p[_DYN_DIAG_LOG$1](), t, r));
          p[_DYN_CORE$1][_DYN_TRACK](n);
        }, p[_DYN_SEND_PAGE_VIEW_PERFO3] = function (e, t, r) {
          e = createTelemetryItem(e, PageViewPerformance[_DYN_DATA_TYPE$1], PageViewPerformance[_DYN_ENVELOPE_TYPE$1], p[_DYN_DIAG_LOG$1](), t, r);
          p[_DYN_CORE$1][_DYN_TRACK](e);
        }, p.trackPageViewPerformance = function (e, t) {
          e = e || {};
          try {
            v[_DYN_POPULATE_PAGE_VIEW_P4](e), p[_DYN_SEND_PAGE_VIEW_PERFO3](e, t);
          } catch (e) {
            c(1, 37, "trackPageViewPerformance failed, page view will not be collected: " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
        }, p.startTrackPage = function (e) {
          try {
            var t;
            "string" != typeof e && (e = (t = getDocument()) && t.title || ""), g.start(e);
          } catch (e) {
            c(1, 31, "startTrackPage failed, page view may not be collected: " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
        }, p.stopTrackPage = function (e, t, r, n) {
          try {
            var i, o;
            "string" != typeof e && (e = (i = getDocument()) && i.title || ""), "string" != typeof t && (t = (o = getLocation()) && o[_DYN_HREF] || ""), g.stop(e, t, r, n), D && E[_DYN_TRACK_PREVIOUS_PAGE_1](e, t);
          } catch (e) {
            c(1, 32, "stopTrackPage failed, page view will not be collected: " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
        }, p[_DYN_SEND_EXCEPTION_INTER5] = function (e, t, r) {
          var n = e && (e[_DYN_EXCEPTION$1] || e[_DYN_ERROR]) || isError(e) && e || {
            name: e && typeof e,
            message: e || strNotSpecified
          };
          e = e || {};
          n = createTelemetryItem(new Exception(p[_DYN_DIAG_LOG$1](), n, e[_DYN_PROPERTIES] || t, e.measurements, e.severityLevel, e.id).toInterface(), Exception[_DYN_DATA_TYPE$1], Exception[_DYN_ENVELOPE_TYPE$1], p[_DYN_DIAG_LOG$1](), t, r);
          p[_DYN_CORE$1][_DYN_TRACK](n);
        }, p.trackException = function (e, t) {
          e && !e[_DYN_EXCEPTION$1] && e[_DYN_ERROR] && (e[_DYN_EXCEPTION$1] = e[_DYN_ERROR]);
          try {
            p[_DYN_SEND_EXCEPTION_INTER5](e, t);
          } catch (e) {
            c(1, 35, "trackException failed, exception will not be collected: " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
        }, p[_DYN__ONERROR] = function (e) {
          var t = e && e[_DYN_ERROR],
            r = e && e.evt;
          try {
            r || (l = getWindow()) && (r = l[strEvent]);
            var n,
              i,
              o = e && e.url || (getDocument() || {}).URL,
              a = e[_DYN_ERROR_SRC] || "window.onerror@" + o + ":" + (e[_DYN_LINE_NUMBER] || 0) + ":" + (e[_DYN_COLUMN_NUMBER] || 0),
              s = {
                errorSrc: a,
                url: o,
                lineNumber: e[_DYN_LINE_NUMBER] || 0,
                columnNumber: e[_DYN_COLUMN_NUMBER] || 0,
                message: e[_DYN_MESSAGE]
              };
            isCrossOriginError(e.message, e.url, e.lineNumber, e.columnNumber, e[_DYN_ERROR]) ? (n = Exception[_DYN__CREATE_AUTO_EXCEPTI6]("Script error: The browser's same-origin policy prevents us from getting the details of this exception. Consider using the 'crossorigin' attribute.", o, e[_DYN_LINE_NUMBER] || 0, e[_DYN_COLUMN_NUMBER] || 0, t, r, null, a), i = s, n = createTelemetryItem(n, Exception[_DYN_DATA_TYPE$1], Exception[_DYN_ENVELOPE_TYPE$1], p[_DYN_DIAG_LOG$1](), i), p[_DYN_CORE$1][_DYN_TRACK](n)) : (e[_DYN_ERROR_SRC] || (e[_DYN_ERROR_SRC] = a), p.trackException({
              exception: e,
              severityLevel: 3
            }, s));
          } catch (e) {
            var l = t ? t.name + ", " + t[_DYN_MESSAGE] : "null";
            c(1, 11, "_onError threw exception while logging error, error will not be collected: " + getExceptionName(e), {
              exception: dumpObj(e),
              errorString: l
            });
          }
        }, p[_DYN_ADD_TELEMETRY_INITIA7] = function (e) {
          if (p[_DYN_CORE$1]) return p[_DYN_CORE$1][_DYN_ADD_TELEMETRY_INITIA7](e);
          (b = b || []).push(e);
        }, p.initialize = function (e, t, r, n) {
          if (!p.isInitialized()) {
            isNullOrUndefined(t) && throwError("Error initializing"), f.initialize(e, t, r, n);
            try {
              var i, o;
              M = mergeEvtNamespace(createUniqueNamespace(p.identifier), t.evtNamespace && t.evtNamespace()), b && (arrForEach(b, function (e) {
                t[_DYN_ADD_TELEMETRY_INITIA7](e);
              }), b = null), u = e, h = p.identifier, d = p[_DYN_CORE$1], p[_DYN__ADD_HOOK$1](onConfigChange(u, function () {
                var n,
                  e = createProcessTelemetryContext(null, u, d);
                P = e.getExtCfg(h, defaultValues), D = P[_DYN_AUTO_TRACK_PAGE_VISI9], u.storagePrefix && utlSetStoragePrefix(u.storagePrefix), _updateStorageUsage(P), w = P[_DYN_IS_BROWSER_LINK_TRAC10], !T && w && (n = ["/browserLinkSignalR/", "/__browserLink/"], p[_DYN__ADD_HOOK$1](p[_DYN_ADD_TELEMETRY_INITIA7](function (e) {
                  if (w && e.baseType === RemoteDependencyData[_DYN_DATA_TYPE$1]) {
                    var t = e.baseData;
                    if (t) for (var r = 0; r < n[_DYN_LENGTH$3]; r++) if (t.target && 0 <= strIndexOf(t.target, n[r])) return !1;
                  }
                  return !0;
                })), T = !0);
              })), v = new PageViewPerformanceManager(p[_DYN_CORE$1]), y = new PageViewManager(p, P.overridePageViewDuration, p[_DYN_CORE$1], v), E = new PageVisitTimeManager(p[_DYN_DIAG_LOG$1](), function (e, t, r) {
                var n = e;
                n = {
                  PageName: e,
                  PageUrl: t
                }, p.trackMetric({
                  name: "PageVisitTime",
                  average: r,
                  max: r,
                  min: r,
                  sampleCount: 1
                }, n);
              }), (m = new Timing(p[_DYN_DIAG_LOG$1](), "trackEvent")).action = function (e, t, r, n, i) {
                i = i || {}, (n = n || {}).duration = r[_DYN_TO_STRING$1](), p.trackEvent({
                  name: e,
                  properties: n,
                  measurements: i
                });
              }, (g = new Timing(p[_DYN_DIAG_LOG$1](), "trackPageView")).action = function (e, t, r, n, i) {
                (n = isNullOrUndefined(n) ? {} : n).duration = r[_DYN_TO_STRING$1](), p[_DYN_SEND_PAGE_VIEW_INTER2]({
                  name: e,
                  uri: t,
                  properties: n,
                  measurements: i
                }, n);
              }, hasWindow() && (l = getWindow(), c = getLocation(!0), p[_DYN__ADD_HOOK$1](onConfigChange(P, function () {
                (C = P.disableExceptionTracking) || A || P.autoExceptionInstrumented || (_(InstrumentEvent(l, "onerror", {
                  ns: M,
                  rsp: function (e, t, r, n, i, o) {
                    C || !0 === e.rslt || p[_DYN__ONERROR](Exception[_DYN__CREATE_AUTO_EXCEPTI6](t, r, n, i, o, e.evt));
                  }
                }, !1)), A = !0);
              })), i = l, o = c, p[_DYN__ADD_HOOK$1](onConfigChange(P, function () {
                I = !0 === P[_DYN_ENABLE_UNHANDLED_PRO12], A = A || P[_DYN_AUTO_UNHANDLED_PROMI13], I && !N && (_(InstrumentEvent(i, "onunhandledrejection", {
                  ns: M,
                  rsp: function (e, t) {
                    I && !0 !== e.rslt && p[_DYN__ONERROR](Exception[_DYN__CREATE_AUTO_EXCEPTI6](_getReason(t), o ? o[_DYN_HREF] : "", 0, 0, t, e.evt));
                  }
                }, !1)), P[_DYN_AUTO_UNHANDLED_PROMI13] = N = !0);
              })), a = getWindow(), s = getLocation(!0), p[_DYN__ADD_HOOK$1](onConfigChange(P, function () {
                var e, t, r, n;
                S = !0 === P[_DYN_ENABLE_AUTO_ROUTE_TR11], a && S && !x && hasHistory() && (t = getHistory(), isFunction(t.pushState)) && isFunction(t.replaceState) && typeof Event !== strShimUndefined && (e = a, t = t, r = s, x || (n = P.namePrefix || "", _(InstrumentEvent(t, "pushState", {
                  ns: M,
                  rsp: function () {
                    S && (_dispatchEvent(e, createDomEvent(n + "pushState")), _dispatchEvent(e, createDomEvent(n + "locationchange")));
                  }
                }, !0)), _(InstrumentEvent(t, "replaceState", {
                  ns: M,
                  rsp: function () {
                    S && (_dispatchEvent(e, createDomEvent(n + "replaceState")), _dispatchEvent(e, createDomEvent(n + "locationchange")));
                  }
                }, !0)), eventOn(e, n + "popstate", function () {
                  S && _dispatchEvent(e, createDomEvent(n + "locationchange"));
                }, M), eventOn(e, n + "locationchange", function () {
                  O = (O && (R = O), r && r[_DYN_HREF] || "");
                  {
                    var e, t;
                    S && ((e = function () {
                      var e = null;
                      p[_DYN_CORE$1] && p[_DYN_CORE$1].getTraceCtx && (e = p[_DYN_CORE$1].getTraceCtx(!1));
                      {
                        var t;
                        e || (t = p[_DYN_CORE$1].getPlugin(PropertiesPluginIdentifier)) && (t = t.plugin.context) && (e = createDistributedTraceContextFromTrace(t.telemetryTrace));
                      }
                      return e;
                    }()) && (e.setTraceId(generateW3CId()), t = "_unknown_", r && r.pathname && (t = r.pathname + (r.hash || "")), e.setName(dataSanitizeString(p[_DYN_DIAG_LOG$1](), t))), scheduleTimeout(function (e) {
                      p[_DYN_TRACK_PAGE_VIEW]({
                        refUri: e,
                        properties: {
                          duration: 0
                        }
                      });
                    }.bind(p, R), p.autoRoutePVDelay));
                  }
                }, M), x = !0));
              })));
            } catch (e) {
              throw p.setInitialized(!1), e;
            }
            var a, s, l, c, u, h, d;
          }
        }, p._doTeardown = function (e, t) {
          y && y.teardown(e, t), eventOff(window, null, null, M), r();
        }, objDefine(p, "_pageViewManager", {
          g: function () {
            return y;
          }
        }), objDefine(p, "_pageViewPerformanceManager", {
          g: function () {
            return v;
          }
        }), objDefine(p, "_pageVisitTimeManager", {
          g: function () {
            return E;
          }
        }), objDefine(p, "_evtNamespace", {
          g: function () {
            return "." + M;
          }
        });
      }), e;
    }
    return __extendsFn(r, t), r.Version = "3.0.7", r;
  }(BaseTelemetryPlugin),
  _DYN_FEATURE_OPT_IN = "featureOptIn",
  _DYN_ON_CFG_CHANGE_RECEIV0 = "onCfgChangeReceive",
  _DYN_NON_OVERRIDE_CONFIGS = "nonOverrideConfigs",
  _DYN_SCHEDULE_FETCH_TIMEO1 = "scheduleFetchTimeout";
function replaceByNonOverrideCfg(e, r, n, i) {
  try {
    var t = i < n,
      o = (t && (e = null), 0 == n ? objExtend$1({}, e) : e);
    return o && r && !t && objForEachKey(o, function (e) {
      var t = r[e];
      t && (isObject(o[e]) && isObject(t) ? o[e] = replaceByNonOverrideCfg(o[e], t, ++n, i) : delete o[e]);
    }), o;
  } catch (e) {}
  return e;
}
var _a$4,
  F = "featureOptIn.",
  M = ".mode",
  ON = ".onCfg",
  OFF = ".offCfg";
function resolveCdnFeatureCfg(e, t, r) {
  var n, i, o, a, s, l, c, u, h, d;
  return t && t.enabled ? (n = (t = (t[_DYN_FEATURE_OPT_IN] || {})[e] || {
    mode: 1
  }).mode, i = t.onCfg, t = t.offCfg, o = (r = (r || {})[e] || {
    mode: 2
  }).mode, a = r.onCfg, s = r.offCfg, r = !!r.blockCdnCfg, l = F + e + ON, c = F + e + OFF, u = o, h = a, d = s, r || (4 === n || 5 === n ? (u = 4 == n ? 3 : 2, h = i || a, d = t || s) : 2 === n || 2 === o ? (u = 2, h = a || i, d = s || t) : 3 === n ? (u = 3, h = a || i, d = s || t) : 1 === n && 1 === o && (u = 1)), (r = {})[F + e + M] = u, r[l] = h, r[c] = d, r) : null;
}
function applyCdnfeatureCfg(r, n) {
  try {
    var e, i;
    return r && r.enabled ? r[_DYN_FEATURE_OPT_IN] ? (e = r[_DYN_FEATURE_OPT_IN], i = r.config || {}, objForEachKey(e, function (e) {
      var t = resolveCdnFeatureCfg(e, r, n.config[_DYN_FEATURE_OPT_IN]);
      isNullOrUndefined(t) || (objForEachKey(t, function (e, t) {
        setValueByKey(i, e, t);
      }), _overrideCdnCfgByFeature(e, t, i));
    }), i) : r.config : null;
  } catch (e) {}
  return null;
}
function _overrideCdnCfgByFeature(e, t, r) {
  var n = t[F + e + M],
    i = t[F + e + ON],
    t = t[F + e + OFF],
    e = 2 === n ? t : 3 === n ? i : null;
  e && objForEachKey(e, function (e, t) {
    setValueByKey(r, e, t);
  });
}
var EVENT_NAME = "ai_cfgsync",
  STR_GET_METHOD = "GET",
  FETCH_TIMEOUT = 18e5,
  udfVal = void 0,
  defaultNonOverrideCfg = {
    instrumentationKey: !0,
    connectionString: !0,
    endpointUrl: !0
  },
  _defaultConfig$2 = objDeepFreeze(((_a$4 = {
    syncMode: 1,
    blkCdnCfg: udfVal,
    customEvtName: udfVal,
    cfgUrl: udfVal,
    overrideSyncFn: udfVal,
    overrideFetchFn: udfVal
  })[_DYN_ON_CFG_CHANGE_RECEIV0] = udfVal, _a$4[_DYN_SCHEDULE_FETCH_TIMEO1] = FETCH_TIMEOUT, _a$4[_DYN_NON_OVERRIDE_CONFIGS] = defaultNonOverrideCfg, _a$4)),
  CfgSyncPlugin = function (r) {
    function i() {
      var g,
        y,
        v,
        E,
        b,
        e,
        w,
        T,
        S,
        x,
        C,
        A,
        I,
        N,
        P,
        D,
        t = r.call(this) || this,
        n = (t.priority = 198, !(t.identifier = "AppInsightsCfgSyncPlugin"));
      return dynamicProto(i, t, function (s, l) {
        function r() {
          A = D = P = S = C = x = e = I = T = w = b = E = v = y = null;
        }
        function o(e, t) {
          if (e) {
            if (y = e, t && !n) return u();
            if (w && !n) return s.core.updateCfg(e), !0;
          }
          return !1;
        }
        function c() {
          try {
            var e = getGlobal();
            e && eventOff(e, null, null, E);
          } catch (e) {}
        }
        function u(e) {
          try {
            return D && isFunction(D) ? D(y, e) : sendCustomEvent(v, y, e);
          } catch (e) {}
          return !1;
        }
        function h(e) {
          try {
            if (c(), e && (v = e, w)) {
              var t = getGlobal();
              if (t) try {
                eventOn(t, v, function (e) {
                  var e = e && e.detail;
                  A && e ? A(e) : (e = (e = e && e.cfg) && isPlainObject(e) && function (e) {
                    var t = null;
                    try {
                      e && (t = replaceByNonOverrideCfg(e, I, 0, 5));
                    } catch (e) {}
                    return t;
                  }(e)) && o(e);
                }, E, !0);
              } catch (e) {}
            }
            return !0;
          } catch (e) {}
          return !1;
        }
        function d(e, r, n) {
          var t = getGlobal(),
            t = t && t.fetch || null;
          if (e && t && isFunction(t)) try {
            var i = new Request(e, {
              method: STR_GET_METHOD
            });
            doAwaitResponse(fetch(i), function (e) {
              var t = e.value;
              e.rejected ? a(r, 400) : t.ok ? doAwaitResponse(t.text(), function (e) {
                a(r, t.status, e.value, n);
              }) : a(r, t.status, null, n);
            });
          } catch (e) {}
        }
        function p(e, t, r) {
          try {
            var n = new XMLHttpRequest();
            n.open(STR_GET_METHOD, e), n.onreadystatechange = function () {
              n.readyState === XMLHttpRequest.DONE && a(t, n.status, n.responseText, r);
            }, n.onerror = function () {
              a(t, 400);
            }, n.ontimeout = function () {
              a(t, 400);
            }, n.send();
          } catch (e) {}
        }
        function f(e, t, r) {
          try {
            var n, i;
            200 <= e && e < 400 && t ? (C = 0, (n = getJSON()) && (i = applyCdnfeatureCfg(n.parse(t), s.core)) && o(i, r)) : C++, C < 3 && _();
          } catch (e) {}
        }
        function a(e, t, r, n) {
          try {
            e(t, r, n);
          } catch (e) {}
        }
        function _() {
          !e && x && (e = scheduleTimeout(function () {
            e = null, N(b, f, T);
          }, x)).unref();
        }
        function m() {
          e && e.cancel(), e = null, C = 0;
        }
        r(), s.initialize = function (e, t, r, n) {
          var i, o, a;
          l.initialize(e, t, r, n), E = mergeEvtNamespace(createUniqueNamespace(s.identifier), t.evtNamespace && t.evtNamespace()), i = e, o = s.identifier, a = s.core, s._addHook(onConfigChange(i, function () {
            var e = createProcessTelemetryContext(null, i, a),
              e = (g = e.getExtCfg(o, _defaultConfig$2), S),
              e = (S = !!g.blkCdnCfg, isNullOrUndefined(e) || e === S || (!S && b ? N && N(b, f, T) : m()), isNullOrUndefined(w) && (w = 2 === g.syncMode), isNullOrUndefined(T) && (T = 1 === g.syncMode), g.customEvtName || EVENT_NAME);
            v !== e && (w ? h(e) : (c(), v = e)), (b = isNullOrUndefined(b) ? g.cfgUrl : b) || (y = i, T && u());
          })), D = g.overrideSyncFn, P = g.overrideFetchFn, A = g[_DYN_ON_CFG_CHANGE_RECEIV0], I = g[_DYN_NON_OVERRIDE_CONFIGS], x = g[_DYN_SCHEDULE_FETCH_TIMEO1], N = function () {
            var e = P;
            isNullOrUndefined(e) && (isFetchSupported() ? e = d : isXhrSupported() && (e = p));
            return e;
          }(), C = 0, b && !S && N && N(b, f, T);
        }, s.getCfg = function () {
          return y;
        }, s.pause = function () {
          n = !0, m();
        }, s.resume = function () {
          n = !1, _();
        }, s.setCfg = function (e) {
          return o(e);
        }, s.sync = u, s.updateEventListenerName = h, s._doTeardown = function (e, t) {
          c(), m(), r();
        }, s._getDbgPlgTargets = function () {
          return [T, w, v, S];
        }, s.processTelemetry = function (e, t) {
          s.processNext(e, t);
        };
      }), t;
    }
    return __extendsFn(i, r), i.__ieDyn = 1, i;
  }(BaseTelemetryPlugin),
  STR_DURATION$1 = "duration",
  _DYN_TAGS = "tags",
  _DYN_DEVICE_TYPE = "deviceType",
  _DYN_DATA = "data",
  _DYN_NAME$1 = "name",
  _DYN_TRACE_ID$1 = "traceID",
  _DYN_LENGTH$2 = "length",
  _DYN_STRINGIFY = "stringify",
  _DYN_MEASUREMENTS = "measurements",
  _DYN_DATA_TYPE = "dataType",
  _DYN_ENVELOPE_TYPE = "envelopeType",
  _DYN_TO_STRING = "toString",
  _DYN_ON_LINE = "onLine",
  _DYN_IS_ONLINE = "isOnline",
  _DYN__GET = "_get",
  _DYN_ENQUEUE = "enqueue",
  _DYN_COUNT = "count",
  _DYN_EVENTS_LIMIT_IN_MEM = "eventsLimitInMem",
  _DYN_PUSH = "push",
  _DYN_EMIT_LINE_DELIMITED_0 = "emitLineDelimitedJson",
  _DYN_CLEAR = "clear",
  _DYN_BATCH_PAYLOADS = "batchPayloads",
  _DYN_CREATE_NEW = "createNew",
  _DYN_MARK_AS_SENT = "markAsSent",
  _DYN_CLEAR_SENT = "clearSent",
  _DYN_BUFFER_OVERRIDE = "bufferOverride",
  _DYN__BUFFER__KEY = "BUFFER_KEY",
  _DYN__SENT__BUFFER__KEY = "SENT_BUFFER_KEY",
  _DYN__MAX__BUFFER__SIZE = "MAX_BUFFER_SIZE",
  _DYN_SEND_POST = "sendPOST",
  _DYN_TRIGGER_SEND = "triggerSend",
  _DYN_DIAG_LOG = "diagLog",
  _DYN__SENDER = "_sender",
  _DYN_CUSTOM_HEADERS = "customHeaders",
  _DYN_MAX_BATCH_SIZE_IN_BY1 = "maxBatchSizeInBytes",
  _DYN_ONUNLOAD_DISABLE_BEA2 = "onunloadDisableBeacon",
  _DYN_IS_BEACON_API_DISABL3 = "isBeaconApiDisabled",
  _DYN_ALWAYS_USE_XHR_OVERR4 = "alwaysUseXhrOverride",
  _DYN_ENABLE_SESSION_STORA5 = "enableSessionStorageBuffer",
  _DYN__BUFFER = "_buffer",
  _DYN_ONUNLOAD_DISABLE_FET6 = "onunloadDisableFetch",
  _DYN_DISABLE_SEND_BEACON_7 = "disableSendBeaconSplit",
  _DYN_INSTRUMENTATION_KEY$1 = "instrumentationKey",
  _DYN_CONVERT_UNDEFINED = "convertUndefined",
  _DYN_MAX_BATCH_INTERVAL = "maxBatchInterval",
  _DYN_BASE_TYPE = "baseType",
  _DYN_SAMPLE_RATE = "sampleRate",
  _DYN__XHR_READY_STATE_CHA8 = "_xhrReadyStateChange",
  _DYN__ON_ERROR = "_onError",
  _DYN__ON_PARTIAL_SUCCESS = "_onPartialSuccess",
  _DYN__ON_SUCCESS = "_onSuccess",
  _DYN_ITEMS_ACCEPTED = "itemsAccepted",
  _DYN_ITEMS_RECEIVED = "itemsReceived",
  _DYN_ORI_PAYLOAD = "oriPayload",
  _DYN_SET_REQUEST_HEADER$1 = "setRequestHeader",
  _DYN_EVENTS_SEND_REQUEST = "eventsSendRequest",
  _DYN_GET_SAMPLING_SCORE = "getSamplingScore",
  _DYN_GET_HASH_CODE_SCORE = "getHashCodeScore",
  strBaseType = "baseType",
  strBaseData = "baseData",
  strProperties = "properties",
  strTrue = "true";
function _setValueIf(e, t, r) {
  return setValue(e, t, r, isTruthy);
}
function _extractPartAExtensions(e, t, r) {
  for (var n = r[_DYN_TAGS] = r[_DYN_TAGS] || {}, i = t.ext = t.ext || {}, o = t[_DYN_TAGS] = t[_DYN_TAGS] || [], a = i.user, a = (a && (_setValueIf(n, CtxTagKeys.userAuthUserId, a.authId), _setValueIf(n, CtxTagKeys.userId, a.id || a.localId)), i.app), a = (a && _setValueIf(n, CtxTagKeys.sessionId, a.sesId), i.device), a = (a && (_setValueIf(n, CtxTagKeys.deviceId, a.id || a.localId), _setValueIf(n, CtxTagKeys[_DYN_DEVICE_TYPE], a.deviceClass), _setValueIf(n, CtxTagKeys.deviceIp, a.ip), _setValueIf(n, CtxTagKeys.deviceModel, a.model), _setValueIf(n, CtxTagKeys[_DYN_DEVICE_TYPE], a[_DYN_DEVICE_TYPE])), t.ext.web), t = (a && (_setValueIf(n, CtxTagKeys.deviceLanguage, a.browserLang), _setValueIf(n, CtxTagKeys.deviceBrowserVersion, a.browserVer), _setValueIf(n, CtxTagKeys.deviceBrowser, a.browser), _setValueIf(t = (t = (t = r[_DYN_DATA] = r[_DYN_DATA] || {})[strBaseData] = t[strBaseData] || {})[strProperties] = t[strProperties] || {}, "domain", a.domain), _setValueIf(t, "isManual", a.isManual ? strTrue : null), _setValueIf(t, "screenRes", a.screenRes), _setValueIf(t, "userConsent", a.userConsent ? strTrue : null)), i.os), a = (t && _setValueIf(n, CtxTagKeys.deviceOS, t[_DYN_NAME$1]), i.trace), s = (a && (_setValueIf(n, CtxTagKeys.operationParentId, a.parentID), _setValueIf(n, CtxTagKeys.operationName, dataSanitizeString(e, a[_DYN_NAME$1])), _setValueIf(n, CtxTagKeys.operationId, a[_DYN_TRACE_ID$1])), {}), l = o[_DYN_LENGTH$2] - 1; 0 <= l; l--) objForEachKey(o[l], function (e, t) {
    s[e] = t;
  }), o.splice(l, 1);
  objForEachKey(o, function (e, t) {
    s[e] = t;
  });
  t = __assignFn(__assignFn({}, n), s);
  t[CtxTagKeys.internalSdkVersion] || (t[CtxTagKeys.internalSdkVersion] = dataSanitizeString(e, "javascript:".concat(EnvelopeCreator.Version), 64)), r[_DYN_TAGS] = optimizeObject(t);
}
function _extractPropsAndMeasurements(e, r, n) {
  isNullOrUndefined(e) || objForEachKey(e, function (e, t) {
    isNumber(t) ? n[e] = t : isString(t) ? r[e] = t : hasJSON() && (r[e] = getJSON()[_DYN_STRINGIFY](t));
  });
}
function _convertPropsUndefinedToCustomDefinedValue(r, n) {
  isNullOrUndefined(r) || objForEachKey(r, function (e, t) {
    r[e] = t || n;
  });
}
function _createEnvelope(e, t, r, n) {
  n = new Envelope(e, n, t), _setValueIf(n, "sampleRate", r[SampleRate]), (r[strBaseData] || {}).startTime && (n.time = toISOString(r[strBaseData].startTime)), n.iKey = r.iKey, t = r.iKey.replace(/-/g, "");
  return n[_DYN_NAME$1] = n[_DYN_NAME$1].replace("{0}", t), _extractPartAExtensions(e, r, n), r[_DYN_TAGS] = r[_DYN_TAGS] || [], optimizeObject(n);
}
function EnvelopeCreatorInit(e, t) {
  isNullOrUndefined(t[strBaseData]) && _throwInternal(e, 1, 46, "telemetryItem.baseData cannot be null.");
}
var EnvelopeCreator = {
  Version: "3.0.7"
};
function DependencyEnvelopeCreator(e, t, r) {
  EnvelopeCreatorInit(e, t);
  var n,
    i = t[strBaseData][_DYN_MEASUREMENTS] || {},
    o = t[strBaseData][strProperties] || {},
    r = (_extractPropsAndMeasurements(t[_DYN_DATA], o, i), isNullOrUndefined(r) || _convertPropsUndefinedToCustomDefinedValue(o, r), t[strBaseData]);
  return isNullOrUndefined(r) ? (_warnToConsole(e, "Invalid input for dependency data"), null) : (n = r[strProperties] && r[strProperties][HttpMethod] ? r[strProperties][HttpMethod] : "GET", n = new RemoteDependencyData(e, r.id, r.target, r[_DYN_NAME$1], r[STR_DURATION$1], r.success, r.responseCode, n, r.type, r.correlationContext, o, i), r = new Data(RemoteDependencyData[_DYN_DATA_TYPE], n), _createEnvelope(e, RemoteDependencyData[_DYN_ENVELOPE_TYPE], t, r));
}
function EventEnvelopeCreator(e, t, r) {
  EnvelopeCreatorInit(e, t);
  var n = {},
    i = {},
    r = (t[strBaseType] !== Event$1[_DYN_DATA_TYPE] && (n.baseTypeSource = t[strBaseType]), t[strBaseType] === Event$1[_DYN_DATA_TYPE] ? (n = t[strBaseData][strProperties] || {}, i = t[strBaseData][_DYN_MEASUREMENTS] || {}) : t[strBaseData] && _extractPropsAndMeasurements(t[strBaseData], n, i), _extractPropsAndMeasurements(t[_DYN_DATA], n, i), isNullOrUndefined(r) || _convertPropsUndefinedToCustomDefinedValue(n, r), t[strBaseData][_DYN_NAME$1]),
    r = new Event$1(e, r, n, i),
    n = new Data(Event$1[_DYN_DATA_TYPE], r);
  return _createEnvelope(e, Event$1[_DYN_ENVELOPE_TYPE], t, n);
}
function ExceptionEnvelopeCreator(e, t, r) {
  EnvelopeCreatorInit(e, t);
  var n = t[strBaseData][_DYN_MEASUREMENTS] || {},
    i = t[strBaseData][strProperties] || {},
    r = (_extractPropsAndMeasurements(t[_DYN_DATA], i, n), isNullOrUndefined(r) || _convertPropsUndefinedToCustomDefinedValue(i, r), t[strBaseData]),
    r = Exception.CreateFromInterface(e, r, i, n),
    i = new Data(Exception[_DYN_DATA_TYPE], r);
  return _createEnvelope(e, Exception[_DYN_ENVELOPE_TYPE], t, i);
}
function MetricEnvelopeCreator(e, t, r) {
  EnvelopeCreatorInit(e, t);
  var n = t[strBaseData],
    i = n[strProperties] || {},
    o = n[_DYN_MEASUREMENTS] || {},
    r = (_extractPropsAndMeasurements(t[_DYN_DATA], i, o), isNullOrUndefined(r) || _convertPropsUndefinedToCustomDefinedValue(i, r), new Metric(e, n[_DYN_NAME$1], n.average, n.sampleCount, n.min, n.max, n.stdDev, i, o)),
    n = new Data(Metric[_DYN_DATA_TYPE], r);
  return _createEnvelope(e, Metric[_DYN_ENVELOPE_TYPE], t, n);
}
function PageViewEnvelopeCreator(e, t, r) {
  EnvelopeCreatorInit(e, t);
  var n,
    i = t[strBaseData],
    i = (isNullOrUndefined(i) || isNullOrUndefined(i[strProperties]) || isNullOrUndefined(i[strProperties][STR_DURATION$1]) ? isNullOrUndefined(t[_DYN_DATA]) || isNullOrUndefined(t[_DYN_DATA][STR_DURATION$1]) || (n = t[_DYN_DATA][STR_DURATION$1], delete t[_DYN_DATA][STR_DURATION$1]) : (n = i[strProperties][STR_DURATION$1], delete i[strProperties][STR_DURATION$1]), t[strBaseData]),
    o = (((t.ext || {}).trace || {})[_DYN_TRACE_ID$1] && (o = t.ext.trace[_DYN_TRACE_ID$1]), i.id || o),
    a = i[_DYN_NAME$1],
    s = i.uri,
    l = i[strProperties] || {},
    c = i[_DYN_MEASUREMENTS] || {},
    i = (isNullOrUndefined(i.refUri) || (l.refUri = i.refUri), isNullOrUndefined(i.pageType) || (l.pageType = i.pageType), isNullOrUndefined(i.isLoggedIn) || (l.isLoggedIn = i.isLoggedIn[_DYN_TO_STRING]()), isNullOrUndefined(i[strProperties]) || objForEachKey(i[strProperties], function (e, t) {
      l[e] = t;
    }), _extractPropsAndMeasurements(t[_DYN_DATA], l, c), isNullOrUndefined(r) || _convertPropsUndefinedToCustomDefinedValue(l, r), new PageView(e, a, s, n, l, c, o)),
    r = new Data(PageView[_DYN_DATA_TYPE], i);
  return _createEnvelope(e, PageView[_DYN_ENVELOPE_TYPE], t, r);
}
function PageViewPerformanceEnvelopeCreator(e, t, r) {
  EnvelopeCreatorInit(e, t);
  var n = t[strBaseData],
    i = n[_DYN_NAME$1],
    o = n.uri || n.url,
    a = n[strProperties] || {},
    s = n[_DYN_MEASUREMENTS] || {},
    r = (_extractPropsAndMeasurements(t[_DYN_DATA], a, s), isNullOrUndefined(r) || _convertPropsUndefinedToCustomDefinedValue(a, r), new PageViewPerformance(e, i, o, void 0, a, s, n)),
    i = new Data(PageViewPerformance[_DYN_DATA_TYPE], r);
  return _createEnvelope(e, PageViewPerformance[_DYN_ENVELOPE_TYPE], t, i);
}
function TraceEnvelopeCreator(e, t, r) {
  EnvelopeCreatorInit(e, t);
  var n = t[strBaseData].message,
    i = t[strBaseData].severityLevel,
    o = t[strBaseData][strProperties] || {},
    a = t[strBaseData][_DYN_MEASUREMENTS] || {},
    r = (_extractPropsAndMeasurements(t[_DYN_DATA], o, a), isNullOrUndefined(r) || _convertPropsUndefinedToCustomDefinedValue(o, r), new Trace(e, n, i, o, a)),
    n = new Data(Trace[_DYN_DATA_TYPE], r);
  return _createEnvelope(e, Trace[_DYN_ENVELOPE_TYPE], t, n);
}
function _disableEvents(e, t) {
  eventOff(e, null, null, t);
}
function createOfflineListener(e) {
  var t,
    r = getDocument(),
    n = getNavigator(),
    i = !1,
    o = !0,
    a = mergeEvtNamespace(createUniqueNamespace("OfflineListener"), e);
  try {
    s(getWindow()) && (i = !0), (i = r && (t = r.body || r).ononline && s(t) ? !0 : i) && n && !isNullOrUndefined(n[_DYN_ON_LINE]) && (o = n[_DYN_ON_LINE]);
  } catch (e) {
    i = !1;
  }
  function s(e) {
    var t = !1;
    return e && (t = eventOn(e, "online", l, a)) && eventOn(e, "offline", c, a), t;
  }
  function l() {
    o = !0;
  }
  function c() {
    o = !1;
  }
  return (e = {})[_DYN_IS_ONLINE] = function () {
    var e = !0;
    return i ? e = o : n && !isNullOrUndefined(n[_DYN_ON_LINE]) && (e = n[_DYN_ON_LINE]), e;
  }, e.isListening = function () {
    return i;
  }, e.unload = function () {
    var e = getWindow();
    e && i && (_disableEvents(e, a), r && !isUndefined((e = r.body || r).ononline) && _disableEvents(e, a), i = !1);
  }, e;
}
var _a$3,
  _b$1,
  BaseSendBuffer = function () {
    function e(o, r) {
      var a = [],
        n = !1;
      this[_DYN__GET] = function () {
        return a;
      }, this._set = function (e) {
        return a = e;
      }, dynamicProto(e, this, function (t) {
        t[_DYN_ENQUEUE] = function (e) {
          t[_DYN_COUNT]() >= r[_DYN_EVENTS_LIMIT_IN_MEM] ? n || (_throwInternal(o, 2, 105, "Maximum in-memory buffer size reached: " + t[_DYN_COUNT](), !0), n = !0) : a[_DYN_PUSH](e);
        }, t[_DYN_COUNT] = function () {
          return a[_DYN_LENGTH$2];
        }, t.size = function () {
          for (var e = a[_DYN_LENGTH$2], t = 0; t < a[_DYN_LENGTH$2]; t++) e += a[t][_DYN_LENGTH$2];
          return r[_DYN_EMIT_LINE_DELIMITED_0] || (e += 2), e;
        }, t[_DYN_CLEAR] = function () {
          n = !(a = []);
        }, t.getItems = function () {
          return a.slice(0);
        }, t[_DYN_BATCH_PAYLOADS] = function (e) {
          return e && 0 < e[_DYN_LENGTH$2] ? r[_DYN_EMIT_LINE_DELIMITED_0] ? e.join("\n") : "[" + e.join(",") + "]" : null;
        }, t[_DYN_CREATE_NEW] = function (e, t, r) {
          var n = a.slice(0),
            i = new (r ? SessionStorageSendBuffer : ArraySendBuffer)(e = e || o, t = t || {});
          return arrForEach(n, function (e) {
            i[_DYN_ENQUEUE](e);
          }), i;
        };
      });
    }
    return e.__ieDyn = 1, e;
  }(),
  ArraySendBuffer = function (r) {
    function n(e, t) {
      e = r.call(this, e, t) || this;
      return dynamicProto(n, e, function (e, t) {
        e[_DYN_MARK_AS_SENT] = function (e) {
          t[_DYN_CLEAR]();
        }, e[_DYN_CLEAR_SENT] = function (e) {};
      }), e;
    }
    return __extendsFn(n, r), n.__ieDyn = 1, n;
  }(BaseSendBuffer),
  SessionStorageSendBuffer = function (r) {
    function d(l, e) {
      var t = r.call(this, l, e) || this,
        o = !1,
        c = null == e ? void 0 : e.namePrefix,
        e = e[_DYN_BUFFER_OVERRIDE] || {
          getItem: utlGetSessionStorage,
          setItem: utlSetSessionStorage
        },
        u = e.getItem,
        h = e.setItem;
      return dynamicProto(d, t, function (a, t) {
        var e = s(d[_DYN__BUFFER__KEY]),
          r = s(d[_DYN__SENT__BUFFER__KEY]),
          e = a._set(e.concat(r));
        function n(t, e) {
          var r = [];
          return arrForEach(e, function (e) {
            isFunction(e) || -1 !== arrIndexOf(t, e) || r[_DYN_PUSH](e);
          }), r;
        }
        function s(t) {
          try {
            var e = u(l, t = c ? c + "_" + t : t);
            if (e) {
              var r = getJSON().parse(e);
              if ((r = isString(r) ? getJSON().parse(r) : r) && isArray(r)) return r;
            }
          } catch (e) {
            _throwInternal(l, 1, 42, " storage key: " + t + ", " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
          return [];
        }
        function i(t, e) {
          try {
            var t = c ? c + "_" + t : t,
              r = JSON[_DYN_STRINGIFY](e);
            h(l, t, r);
          } catch (e) {
            h(l, t, JSON[_DYN_STRINGIFY]([])), _throwInternal(l, 2, 41, " storage key: " + t + ", " + getExceptionName(e) + ". Buffer cleared", {
              exception: dumpObj(e)
            });
          }
        }
        e[_DYN_LENGTH$2] > d[_DYN__MAX__BUFFER__SIZE] && (e[_DYN_LENGTH$2] = d[_DYN__MAX__BUFFER__SIZE]), i(d[_DYN__SENT__BUFFER__KEY], []), i(d[_DYN__BUFFER__KEY], e), a[_DYN_ENQUEUE] = function (e) {
          a[_DYN_COUNT]() >= d[_DYN__MAX__BUFFER__SIZE] ? o || (_throwInternal(l, 2, 67, "Maximum buffer size reached: " + a[_DYN_COUNT](), !0), o = !0) : (t[_DYN_ENQUEUE](e), i(d.BUFFER_KEY, a[_DYN__GET]()));
        }, a[_DYN_CLEAR] = function () {
          t[_DYN_CLEAR](), i(d.BUFFER_KEY, a[_DYN__GET]()), i(d[_DYN__SENT__BUFFER__KEY], []), o = !1;
        }, a[_DYN_MARK_AS_SENT] = function (e) {
          i(d[_DYN__BUFFER__KEY], a._set(n(e, a[_DYN__GET]())));
          var t = s(d[_DYN__SENT__BUFFER__KEY]);
          t instanceof Array && e instanceof Array && ((t = t.concat(e))[_DYN_LENGTH$2] > d[_DYN__MAX__BUFFER__SIZE] && (_throwInternal(l, 1, 67, "Sent buffer reached its maximum size: " + t[_DYN_LENGTH$2], !0), t[_DYN_LENGTH$2] = d[_DYN__MAX__BUFFER__SIZE]), i(d[_DYN__SENT__BUFFER__KEY], t));
        }, a[_DYN_CLEAR_SENT] = function (e) {
          e = n(e, s(d[_DYN__SENT__BUFFER__KEY]));
          i(d[_DYN__SENT__BUFFER__KEY], e);
        }, a[_DYN_CREATE_NEW] = function (e, t, r) {
          r = !!r;
          var n = a[_DYN__GET]().slice(0),
            i = s(d[_DYN__SENT__BUFFER__KEY]).slice(0),
            o = (e = e || l, t = t || {}, a[_DYN_CLEAR](), new (r ? d : ArraySendBuffer)(e, t));
          return arrForEach(n, function (e) {
            o[_DYN_ENQUEUE](e);
          }), r && o[_DYN_MARK_AS_SENT](i), o;
        };
      }), t;
    }
    return __extendsFn(d, r), d.BUFFER_KEY = "AI_buffer", d.SENT_BUFFER_KEY = "AI_sentBuffer", d.MAX_BUFFER_SIZE = 2e3, d;
  }(BaseSendBuffer),
  Serializer = function () {
    function e(h) {
      dynamicProto(e, this, function (e) {
        function c(a, s) {
          var e = "__aiCircularRefCheck",
            l = {};
          if (a) {
            if (a[e]) _throwInternal(h, 2, 50, "Circular reference detected while serializing object", {
              name: s
            }, !0);else if (a.aiDataContract) a[e] = !0, objForEachKey(a.aiDataContract, function (e, t) {
              var r = isFunction(t) ? 1 & t() : 1 & t,
                n = isFunction(t) ? 4 & t() : 4 & t,
                t = 2 & t,
                i = void 0 !== a[e],
                o = isObject(a[e]) && null !== a[e];
              !r || i || t ? n || (r = void 0) !== (r = o ? (t ? u : c)(a[e], e) : a[e]) && (l[e] = r) : _throwInternal(h, 1, 24, "Missing required field specification. The field is required but not present on source", {
                field: e,
                name: s
              });
            }), delete a[e];else if ("measurements" === s) l = t(a, "number", s);else if ("properties" === s) l = t(a, "string", s);else if ("tags" === s) l = t(a, "string", s);else if (isArray(a)) l = u(a, s);else {
              _throwInternal(h, 2, 49, "Attempting to serialize an object which does not implement ISerializable", {
                name: s
              }, !0);
              try {
                getJSON()[_DYN_STRINGIFY](a), l = a;
              } catch (e) {
                _throwInternal(h, 1, 48, e && isFunction(e[_DYN_TO_STRING]) ? e[_DYN_TO_STRING]() : "Error serializing object", null, !0);
              }
            }
          } else _throwInternal(h, 1, 48, "cannot serialize object because it is null or undefined", {
            name: s
          }, !0);
          return l;
        }
        function u(e, t) {
          if (e) if (isArray(e)) for (var r = [], n = 0; n < e[_DYN_LENGTH$2]; n++) {
            var i = c(e[n], t + "[" + n + "]");
            r[_DYN_PUSH](i);
          } else _throwInternal(h, 1, 54, "This field was specified as an array in the contract but the item is not an array.\r\n", {
            name: t
          }, !0);
          return r;
        }
        function t(e, r, n) {
          var i;
          return e && (i = {}, objForEachKey(e, function (e, t) {
            "string" === r ? void 0 === t ? i[e] = "undefined" : null === t ? i[e] = "null" : t[_DYN_TO_STRING] ? i[e] = t[_DYN_TO_STRING]() : i[e] = "invalid field: toString() is not defined." : "number" === r ? void 0 === t ? i[e] = "undefined" : null === t ? i[e] = "null" : (t = parseFloat(t), isNaN(t) ? i[e] = "NaN" : i[e] = t) : (i[e] = "invalid field: " + n + " is of unknown type.", _throwInternal(h, 1, i[e], null, !0));
          })), i;
        }
        e.serialize = function (e) {
          e = c(e, "root");
          try {
            return getJSON()[_DYN_STRINGIFY](e);
          } catch (e) {
            _throwInternal(h, 1, 48, e && isFunction(e[_DYN_TO_STRING]) ? e[_DYN_TO_STRING]() : "Error serializing object", null, !0);
          }
        };
      });
    }
    return e.__ieDyn = 1, e;
  }(),
  MIN_INPUT_LENGTH = 8,
  HashCodeScoreGenerator = function () {
    function t() {}
    return t.prototype.getHashCodeScore = function (e) {
      return 100 * (this.getHashCode(e) / t.INT_MAX_VALUE);
    }, t.prototype.getHashCode = function (e) {
      if ("" === e) return 0;
      for (; e[_DYN_LENGTH$2] < MIN_INPUT_LENGTH;) e = e.concat(e);
      for (var t = 5381, r = 0; r < e[_DYN_LENGTH$2]; ++r) t = (t << 5) + t + e.charCodeAt(r), t &= t;
      return Math.abs(t);
    }, t.INT_MAX_VALUE = 2147483647, t;
  }(),
  SamplingScoreGenerator = function () {
    var t = new HashCodeScoreGenerator(),
      r = new ContextTagKeys();
    this[_DYN_GET_SAMPLING_SCORE] = function (e) {
      return e[_DYN_TAGS] && e[_DYN_TAGS][r.userId] ? t.getHashCodeScore(e[_DYN_TAGS][r.userId]) : e.ext && e.ext.user && e.ext.user.id ? t[_DYN_GET_HASH_CODE_SCORE](e.ext.user.id) : e[_DYN_TAGS] && e[_DYN_TAGS][r.operationId] ? t.getHashCodeScore(e[_DYN_TAGS][r.operationId]) : e.ext && e.ext.telemetryTrace && e.ext.telemetryTrace[_DYN_TRACE_ID$1] ? t.getHashCodeScore(e.ext.telemetryTrace[_DYN_TRACE_ID$1]) : 100 * Math.random();
    };
  },
  Sample = function () {
    function e(e, t) {
      this.INT_MAX_VALUE = 2147483647;
      t = t || safeGetLogger(null);
      (100 < e || e < 0) && (t.throwInternal(2, 58, "Sampling rate is out of range (0..100). Sampling will be disabled, you may be sending too much data which may affect your AI service level.", {
        samplingRate: e
      }, !0), e = 100), this[_DYN_SAMPLE_RATE] = e, this.samplingScoreGenerator = new SamplingScoreGenerator();
    }
    return e.prototype.isSampledIn = function (e) {
      var t = this[_DYN_SAMPLE_RATE];
      return null == t || 100 <= t || e.baseType === Metric[_DYN_DATA_TYPE] || this.samplingScoreGenerator[_DYN_GET_SAMPLING_SCORE](e) < t;
    }, e;
  }(),
  UNDEFINED_VALUE$1 = void 0,
  FetchSyncRequestSizeLimitBytes = 65e3;
function _getResponseText(e) {
  try {
    return e.responseText;
  } catch (e) {}
  return null;
}
function isOverrideFn(e) {
  return e && e[_DYN_SEND_POST];
}
var defaultAppInsightsChannelConfig = objDeepFreeze(((_a$3 = {
  endpointUrl: cfgDfValidate(isTruthy, DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH)
})[_DYN_EMIT_LINE_DELIMITED_0] = cfgDfBoolean(), _a$3[_DYN_MAX_BATCH_INTERVAL] = 15e3, _a$3[_DYN_MAX_BATCH_SIZE_IN_BY1] = 102400, _a$3.disableTelemetry = cfgDfBoolean(), _a$3[_DYN_ENABLE_SESSION_STORA5] = cfgDfBoolean(!0), _a$3.isRetryDisabled = cfgDfBoolean(), _a$3[_DYN_IS_BEACON_API_DISABL3] = cfgDfBoolean(!0), _a$3[_DYN_DISABLE_SEND_BEACON_7] = cfgDfBoolean(), _a$3.disableXhr = cfgDfBoolean(), _a$3[_DYN_ONUNLOAD_DISABLE_FET6] = cfgDfBoolean(), _a$3[_DYN_ONUNLOAD_DISABLE_BEA2] = cfgDfBoolean(), _a$3[_DYN_INSTRUMENTATION_KEY$1] = UNDEFINED_VALUE$1, _a$3.namePrefix = UNDEFINED_VALUE$1, _a$3.samplingPercentage = cfgDfValidate(_chkSampling, 100), _a$3[_DYN_CUSTOM_HEADERS] = UNDEFINED_VALUE$1, _a$3[_DYN_CONVERT_UNDEFINED] = UNDEFINED_VALUE$1, _a$3[_DYN_EVENTS_LIMIT_IN_MEM] = 1e4, _a$3[_DYN_BUFFER_OVERRIDE] = !1, _a$3.httpXHROverride = {
  isVal: isOverrideFn,
  v: UNDEFINED_VALUE$1
}, _a$3[_DYN_ALWAYS_USE_XHR_OVERR4] = cfgDfBoolean(), _a$3));
function _chkSampling(e) {
  return !isNaN(e) && 0 < e && e <= 100;
}
(_b$1 = {})[Event$1.dataType] = EventEnvelopeCreator, _b$1[Trace.dataType] = TraceEnvelopeCreator, _b$1[PageView.dataType] = PageViewEnvelopeCreator, _b$1[PageViewPerformance.dataType] = PageViewPerformanceEnvelopeCreator, _b$1[Exception.dataType] = ExceptionEnvelopeCreator, _b$1[Metric.dataType] = MetricEnvelopeCreator, _b$1[RemoteDependencyData.dataType] = DependencyEnvelopeCreator;
var EnvelopeTypeCreator = _b$1,
  Sender = function (e) {
    function ie() {
      var I,
        N,
        P,
        t,
        D,
        i,
        R,
        O,
        M,
        k,
        L,
        U,
        F,
        B,
        $,
        z,
        Y,
        H,
        j,
        G,
        q,
        V,
        K,
        W,
        Z,
        X,
        J,
        Q,
        ee,
        te,
        re = e.call(this) || this,
        ne = (re.priority = 1001, re.identifier = BreezeChannelIdentifier, 0);
      return dynamicProto(ie, re, function (d, n) {
        function p(e, t) {
          for (var r, n, i = null, o = 0; null == i && o < e[_DYN_LENGTH$2];) n = e[o], X || 1 !== n ? 2 === n && isFetchSupported(t) ? i = s : isBeaconsSupported() && 3 === n && (i = u) : useXDomainRequest() ? i = C : isXhrSupported() && (i = y), o++;
          return i ? ((r = {})[_DYN_SEND_POST] = i, r) : null;
        }
        function o(e, t, r, n) {
          200 === t && e ? d._onSuccess(e, e[_DYN_LENGTH$2]) : n && d[_DYN__ON_ERROR](e, n);
        }
        function f(e, n, t, r) {
          void 0 === r && (r = !0);
          var i = a(n),
            e = e && e[_DYN_SEND_POST];
          return e && i ? (r && d._buffer[_DYN_MARK_AS_SENT](n), e(i, function (e, t, r) {
            return o(n, e, 0, r);
          }, !t)) : null;
        }
        function a(e) {
          var t, r;
          return isArray(e) && 0 < e[_DYN_LENGTH$2] ? (r = d._buffer[_DYN_BATCH_PAYLOADS](e), (t = {})[_DYN_DATA] = r, t.urlString = L, t.headers = R, t.disableXhrSync = X, t.disableFetchKeepAlive = !J, t[_DYN_ORI_PAYLOAD] = e, t) : null;
        }
        function s(e, t, r) {
          return h(e, t, !1);
        }
        function _(e) {
          e = e ? e[_DYN_LENGTH$2] : 0;
          d[_DYN__BUFFER].size() + e > F && (M && !M[_DYN_IS_ONLINE]() || d[_DYN_TRIGGER_SEND](!0, null, 10));
        }
        function m(e, t, r, n, i, o) {
          var a = null;
          d._appId || (a = E(o)) && a.appId && (d._appId = a.appId), (e < 200 || 300 <= e) && 0 !== e ? (301 !== e && 307 !== e && 308 !== e || l(r)) && !j && S(e) ? (b(t), _throwInternal(d[_DYN_DIAG_LOG](), 2, 40, ". Response code " + e + ". Will retry to send " + t[_DYN_LENGTH$2] + " items.")) : d[_DYN__ON_ERROR](t, i) : M && !M[_DYN_IS_ONLINE]() ? j || (b(t, 10), _throwInternal(d[_DYN_DIAG_LOG](), 2, 40, ". Offline - Response Code: ".concat(e, ". Offline status: ").concat(!M.isOnline(), ". Will retry to send ").concat(t.length, " items."))) : (l(r), 206 === e ? (a = a || E(o)) && !j ? d[_DYN__ON_PARTIAL_SUCCESS](t, a) : d[_DYN__ON_ERROR](t, i) : (I = 0, d[_DYN__ON_SUCCESS](t, n)));
        }
        function l(e) {
          return !(10 <= i || isNullOrUndefined(e) || "" === e || e === L) && (L = e, ++i, 1);
        }
        function g(e, t, r, n) {
          try {
            e(t, r, n);
          } catch (e) {}
        }
        function e(e, t) {
          O ? O(e, !1) : u(a(e));
        }
        function c(e) {
          var t = getNavigator(),
            r = L,
            n = d[_DYN__BUFFER][_DYN_BATCH_PAYLOADS](e),
            n = new Blob([n], {
              type: "text/plain;charset=UTF-8"
            }),
            t = t.sendBeacon(r, n);
          return t && d._onSuccess(e, e[_DYN_LENGTH$2]), t;
        }
        function u(e, t, r) {
          var n = e && e[_DYN_ORI_PAYLOAD];
          if (isArray(n) && 0 < n[_DYN_LENGTH$2] && !c(n)) if (te) ee && ee(n, !0), _throwInternal(d[_DYN_DIAG_LOG](), 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender.");else {
            for (var i = [], o = 0; o < n[_DYN_LENGTH$2]; o++) {
              var a = n[o];
              c([a]) || i[_DYN_PUSH](a);
            }
            0 < i[_DYN_LENGTH$2] && (ee && ee(i, !0), _throwInternal(d[_DYN_DIAG_LOG](), 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender."));
          }
        }
        function y(e, t, r) {
          var n,
            i,
            o,
            a = e,
            s = new XMLHttpRequest(),
            l = L;
          try {
            s[DisabledPropertyName] = !0;
          } catch (e) {}
          return s.open("POST", l, !r), s[_DYN_SET_REQUEST_HEADER$1]("Content-type", "application/json"), isInternalApplicationInsightsEndpoint(l) && s[_DYN_SET_REQUEST_HEADER$1](RequestHeaders[6], RequestHeaders[7]), arrForEach(objKeys(R), function (e) {
            s[_DYN_SET_REQUEST_HEADER$1](e, R[e]);
          }), s.onreadystatechange = function () {
            var e = a[_DYN_ORI_PAYLOAD];
            d._xhrReadyStateChange(s, e, e[_DYN_LENGTH$2]), 4 === s.readyState && i && i(!0);
          }, s.onerror = function (e) {
            g(t, 400, {}, x(s)), o && o(e);
          }, !r && W && (n = createPromise(function (e, t) {
            i = e, o = t;
          })), s.send(e[_DYN_DATA]), n;
        }
        function v(n, e) {
          if (isArray(n)) {
            for (var t = n[_DYN_LENGTH$2], r = 0; r < n[_DYN_LENGTH$2]; r++) t += n[r][_DYN_LENGTH$2];
            var i = a(n);
            d._buffer[_DYN_MARK_AS_SENT](n), ne + t <= FetchSyncRequestSizeLimitBytes ? h(i, function (e, t, r) {
              return o(n, e, 0, r);
            }, !0) : isBeaconsSupported() ? u(i) : (ee && ee(n, !0), _throwInternal(d[_DYN_DIAG_LOG](), 2, 40, ". Failed to send telemetry with Beacon API, retried with xhrSender."));
          }
        }
        function h(e, t, n) {
          var r,
            i,
            o,
            a = L,
            s = e,
            e = s[_DYN_DATA],
            l = new Blob([e], {
              type: "application/json"
            }),
            c = new Headers(),
            u = e[_DYN_LENGTH$2],
            e = !1,
            h = !1,
            a = (isInternalApplicationInsightsEndpoint(a) && c.append(RequestHeaders[6], RequestHeaders[7]), arrForEach(objKeys(R), function (e) {
              c.append(e, R[e]);
            }), (l = {
              method: "POST",
              headers: c,
              body: l
            })[DisabledPropertyName] = !0, n && (e = l.keepalive = !0, ne += u), new Request(a, l));
          try {
            a[DisabledPropertyName] = !0;
          } catch (e) {}
          !n && W && (r = createPromise(function (e, t) {
            i = e, o = t;
          }));
          try {
            doAwaitResponse(fetch(a), function (e) {
              var r;
              n && (ne -= u, u = 0), h || (h = !0, e.rejected ? (g(t, 400, {}, e.reason && e.reason.message), o && o(e.reason)) : (r = e.value).ok ? doAwaitResponse(r.text(), function (e) {
                var t = s[_DYN_ORI_PAYLOAD];
                m(r.status, t, r.url, t[_DYN_LENGTH$2], r.statusText, e.value || ""), i && i(!0);
              }) : (g(t, 400, {}, r.statusText), i && i(!1)));
            });
          } catch (e) {
            h || (g(t, 400, {}, dumpObj(e)), o && o(e));
          }
          return e && !h && (h = !0, g(t, 200, {}), i) && i(!0), r;
        }
        function E(t) {
          try {
            if (t && "" !== t) {
              var e = getJSON().parse(t);
              if (e && e.itemsReceived && e.itemsReceived >= e[_DYN_ITEMS_ACCEPTED] && e.itemsReceived - e.itemsAccepted === e.errors[_DYN_LENGTH$2]) return e;
            }
          } catch (e) {
            _throwInternal(d[_DYN_DIAG_LOG](), 1, 43, "Cannot parse the response. " + getExceptionName(e), {
              response: t
            });
          }
          return null;
        }
        function b(e, t) {
          if (void 0 === t && (t = 1), e && 0 !== e[_DYN_LENGTH$2]) {
            var r = d[_DYN__BUFFER];
            r[_DYN_CLEAR_SENT](e), I++;
            for (var n, i = 0, o = e; i < o.length; i++) {
              var a = o[i];
              r[_DYN_ENQUEUE](a);
            }
            e = t, e = I <= 1 ? 10 : (n = (Math.pow(2, I) - 1) / 2, n = Math.floor(Math.random() * n * 10) + 1, n *= e, Math.max(Math.min(n, 3600), 10)), n = utcNow() + 1e3 * e, N = n, w();
          }
        }
        function w() {
          var e;
          t || P || (e = N ? Math.max(0, N - utcNow()) : 0, e = Math.max(G, e), t = scheduleTimeout(function () {
            t = null, d[_DYN_TRIGGER_SEND](!0, null, 1);
          }, e));
        }
        function T() {
          t && t.cancel(), N = t = null;
        }
        function S(e) {
          return 401 === e || 403 === e || 408 === e || 429 === e || 500 === e || 502 === e || 503 === e || 504 === e;
        }
        function x(e, t) {
          return e ? "XMLHttpRequest,Status:" + e.status + ",Response:" + _getResponseText(e) || e.response || "" : t;
        }
        function C(e, t, r) {
          var n = e,
            e = getWindow(),
            i = new XDomainRequest(),
            o = n[_DYN_DATA],
            e = (i.onload = function () {
              var e = n[_DYN_ORI_PAYLOAD];
              d._xdrOnLoad(i, e);
            }, i.onerror = function () {
              g(t, 400, {}, A(i));
            }, e && e.location && e.location.protocol || "");
          0 !== L.lastIndexOf(e, 0) ? (_throwInternal(d[_DYN_DIAG_LOG](), 2, 40, ". Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol."), d._buffer[_DYN_CLEAR]()) : (e = L.replace(/^(https?:)/, ""), i.open("POST", e), i.send(o));
        }
        function A(e, t) {
          return e ? "XDomainRequest,Response:" + _getResponseText(e) || "" : t;
        }
        function r() {
          d[_DYN__SENDER] = null, d[_DYN__BUFFER] = null, d._appId = null, d._sample = null, F = ne = i = I = 0, K = H = UNDEFINED_VALUE$1, te = J = X = j = z = B = P = !(R = {}), ee = Q = q = Y = $ = U = L = k = O = D = t = N = M = null, objDefine(d, "_senderConfig", {
            g: function () {
              return objExtend({}, defaultAppInsightsChannelConfig);
            }
          });
        }
        r(), d.pause = function () {
          T(), P = !0;
        }, d.resume = function () {
          P && (P = !1, N = null, _(), w());
        }, d.flush = function (e, t, r) {
          if (void 0 === e && (e = !0), !P) {
            T();
            try {
              return d[_DYN_TRIGGER_SEND](e, null, r || 1);
            } catch (e) {
              _throwInternal(d[_DYN_DIAG_LOG](), 1, 22, "flush failed, telemetry will not be collected: " + getExceptionName(e), {
                exception: dumpObj(e)
              });
            }
          }
        }, d.onunloadFlush = function () {
          if (!P) if (B || Z) try {
            return d[_DYN_TRIGGER_SEND](!0, e, 2);
          } catch (e) {
            _throwInternal(d[_DYN_DIAG_LOG](), 1, 20, "failed to flush with beacon sender on page unload, telemetry will not be collected: " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          } else d.flush(!1);
        }, d.addHeader = function (e, t) {
          R[e] = t;
        }, d.initialize = function (e, c, t, r) {
          d.isInitialized() && _throwInternal(d[_DYN_DIAG_LOG](), 1, 28, "Sender is already initialized"), n.initialize(e, c, t, r);
          var u = d.identifier,
            h = (D = new Serializer(c.logger), I = 0, N = null, d[_DYN__SENDER] = null, i = 0, d[_DYN_DIAG_LOG]());
          k = mergeEvtNamespace(createUniqueNamespace("Sender"), c.evtNamespace && c.evtNamespace()), M = createOfflineListener(k), d._addHook(onConfigChange(e, function (e) {
            e = e.cfg;
            e.storagePrefix && utlSetStoragePrefix(e.storagePrefix);
            var t = createProcessTelemetryContext(null, e, c).getExtCfg(u, defaultAppInsightsChannelConfig),
              r = (objDefine(d, "_senderConfig", {
                g: function () {
                  return t;
                }
              }), U !== t.endpointUrl && (L = U = t.endpointUrl), $ && $ !== t[_DYN_CUSTOM_HEADERS] && arrForEach($, function (e) {
                delete R[e.header];
              }), F = t[_DYN_MAX_BATCH_SIZE_IN_BY1], B = (!1 === t[_DYN_ONUNLOAD_DISABLE_BEA2] || !1 === t[_DYN_IS_BEACON_API_DISABL3]) && isBeaconsSupported(), Z = t[_DYN_ALWAYS_USE_XHR_OVERR4], X = !!t.disableXhr, t[_DYN_BUFFER_OVERRIDE]),
              n = !!t[_DYN_ENABLE_SESSION_STORA5] && (!!r || utlCanUseSessionStorage()),
              i = t.namePrefix,
              o = n !== q || n && K !== i || n && V !== r;
            if (d[_DYN__BUFFER]) {
              if (o) try {
                d._buffer = d._buffer[_DYN_CREATE_NEW](h, t, n);
              } catch (e) {
                _throwInternal(d[_DYN_DIAG_LOG](), 1, 12, "failed to transfer telemetry to different buffer storage, telemetry will be lost: " + getExceptionName(e), {
                  exception: dumpObj(e)
                });
              }
              _();
            } else d[_DYN__BUFFER] = new (n ? SessionStorageSendBuffer : ArraySendBuffer)(h, t);
            K = i, q = n, V = r, J = !t[_DYN_ONUNLOAD_DISABLE_FET6] && isFetchSupported(!0), te = !!t[_DYN_DISABLE_SEND_BEACON_7], d._sample = new Sample(t.samplingPercentage, h), function (e, t) {
              t = t.disableInstrumentationKeyValidation;
              if (!isNullOrUndefined(t) && t) return 1;
              return new RegExp("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$").test(e);
            }(Y = t[_DYN_INSTRUMENTATION_KEY$1], e) || _throwInternal(h, 1, 100, "Invalid Instrumentation key " + Y), $ = t[_DYN_CUSTOM_HEADERS], !isInternalApplicationInsightsEndpoint(L) && $ && 0 < $[_DYN_LENGTH$2] ? arrForEach($, function (e) {
              re.addHeader(e.header, e.value);
            }) : $ = null, W = t.enableSendPromise;
            var a,
              o = t.httpXHROverride,
              s = null,
              s = p([1, 2], !1),
              l = {
                sendPOST: y
              };
            Q = function (e, t) {
              return f(l, e, t);
            }, ee = function (e, t) {
              return f(l, e, t, !1);
            }, !t[_DYN_IS_BEACON_API_DISABL3] && isBeaconsSupported() && (s = p([3], !1)), s = Z ? o : s || o || l, d[_DYN__SENDER] = function (e, t) {
              return f(s, e, t);
            }, J && (O = v), a = !Z && p([3, 1], !0) || o, O = (O = !Z && O || !a ? O : function (e, t) {
              return f(a, e, t);
            }) || Q, z = t.disableTelemetry, H = t[_DYN_CONVERT_UNDEFINED] || UNDEFINED_VALUE$1, j = t.isRetryDisabled, G = t[_DYN_MAX_BATCH_INTERVAL];
          }));
        }, d.processTelemetry = function (e, t) {
          var r = (t = d._getTelCtx(t))[_DYN_DIAG_LOG]();
          try {
            if (z) return;
            if (!e) return void _throwInternal(r, 1, 7, "Cannot send empty telemetry");
            if (e.baseData && !e[_DYN_BASE_TYPE]) return void _throwInternal(r, 1, 70, "Cannot send telemetry without baseData and baseType");
            if (e[_DYN_BASE_TYPE] || (e[_DYN_BASE_TYPE] = "EventData"), !d[_DYN__SENDER]) return void _throwInternal(r, 1, 28, "Sender was not initialized");
            if (!d._sample.isSampledIn(e)) return void _throwInternal(r, 2, 33, "Telemetry item was sampled out and not sent", {
              SampleRate: d._sample[_DYN_SAMPLE_RATE]
            });
            e[SampleRate] = d._sample[_DYN_SAMPLE_RATE];
            var n = e.iKey || Y,
              i = ie.constructEnvelope(e, n, r, H);
            if (!i) return void _throwInternal(r, 1, 47, "Unable to create an AppInsights envelope");
            var o = !1;
            if (e[_DYN_TAGS] && e[_DYN_TAGS][ProcessLegacy] && (arrForEach(e[_DYN_TAGS][ProcessLegacy], function (e) {
              try {
                e && !1 === e(i) && (o = !0, _warnToConsole(r, "Telemetry processor check returns false"));
              } catch (e) {
                _throwInternal(r, 1, 64, "One of telemetry initializers failed, telemetry item will not be sent: " + getExceptionName(e), {
                  exception: dumpObj(e)
                }, !0);
              }
            }), delete e[_DYN_TAGS][ProcessLegacy]), o) return;
            var a = D.serialize(i),
              s = d[_DYN__BUFFER];
            _(a), s[_DYN_ENQUEUE](a), w();
          } catch (e) {
            _throwInternal(r, 2, 12, "Failed adding telemetry to the sender's buffer, some telemetry will be lost: " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
          d.processNext(e, t);
        }, d[_DYN__XHR_READY_STATE_CHA8] = function (e, t, r) {
          4 === e.readyState && m(e.status, t, e.responseURL, r, x(e), _getResponseText(e) || e.response);
        }, d[_DYN_TRIGGER_SEND] = function (e, t, r) {
          var n;
          if (void 0 === e && (e = !0), !P) try {
            var i = d[_DYN__BUFFER];
            if (z) i[_DYN_CLEAR]();else if (0 < i[_DYN_COUNT]()) {
              var o = i.getItems(),
                a = r || 0,
                s = e,
                l = function () {
                  var e = "getNotifyMgr";
                  if (d.core[e]) return d.core[e]();
                  return d.core._notificationManager;
                }();
              if (l && l[_DYN_EVENTS_SEND_REQUEST]) try {
                l[_DYN_EVENTS_SEND_REQUEST](a, s);
              } catch (e) {
                _throwInternal(d[_DYN_DIAG_LOG](), 1, 74, "send request notification failed: " + getExceptionName(e), {
                  exception: dumpObj(e)
                });
              }
              n = t ? t.call(d, o, e) : d[_DYN__SENDER](o, e);
            }
            T();
          } catch (e) {
            i = getIEVersion();
            (!i || 9 < i) && _throwInternal(d[_DYN_DIAG_LOG](), 1, 40, "Telemetry transmission failed, some telemetry will be lost: " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
          return n;
        }, d._doTeardown = function (e, t) {
          d.onunloadFlush(), runTargetUnload(M, !1), r();
        }, d[_DYN__ON_ERROR] = function (e, t, r) {
          _throwInternal(d[_DYN_DIAG_LOG](), 2, 26, "Failed to send telemetry.", {
            message: t
          }), d._buffer && d._buffer[_DYN_CLEAR_SENT](e);
        }, d[_DYN__ON_PARTIAL_SUCCESS] = function (e, t) {
          for (var r = [], n = [], i = 0, o = t.errors.reverse(); i < o.length; i++) {
            var a = o[i],
              s = e.splice(a.index, 1)[0];
            (S(a.statusCode) ? n : r)[_DYN_PUSH](s);
          }
          0 < e[_DYN_LENGTH$2] && d[_DYN__ON_SUCCESS](e, t[_DYN_ITEMS_ACCEPTED]), 0 < r[_DYN_LENGTH$2] && d[_DYN__ON_ERROR](r, x(null, ["partial success", t[_DYN_ITEMS_ACCEPTED], "of", t.itemsReceived].join(" "))), 0 < n[_DYN_LENGTH$2] && (b(n), _throwInternal(d[_DYN_DIAG_LOG](), 2, 40, "Partial success. Delivered: " + e[_DYN_LENGTH$2] + ", Failed: " + r[_DYN_LENGTH$2] + ". Will retry to send " + n[_DYN_LENGTH$2] + " our of " + t[_DYN_ITEMS_RECEIVED] + " items"));
        }, d[_DYN__ON_SUCCESS] = function (e, t) {
          d._buffer && d._buffer[_DYN_CLEAR_SENT](e);
        }, d._xdrOnLoad = function (e, t) {
          var r = _getResponseText(e);
          !e || r + "" != "200" && "" !== r ? (r = E(r)) && r.itemsReceived && r.itemsReceived > r[_DYN_ITEMS_ACCEPTED] && !j ? d[_DYN__ON_PARTIAL_SUCCESS](t, r) : d[_DYN__ON_ERROR](t, A(e)) : (I = 0, d[_DYN__ON_SUCCESS](t, 0));
        };
      }), re;
    }
    return __extendsFn(ie, e), ie.constructEnvelope = function (e, t, r, n) {
      e = t === e.iKey || isNullOrUndefined(t) ? e : __assignFn(__assignFn({}, e), {
        iKey: t
      });
      return (EnvelopeTypeCreator[e.baseType] || EventEnvelopeCreator)(r, e, n);
    }, ie;
  }(BaseTelemetryPlugin),
  STR_DURATION = "duration",
  STR_PROPERTIES = "properties",
  _DYN_REQUEST_URL = "requestUrl",
  _DYN_INST = "inst",
  _DYN_LENGTH$1 = "length",
  _DYN_TRACE_ID = "traceID",
  _DYN_SPAN_ID = "spanID",
  _DYN_TRACE_FLAGS = "traceFlags",
  _DYN_CONTEXT$1 = "context",
  _DYN_ABORTED = "aborted",
  _DYN_TRACE_ID0 = "traceId",
  _DYN_SPAN_ID1 = "spanId",
  _DYN__ADD_HOOK = "_addHook",
  _DYN_CORE = "core",
  _DYN_INCLUDE_CORRELATION_2 = "includeCorrelationHeaders",
  _DYN_GET_ABSOLUTE_URL = "getAbsoluteUrl",
  _DYN_HEADERS = "headers",
  _DYN_REQUEST_HEADERS = "requestHeaders",
  _DYN_SET_REQUEST_HEADER = "setRequestHeader",
  _DYN_TRACK_DEPENDENCY_DAT3 = "trackDependencyDataInternal",
  _DYN_START_TIME = "startTime",
  _DYN_TO_LOWER_CASE = "toLowerCase",
  _DYN_ENABLE_REQUEST_HEADE4 = "enableRequestHeaderTracking",
  _DYN_ENABLE_AJAX_ERROR_ST5 = "enableAjaxErrorStatusText",
  _DYN_ENABLE_AJAX_PERF_TRA6 = "enableAjaxPerfTracking",
  _DYN_MAX_AJAX_CALLS_PER_V7 = "maxAjaxCallsPerView",
  _DYN_EXCLUDE_REQUEST_FROM8 = "excludeRequestFromAutoTrackingPatterns",
  _DYN_ADD_REQUEST_CONTEXT = "addRequestContext",
  _DYN_DISABLE_AJAX_TRACKIN9 = "disableAjaxTracking",
  _DYN_AJAX_PERF_LOOKUP_DEL10 = "ajaxPerfLookupDelay",
  _DYN_DISABLE_FETCH_TRACKI11 = "disableFetchTracking",
  _DYN_ENABLE_RESPONSE_HEAD12 = "enableResponseHeaderTracking",
  _DYN_STATUS = "status",
  _DYN_STATUS_TEXT = "statusText",
  _DYN_HEADER_MAP = "headerMap",
  _DYN_OPEN_DONE = "openDone",
  _DYN_SEND_DONE = "sendDone",
  _DYN_REQUEST_SENT_TIME = "requestSentTime",
  _DYN_ABORT_DONE = "abortDone",
  _DYN_GET_TRACE_ID = "getTraceId",
  _DYN_GET_TRACE_FLAGS = "getTraceFlags",
  _DYN_METHOD = "method",
  _DYN_ERROR_STATUS_TEXT = "errorStatusText",
  _DYN_STATE_CHANGE_ATTACHE13 = "stateChangeAttached",
  _DYN_RESPONSE_TEXT = "responseText",
  _DYN_RESPONSE_FINISHED_TI14 = "responseFinishedTime",
  _DYN__CREATE_TRACK_ITEM = "CreateTrackItem",
  _DYN_RESPONSE = "response",
  _DYN_GET_ALL_RESPONSE_HEA15 = "getAllResponseHeaders",
  _DYN_GET_PART_APROPS = "getPartAProps",
  _DYN_PERF_MARK = "perfMark",
  _DYN_NAME = "name",
  _DYN_PERF_TIMING = "perfTiming",
  _DYN_EXCEPTION = "exception",
  _DYN_AJAX_DIAGNOSTICS_MES16 = "ajaxDiagnosticsMessage",
  _DYN_CORRELATION_CONTEXT = "correlationContext",
  _DYN_AJAX_TOTAL_DURATION = "ajaxTotalDuration",
  _DYN_EVENT_TRACE_CTX = "eventTraceCtx";
function _calcPerfDuration(e, t, r) {
  var n = 0,
    t = e[t],
    e = e[r];
  return n = t && e ? dateTimeUtilsDuration(t, e) : n;
}
function _setPerfDuration(e, t, r, n, i) {
  var o = 0,
    r = _calcPerfDuration(r, n, i);
  return o = r ? _setPerfValue(e, t, msToTimeSpan(r)) : o;
}
function _setPerfValue(e, t, r) {
  var n = 0;
  return e && t && r && ((e.ajaxPerf = e.ajaxPerf || {})[t] = r, n = 1), n;
}
function _populatePerfData(e, t) {
  var n,
    r = e[_DYN_PERF_TIMING],
    i = t[STR_PROPERTIES] || {},
    o = 0,
    a = "Start",
    s = "domainLookup",
    l = "connect",
    c = "request",
    u = "response",
    h = l + "End",
    a = c + a,
    d = u + "End",
    p = "transferSize",
    f = "encodedBodySize",
    _ = "decodedBodySize",
    m = "serverTiming";
  r ? (o = (o = (o = (o = (o = (o = (o |= _setPerfDuration(i, "End", r, "redirectStart", "End")) | _setPerfDuration(i, s, r, "domainLookupStart", "domainLookupEnd")) | _setPerfDuration(i, l, r, "connectStart", h)) | _setPerfDuration(i, c, r, a, "requestEnd")) | _setPerfDuration(i, u, r, "responseStart", d)) | _setPerfDuration(i, "networkConnect", r, "startTime", h)) | _setPerfDuration(i, "sentRequest", r, a, d), s = (s = r[STR_DURATION]) || _calcPerfDuration(r, "startTime", d) || 0, o = (o |= _setPerfValue(i, STR_DURATION, s)) | _setPerfValue(i, "perfTotal", s), (l = r[m]) && (n = {}, arrForEach(l, function (e, t) {
    var t = normalizeJsName(e.name || "" + t),
      r = n[t] || {};
    objForEachKey(e, function (e, t) {
      !("name" !== e && isString(t) || isNumber(t)) || !(t = r[e] ? r[e] + ";" + t : t) && isString(t) || (r[e] = t);
    }), n[t] = r;
  }), o |= _setPerfValue(i, m, n)), o = (o = (o |= _setPerfValue(i, p, r[p])) | _setPerfValue(i, f, r[f])) | _setPerfValue(i, _, r[_])) : e[_DYN_PERF_MARK] && (o |= _setPerfValue(i, "missing", e.perfAttempts)), o && (t[STR_PROPERTIES] = i);
}
var _a$2,
  XHRMonitoringState = function () {
    this[_DYN_OPEN_DONE] = !1, this.setRequestHeaderDone = !1, this[_DYN_SEND_DONE] = !1, this[_DYN_ABORT_DONE] = !1, this[_DYN_STATE_CHANGE_ATTACHE13] = !1;
  },
  ajaxRecord = function () {
    function a(e, t, r, n) {
      var i = this,
        o = r;
      i[_DYN_PERF_MARK] = null, i.completed = !1, i.requestHeadersSize = null, i[_DYN_REQUEST_HEADERS] = null, i.responseReceivingDuration = null, i.callbackDuration = null, i[_DYN_AJAX_TOTAL_DURATION] = null, i[_DYN_ABORTED] = 0, i.pageUrl = null, i[_DYN_REQUEST_URL] = null, i.requestSize = 0, i[_DYN_METHOD] = null, i[_DYN_STATUS] = null, i[_DYN_REQUEST_SENT_TIME] = null, i.responseStartedTime = null, i[_DYN_RESPONSE_FINISHED_TI14] = null, i.callbackFinishedTime = null, i.endTime = null, i.xhrMonitoringState = new XHRMonitoringState(), i.clientFailure = 0, i[_DYN_TRACE_ID] = e, i[_DYN_SPAN_ID] = t, i[_DYN_TRACE_FLAGS] = null == n ? void 0 : n.getTraceFlags(), i[_DYN_EVENT_TRACE_CTX] = n ? ((r = {})[_DYN_TRACE_ID0] = n[_DYN_GET_TRACE_ID](), r[_DYN_SPAN_ID1] = n.getSpanId(), r[_DYN_TRACE_FLAGS] = n[_DYN_GET_TRACE_FLAGS](), r) : null, dynamicProto(a, i, function (i) {
        i.getAbsoluteUrl = function () {
          return i[_DYN_REQUEST_URL] ? urlGetAbsoluteUrl(i[_DYN_REQUEST_URL]) : null;
        }, i.getPathName = function () {
          return i[_DYN_REQUEST_URL] ? dataSanitizeUrl(o, urlGetCompleteUrl(i[_DYN_METHOD], i[_DYN_REQUEST_URL])) : null;
        }, i[_DYN__CREATE_TRACK_ITEM] = function (e, t, r) {
          var n;
          return i.ajaxTotalDuration = Math.round(1e3 * dateTimeUtilsDuration(i.requestSentTime, i.responseFinishedTime)) / 1e3, i[_DYN_AJAX_TOTAL_DURATION] < 0 ? null : ((n = {
            id: "|" + i[_DYN_TRACE_ID] + "." + i[_DYN_SPAN_ID],
            target: i[_DYN_GET_ABSOLUTE_URL]()
          })[_DYN_NAME] = i.getPathName(), n.type = e, n[_DYN_START_TIME] = null, n.duration = i[_DYN_AJAX_TOTAL_DURATION], n.success = 200 <= +i[_DYN_STATUS] && +i[_DYN_STATUS] < 400, n.responseCode = +i[_DYN_STATUS], n[STR_PROPERTIES] = {
            HttpMethod: i[_DYN_METHOD]
          }, n = (e = n)[STR_PROPERTIES], i[_DYN_ABORTED] && (n[_DYN_ABORTED] = !0), i[_DYN_REQUEST_SENT_TIME] && (e[_DYN_START_TIME] = new Date(), e[_DYN_START_TIME].setTime(i[_DYN_REQUEST_SENT_TIME])), _populatePerfData(i, e), t && 0 < objKeys(i.requestHeaders)[_DYN_LENGTH$1] && (n[_DYN_REQUEST_HEADERS] = i[_DYN_REQUEST_HEADERS]), r && (t = r()) && ((r = t[_DYN_CORRELATION_CONTEXT]) && (e.correlationContext = r), t[_DYN_HEADER_MAP] && 0 < objKeys(t.headerMap)[_DYN_LENGTH$1] && (n.responseHeaders = t[_DYN_HEADER_MAP]), i[_DYN_ERROR_STATUS_TEXT]) && (400 <= i[_DYN_STATUS] ? ("" !== (r = t.type) && "text" !== r || (n.responseText = t.responseText ? t[_DYN_STATUS_TEXT] + " - " + t.responseText : t[_DYN_STATUS_TEXT]), "json" === r && (n.responseText = t.response ? t[_DYN_STATUS_TEXT] + " - " + JSON.stringify(t[_DYN_RESPONSE]) : t[_DYN_STATUS_TEXT])) : 0 === i[_DYN_STATUS] && (n.responseText = t[_DYN_STATUS_TEXT] || "")), e);
        }, i[_DYN_GET_PART_APROPS] = function () {
          var e,
            t = null,
            r = i[_DYN_EVENT_TRACE_CTX];
          return r && (r[_DYN_TRACE_ID0] || r[_DYN_SPAN_ID1]) && (e = (t = {})[Extensions.TraceExt] = ((e = {})[_DYN_TRACE_ID] = r[_DYN_TRACE_ID0], e.parentID = r[_DYN_SPAN_ID1], e), isNullOrUndefined(r[_DYN_TRACE_FLAGS]) || (e[_DYN_TRACE_FLAGS] = r[_DYN_TRACE_FLAGS])), t;
        };
      });
    }
    return a.__ieDyn = 1, a;
  }(),
  AJAX_MONITOR_PREFIX = "ai.ajxmn.",
  strDiagLog = "diagLog",
  AJAX_DATA_CONTAINER = "_ajaxData",
  STR_FETCH = "fetch",
  ERROR_HEADER = "Failed to monitor XMLHttpRequest",
  ERROR_PREFIX = ", monitoring data for this ajax call ",
  ERROR_POSTFIX = ERROR_PREFIX + "may be incorrect.",
  ERROR_NOT_SENT = ERROR_PREFIX + "won't be sent.",
  CORRELATION_HEADER_ERROR = "Failed to get Request-Context correlation header as it may be not included in the response or not accessible.",
  CUSTOM_REQUEST_CONTEXT_ERROR = "Failed to add custom defined request context as configured call back may missing a null check.",
  FAILED_TO_CALCULATE_DURATION_ERROR = "Failed to calculate the duration of the ",
  _markCount = 0;
function _supportsFetch() {
  var e = getGlobal();
  return !e || isNullOrUndefined(e.Request) || isNullOrUndefined(e.Request[strShimPrototype]) || isNullOrUndefined(e[STR_FETCH]) ? null : e[STR_FETCH];
}
function _supportsAjaxMonitoring(t, e) {
  var r,
    n = !1,
    i = (isXhrSupported() && (n = !(isNullOrUndefined(i = XMLHttpRequest[strShimPrototype]) || isNullOrUndefined(i.open) || isNullOrUndefined(i.send) || isNullOrUndefined(i.abort))), getIEVersion());
  if (n = i && i < 9 ? !1 : n) try {
    var o = new XMLHttpRequest(),
      a = {
        xh: [],
        i: ((r = {})[e] = {}, r)
      },
      s = (o[AJAX_DATA_CONTAINER] = a, XMLHttpRequest[strShimPrototype].open);
    XMLHttpRequest[strShimPrototype].open = s;
  } catch (e) {
    n = !1, _throwInternalCritical(t, 15, "Failed to enable XMLHttpRequest monitoring, extension is not supported", ((i = {})[_DYN_EXCEPTION] = dumpObj(e), i));
  }
  return n;
}
var _getAjaxData = function (e, t) {
    return e && t && e[AJAX_DATA_CONTAINER] ? (e[AJAX_DATA_CONTAINER].i || {})[t] : null;
  },
  _addSharedXhrHeaders = function (e, t, r) {
    e && (e = (e[AJAX_DATA_CONTAINER] || {}).xh) && e.push({
      n: t,
      v: r
    });
  },
  _isHeaderSet = function (e, t) {
    var r = !1;
    return e && (e = (e[AJAX_DATA_CONTAINER] || {}).xh) && arrForEach(e, function (e) {
      if (e.n === t) return r = !0, -1;
    }), r;
  };
function _getFailedAjaxDiagnosticsMessage(e, t) {
  var r = "";
  try {
    var n = _getAjaxData(e, t);
    n && n[_DYN_REQUEST_URL] && (r += "(url: '" + n[_DYN_REQUEST_URL] + "')");
  } catch (e) {}
  return r;
}
function _throwInternalCritical(e, t, r, n, i) {
  _throwInternal(e[strDiagLog](), 1, t, r, n, i);
}
function _throwInternalWarning(e, t, r, n, i) {
  _throwInternal(e[strDiagLog](), 2, t, r, n, i);
}
function _createErrorCallbackFunc(r, n, i) {
  return function (e) {
    var t;
    _throwInternalCritical(r, n, i, ((t = {
      ajaxDiagnosticsMessage: _getFailedAjaxDiagnosticsMessage(e[_DYN_INST], r._ajaxDataId)
    })[_DYN_EXCEPTION] = dumpObj(e.err), t));
  };
}
function _indexOf(e, t) {
  return e && t ? strIndexOf(e, t) : -1;
}
function _addHandler(r, e, t) {
  var n = {
    id: e,
    fn: t
  };
  return r.push(n), {
    remove: function () {
      arrForEach(r, function (e, t) {
        if (e.id === n.id) return r.splice(t, 1), -1;
      });
    }
  };
}
function _processDependencyContainer(r, e, n, i) {
  var o = !0;
  return arrForEach(e, function (e, t) {
    try {
      !1 === e.fn.call(null, n) && (o = !1);
    } catch (e) {
      _throwInternal(r && r.logger, 1, 64, "Dependency " + i + " [#" + t + "] failed: " + getExceptionName(e), {
        exception: dumpObj(e)
      }, !0);
    }
  }), o;
}
function _processDependencyListeners(e, t, r, n, i, o) {
  var a;
  0 < e[_DYN_LENGTH$1] && ((a = {})[_DYN_CORE] = t, a.xhr = n, a.input = i, a.init = o, a.traceId = r[_DYN_TRACE_ID], a.spanId = r[_DYN_SPAN_ID], a.traceFlags = r[_DYN_TRACE_FLAGS], a.context = r[_DYN_CONTEXT$1] || {}, a.aborted = !!r[_DYN_ABORTED], _processDependencyContainer(t, e, n = a, "listener"), r[_DYN_TRACE_ID] = n[_DYN_TRACE_ID0], r[_DYN_SPAN_ID] = n[_DYN_SPAN_ID1], r[_DYN_TRACE_FLAGS] = n[_DYN_TRACE_FLAGS], r[_DYN_CONTEXT$1] = n[_DYN_CONTEXT$1]);
}
var BLOB_CORE = "*.blob.core.",
  DfltAjaxCorrelationHeaderExDomains = objFreeze([BLOB_CORE + "windows.net", BLOB_CORE + "chinacloudapi.cn", BLOB_CORE + "cloudapi.de", BLOB_CORE + "usgovcloudapi.net"]),
  _internalExcludeEndpoints = [/https:\/\/[^\/]*(\.pipe\.aria|aria\.pipe|events\.data|collector\.azure)\.[^\/]+\/(OneCollector\/1|Collector\/3)\.0/i],
  _defaultConfig$1 = objFreeze(((_a$2 = {})[_DYN_MAX_AJAX_CALLS_PER_V7] = 500, _a$2[_DYN_DISABLE_AJAX_TRACKIN9] = !1, _a$2[_DYN_DISABLE_FETCH_TRACKI11] = !1, _a$2[_DYN_EXCLUDE_REQUEST_FROM8] = void 0, _a$2.disableCorrelationHeaders = !1, _a$2.distributedTracingMode = 1, _a$2.correlationHeaderExcludedDomains = DfltAjaxCorrelationHeaderExDomains, _a$2.correlationHeaderDomains = void 0, _a$2.correlationHeaderExcludePatterns = void 0, _a$2.appId = void 0, _a$2.enableCorsCorrelation = !1, _a$2[_DYN_ENABLE_REQUEST_HEADE4] = !1, _a$2[_DYN_ENABLE_RESPONSE_HEAD12] = !1, _a$2[_DYN_ENABLE_AJAX_ERROR_ST5] = !1, _a$2[_DYN_ENABLE_AJAX_PERF_TRA6] = !1, _a$2.maxAjaxPerfLookupAttempts = 3, _a$2[_DYN_AJAX_PERF_LOOKUP_DEL10] = 25, _a$2.ignoreHeaders = ["Authorization", "X-API-Key", "WWW-Authenticate"], _a$2[_DYN_ADD_REQUEST_CONTEXT] = void 0, _a$2.addIntEndpoints = !0, _a$2)),
  AjaxMonitor = function (r) {
    function V() {
      var v,
        E,
        b,
        w,
        T,
        S,
        n,
        x,
        C,
        A,
        I,
        N,
        P,
        D,
        R,
        O,
        M,
        k,
        L,
        U,
        F,
        t,
        B,
        $,
        z,
        Y,
        H,
        j,
        G,
        q,
        e = r.call(this) || this;
      return e.identifier = V.identifier, e.priority = 120, dynamicProto(V, e, function (h, a) {
        var s = a[_DYN__ADD_HOOK];
        function e() {
          var e = getLocation();
          q = E = v = !1, b = e && e.host && e.host[_DYN_TO_LOWER_CASE](), D = N = A = C = S = T = !1, M = O = !(R = {}), U = L = k = I = x = w = null, t = P = n = 0, B = [], $ = [], F = createUniqueNamespace("ajaxData"), h._ajaxDataId = F, j = H = Y = 1, G = z = null;
        }
        function d(t) {
          var r = !0;
          return (t || z) && arrForEach(z, function (e) {
            if (e[_DYN_TO_LOWER_CASE]() === t[_DYN_TO_LOWER_CASE]()) return r = !1, -1;
          }), r;
        }
        function l(e, t, r) {
          s(InstrumentProto(e, t, r));
        }
        function p(e, t, r) {
          var n,
            i,
            o = !1,
            a = ((isString(t) ? t : (t || {}).url || "") || "")[_DYN_TO_LOWER_CASE]();
          return arrForEach(k, function (e) {
            var t = e;
            isString(e) && (t = new RegExp(e)), o = o || t.test(a);
          }), o || (n = _indexOf(a, "?"), i = _indexOf(a, "#"), -1 !== (n = -1 === n || -1 !== i && i < n ? i : n) && (a = a.substring(0, n)), isNullOrUndefined(e) ? isNullOrUndefined(t) || (o = "object" == typeof t && !0 === t[DisabledPropertyName] || !!r && !0 === r[DisabledPropertyName]) : o = !0 === e[DisabledPropertyName] || !0 === a[DisabledPropertyName], (o = !o && a && isInternalApplicationInsightsEndpoint(a) ? !0 : o) ? R[a] || (R[a] = 1) : R[a] && (o = !0)), o;
        }
        function f(e, t, r) {
          var n = !0,
            i = E;
          return isNullOrUndefined(e) || (n = !0 === r || !isNullOrUndefined(t)), i && n;
        }
        function _() {
          var e = null;
          return e = !(e = h[_DYN_CORE] && h[_DYN_CORE].getTraceCtx ? h[_DYN_CORE].getTraceCtx(!1) : e) && x && x.telemetryTrace ? createDistributedTraceContextFromTrace(x.telemetryTrace) : e;
        }
        function c(e, t) {
          var r;
          t[_DYN_REQUEST_URL] && I && N && (r = getPerformance()) && isFunction(r.mark) && (e = I + e + "#" + ++_markCount, r.mark(e), r = r.getEntriesByName(e)) && 1 === r[_DYN_LENGTH$1] && (t[_DYN_PERF_MARK] = r[0]);
        }
        function m(o, a, s, l) {
          var c = a[_DYN_PERF_MARK],
            u = getPerformance(),
            h = Y,
            d = H,
            p = a[_DYN_REQUEST_URL],
            f = 0;
          !function e() {
            try {
              if (u && c) {
                f++;
                for (var t = null, r = u.getEntries(), n = r[_DYN_LENGTH$1] - 1; 0 <= n; n--) {
                  var i = r[n];
                  if (i) {
                    if ("resource" === i.entryType) i.initiatorType !== o || -1 === _indexOf(i[_DYN_NAME], p) && -1 === _indexOf(p, i[_DYN_NAME]) || (t = i);else if ("mark" === i.entryType && i[_DYN_NAME] === c[_DYN_NAME]) {
                      a[_DYN_PERF_TIMING] = t;
                      break;
                    }
                    if (i[_DYN_START_TIME] < c[_DYN_START_TIME] - 1e3) break;
                  }
                }
              }
              !c || a[_DYN_PERF_TIMING] || h <= f || !1 === a.async ? (c && isFunction(u.clearMarks) && u.clearMarks(c[_DYN_NAME]), a.perfAttempts = f, s()) : scheduleTimeout(e, d);
            } catch (e) {
              l(e);
            }
          }();
        }
        function u(e) {
          var t = "";
          try {
            isNullOrUndefined(e) || (t += "(url: '".concat("string" == typeof e ? e : e.url, "')"));
          } catch (e) {
            _throwInternalCritical(h, 15, "Failed to grab failed fetch diagnostics message", {
              exception: dumpObj(e)
            });
          }
          return t;
        }
        function g(e, r, n, i, o, a) {
          function s(e, t, r) {
            r = r || {};
            r.fetchDiagnosticsMessage = u(n), t && (r.exception = dumpObj(t)), _throwInternalWarning(h, e, FAILED_TO_CALCULATE_DURATION_ERROR + "fetch call" + ERROR_NOT_SENT, r);
          }
          o && (o[_DYN_RESPONSE_FINISHED_TI14] = dateTimeUtilsNow(), o[_DYN_STATUS] = r, m(STR_FETCH, o, function () {
            var e,
              t = o[_DYN__CREATE_TRACK_ITEM]("Fetch", T, a);
            try {
              L && (e = L({
                status: r,
                request: n,
                response: i
              }));
            } catch (e) {
              _throwInternalWarning(h, 104, CUSTOM_REQUEST_CONTEXT_ERROR);
            }
            t ? (void 0 !== e && (t[STR_PROPERTIES] = __assignFn(__assignFn({}, t.properties), e)), e = o[_DYN_GET_PART_APROPS](), y($, h[_DYN_CORE], o, t, null, e)) : s(14, null, {
              requestSentTime: o[_DYN_REQUEST_SENT_TIME],
              responseFinishedTime: o[_DYN_RESPONSE_FINISHED_TI14]
            });
          }, function (e) {
            s(18, e, null);
          }));
        }
        function y(e, t, r, n, i, o) {
          var a,
            s = !0;
          0 < e[_DYN_LENGTH$1] && ((a = {
            item: n
          })[STR_PROPERTIES] = i, a.sysProperties = o, a.context = r ? r[_DYN_CONTEXT$1] : null, a.aborted = !!r && !!r[_DYN_ABORTED], s = _processDependencyContainer(t, e, a, "initializer")), s && h[_DYN_TRACK_DEPENDENCY_DAT3](n, i, o);
        }
        e(), h.initialize = function (e, t, r, n) {
          var i, o;
          !h.isInitialized() && (a.initialize(e, t, r, n), U = mergeEvtNamespace(createUniqueNamespace("ajax"), t && t.evtNamespace && t.evtNamespace()), h[_DYN__ADD_HOOK](onConfigChange(e, function (e) {
            var e = e.cfg,
              t = createProcessTelemetryContext(null, e, h[_DYN_CORE]);
            w = t.getExtCfg(V.identifier, _defaultConfig$1), j = w.distributedTracingMode, T = w[_DYN_ENABLE_REQUEST_HEADE4], S = w[_DYN_ENABLE_AJAX_ERROR_ST5], N = w[_DYN_ENABLE_AJAX_PERF_TRA6], P = w[_DYN_MAX_AJAX_CALLS_PER_V7], k = [].concat(w[_DYN_EXCLUDE_REQUEST_FROM8] || [], !1 !== w.addIntEndpoints ? _internalExcludeEndpoints : []), L = w[_DYN_ADD_REQUEST_CONTEXT], A = 0 === j || 1 === j, C = 1 === j || 2 === j, N && (t = e.instrumentationKey || "unkwn", I = 5 < t[_DYN_LENGTH$1] ? AJAX_MONITOR_PREFIX + strSubstring(t, t[_DYN_LENGTH$1] - 5) + "." : AJAX_MONITOR_PREFIX + t + "."), O = !!w[_DYN_DISABLE_AJAX_TRACKIN9], Y = w.maxAjaxPerfLookupAttempts, H = w[_DYN_AJAX_PERF_LOOKUP_DEL10], z = w.ignoreHeaders, G = w.appId;
          })), _supportsAjaxMonitoring(h, F) && h[_DYN__ADD_HOOK](onConfigChange(w, function () {
            O = !!w[_DYN_DISABLE_AJAX_TRACKIN9], T = w[_DYN_ENABLE_REQUEST_HEADE4], O || E || (l(XMLHttpRequest, "open", {
              ns: U,
              req: function (e, t, r, n) {
                var i, s, l, o, a, c, u;
                O || (e = e[_DYN_INST], i = _getAjaxData(e, F), !p(e, r) && f(e, i, !0) && (i && i.xhrMonitoringState[_DYN_OPEN_DONE] || (o = e, t = t, r = r, n = n, a = _(), c = a && a[_DYN_GET_TRACE_ID]() || generateW3CId(), u = strSubstr(generateW3CId(), 0, 16), o = (o = o[AJAX_DATA_CONTAINER] = o[AJAX_DATA_CONTAINER] || {
                  xh: [],
                  i: {}
                }).i = o.i || {}, (c = o[F] = o[F] || new ajaxRecord(c, u, h[strDiagLog](), null == (o = h.core) ? void 0 : o.getTraceCtx()))[_DYN_TRACE_FLAGS] = a && a[_DYN_GET_TRACE_FLAGS](), c[_DYN_METHOD] = t, c[_DYN_REQUEST_URL] = r, c.xhrMonitoringState[_DYN_OPEN_DONE] = !0, c[_DYN_REQUEST_HEADERS] = {}, c.async = n, c[_DYN_ERROR_STATUS_TEXT] = S, i = c), s = e, (l = i).xhrMonitoringState[_DYN_STATE_CHANGE_ATTACHE13] = eventOn(s, "readystatechange", function () {
                  var t, i, o;
                  try {
                    s && 4 === s.readyState && f(s, l) && ((o = _getAjaxData(i = s, F))[_DYN_RESPONSE_FINISHED_TI14] = dateTimeUtilsNow(), o[_DYN_STATUS] = i[_DYN_STATUS], m("xmlhttprequest", o, function () {
                      try {
                        var e,
                          t = o[_DYN__CREATE_TRACK_ITEM]("Ajax", T, function () {
                            (t = {
                              statusText: i[_DYN_STATUS_TEXT]
                            })[_DYN_HEADER_MAP] = null, t[_DYN_CORRELATION_CONTEXT] = function (t) {
                              try {
                                var r = t[_DYN_GET_ALL_RESPONSE_HEA15]();
                                if (null !== r) if (-1 !== _indexOf(r[_DYN_TO_LOWER_CASE](), RequestHeaders[8])) return correlationIdGetCorrelationContext(t.getResponseHeader(RequestHeaders[0]));
                              } catch (e) {
                                _throwInternalWarning(h, 18, CORRELATION_HEADER_ERROR, ((r = {})[_DYN_AJAX_DIAGNOSTICS_MES16] = _getFailedAjaxDiagnosticsMessage(t, F), r[_DYN_EXCEPTION] = dumpObj(e), r));
                              }
                            }(i), t.type = i.responseType, t[_DYN_RESPONSE_TEXT] = function (e) {
                              try {
                                var t = e.responseType;
                                if ("" === t || "text" === t) return e[_DYN_RESPONSE_TEXT];
                              } catch (e) {}
                              return null;
                            }(i), t.response = i[_DYN_RESPONSE];
                            var e, r, t;
                            return D && (e = i[_DYN_GET_ALL_RESPONSE_HEA15]()) && (e = strTrim(e).split(/[\r\n]+/), r = {}, arrForEach(e, function (e) {
                              var e = e.split(": "),
                                t = e.shift(),
                                e = e.join(": ");
                              d(t) && (r[t] = e);
                            }), t[_DYN_HEADER_MAP] = r), t;
                          }),
                          r = void 0;
                        try {
                          L && (r = L({
                            status: i[_DYN_STATUS],
                            xhr: i
                          }));
                        } catch (e) {
                          _throwInternalWarning(h, 104, CUSTOM_REQUEST_CONTEXT_ERROR);
                        }
                        t ? (void 0 !== r && (t[STR_PROPERTIES] = __assignFn(__assignFn({}, t.properties), r)), e = o[_DYN_GET_PART_APROPS](), y($, h[_DYN_CORE], o, t, null, e)) : a(null, {
                          requestSentTime: o[_DYN_REQUEST_SENT_TIME],
                          responseFinishedTime: o[_DYN_RESPONSE_FINISHED_TI14]
                        });
                      } finally {
                        try {
                          var n = (i[AJAX_DATA_CONTAINER] || {
                            i: {}
                          }).i || {};
                          n[F] && (n[F] = null);
                        } catch (e) {}
                      }
                    }, function (e) {
                      a(e, null);
                    }));
                  } catch (e) {
                    var r = dumpObj(e);
                    r && -1 !== _indexOf(r[_DYN_TO_LOWER_CASE](), "c00c023f") || _throwInternalCritical(h, 16, ERROR_HEADER + " 'readystatechange' event handler" + ERROR_POSTFIX, ((t = {})[_DYN_AJAX_DIAGNOSTICS_MES16] = _getFailedAjaxDiagnosticsMessage(s, F), t[_DYN_EXCEPTION] = r, t));
                  }
                  function a(e, t) {
                    t = t || {};
                    t.ajaxDiagnosticsMessage = _getFailedAjaxDiagnosticsMessage(i, F), e && (t.exception = dumpObj(e)), _throwInternalWarning(h, 14, FAILED_TO_CALCULATE_DURATION_ERROR + "ajax call" + ERROR_NOT_SENT, t);
                  }
                }, U)));
              },
              hkErr: _createErrorCallbackFunc(h, 15, ERROR_HEADER + ".open" + ERROR_POSTFIX)
            }), l(XMLHttpRequest, "send", {
              ns: U,
              req: function (e, t) {
                var r;
                O || f(e = e[_DYN_INST], r = _getAjaxData(e, F)) && !r.xhrMonitoringState[_DYN_SEND_DONE] && (c("xhr", r), r[_DYN_REQUEST_SENT_TIME] = dateTimeUtilsNow(), h[_DYN_INCLUDE_CORRELATION_2](r, void 0, void 0, e), r.xhrMonitoringState[_DYN_SEND_DONE] = !0);
              },
              hkErr: _createErrorCallbackFunc(h, 17, ERROR_HEADER + ERROR_POSTFIX)
            }), l(XMLHttpRequest, "abort", {
              ns: U,
              req: function (e) {
                O || f(e = e[_DYN_INST], e = _getAjaxData(e, F)) && !e.xhrMonitoringState[_DYN_ABORT_DONE] && (e[_DYN_ABORTED] = 1, e.xhrMonitoringState[_DYN_ABORT_DONE] = !0);
              },
              hkErr: _createErrorCallbackFunc(h, 13, ERROR_HEADER + ".abort" + ERROR_POSTFIX)
            }), l(XMLHttpRequest, "setRequestHeader", {
              ns: U,
              req: function (e, t, r) {
                var n;
                O || (e = e[_DYN_INST], (n = _getAjaxData(e, F)) && f(e, n) && (_addSharedXhrHeaders(e, t, r), T) && d(t) && n && (n[_DYN_REQUEST_HEADERS][t] = r));
              },
              hkErr: _createErrorCallbackFunc(h, 71, ERROR_HEADER + ".setRequestHeader" + ERROR_POSTFIX)
            }), E = !0);
          })), (r = _supportsFetch()) && (i = getGlobal(), o = r.polyfill, h[_DYN__ADD_HOOK](onConfigChange(w, function () {
            M = !!w[_DYN_DISABLE_FETCH_TRACKI11], D = w[_DYN_ENABLE_RESPONSE_HEAD12], M || v ? o && !q && (s(InstrumentFunc(i, STR_FETCH, {
              ns: U,
              req: function (e, t, r) {
                p(null, t, r);
              }
            })), q = !0) : (s(InstrumentFunc(i, STR_FETCH, {
              ns: U,
              req: function (e, t, r) {
                var n, i;
                M || !v || p(null, t, r) || o && E || (n = e.ctx(), i = function (e, t) {
                  var r = _(),
                    n = r && r[_DYN_GET_TRACE_ID]() || generateW3CId(),
                    i = strSubstr(generateW3CId(), 0, 16),
                    i = new ajaxRecord(n, i, h[strDiagLog](), null == (n = h.core) ? void 0 : n.getTraceCtx());
                  i[_DYN_TRACE_FLAGS] = r && r[_DYN_GET_TRACE_FLAGS](), i[_DYN_REQUEST_SENT_TIME] = dateTimeUtilsNow(), i[_DYN_ERROR_STATUS_TEXT] = S, n = e instanceof Request ? (e || {}).url || "" : e;
                  "" === n && (r = getLocation()) && r.href && (n = strSplit(r.href, "#")[0]);
                  i[_DYN_REQUEST_URL] = n;
                  r = "GET";
                  t && t[_DYN_METHOD] ? r = t[_DYN_METHOD] : e && e instanceof Request && (r = e[_DYN_METHOD]);
                  i[_DYN_METHOD] = r;
                  var o = {};
                  T && new Headers((t ? t[_DYN_HEADERS] : 0) || e instanceof Request && e[_DYN_HEADERS] || {}).forEach(function (e, t) {
                    d(t) && (o[t] = e);
                  });
                  return i[_DYN_REQUEST_HEADERS] = o, c(STR_FETCH, i), i;
                }(t, r), (t = h[_DYN_INCLUDE_CORRELATION_2](i, t, r)) !== r && e.set(1, t), n.data = i);
              },
              rsp: function (e, r) {
                var n;
                M || (n = e.ctx().data) && (e.rslt = e.rslt.then(function (t) {
                  return g(0, (t || {})[_DYN_STATUS], r, t, n, function () {
                    (e = {
                      statusText: (t || {})[_DYN_STATUS_TEXT]
                    })[_DYN_HEADER_MAP] = null, e[_DYN_CORRELATION_CONTEXT] = function (t) {
                      if (t && t[_DYN_HEADERS]) try {
                        return correlationIdGetCorrelationContext(t[_DYN_HEADERS].get(RequestHeaders[0]));
                      } catch (e) {
                        _throwInternalWarning(h, 18, CORRELATION_HEADER_ERROR, ((t = {
                          fetchDiagnosticsMessage: u(t)
                        })[_DYN_EXCEPTION] = dumpObj(e), t));
                      }
                    }(t);
                    var r, e;
                    return D && t && (r = {}, t.headers.forEach(function (e, t) {
                      d(t) && (r[t] = e);
                    }), e[_DYN_HEADER_MAP] = r), e;
                  }), t;
                }).catch(function (e) {
                  throw g(0, 0, r, null, n, null, e.message || dumpObj(e)), e;
                }));
              },
              hkErr: _createErrorCallbackFunc(h, 15, "Failed to monitor Window.fetch" + ERROR_POSTFIX)
            }, !0, isWebWorker())), v = !0);
          })), o) && (i[STR_FETCH].polyfill = o), n = h[_DYN_CORE].getPlugin(PropertiesPluginIdentifier)) && (x = n.plugin[_DYN_CONTEXT$1]);
        }, h._doTeardown = function () {
          e();
        }, h.trackDependencyData = function (e, t) {
          y($, h[_DYN_CORE], null, e, t);
        }, h[_DYN_INCLUDE_CORRELATION_2] = function (e, t, r, n) {
          var i,
            o,
            a,
            s,
            l = h._currentWindowHost || b;
          return _processDependencyListeners(B, h[_DYN_CORE], e, n, t, r), t || "" === t ? (correlationIdCanIncludeCorrelationHeader(w, e[_DYN_GET_ABSOLUTE_URL](), l) && (r = r || {}, t = new Headers(r[_DYN_HEADERS] || t instanceof Request && t[_DYN_HEADERS] || {}), A && (i = "|" + e[_DYN_TRACE_ID] + "." + e[_DYN_SPAN_ID], t.set(RequestHeaders[3], i), T) && (e[_DYN_REQUEST_HEADERS][RequestHeaders[3]] = i), (o = G || x && x.appId()) && (t.set(RequestHeaders[0], RequestHeaders[2] + o), T) && (e[_DYN_REQUEST_HEADERS][RequestHeaders[0]] = RequestHeaders[2] + o), C && (isNullOrUndefined(a = e[_DYN_TRACE_FLAGS]) && (a = 1), s = formatTraceParent(createTraceParent(e[_DYN_TRACE_ID], e[_DYN_SPAN_ID], a)), t.set(RequestHeaders[4], s), T) && (e[_DYN_REQUEST_HEADERS][RequestHeaders[4]] = s), r[_DYN_HEADERS] = t), r) : n ? (correlationIdCanIncludeCorrelationHeader(w, e[_DYN_GET_ABSOLUTE_URL](), l) && (A && (_isHeaderSet(n, RequestHeaders[3]) ? _throwInternalWarning(h, 71, "Unable to set [" + RequestHeaders[3] + "] as it has already been set by another instance") : (i = "|" + e[_DYN_TRACE_ID] + "." + e[_DYN_SPAN_ID], n[_DYN_SET_REQUEST_HEADER](RequestHeaders[3], i), T && (e[_DYN_REQUEST_HEADERS][RequestHeaders[3]] = i))), (o = G || x && x.appId()) && (_isHeaderSet(n, RequestHeaders[0]) ? _throwInternalWarning(h, 71, "Unable to set [" + RequestHeaders[0] + "] as it has already been set by another instance") : (n[_DYN_SET_REQUEST_HEADER](RequestHeaders[0], RequestHeaders[2] + o), T && (e[_DYN_REQUEST_HEADERS][RequestHeaders[0]] = RequestHeaders[2] + o))), C) && (isNullOrUndefined(a = e[_DYN_TRACE_FLAGS]) && (a = 1), _isHeaderSet(n, RequestHeaders[4]) ? _throwInternalWarning(h, 71, "Unable to set [" + RequestHeaders[4] + "] as it has already been set by another instance") : (s = formatTraceParent(createTraceParent(e[_DYN_TRACE_ID], e[_DYN_SPAN_ID], a)), n[_DYN_SET_REQUEST_HEADER](RequestHeaders[4], s), T && (e[_DYN_REQUEST_HEADERS][RequestHeaders[4]] = s))), n) : void 0;
        }, h[_DYN_TRACK_DEPENDENCY_DAT3] = function (e, t, r) {
          -1 === P || n < P ? (2 !== j && 1 !== j || "string" != typeof e.id || "." === e.id[e.id[_DYN_LENGTH$1] - 1] || (e.id += "."), isNullOrUndefined(e[_DYN_START_TIME]) && (e[_DYN_START_TIME] = new Date()), e = createTelemetryItem(e, RemoteDependencyData.dataType, RemoteDependencyData.envelopeType, h[strDiagLog](), t, r), h[_DYN_CORE].track(e)) : n === P && _throwInternalCritical(h, 55, "Maximum ajax per page view limit reached, ajax monitoring is paused until the next trackPageView(). In order to increase the limit set the maxAjaxCallsPerView configuration parameter.", !0), ++n;
        }, h.addDependencyListener = function (e) {
          return _addHandler(B, t++, e);
        }, h.addDependencyInitializer = function (e) {
          return _addHandler($, t++, e);
        };
      }), e;
    }
    return __extendsFn(V, r), V.prototype.processTelemetry = function (e, t) {
      this.processNext(e, t);
    }, V.prototype.addDependencyInitializer = function (e) {
      return null;
    }, V.identifier = "AjaxDependencyPlugin", V;
  }(BaseTelemetryPlugin),
  Application = function () {},
  Device = function () {
    this.id = "browser", this.deviceClass = "Browser";
  },
  Version = "3.0.7",
  Internal = function (t, e) {
    var r = this,
      n = onConfigChange(t, function () {
        var e = t.sdkExtension;
        r.sdkVersion = (e ? e + "_" : "") + "javascript:" + Version;
      });
    e && e.add(n);
  },
  Location = function () {},
  _DYN_SESSION_MANAGER = "sessionManager",
  _DYN_UPDATE = "update",
  _DYN_IS_USER_COOKIE_SET = "isUserCookieSet",
  _DYN_IS_NEW_USER = "isNewUser",
  _DYN_GET_TRACE_CTX = "getTraceCtx",
  _DYN_TELEMETRY_TRACE = "telemetryTrace",
  _DYN_APPLY_SESSION_CONTEX0 = "applySessionContext",
  _DYN_APPLY_APPLICATION_CO1 = "applyApplicationContext",
  _DYN_APPLY_DEVICE_CONTEXT = "applyDeviceContext",
  _DYN_APPLY_OPERATION_CONT2 = "applyOperationContext",
  _DYN_APPLY_USER_CONTEXT = "applyUserContext",
  _DYN_APPLY_OPERATING_SYST3 = "applyOperatingSystemContxt",
  _DYN_APPLY_LOCATION_CONTE4 = "applyLocationContext",
  _DYN_APPLY_INTERNAL_CONTE5 = "applyInternalContext",
  _DYN_ACCOUNT_ID = "accountId",
  _DYN_GET_SESSION_ID = "getSessionId",
  _DYN_NAME_PREFIX = "namePrefix",
  _DYN_SESSION_COOKIE_POSTF6 = "sessionCookiePostfix",
  _DYN_USER_COOKIE_POSTFIX = "userCookiePostfix",
  _DYN_ID_LENGTH = "idLength",
  _DYN_GET_NEW_ID = "getNewId",
  _DYN_LENGTH = "length",
  _DYN_AUTOMATIC_SESSION = "automaticSession",
  _DYN_AUTHENTICATED_ID = "authenticatedId",
  _DYN_ACQUISITION_DATE = "acquisitionDate",
  _DYN_RENEWAL_DATE = "renewalDate",
  _DYN_JOIN = "join",
  _DYN_COOKIE_SEPARATOR = "cookieSeparator",
  _DYN_AUTH_USER_COOKIE_NAM7 = "authUserCookieName",
  SESSION_COOKIE_NAME = "ai_session",
  ACQUISITION_SPAN = 864e5,
  RENEWAL_SPAN = 18e5,
  COOKIE_UPDATE_INTERVAL = 6e4,
  Session = function () {},
  _SessionManager = function () {
    function r(l, e, t) {
      var c,
        u,
        h,
        d,
        p = safeGetLogger(e),
        f = safeGetCookieMgr(e);
      dynamicProto(r, this, function (o) {
        var e = onConfigChange(l = l || {}, function (e) {
          h = l.sessionExpirationMs || ACQUISITION_SPAN, d = l.sessionRenewalMs || RENEWAL_SPAN;
          var t = l.sessionCookiePostfix || l[_DYN_NAME_PREFIX] || "";
          c = SESSION_COOKIE_NAME + t;
        });
        function a(e, t) {
          var r = !1,
            n = ", session will be reset",
            i = t.split("|");
          if (2 <= i[_DYN_LENGTH]) try {
            var o = +i[1] || 0,
              a = +i[2] || 0;
            isNaN(o) || o <= 0 ? _throwInternal(p, 2, 27, "AI session acquisition date is 0" + n) : isNaN(a) || a <= 0 ? _throwInternal(p, 2, 27, "AI session renewal date is 0" + n) : i[0] && (e.id = i[0], e[_DYN_ACQUISITION_DATE] = o, e[_DYN_RENEWAL_DATE] = a, r = !0);
          } catch (e) {
            _throwInternal(p, 1, 9, "Error parsing ai_session value [" + (t || "") + "]" + n + " - " + getExceptionName(e), {
              exception: dumpObj(e)
            });
          }
          return r;
        }
        function s(e, t) {
          var r = e[_DYN_ACQUISITION_DATE],
            n = (e[_DYN_RENEWAL_DATE] = t, d),
            i = r + h - t,
            e = [e.id, r, t],
            r = 0,
            r = i < n ? i / 1e3 : n / 1e3,
            i = l.cookieDomain || null;
          f.set(c, e[_DYN_JOIN]("|"), 0 < h ? r : null, i), u = t;
        }
        t && t.add(e), o[_DYN_AUTOMATIC_SESSION] = new Session(), o[_DYN_UPDATE] = function () {
          var e,
            t,
            r = utcNow(),
            n = !1,
            i = o[_DYN_AUTOMATIC_SESSION];
          !(n = i.id ? n : !function (e) {
            var t = !1,
              r = f.get(c);
            r && isFunction(r.split) ? t = a(e, r) : (r = utlGetLocalStorage(p, c)) && (t = a(e, r));
            return t || e.id;
          }(i)) && 0 < h && (e = r - i[_DYN_ACQUISITION_DATE], t = r - i[_DYN_RENEWAL_DATE], n = (n = (n = e < 0 || t < 0) || h < e) || d < t), n ? (e = r, t = l[_DYN_GET_NEW_ID] || newId, o.automaticSession.id = t(l[_DYN_ID_LENGTH] || 22), o[_DYN_AUTOMATIC_SESSION][_DYN_ACQUISITION_DATE] = e, s(o[_DYN_AUTOMATIC_SESSION], e), utlCanUseLocalStorage() || _throwInternal(p, 2, 0, "Browser does not support local storage. Session durations will be inaccurate.")) : (!u || COOKIE_UPDATE_INTERVAL < r - u) && s(i, r);
        }, o.backup = function () {
          var e,
            t,
            r = o[_DYN_AUTOMATIC_SESSION];
          e = r.id, t = r[_DYN_ACQUISITION_DATE], r = r[_DYN_RENEWAL_DATE], utlSetLocalStorage(p, c, [e, t, r][_DYN_JOIN]("|"));
        };
      });
    }
    return r.__ieDyn = 1, r;
  }(),
  TelemetryTrace = function (e, t, r, n) {
    this.traceID = e || generateW3CId(), this.parentID = t, e = getLocation(), !r && e && e.pathname && (r = e.pathname), this.name = dataSanitizeString(n, r);
  };
function _validateUserInput(e) {
  return !("string" != typeof e || !e || e.match(/,|;|=| |\|/));
}
var User = function () {
    function u(o, e, a) {
      this.isNewUser = !1, this.isUserCookieSet = !1;
      var s,
        l = safeGetLogger(e),
        c = safeGetCookieMgr(e);
      dynamicProto(u, this, function (n) {
        objDefine(n, "config", {
          g: function () {
            return o;
          }
        });
        var e = onConfigChange(o, function () {
          var e = o[_DYN_USER_COOKIE_POSTFIX] || "",
            e = (s = u.userCookieName + e, c.get(s)),
            e = (e && (n[_DYN_IS_NEW_USER] = !1, 0 < (e = e.split(u[_DYN_COOKIE_SEPARATOR]))[_DYN_LENGTH]) && (n.id = e[0], n[_DYN_IS_USER_COOKIE_SET] = !!n.id), n.id || (n.id = t(), i(r(n.id)[_DYN_JOIN](u[_DYN_COOKIE_SEPARATOR])), e = (o[_DYN_NAME_PREFIX] || "") + "ai_session", utlRemoveStorage(l, e)), n[_DYN_ACCOUNT_ID] = o[_DYN_ACCOUNT_ID] || void 0, c.get(u[_DYN_AUTH_USER_COOKIE_NAM7]));
          e && ((e = (e = decodeURI(e)).split(u[_DYN_COOKIE_SEPARATOR]))[0] && (n[_DYN_AUTHENTICATED_ID] = e[0]), 1 < e[_DYN_LENGTH]) && e[1] && (n[_DYN_ACCOUNT_ID] = e[1]);
        });
        function t() {
          var e = o || {};
          return (e[_DYN_GET_NEW_ID] || newId)(e[_DYN_ID_LENGTH] ? o[_DYN_ID_LENGTH] : 22);
        }
        function r(e) {
          var t = toISOString(new Date());
          return n.accountAcquisitionDate = t, n[_DYN_IS_NEW_USER] = !0, [e, t];
        }
        function i(e) {
          n[_DYN_IS_USER_COOKIE_SET] = c.set(s, e, 31536e3);
        }
        a && a.add(e), n.setAuthenticatedUserContext = function (e, t, r) {
          void 0 === r && (r = !1), !_validateUserInput(e) || t && !_validateUserInput(t) ? _throwInternal(l, 2, 60, "Setting auth user context failed. User auth/account id should be of type string, and not contain commas, semi-colons, equal signs, spaces, or vertical-bars.", !0) : (n[_DYN_AUTHENTICATED_ID] = e, e = n[_DYN_AUTHENTICATED_ID], t && (n[_DYN_ACCOUNT_ID] = t, e = [n[_DYN_AUTHENTICATED_ID], n.accountId][_DYN_JOIN](u[_DYN_COOKIE_SEPARATOR])), r && c.set(u[_DYN_AUTH_USER_COOKIE_NAM7], encodeURI(e)));
        }, n.clearAuthenticatedUserContext = function () {
          n[_DYN_AUTHENTICATED_ID] = null, n[_DYN_ACCOUNT_ID] = null, c.del(u[_DYN_AUTH_USER_COOKIE_NAM7]);
        }, n[_DYN_UPDATE] = function (e) {
          n.id === e && n[_DYN_IS_USER_COOKIE_SET] || i(r(e || t())[_DYN_JOIN](u[_DYN_COOKIE_SEPARATOR]));
        };
      });
    }
    return u.cookieSeparator = "|", u.userCookieName = "ai_user", u.authUserCookieName = "ai_authUser", u;
  }(),
  strExt = "ext",
  strTags = "tags";
function _removeEmpty(e, t) {
  e && e[t] && 0 === objKeys(e[t])[_DYN_LENGTH] && delete e[t];
}
function _nullResult() {
  return null;
}
var _a$1,
  undefString,
  _a,
  _b,
  _c,
  _internalSdkSrc,
  TelemetryContext = function () {
    function e(n, o, a, s) {
      var l = this,
        c = n.logger;
      dynamicProto(e, this, function (i) {
        var e, t, r;
        i.appId = _nullResult, i[_DYN_GET_SESSION_ID] = _nullResult, i.application = new Application(), i.internal = new Internal(o, s), hasWindow() && (i[_DYN_SESSION_MANAGER] = new _SessionManager(o, n, s), i.device = new Device(), i.location = new Location(), i.user = new User(o, n, s), t = e = void 0, a && (e = a.getTraceId(), t = a.getSpanId(), r = a.getName()), i[_DYN_TELEMETRY_TRACE] = new TelemetryTrace(e, t, r, c), i.session = new Session()), i[_DYN_GET_SESSION_ID] = function () {
          var e = i.session;
          return e && isString(e.id) ? e.id : (e = (i[_DYN_SESSION_MANAGER] || {})[_DYN_AUTOMATIC_SESSION]) && isString(e.id) ? e.id : null;
        }, i[_DYN_APPLY_SESSION_CONTEX0] = function (e, t) {
          setValue(getSetValue(e.ext, Extensions.AppExt), "sesId", i[_DYN_GET_SESSION_ID](), isString);
        }, i[_DYN_APPLY_OPERATING_SYST3] = function (e, t) {
          setValue(e.ext, Extensions.OSExt, i.os);
        }, i[_DYN_APPLY_APPLICATION_CO1] = function (e, t) {
          var r = i.application;
          r && (setValue(e = getSetValue(e, strTags), CtxTagKeys.applicationVersion, r.ver, isString), setValue(e, CtxTagKeys.applicationBuild, r.build, isString));
        }, i[_DYN_APPLY_DEVICE_CONTEXT] = function (e, t) {
          var r = i.device;
          r && (setValue(e = getSetValue(getSetValue(e, strExt), Extensions.DeviceExt), "localId", r.id, isString), setValue(e, "ip", r.ip, isString), setValue(e, "model", r.model, isString), setValue(e, "deviceClass", r.deviceClass, isString));
        }, i[_DYN_APPLY_INTERNAL_CONTE5] = function (e, t) {
          var r,
            n = i.internal;
          n && (setValue(r = getSetValue(e, strTags), CtxTagKeys.internalAgentVersion, n.agentVersion, isString), setValue(r, CtxTagKeys.internalSdkVersion, dataSanitizeString(c, n.sdkVersion, 64), isString), e.baseType !== _InternalLogMessage.dataType && e.baseType !== PageView.dataType || (setValue(r, CtxTagKeys.internalSnippet, n.snippetVer, isString), setValue(r, CtxTagKeys.internalSdkSrc, n.sdkSrc, isString)));
        }, i[_DYN_APPLY_LOCATION_CONTE4] = function (e, t) {
          var r = l.location;
          r && setValue(getSetValue(e, strTags, []), CtxTagKeys.locationIp, r.ip, isString);
        }, i[_DYN_APPLY_OPERATION_CONT2] = function (e, t) {
          var r = i[_DYN_TELEMETRY_TRACE];
          r && (setValue(e = getSetValue(getSetValue(e, strExt), Extensions.TraceExt, {
            traceID: void 0,
            parentID: void 0
          }), "traceID", r.traceID, isString, isNullOrUndefined), setValue(e, "name", r.name, isString, isNullOrUndefined), setValue(e, "parentID", r.parentID, isString, isNullOrUndefined));
        }, i.applyWebContext = function (e, t) {
          var r = l.web;
          r && setValue(getSetValue(e, strExt), Extensions.WebExt, r);
        }, i[_DYN_APPLY_USER_CONTEXT] = function (e, t) {
          var r = i.user;
          r && (setValue(getSetValue(e, strTags, []), CtxTagKeys.userAccountId, r[_DYN_ACCOUNT_ID], isString), setValue(e = getSetValue(getSetValue(e, strExt), Extensions.UserExt), "id", r.id, isString), setValue(e, "authId", r[_DYN_AUTHENTICATED_ID], isString));
        }, i.cleanUp = function (e, t) {
          e = e.ext;
          e && (_removeEmpty(e, Extensions.DeviceExt), _removeEmpty(e, Extensions.UserExt), _removeEmpty(e, Extensions.WebExt), _removeEmpty(e, Extensions.OSExt), _removeEmpty(e, Extensions.AppExt), _removeEmpty(e, Extensions.TraceExt));
        };
      });
    }
    return e.__ieDyn = 1, e;
  }(),
  nullValue = null,
  _defaultConfig = objDeepFreeze(((_a$1 = {})[_DYN_ACCOUNT_ID] = nullValue, _a$1.sessionRenewalMs = 18e5, _a$1.samplingPercentage = 100, _a$1.sessionExpirationMs = 864e5, _a$1.cookieDomain = nullValue, _a$1.sdkExtension = nullValue, _a$1.isBrowserLinkTrackingEnabled = !1, _a$1.appId = nullValue, _a$1[_DYN_GET_SESSION_ID] = nullValue, _a$1[_DYN_NAME_PREFIX] = undefString, _a$1[_DYN_SESSION_COOKIE_POSTF6] = undefString, _a$1[_DYN_USER_COOKIE_POSTFIX] = undefString, _a$1[_DYN_ID_LENGTH] = 22, _a$1[_DYN_GET_NEW_ID] = nullValue, _a$1)),
  PropertiesPlugin = function (t) {
    function r() {
      var c,
        u,
        h,
        d,
        e = t.call(this) || this;
      return e.priority = 110, e.identifier = PropertiesPluginIdentifier, dynamicProto(r, e, function (s, l) {
        function r() {
          d = h = u = c = null;
        }
        r(), objDefine(s, "context", {
          g: function () {
            return d;
          }
        }), s.initialize = function (e, t, r, n) {
          var i, o, a;
          l.initialize(e, t, r, n), i = e, o = s.identifier, a = s.core, s._addHook(onConfigChange(i, function () {
            var e = createProcessTelemetryContext(null, i, a);
            i.storagePrefix && utlSetStoragePrefix(i.storagePrefix), c = e.getExtCfg(o, _defaultConfig), s._extConfig = c;
          })), h = a[_DYN_GET_TRACE_CTX](!1), d = new TelemetryContext(a, c, h, s._unloadHooks), u = createDistributedTraceContextFromTrace(s.context[_DYN_TELEMETRY_TRACE], h), a.setTraceCtx(u), s.context.appId = function () {
            var e = a.getPlugin(BreezeChannelIdentifier);
            return e ? e.plugin._appId : null;
          };
        }, s.processTelemetry = function (e, t) {
          var r, n, i, o;
          isNullOrUndefined(e) || (t = s._getTelCtx(t), e.name === PageView.envelopeType && t.diagLog().resetInternalMessageCount(), (i = d || {}).session && "string" != typeof d.session.id && i[_DYN_SESSION_MANAGER] && i[_DYN_SESSION_MANAGER][_DYN_UPDATE](), (r = i.user) && !r[_DYN_IS_USER_COOKIE_SET] && r[_DYN_UPDATE](i.user.id), i = t, getSetValue(n = e, "tags", []), getSetValue(n, "ext", {}), (o = s.context)[_DYN_APPLY_SESSION_CONTEX0](n, i), o[_DYN_APPLY_APPLICATION_CO1](n, i), o[_DYN_APPLY_DEVICE_CONTEXT](n, i), o[_DYN_APPLY_OPERATION_CONT2](n, i), o[_DYN_APPLY_USER_CONTEXT](n, i), o[_DYN_APPLY_OPERATING_SYST3](n, i), o.applyWebContext(n, i), o[_DYN_APPLY_LOCATION_CONTE4](n, i), o[_DYN_APPLY_INTERNAL_CONTE5](n, i), o.cleanUp(n, i), r && r[_DYN_IS_NEW_USER] && (r[_DYN_IS_NEW_USER] = !1, o = new _InternalLogMessage(72, (getNavigator() || {}).userAgent || ""), _logInternalMessage(t.diagLog(), 1, o)), s.processNext(e, t));
        }, s._doTeardown = function (e, t) {
          e = (e || {}).core();
          e && e[_DYN_GET_TRACE_CTX] && e[_DYN_GET_TRACE_CTX](!1) === u && e.setTraceCtx(h), r();
        };
      }), e;
    }
    return __extendsFn(r, t), r.__ieDyn = 1, r;
  }(BaseTelemetryPlugin),
  PropertiesPlugin$1 = PropertiesPlugin,
  _AUTHENTICATED_USER_CONTEXT = "AuthenticatedUserContext",
  _TRACK = "track",
  STR_SNIPPET = "snippet",
  STR_GET_COOKIE_MGR = "getCookieMgr",
  STR_START_TRACK_PAGE = "startTrackPage",
  STR_STOP_TRACK_PAGE = "stopTrackPage",
  STR_FLUSH = "flush",
  STR_START_TRACK_EVENT = "startTrackEvent",
  STR_STOP_TRACK_EVENT = "stopTrackEvent",
  STR_ADD_TELEMETRY_INITIALIZER = "addTelemetryInitializer",
  STR_POLL_INTERNAL_LOGS = "pollInternalLogs",
  STR_GET_PLUGIN = "getPlugin",
  STR_EVT_NAMESPACE = "evtNamespace",
  STR_TRACK_EVENT = _TRACK + "Event",
  STR_TRACK_TRACE = _TRACK + "Trace",
  STR_TRACK_METRIC = _TRACK + "Metric",
  STR_TRACK_PAGE_VIEW = _TRACK + "PageView",
  STR_TRACK_EXCEPTION = _TRACK + "Exception",
  STR_TRACK_DEPENDENCY_DATA = _TRACK + "DependencyData",
  STR_SET_AUTHENTICATED_USER_CONTEXT = "set" + _AUTHENTICATED_USER_CONTEXT,
  STR_CLEAR_AUTHENTICATED_USER_CONTEXT = "clear" + _AUTHENTICATED_USER_CONTEXT,
  _DYN_VERSION = "version",
  _DYN_QUEUE = "queue",
  _DYN_CONNECTION_STRING = "connectionString",
  _DYN_ENDPOINT_URL = "endpointUrl",
  _DYN_INSTRUMENTATION_KEY = "instrumentationKey",
  _DYN_ONUNLOAD_FLUSH = "onunloadFlush",
  _DYN_CONTEXT = "context",
  _DYN_ADD_HOUSEKEEPING_BEF0 = "addHousekeepingBeforeUnload",
  _DYN_SEND_MESSAGE = "sendMessage",
  _DYN_UPDATE_SNIPPET_DEFIN1 = "updateSnippetDefinitions",
  _ignoreUpdateSnippetProperties = [STR_SNIPPET, "dependencies", "properties", "_snippetVersion", "appInsightsNew", "getSKUDefaults"],
  IKEY_USAGE = "iKeyUsage",
  CDN_USAGE = "CdnUsage",
  SDK_LOADER_VER = "SdkLoaderVer",
  UNDEFINED_VALUE = void 0,
  default_limit = {
    samplingRate: 100,
    maxSendNumber: 1
  },
  default_interval = {
    monthInterval: 3,
    daysOfMonth: [28]
  },
  default_throttle_config = {
    disabled: !0,
    limit: cfgDfMerge(default_limit),
    interval: cfgDfMerge(default_interval)
  },
  defaultConfigValues = ((_a = {})[_DYN_CONNECTION_STRING] = UNDEFINED_VALUE, _a[_DYN_ENDPOINT_URL] = UNDEFINED_VALUE, _a[_DYN_INSTRUMENTATION_KEY] = UNDEFINED_VALUE, _a.diagnosticLogInterval = cfgDfValidate(_chkDiagLevel, 1e4), _a.featureOptIn = ((_b = {})[IKEY_USAGE] = {
    mode: 2
  }, _b[CDN_USAGE] = {
    mode: 2
  }, _b[SDK_LOADER_VER] = {
    mode: 2
  }, _b), _a.throttleMgrCfg = cfgDfMerge(((_c = {})[109] = cfgDfMerge(default_throttle_config), _c[106] = cfgDfMerge(default_throttle_config), _c[111] = cfgDfMerge(default_throttle_config), _c[110] = cfgDfMerge(default_throttle_config), _c)), _a);
function _chkDiagLevel(e) {
  return e && 0 < e;
}
var AppInsightsSku = function () {
  function r(e) {
    var c,
      u,
      h,
      d,
      t,
      p,
      f,
      _,
      m,
      g,
      y,
      v,
      E,
      b,
      w = this;
    dynamicProto(r, this, function (o) {
      a(), objDefine(o, "config", {
        g: function () {
          return _;
        }
      }), arrForEach(["pluginVersionStringArr", "pluginVersionString"], function (e) {
        objDefine(o, e, {
          g: function () {
            return f ? f[e] : null;
          }
        });
      }), d = "" + (e.sv || e[_DYN_VERSION] || ""), e[_DYN_QUEUE] = e[_DYN_QUEUE] || [], e[_DYN_VERSION] = e[_DYN_VERSION] || 2;
      var i = createDynamicConfig(e.config || {}, defaultConfigValues);
      function a() {
        t = createUniqueNamespace("AISKU"), y = d = h = u = c = p = null, b = E = v = !1, g = new CfgSyncPlugin();
      }
      function s() {
        p && (removePageUnloadEventListener(null, p), removePageHideEventListener(null, p));
      }
      function l(e) {
        f.addUnloadHook(e);
      }
      _ = i.cfg, m = new AnalyticsPlugin(), objDefine(o, "appInsights", {
        g: function () {
          return m;
        }
      }), u = new PropertiesPlugin$1(), c = new AjaxMonitor(), h = new Sender(), f = new AppInsightsCore(), objDefine(o, "core", {
        g: function () {
          return f;
        }
      }), l(onConfigChange(i, function () {
        var e, t;
        _[_DYN_CONNECTION_STRING] && (t = (e = parseConnectionString(_[_DYN_CONNECTION_STRING])).ingestionendpoint, _[_DYN_ENDPOINT_URL] = t ? t + DEFAULT_BREEZE_PATH : _[_DYN_ENDPOINT_URL], _[_DYN_INSTRUMENTATION_KEY] = e.instrumentationkey || _[_DYN_INSTRUMENTATION_KEY]);
      })), o[STR_SNIPPET] = e, o[STR_FLUSH] = function (n, i) {
        var e;
        return doPerf(f, function () {
          return "AISKU.flush";
        }, function () {
          n && !i && (e = createPromise(function (e) {
            i = e;
          }));
          function t() {
            0 === --r && i();
          }
          var r = 1;
          arrForEach(f.getChannels(), function (e) {
            e && (r++, e[STR_FLUSH](n, t));
          }), t();
        }, null, n = void 0 === n ? !0 : n), e;
      }, o[_DYN_ONUNLOAD_FLUSH] = function (t) {
        void 0 === t && (t = !0), arrForEach(f.getChannels(), function (e) {
          e[_DYN_ONUNLOAD_FLUSH] ? e[_DYN_ONUNLOAD_FLUSH]() : e[STR_FLUSH](t);
        });
      }, o.loadAppInsights = function (e, t, n) {
        return (e = void 0 === e ? !1 : e) && throwUnsupported("Legacy Mode is no longer supported"), doPerf(o.core, function () {
          return "AISKU.loadAppInsights";
        }, function () {
          f.initialize(_, [h, u, c, m, g], t, n), objDefine(o, "context", {
            g: function () {
              return u[_DYN_CONTEXT];
            }
          }), y = y || new ThrottleMgr(f);
          var r,
            e = _findSdkSourceFile();
          e && o[_DYN_CONTEXT] && (o[_DYN_CONTEXT].internal.sdkSrc = e), (r = o[STR_SNIPPET]) && (e = "", isNullOrUndefined(d) || (e += d), o[_DYN_CONTEXT] && o[_DYN_CONTEXT].internal && (o[_DYN_CONTEXT].internal.snippetVer = e || "-"), objForEachKey(o, function (e, t) {
            isString(e) && !isFunction(t) && e && "_" !== e[0] && -1 === arrIndexOf(_ignoreUpdateSnippetProperties, e) && r[e] !== t && (r[e] = t);
          })), o.emptyQueue(), o[STR_POLL_INTERNAL_LOGS](), o[_DYN_ADD_HOUSEKEEPING_BEF0](o), l(onConfigChange(i, function () {
            var e = !1;
            _.throttleMgrCfg[109] && (e = !_.throttleMgrCfg[109].disabled), !y.isReady() && _.extensionConfig && _.extensionConfig[g.identifier] && e && y.onReadyState(!0), v || _[_DYN_CONNECTION_STRING] || !isFeatureEnabled(IKEY_USAGE, _) || (y[_DYN_SEND_MESSAGE](106, "See Instrumentation key support at aka.ms/IkeyMigrate"), v = !0), !E && o[_DYN_CONTEXT].internal.sdkSrc && -1 != o[_DYN_CONTEXT].internal.sdkSrc.indexOf("az416426") && isFeatureEnabled(CDN_USAGE, _) && (y[_DYN_SEND_MESSAGE](110, "See Cdn support notice at aka.ms/JsActiveCdn"), E = !0), !b && parseInt(d) < 6 && isFeatureEnabled(SDK_LOADER_VER, _) && (y[_DYN_SEND_MESSAGE](111, "An updated Sdk Loader is available, see aka.ms/SnippetVer"), b = !0);
          }));
        }), o;
      }, o[_DYN_UPDATE_SNIPPET_DEFIN1] = function (e) {
        proxyAssign(e, o, function (e) {
          return e && -1 === arrIndexOf(_ignoreUpdateSnippetProperties, e);
        });
      }, o.emptyQueue = function () {
        try {
          if (isArray(o.snippet[_DYN_QUEUE])) {
            for (var e = o.snippet[_DYN_QUEUE].length, t = 0; t < e; t++) (0, o.snippet[_DYN_QUEUE][t])();
            o.snippet[_DYN_QUEUE] = void 0, delete o.snippet[_DYN_QUEUE];
          }
        } catch (e) {
          e && isFunction(e.toString) && e.toString();
        }
      }, o[_DYN_ADD_HOUSEKEEPING_BEF0] = function (r) {
        var n, i;
        (hasWindow() || hasDocument()) && (i = !(n = function () {
          var e;
          r[_DYN_ONUNLOAD_FLUSH](!1), isFunction(o.core[STR_GET_PLUGIN]) && (e = w.core[STR_GET_PLUGIN](PropertiesPluginIdentifier)) && (e = e.plugin) && e[_DYN_CONTEXT] && e[_DYN_CONTEXT]._sessionManager && e[_DYN_CONTEXT]._sessionManager.backup();
        }), p = p || mergeEvtNamespace(t, f[STR_EVT_NAMESPACE] && f[STR_EVT_NAMESPACE]()), l(onConfigChange(_, function (e) {
          var e = e.cfg,
            t = r.appInsights,
            t = createProcessTelemetryContext(null, e, t.core).getExtCfg(t.identifier || AnalyticsPluginIdentifier),
            e = (s(), e.disablePageUnloadEvents);
          t.disableFlushOnBeforeUnload || (addPageUnloadEventListener(n, e, p) && (i = !0), i = !!addPageHideEventListener(n, e, p) || i) || isReactNative() || _throwInternal(f.logger, 1, 19, "Could not add handler for beforeunload and pagehide"), i || t.disableFlushOnUnload || addPageHideEventListener(n, e, p);
        })));
      }, o.getSender = function () {
        return h;
      }, o.unload = function (e, t, r) {
        var n,
          i = !1;
        return e && !t && (n = createPromise(function (e) {
          t = e;
        })), o[_DYN_ONUNLOAD_FLUSH](e), s(), f.unload && f.unload(e, function (e) {
          i || (i = !0, a(), t && t(e));
        }, r), n;
      }, proxyFunctions(o, m, [STR_GET_COOKIE_MGR, STR_TRACK_EVENT, STR_TRACK_PAGE_VIEW, "trackPageViewPerformance", STR_TRACK_EXCEPTION, "_onerror", STR_TRACK_TRACE, STR_TRACK_METRIC, STR_START_TRACK_PAGE, STR_STOP_TRACK_PAGE, STR_START_TRACK_EVENT, STR_STOP_TRACK_EVENT]), proxyFunctions(o, function () {
        return c;
      }, [STR_TRACK_DEPENDENCY_DATA, "addDependencyListener", "addDependencyInitializer"]), proxyFunctions(o, f, [STR_ADD_TELEMETRY_INITIALIZER, STR_POLL_INTERNAL_LOGS, "stopPollingInternalLogs", STR_GET_PLUGIN, "addPlugin", STR_EVT_NAMESPACE, "addUnloadCb", "getTraceCtx", "updateCfg", "onCfgChange"]), proxyFunctions(o, function () {
        var e = u[_DYN_CONTEXT];
        return e ? e.user : null;
      }, [STR_SET_AUTHENTICATED_USER_CONTEXT, STR_CLEAR_AUTHENTICATED_USER_CONTEXT]);
    });
  }
  return r.prototype.addDependencyInitializer = function (e) {
    return null;
  }, r;
}();
function _findSdkSourceFile() {
  if (!_internalSdkSrc) {
    var e = null;
    try {
      var t = (document || {}).currentScript;
      t && (e = t.src);
    } catch (e) {}
    if (e) {
      try {
        var r,
          n = e.toLowerCase();
        n && (r = "", arrForEach(["://js.monitor.azure.com/", "://az416426.vo.msecnd.net/"], function (e, t) {
          if (-1 !== strIndexOf(n, e)) return r = "cdn" + (t + 1), -1 === strIndexOf(n, "/scripts/") && (-1 !== strIndexOf(n, "/next/") ? r += "-next" : -1 !== strIndexOf(n, "/beta/") && (r += "-beta")), _internalSdkSrc = r + "", -1;
        }));
      } catch (e) {}
      _internalSdkSrc = e;
    }
  }
  return _internalSdkSrc;
}
var IncidentPopupIconName,
  Insights = function () {
    function e(e) {
      this.options = e, !this.options.disableTelemetry && env.appInsightsKey && (this.appInsights = new AppInsightsSku({
        config: {
          instrumentationKey: env.appInsightsKey,
          disableExceptionTracking: !0,
          disableAjaxTracking: !0,
          isCookieUseDisabled: !0,
          maxBatchInterval: 5e3
        }
      }), this.appInsights.loadAppInsights(), this.appInsights.addTelemetryInitializer(function (e) {
        e.tags[CtxTagKeys.applicationVersion] = Version$1.getFullVersion();
      }));
    }
    return e.prototype.trackEvent = function (e, t) {
      !this.options.disableTelemetry && this.appInsights && this.appInsights.trackEvent(e, t);
    }, e.prototype.setAuthenticatedUserContext = function (e, t) {
      !this.options.disableTelemetry && this.appInsights && this.appInsights.setAuthenticatedUserContext(e, t);
    }, e.prototype.trackException = function (e) {
      !this.options.disableTelemetry && this.appInsights && this.appInsights.trackException(e);
    }, e.prototype.flush = function (e) {
      !this.options.disableTelemetry && this.appInsights && this.appInsights.flush(e);
    }, e;
  }(),
  __extends$k = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  CopyrightControlOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.copyrightMessage = void 0, e.copyrightContent = void 0, e.customAttribution = void 0, e.showFeedbackLink = !0, e.showLogo = !0, e;
    }
    return __extends$k(e, t), e;
  }(Options),
  __extends$j = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  CopyrightControl = function (t) {
    function n(e) {
      var r = t.call(this) || this;
      return r.textAttribution = function (e) {
        return [r.options.copyrightMessage, r.options.customAttribution].filter(function (e) {
          return e;
        }).join("");
      }, r.updateFeedbackLink = function () {
        var e, t;
        r.feedbackAnchor && r.map && (e = (t = r.map.getCamera()).center, t = t.zoom, r.feedbackAnchor.href = "".concat(n.feedbackLink, "&cp=").concat(e[1], "~").concat(e[0], "&lvl=").concat(t + 1));
      }, r.options = new CopyrightControlOptions().merge(e), r;
    }
    return __extends$j(n, t), n.prototype.onAdd = function (e) {
      return this.map = e, this.container = this.buildContainer(e, ControlStyle.auto), this.container.className = "map-copyright", this.copyrightDiv = this.buildCopyrightDiv(), this.copyrightDiv.className = "azure-map-copyright", this.container.appendChild(this.copyrightDiv), this.options.showLogo && this.addRemoveLogo(!0), this.options.showFeedbackLink && this.addRemoveFeedbackDiv(!0), this.container;
    }, n.prototype.onRemove = function () {
      t.prototype.onRemove.call(this), delete this.container;
    }, n.prototype.setOptions = function (e) {
      var t,
        r = this,
        e = new CopyrightControlOptions().merge(this.options, e);
      e.copyrightMessage === this.options.copyrightMessage && e.customAttribution === this.options.customAttribution || (this.copyrightDiv.innerText = this.textAttribution(e)), e.copyrightContent !== this.options.copyrightContent && (this.options.copyrightContent && (t = Array.from(this.copyrightDiv.children).find(function (e) {
        return e === r.options.copyrightContent;
      }), this.copyrightDiv.removeChild(t)), 0 < this.copyrightDiv.childNodes.length ? this.copyrightDiv.insertBefore(e.copyrightContent, this.copyrightDiv.childNodes[0]) : this.copyrightDiv.appendChild(e.copyrightContent), this.options.copyrightContent = e.copyrightContent), !e.showLogo && this.logoAnchor ? this.addRemoveLogo(!1) : e.showLogo && !this.logoAnchor && this.addRemoveLogo(!0), !e.showFeedbackLink && this.feedbackAnchor ? this.addRemoveFeedbackDiv(!1) : e.showFeedbackLink && !this.feedbackAnchor && this.addRemoveFeedbackDiv(!0), this.options = e;
    }, n.prototype.getDefaultAttributions = function () {
      var e = new Date().getFullYear(),
        t = ["©".concat(e, " TomTom")];
      return this.options.showLogo || t.push("©".concat(e, " Microsoft")), t;
    }, n.prototype.buildCopyrightDiv = function () {
      var e = document.createElement("div");
      return e.innerText = this.textAttribution(this.options) || "", e;
    }, n.prototype.buildFeedbackLink = function () {
      var e = document.createElement("a");
      return e.setAttribute("alt", "Provide Map Data Feedback"), e.setAttribute("aria-label", "Provide Map Data Feedback"), e.href = n.feedbackLink, e.target = "_blank", e.rel = "noopener", e.className = "azure-map-feedback", e;
    }, n.prototype.addRemoveFeedbackDiv = function (e) {
      e ? (this.feedbackAnchor = this.buildFeedbackLink(), this.tooltip = buildAccessibleTooltip("Provide Map Data Feedback"), this.container.appendChild(this.feedbackAnchor), this.container.appendChild(this.tooltip), positionTooltip(this.tooltip, this.feedbackAnchor), null != (e = null == (e = this.map) ? void 0 : e.events) && e.add("moveend", this.updateFeedbackLink)) : (this.feedbackAnchor.remove(), this.tooltip.remove(), delete this.tooltip, delete this.feedbackAnchor, null != (e = null == (e = this.map) ? void 0 : e.events) && e.remove("moveend", this.updateFeedbackLink));
    }, n.prototype.addRemoveLogo = function (e) {
      e ? (this.logoAnchor = document.createElement("a"), this.logoAnchor.className = "azure-map-logo", this.logoAnchor.href = "https://aka.ms/azuremaps", this.logoAnchor.setAttribute("aria-label", "Visit azure.microsoft.com"), this.logoAnchor.setAttribute("target", "_blank"), this.container.appendChild(this.logoAnchor), this.logoTooltip = buildAccessibleTooltip("Visit azure.microsoft.com"), this.container.appendChild(this.logoTooltip), positionTooltip(this.logoTooltip, this.logoAnchor)) : (this.logoAnchor.remove(), this.logoTooltip.remove(), delete this.logoAnchor);
    }, n.feedbackLink = "https://aka.ms/azuremapsdatafeedback?feedbackep=UrlAzureMapsWebSdk", n;
  }(ControlBase),
  ErrorHandler = function () {
    function e() {}
    return e.throwOnError = function (e, t) {
      function r(e) {
        throw n.off("error", r), e.error;
      }
      var n = e instanceof Map$1 ? e._getMap() : e,
        e = (n.on("error", r), t());
      return n.off("error", r), e;
    }, e.tryCatch = function (e, t, r, n) {
      try {
        return this.throwOnError(e, t);
      } catch (e) {
        return r(e);
      } finally {
        "function" == typeof n && n();
      }
    }, e.tryFinally = function (e, t, r) {
      try {
        return this.throwOnError(e, t);
      } finally {
        r();
      }
    }, e;
  }(),
  __assign$6 = window && window.__assign || function () {
    return (__assign$6 = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      return e;
    }).apply(this, arguments);
  },
  NearbyGeographySearchService = function () {
    function e(e) {
      this.map = e;
    }
    return e.prototype.request = function (e) {
      var t,
        e = {
          domain: this.map.getServiceOptions().domain,
          path: "reverseGeocode",
          queryParams: __assign$6({
            "api-version": "2023-06-01",
            coordinates: "".concat(normalizeLongitude(e.position[0]), ",").concat(normalizeLatitude(e.position[1]))
          }, e.style.view && {
            view: e.style.view
          }),
          headers: {
            "Accept-Language": e.style.language
          }
        };
      return new Url((null == (t = this.map.authentication) ? void 0 : t.signRequest(e)) || e).get();
    }, e;
  }(),
  MapLabelCache = function () {
    function e() {
      this._labelCache = {}, this._labelIdx = {}, this._preloadedCache = new Set();
    }
    return e.prototype.cache = function (e, t, r, n) {
      n = "".concat(e, "_").concat(r[0], "_").concat(r[1], "_").concat(n);
      this._labelIdx[t.labelType] || (this._labelIdx[t.labelType] = [], this._labelCache[t.labelType] = []), -1 === this._labelIdx[t.labelType].indexOf(n) && (this._labelCache[t.labelType].push({
        name: e,
        radius: t.radius,
        minZoom: t.minZoom,
        maxZoom: t.maxZoom || 24,
        position: r
      }), this._labelIdx[t.labelType].push(n));
    }, e.prototype.getNearestLabel = function (e, t, r) {
      var n = null,
        i = this._labelCache[e];
      if (i) for (var o, a = 1 / 0, s = 0, l = i.length; s < l; s++) r >= i[s].minZoom && r <= i[s].maxZoom && (o = getDistanceTo(i[s].position, t)) <= i[s].radius && o <= a && (a = o, n = i[s]);
      return n;
    }, e.prototype._preloadCache = function (e) {
      if (!this._preloadedCache.has(e)) {
        this._preloadedCache.add(e);
        var t = {
            source: [],
            labelType: "water",
            minZoom: 0,
            radius: 395e4,
            polygonSources: []
          },
          r = e,
          n = r.indexOf("-");
        switch (r = -1 !== n ? r.substr(0, n) : r) {
          case "fr":
            this.cache("Océan Pacifique", t, [-170, 32], e), this.cache("Océan Pacifique", t, [-138, -27], e), this.cache("Océan Atlantique", t, [-40, 32], e), this.cache("Océan Atlantique", t, [-17, -29], e);
            break;
          case "es":
            this.cache("Océan Pacifique", t, [-170, 32], e), this.cache("Océan Pacifique", t, [-138, -27], e), this.cache("Océano Atlántico", t, [-40, 32], e), this.cache("Océano Atlántico", t, [-17, -29], e);
            break;
          case "pt":
            this.cache("Oceano Pacífico", t, [-170, 32], e), this.cache("Oceano Pacífico", t, [-138, -27], e), this.cache("Oceano Atlântico", t, [-40, 32], e), this.cache("Oceano Atlântico", t, [-17, -29], e);
            break;
          case "ja":
            this.cache("太平洋", t, [-170, 32], e), this.cache("太平洋", t, [-138, -27], e);
            break;
          case "en":
            this.cache("Pacific Ocean", t, [-170, 32], e), this.cache("Pacific Ocean", t, [-138, -27], e), this.cache("Atlantic Ocean", t, [-40, 32], e), this.cache("Atlantic Ocean", t, [-17, -29], e), this.cache("Indian Ocean", t, [77, -26], e);
        }
      }
    }, e;
  }(),
  __awaiter$5 = window && window.__awaiter || function (e, a, s, l) {
    return new (s = s || Promise)(function (r, t) {
      function n(e) {
        try {
          o(l.next(e));
        } catch (e) {
          t(e);
        }
      }
      function i(e) {
        try {
          o(l.throw(e));
        } catch (e) {
          t(e);
        }
      }
      function o(e) {
        var t;
        e.done ? r(e.value) : ((t = e.value) instanceof s ? t : new s(function (e) {
          e(t);
        })).then(n, i);
      }
      o((l = l.apply(e, a || [])).next());
    });
  },
  __generator$5 = window && window.__generator || function (n, i) {
    var o,
      a,
      s,
      l = {
        label: 0,
        sent: function () {
          if (1 & s[0]) throw s[1];
          return s[1];
        },
        trys: [],
        ops: []
      },
      c = {
        next: e(0),
        throw: e(1),
        return: e(2)
      };
    return "function" == typeof Symbol && (c[Symbol.iterator] = function () {
      return this;
    }), c;
    function e(r) {
      return function (e) {
        var t = [r, e];
        if (o) throw new TypeError("Generator is already executing.");
        for (; l = c && t[c = 0] ? 0 : l;) try {
          if (o = 1, a && (s = 2 & t[0] ? a.return : t[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, t[1])).done) return s;
          switch (a = 0, (t = s ? [2 & t[0], s.value] : t)[0]) {
            case 0:
            case 1:
              s = t;
              break;
            case 4:
              return l.label++, {
                value: t[1],
                done: !1
              };
            case 5:
              l.label++, a = t[1], t = [0];
              continue;
            case 7:
              t = l.ops.pop(), l.trys.pop();
              continue;
            default:
              if (!(s = 0 < (s = l.trys).length && s[s.length - 1]) && (6 === t[0] || 2 === t[0])) {
                l = 0;
                continue;
              }
              if (3 === t[0] && (!s || t[1] > s[0] && t[1] < s[3])) l.label = t[1];else if (6 === t[0] && l.label < s[1]) l.label = s[1], s = t;else {
                if (!(s && l.label < s[2])) {
                  s[2] && l.ops.pop(), l.trys.pop();
                  continue;
                }
                l.label = s[2], l.ops.push(t);
              }
          }
          t = i.call(n, l);
        } catch (e) {
          t = [6, e], a = 0;
        } finally {
          o = s = 0;
        }
        if (5 & t[0]) throw t[1];
        return {
          value: t[0] ? t[1] : void 0,
          done: !0
        };
      };
    }
  },
  __read$b = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  __spreadArray$9 = window && window.__spreadArray || function (e, t, r) {
    if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++) !n && i in t || ((n = n || Array.prototype.slice.call(t, 0, i))[i] = t[i]);
    return e.concat(n || Array.prototype.slice.call(t));
  },
  MapViewDescriptor = function () {
    function g(e, t) {
      var o = this;
      this._disposed = !1, this._lastHeadingTime = 0, this._actionQueue = [], this._pointerUpdateDelay = 3e3, this._camUpdateDelay = 1e3, this._headUpdateLimit = 1e3, this._controlEventDelay = 500, this._moveThreshold = 25, this._headingThreshold = 5, this._pitchThreshold = 5, this._roadPixelRadius = 120, this._minRoadDistance = 25, this._minIntersectionPixelDistance = 50, this._labelConfig = [{
        source: ["Ocean label", "Ocean name"],
        labelType: "water",
        minZoom: 0,
        radius: 395e4,
        polygonSources: ["Ocean", "Ocean or sea"]
      }, {
        source: ["Sea label"],
        labelType: "water",
        minZoom: 3,
        radius: 1e6,
        polygonSources: ["Sea", "Ocean or sea"]
      }, {
        source: ["Country name"],
        labelType: "country",
        minZoom: 0,
        maxZoom: 5,
        radius: 3e5
      }, {
        source: ["State name", "State name short"],
        labelType: "state",
        minZoom: 4,
        maxZoom: 7,
        radius: 3e5
      }, {
        source: ["Capital city", "Large city"],
        labelType: "city",
        minZoom: 8,
        radius: 4e4
      }, {
        source: ["Medium city"],
        labelType: "city",
        minZoom: 8,
        radius: 3e4
      }, {
        source: ["Small city"],
        labelType: "city",
        minZoom: 8,
        radius: 2e4
      }, {
        source: ["Island label"],
        labelType: "city",
        minZoom: 8,
        radius: 1e4
      }, {
        source: ["Town"],
        labelType: "city",
        minZoom: 10,
        radius: 1e4
      }, {
        source: ["Village"],
        labelType: "neighbourhood",
        minZoom: 12,
        radius: 6e3
      }, {
        source: ["Amusement area label"],
        labelType: "poi",
        minZoom: 14,
        radius: 2e3,
        polygonSources: ["Amusement park"]
      }, {
        source: ["Hospital label"],
        labelType: "poi",
        minZoom: 14,
        radius: 1e3,
        polygonSources: ["Hospital"]
      }, {
        source: ["Shopping centre label"],
        labelType: "poi",
        minZoom: 14,
        radius: 1e3,
        polygonSources: ["Shopping"]
      }, {
        source: ["Stadium label"],
        labelType: "poi",
        minZoom: 14,
        radius: 1e3,
        polygonSources: ["Stadium"]
      }, {
        source: ["University/School label"],
        labelType: "poi",
        minZoom: 14,
        radius: 1e3,
        polygonSources: ["University"]
      }, {
        source: ["Zoo label"],
        labelType: "poi",
        minZoom: 14,
        radius: 1e3,
        polygonSources: ["Zoo"]
      }, {
        source: ["Airport Label", "Airport name", "Airport POI"],
        labelType: "majorPoi",
        minZoom: 11,
        radius: 3e3,
        polygonSources: ["Airport", "Runway"]
      }, {
        source: ["National park label"],
        labelType: "majorPoi",
        minZoom: 7,
        radius: 15e3,
        polygonSources: ["National or state park", "National park", "Forest"]
      }, {
        source: ["Reservation label"],
        labelType: "majorPoi",
        minZoom: 7,
        radius: 15e3,
        polygonSources: ["Reservation"]
      }], this._labelCache = new Set(["city", "state", "country", "water", "majorPoi"]), this._roadLayers = new Set(["Connecting road", "Connecting road tunnel", "International road", "International road tunnel", "Local road", "Local road tunnel", "Major local road", "Major local road tunnel", "Major road", "Major road tunnel", "Minor local road", "Minor local road tunnel", "Motorway", "Motorway tunnel", "Secondary road", "Secondary road tunnel", "Toll connecting road", "Toll connecting road tunnel", "Toll international road", "Toll international road tunnel", "Toll local road", "Toll local road tunnel", "Toll major local road", "Toll major local road tunnel", "Toll major road", "Toll major road tunnel", "Toll minor local road", "Toll minor local road tunnel", "Toll motorway", "Toll motorway tunnel", "Toll secondary road", "Toll secondary road tunnel"]), this._returnDetailedDescriptions = !1, this._shortcutListener = function (i) {
        return __awaiter$5(o, void 0, void 0, function () {
          var t, r, n;
          return __generator$5(this, function (e) {
            switch (e.label) {
              case 0:
                return i.altKey && i.ctrlKey && 68 === i.keyCode ? (this._returnDetailedDescriptions = !this._returnDetailedDescriptions, n = this._map.getCamera(), r = this._map.getStyle(), t = r.language.toLowerCase(), r = r.style.toLowerCase(), [4, this._getLocDesc(n, t, r)]) : [3, 2];
              case 1:
                n = e.sent(), this._descCallback(n), e.label = 2;
              case 2:
                return [2];
            }
          });
        });
      }, this._onRotate = function () {
        o._rotateTimeout || (Date.now() - o._lastHeadingTime >= o._headUpdateLimit ? o._rotateTimeout = setTimeout(o._updateHeading, CompassControl.RotationDuration + 25) : o._rotateTimeout = setTimeout(o._updateHeading, o._headUpdateLimit - (Date.now() - o._lastHeadingTime)));
      }, this._onMove = function () {
        o._moveTimeout && (clearTimeout(o._moveTimeout), delete o._moveTimeout), o._controlTimeout && (clearTimeout(o._controlTimeout), delete o._controlTimeout);
      }, this._onMoveEnd = function (e) {
        e.fromControl ? o._controlTimeout = setTimeout(o._updateCam, o._controlEventDelay) : o._updateCam();
      }, this._onStyleData = function () {
        setTimeout(o._updateStyle);
      }, this._onPointerDown = function (e) {
        o._lastPointerPos = o._getEventPos(e), o._pointerTimeout = setTimeout(function () {
          return __awaiter$5(o, void 0, void 0, function () {
            var t, r, n;
            return __generator$5(this, function (e) {
              switch (e.label) {
                case 0:
                  return r = this._map.getStyle(), t = r.language.toLowerCase(), r = r.style.toLowerCase(), (n = this._map.getCamera()).center = this._map.pixelsToPositions([this._lastPointerPos])[0], [4, this._getLocDesc(n, t, r)];
                case 1:
                  return n = e.sent(), this._descCallback(n), this._onPointerUp(), [2];
              }
            });
          });
        }, o._pointerUpdateDelay), o._map.getCanvas().addEventListener("mousemove", o._onPointerMove), o._map.getCanvas().addEventListener("touchmove", o._onPointerMove), o._map.getCanvas().addEventListener("mouseup", o._onPointerUp), o._map.getCanvas().addEventListener("touchend", o._onPointerUp);
      }, this._onPointerMove = function (e) {
        var e = o._getEventPos(e),
          t = o._lastPointerPos[0] - e[0],
          e = o._lastPointerPos[1] - e[1];
        Math.sqrt(t * t + e * e) > o._moveThreshold && o._onPointerUp();
      }, this._onPointerUp = function () {
        clearTimeout(o._pointerTimeout), delete o._pointerTimeout, o._map.getCanvas().removeEventListener("mousemove", o._onPointerMove), o._map.getCanvas().removeEventListener("touchmove", o._onPointerMove), o._map.getCanvas().removeEventListener("mouseup", o._onPointerUp), o._map.getCanvas().removeEventListener("touchend", o._onPointerUp);
      }, this._updateHeading = function () {
        var e,
          t = o._map.getCamera();
        o._lastHead && !o._checkHeadingThreshold(t.bearing, o._lastHead) || (e = o._getHeadingDesc(t), o._lastHead = t.bearing, o._descCallback("<p>Map heading ".concat(e, ".</p>")), o._lastHeadingTime = Date.now()), delete o._rotateTimeout;
      }, this._updateStyle = function () {
        return __awaiter$5(o, void 0, void 0, function () {
          var t, r, n, i;
          return __generator$5(this, function (e) {
            switch (e.label) {
              case 0:
                return (t = this._map.getCamera(), n = this._map.getStyle(), r = n.language.toLowerCase(), n = n.style.toLowerCase(), this._lastLang === r) ? [3, 2] : (g._labelCache._preloadCache(r), [4, this._getLocDesc(t, r, n)]);
              case 1:
                return i = e.sent(), [3, 4];
              case 2:
                return this._lastStyle === n || "blank" !== this._lastStyle ? [3, 4] : [4, this._getLocDesc(t, r, n)];
              case 3:
                i = e.sent(), e.label = 4;
              case 4:
                return this._lastLang = r, this._lastStyle = n, i && this._descCallback(i), [2];
            }
          });
        });
      }, this._updateCam = function (e) {
        void 0 === e && (e = !1);
        var r,
          n,
          t,
          i = o._map.getCamera();
        (!o._lastCam || 0 < o._actionQueue.length || o._checkThresholds(i, o._lastCam)) && (t = o._map.getStyle(), r = t.language.toLowerCase(), n = t.style.toLowerCase(), (t = o._getActionDesc(i)) && o._actionQueue.push(t), o._lastCam = i, o._moveTimeout && (clearTimeout(o._moveTimeout), delete o._moveTimeout), o._moveTimeout = setTimeout(function () {
          return __awaiter$5(o, void 0, void 0, function () {
            var t;
            return __generator$5(this, function (e) {
              switch (e.label) {
                case 0:
                  return clearTimeout(this._rotateTimeout), delete this._rotateTimeout, [4, this._getLocDesc(i, r, n)];
                case 1:
                  return t = e.sent(), 0 < this._actionQueue.length ? (this._descCallback("<p>Map ".concat(this._actionQueue.join(", then "), ".</p>").concat(t)), this._actionQueue = []) : this._descCallback(t), [2];
              }
            });
          });
        }, e ? 0 : o._camUpdateDelay));
      }, this._map = e, this._restFallback = e.getServiceOptions().enableAccessibilityLocationFallback, this._descCallback = t, this._reverseSearch = new NearbyGeographySearchService(e), g._labelCache || (g._labelCache = new MapLabelCache()), this._lastLang = this._map.getStyle().language.toLowerCase(), g._labelCache._preloadCache(this._lastLang), this._map.events.addOnce("idle", function () {
        var e;
        o._disposed || (o._updateCam(!0), o._baseVectorTileSourceId = g._baseVectorTileSourceIds.find(function (e) {
          return o._map.sources.getById(e);
        }), "bing-mvt" === o._baseVectorTileSourceId && (o._labelConfig = g._labelConfigBing, o._roadLayers = g._roadLayersBing), o._polygonStyleLayer = o._labelConfig.reduce(function (e, t) {
          return t.polygonSources && e.push.apply(e, __spreadArray$9([], __read$b(t.polygonSources), !1)), e;
        }, []), (e = o._map._getMap()).on("move", o._onMove), e.on("moveend", o._onMoveEnd), e.on("styledata", o._onStyleData), e.on("rotate", o._onRotate), (e = o._map.getCanvas()).addEventListener("mousedown", o._onPointerDown), e.addEventListener("touchstart", o._onPointerDown));
      }), this._map.getMapContainer().addEventListener("keydown", this._shortcutListener);
    }
    return g.prototype.dispose = function () {
      this._disposed = !0;
      var e = this._map._getMap(),
        e = (e.off("move", this._onMove), e.off("moveend", this._onMoveEnd), e.off("styledata", this._onStyleData), e.off("rotate", this._onRotate), this._map.getCanvas());
      e.removeEventListener("mousedown", this._onPointerDown), e.removeEventListener("touchstart", this._onPointerDown), this._map.getMapContainer().removeEventListener("keydown", this._shortcutListener);
    }, g.prototype._getEventPos = function (e) {
      var t, r;
      return "touches" in e ? (t = e.touches[0], r = e.target.getBoundingClientRect(), [t.pageX - r.left, t.pageY - r.top]) : [e.offsetX, e.offsetY];
    }, g.prototype._checkThresholds = function (e, t) {
      return this._checkZoomThreshold(e.zoom, t.zoom) || this._checkPitchThreshold(e.pitch, t.pitch) || this._checkLocThreshold(e.center, t.center) || this._checkHeadingThreshold(e.bearing, t.bearing);
    }, g.prototype._checkZoomThreshold = function (e, t) {
      return this._round(e) !== this._round(t);
    }, g.prototype._checkPitchThreshold = function (e, t) {
      return Math.abs(e - t) >= this._pitchThreshold;
    }, g.prototype._checkLocThreshold = function (e, t) {
      e = (t = __read$b(this._map.positionsToPixels([t, e]), 2))[0], t = t[1];
      return Pixel.getDistance(e, t) >= this._moveThreshold;
    }, g.prototype._checkHeadingThreshold = function (e, t) {
      e < 0 && (e += 360), t < 0 && (t += 360);
      e = Math.abs(e - t);
      return (e = 180 < e ? 360 - e : e) >= this._headingThreshold;
    }, g.prototype._getLocDesc = function (h, d, p) {
      return __awaiter$5(this, void 0, void 0, function () {
        var t,
          r,
          n,
          i,
          o,
          a,
          s,
          l,
          c,
          u = this;
        return __generator$5(this, function (e) {
          switch (e.label) {
            case 0:
              return "blank" === p ? [3, 3] : this._map._getMap().loaded() ? [3, 2] : [4, new Promise(function (e) {
                return u._map._getMap().once("idle", e);
              })];
            case 1:
              e.sent(), e.label = 2;
            case 2:
              for (t = {}, r = this._map.positionsToPixels([h.center])[0], ErrorHandler.tryCatch(this._map, function () {
                var t = u._map._getMap();
                n = t.queryRenderedFeatures(r, {
                  layers: u._polygonStyleLayer.filter(function (e) {
                    return t.getLayer(e);
                  }),
                  filter: ["==", ["geometry-type"], "Polygon"]
                });
              }, function () {}), i = null, n && 0 < n.length && (i = n[0]), o = null, a = 0, s = this._labelConfig.length; a < s; a++) l = this._labelConfig[a], h.zoom >= l.minZoom ? l.polygonSources ? i && -1 !== l.polygonSources.indexOf(i.layer["source-layer"]) ? (o = l.labelType, this._getClosestLabel(l, h, d, t, !1)) : this._getClosestLabel(l, h, d, t, !0) : this._getClosestLabel(l, h, d, t, !1) : this._getClosestLabel(l, h, d, t, !0);
              return 8 <= h.zoom && this._processRoads(t, h, d), this._labelCache.forEach(function (e) {
                !t[e] && (c = null, c = "water" !== e && "majorPoi" !== e || e === o ? g._labelCache.getNearestLabel(e, h.center, h.zoom) : c) && (t[e] = c.name);
              }), [2, this._processLocInfo(h, o, t, !0, this._restFallback)];
            case 3:
              return [2, this._processLocInfo(h, null, null, !1, !1)];
          }
        });
      });
    }, g.prototype._getHeadingDesc = function (e) {
      var t = e.bearing;
      switch (t < 0 && (t += 360), t = this._round(t, this._headingThreshold)) {
        case 0:
        case 360:
          return "north";
        case 45:
          return "north east";
        case 90:
          return "east";
        case 135:
          return "south east";
        case 180:
          return "south";
        case 225:
          return "south west";
        case 270:
          return "west";
        case 315:
          return "north west";
        default:
          return "".concat(t, " degrees");
      }
    }, g.prototype._getClosestLabel = function (e, t, r, n, i) {
      for (var o = e.radius, a = 0, s = e.source.length; a < s; a++) {
        var l = {
            sourceLayer: e.source[a],
            filter: ["has", "name"]
          },
          c = this._map._getMap().querySourceFeatures(this._baseVectorTileSourceId, l),
          u = null,
          h = 1 / 0,
          d = this._labelCache.has(e.labelType);
        if (!i || d) for (var p = 0, f = c.length; p < f; p++) {
          var _,
            m = "Point" === c[p].geometry.type ? c[p] : getClosestPointOnGeometry(t.center, c[p].geometry);
          i || (_ = "Point" === c[p].geometry.type ? getDistanceTo(t.center, m.geometry.coordinates) : m.properties.distance) < h && (h = _, u = c[p]), d && g._labelCache.cache(c[p].properties.name, e, m.geometry.coordinates, r);
        }
        i || (l = e.labelType + "Dis", u && h <= o && ("number" != typeof n[l] || h <= n[l]) && (n[e.labelType] = u.properties.name, n[l] = h));
      }
    }, g.prototype._processRoads = function (e, t, r, n) {
      var i = this._map._getMap().queryRenderedFeatures(n, {
        filter: ["==", ["geometry-type"], "LineString"]
      });
      if (i) {
        for (var o, a = void 0, s = void 0, l = void 0, c = void 0, u = 0, h = i.length; u < h; u++) this._roadLayers.has(i[u].layer["source-layer"]) && i[u].properties.name && "" !== i[u].properties.name && (o = getClosestPointOnGeometry(t.center, i[u]), !l || o.properties.distance < l.properties.distance) && (a && i[u].properties.name === a.properties.name ? l = o : a && i[u].properties.name === a.properties.name ? (!c || o.properties.distance < c.properties.distance) && (c = o, s = i[u]) : (c = l, s = a, l = o, a = i[u]));
        a && (!e.country && a.properties.country_code && (e.country = a.properties.country_code, e.countryDis = 0, g._labelCache.cache(e.country, {
          source: [],
          labelType: "country",
          radius: 5e3,
          minZoom: 0
        }, l.geometry.coordinates, r)), !e.state && a.properties.country_subdivision && (e.state = a.properties.country_subdivision, e.stateDis = 0, g._labelCache.cache(e.state, {
          source: [],
          labelType: "state",
          radius: 5e3,
          minZoom: 4
        }, l.geometry.coordinates, r)), 15 <= t.zoom) && (n = this._map.positionsToPixels([t.center, l.geometry.coordinates]), (Pixel.getDistance(n[0], n[1]) < this._roadPixelRadius || l.properties.distance < this._minRoadDistance) && (e.road = a.properties.name), s) && (r = this._map.positionsToPixels([c.geometry.coordinates]), Pixel.getDistance(n[0], r[0]) < this._minIntersectionPixelDistance || c.properties.distance < this._minRoadDistance) && (e.secondRoad = s.properties.name, e.secondRoadDis = c.properties.distance);
      }
    }, g.prototype._getActionDesc = function (e) {
      var t, r, n;
      return this._lastCam && (t = [], this._checkLocThreshold(e.center, this._lastCam.center) && (n = ["panned"], 0 === (r = Math.round(getHeading(this._lastCam.center, e.center))) || 360 === r ? n.push("north") : r < 90 ? n.push("north east") : 90 === r ? n.push("east") : r < 180 ? n.push("south east") : 180 === r ? n.push("south") : r < 270 ? n.push("south west") : 270 === r ? n.push("west") : r < 360 && n.push("north west"), r = getDistanceTo(this._lastCam.center, e.center, DistanceUnits.meters), n.push(1e3 < r ? "".concat(_precision(r / 1e3, 2), " kilometers") : "".concat(_precision(r, 2), " meters")), t.push(n.join(" "))), this._checkZoomThreshold(e.zoom, this._lastCam.zoom) && ((n = ["zoomed"]).push(this._lastCam.zoom < e.zoom ? "in" : "out"), 1 <= (r = Math.abs(this._lastCam.zoom - e.zoom)) && (r = Math.ceil(r), n.push("".concat(r, 1 < r ? " levels" : " level"))), this._getCanonicalZoom(this._lastCam.zoom) !== this._getCanonicalZoom(e.zoom) && n.push("to ".concat(this._getCanonicalZoom(e.zoom), " level")), e.zoom >= e.maxZoom && n.push("Zoom In button disabled, maximum zoom level reached"), r = BoundingBox.getSouth(e.bounds) <= -WEBMERCATOR_MAXLAT && BoundingBox.getNorth(e.bounds) >= WEBMERCATOR_MAXLAT, (e.zoom <= e.minZoom || r) && n.push("Zoom Out button disabled, minimum zoom level reached"), t.push(n.join(" "))), this._checkPitchThreshold(e.pitch, this._lastCam.pitch) && (r = this._round(e.pitch, this._pitchThreshold), t.push("pitched to ".concat(r, " degrees")), 60 !== e.pitch && 0 !== e.pitch || (n = 60 === e.pitch ? "maximum" : "minimum", t.push("reached ".concat(n, " of ").concat(e.pitch, " degrees")))), this._checkHeadingThreshold(this._lastCam.bearing, e.bearing) && t.push("rotated to ".concat(this._getHeadingDesc(e))), t.join(" and ")) || null;
    }, g.prototype._getCanonicalZoom = function (e) {
      return (e = this._round(e)) < 2 ? "world" : e < 5 ? "country" : e < 11 ? "state province" : e < 15 ? "city" : "street";
    }, g.prototype._processLocInfo = function (i, o, a, s, l) {
      var c = this;
      return new Promise(function (t, e) {
        var r = [];
        if (s) {
          var n = [];
          if (a && (o && ("water" === o && a.water ? n.push(a.water) : "majorPoi" === o && a.majorPoi && n.push(a.majorPoi)), 0 === n.length) && (a.majorPoi && 8 <= i.zoom ? n.push(a.majorPoi) : (a.poi && 14 <= i.zoom ? n.push(a.poi) : a.road && 15 <= i.zoom && (a.secondRoad ? n.push(a.road + " & " + a.secondRoad) : n.push(a.road)), a.neighbourhood && 12 <= i.zoom && n.push(a.neighbourhood), a.city && 6 <= i.zoom && n.push(a.city)), a.state && 4 <= i.zoom && n.push(a.state), 0 === n.length ? a.water ? n.push(a.water) : a.country && n.push(a.country) : 1 === n.length && a.state && 4 <= i.zoom && a.country && n.push(a.country)), 0 < n.length) r.push("<p>Location: ", n.join(", "), ".</p>");else if (l && "water" !== o) return void c._reverseGeocodeDescription(i).then(function (e) {
            t(e);
          }, function () {
            e("<p>Location: unknown</p>");
          });
        }
        c._returnDetailedDescriptions && (r.push("<p>Zoom: ", _precision(i.zoom, 2), ".</p>"), r.push("<p>Latitude: ", _precision(i.center[1], 5), ".</p>"), r.push("<p>Longitude: ", _precision(i.center[0], 5), ".</p>")), t(r.join(""));
      });
    }, g.prototype._reverseGeocodeDescription = function (o) {
      var a = this;
      return new Promise(function (n) {
        var i = a._map.getStyle();
        a._reverseSearch.request({
          position: o.center,
          style: i
        }).then(function (e) {
          var t,
            r = {};
          e && e.features && 0 < e.features.length && null != (t = null == (t = e.features[0]) ? void 0 : t.properties) && t.address && ((t = e.features[0].properties.address).countryRegion && (r.country = t.countryRegion.name, g._labelCache.cache(r.country, {
            source: [],
            labelType: "country",
            radius: 5e3,
            minZoom: 0
          }, o.center, i.language)), t.adminDistricts && (r.state = null == (e = t.adminDistricts[0]) ? void 0 : e.shortName, g._labelCache.cache(r.state, {
            source: [],
            labelType: "state",
            radius: 5e3,
            minZoom: 4
          }, o.center, i.language)), t.locality && (r.city = t.locality, g._labelCache.cache(r.city, {
            source: [],
            labelType: "city",
            radius: 1e3,
            minZoom: 10
          }, o.center, i.language)), t.addressLine) && (r.road = t.addressLine), a._processLocInfo(o, null, r, !0, !1).then(function (e) {
            n(e);
          });
        }, function (e) {
          a._processLocInfo(o, null, null, !0, !1).then(function (e) {
            n(e);
          });
        }).catch(function (e) {
          a._processLocInfo(o, null, null, !0, !1).then(function (e) {
            n(e);
          });
        });
      });
    }, g.prototype._round = function (e, t) {
      return void 0 === t && (t = 1), Math.round(e / t) * t;
    }, g._baseVectorTileSourceIds = ["microsoft.base", "vectorTiles", "bing-mvt"], g._labelConfigBing = [{
      source: ["water_feature"],
      labelType: "water",
      minZoom: 0,
      radius: 395e4,
      polygonSources: ["generic_water_fill"]
    }, {
      source: ["water_feature"],
      labelType: "water",
      minZoom: 3,
      radius: 1e6,
      polygonSources: ["generic_water_fill"]
    }, {
      source: ["country_region"],
      labelType: "country",
      minZoom: 0,
      maxZoom: 5,
      radius: 3e5
    }, {
      source: ["admin_division1"],
      labelType: "state",
      minZoom: 4,
      maxZoom: 7,
      radius: 3e5
    }, {
      source: ["populated_place"],
      labelType: "city",
      minZoom: 8,
      radius: 4e4
    }, {
      source: ["neighborhood"],
      labelType: "neighbourhood",
      minZoom: 12,
      radius: 6e3
    }, {
      source: ["amusement_park"],
      labelType: "poi",
      minZoom: 14,
      radius: 2e3,
      polygonSources: ["amusement_park_fill"]
    }, {
      source: ["hospital"],
      labelType: "poi",
      minZoom: 14,
      radius: 1e3,
      polygonSources: ["hospital_fill"]
    }, {
      source: ["shopping_center"],
      labelType: "poi",
      minZoom: 14,
      radius: 1e3,
      polygonSources: ["shopping_center_fill"]
    }, {
      source: ["stadium"],
      labelType: "poi",
      minZoom: 14,
      radius: 1e3,
      polygonSources: ["stadium_fill"]
    }, {
      source: ["higher_education_facility", "school"],
      labelType: "poi",
      minZoom: 14,
      radius: 1e3,
      polygonSources: ["higher_education_facility_fill", "school_fill"]
    }, {
      source: ["zoo"],
      labelType: "poi",
      minZoom: 14,
      radius: 1e3,
      polygonSources: ["zoo_fill"]
    }, {
      source: ["airport", "airport_terminal"],
      labelType: "majorPoi",
      minZoom: 11,
      radius: 3e3,
      polygonSources: ["airport_terminal_fill", "airport_fill-merged7", "airport_runway_fill"]
    }, {
      source: ["reserve"],
      labelType: "majorPoi",
      minZoom: 7,
      radius: 15e3,
      polygonSources: ["generic_reserve_fill", "land_cover_forest_fill"]
    }], g._roadLayersBing = new Set(["road"]), g;
  }(),
  AccessibleMapDelegate = function (e) {
    var r = this;
    this.addToMap = function () {
      null == r.mapViewDesc && (r.initializeMapLiveStateInfo(), r.initializeMapStyleInfo(), r.createMapKeyBindingInfo(), r.map.getMapContainer().setAttribute("role", "application"), r.map.getMapContainer().setAttribute("aria-label", "Map Application"), r.map.getCanvasContainer().setAttribute("aria-live", "polite"), r.map.getCanvasContainer().setAttribute("aria-describedby", "atlas-map-state atlas-map-style"), r.map.getCanvas().setAttribute("aria-label", "Interactive Map"), r.map.getCanvas().setAttribute("aria-describedby", "atlas-map-shortcuts"), r.map.getCanvas().setAttribute("alt", "Interactive Map"));
    }, this.removeFromMap = function () {
      null != r.mapViewDesc && r.mapViewDesc.dispose(), delete r.mapViewDesc, null != r.atlasMapKeyBindings && r.map.getCanvasContainer().removeChild(r.atlasMapKeyBindings), delete r.atlasMapKeyBindings, null != r.atlasMapLiveStateInfo && r.map.getCanvasContainer().removeChild(r.atlasMapLiveStateInfo), delete r.atlasMapLiveStateInfo, null != r.atlasMapStyleInfo && r.map.getCanvasContainer().removeChild(r.atlasMapStyleInfo), delete r.atlasMapStyleInfo, r.map.getMapContainer().removeAttribute("role"), r.map.getMapContainer().removeAttribute("aria-label"), r.map.getCanvasContainer().removeAttribute("aria-live"), r.map.getCanvasContainer().removeAttribute("aria-describedby"), r.map.getCanvas().removeAttribute("aria-label"), r.map.getCanvas().removeAttribute("aria-describedby"), r.map.getCanvas().removeAttribute("alt"), r.map.events.remove("stylechanged", r.updateMapStyle);
    }, this.createMapKeyBindingInfo = function () {
      r.atlasMapKeyBindings = document.createElement("div"), r.atlasMapKeyBindings.setAttribute("tabindex", "-1"), r.atlasMapKeyBindings.setAttribute("aria-hidden", "true"), r.atlasMapKeyBindings.id = "atlas-map-shortcuts", r.atlasMapKeyBindings.classList.add("hidden-accessible-element"), r.atlasMapKeyBindings.innerHTML = ["Map shortcuts:", "Zoom out: hyphen.", "Zoom in: plus.", "Pan right 100 pixels: right arrow.", "Pan left 100 pixels: left arrow.", "Pan up 100 pixels: up arrow.", "Pan down 100 pixels: down arrow.", "Rotate 15 degrees clockwise: shift + right arrow.", "Rotate 15 degrees counter clockwise: shift + left arrow.", "Increase pitch 10 degrees: shift + up arrow.", "Decrease pitch 10 degrees: shift + down arrow.", "Jump focus to the map: Escape."].join("\n"), r.map.getCanvasContainer().appendChild(r.atlasMapKeyBindings);
      var e = [189, 187, 38, 37, 39, 40],
        t = r.map._getMap()._canvas;
      null != t && t.addEventListener("keyup", function (t) {
        e.find(function (e) {
          return t.keyCode === e;
        }) && (r.atlasMapKeyBindings.innerHTML = "");
      });
    }, this.initializeMapLiveStateInfo = function () {
      r.mapViewDesc = new MapViewDescriptor(r.map, r.updateMapState), r.atlasMapLiveStateInfo = document.createElement("div"), r.atlasMapLiveStateInfo.setAttribute("tabindex", "-1"), r.atlasMapLiveStateInfo.setAttribute("aria-hidden", "true"), r.atlasMapLiveStateInfo.id = "atlas-map-state", r.atlasMapLiveStateInfo.classList.add("hidden-accessible-element"), r.map.getCanvasContainer().appendChild(r.atlasMapLiveStateInfo);
    }, this.initializeMapStyleInfo = function () {
      r.atlasMapStyleInfo = document.createElement("div"), r.atlasMapStyleInfo.setAttribute("tabindex", "-1"), r.atlasMapStyleInfo.setAttribute("aria-hidden", "true"), r.atlasMapStyleInfo.id = "atlas-map-style", r.atlasMapStyleInfo.classList.add("hidden-accessible-element"), r.map.events.add("stylechanged", r.updateMapStyle), r.map.getCanvasContainer().appendChild(r.atlasMapStyleInfo);
    }, this.updateMapStyle = function () {
      r.atlasMapStyleInfo.innerHTML = "<p>Map style: ".concat(r.map.getStyle().style, ".</p>");
    }, this.updateMapState = function (e) {
      r.atlasMapLiveStateInfo.innerHTML = e;
    }, this.map = e;
  },
  FlowServiceDelegate = function (e) {
    var r = this;
    this.listenerEnabled = !1, this.lastFlowMode = "none", this.addToMap = function () {
      if (!r.map._isReady()) throw new Error("Traffic flow could not be added to the map because the map is not ready. Please use a ready event listener to guarantee the map is ready before enabling traffic flow.");
      r.listenerEnabled || (r.map.events.add("styledata", r.addToMap), r.listenerEnabled = !0);
      var e,
        t = r.map.getTraffic();
      "none" !== t.flow && (e = r.map.layers.getLayerById("traffic_".concat(t.flow))) && (r.lastFlowMode = t.flow, e._updateLayoutProperty("visibility", "visible", "none"));
    }, this.removeFromMap = function () {
      var e;
      r.map.getTraffic(), "none" != r.lastFlowMode && ((e = r.map.layers.getLayerById("traffic_".concat(r.lastFlowMode))) && e._updateLayoutProperty("visibility", "none", "visible"), r.lastFlowMode = "none"), r.listenerEnabled && (r.map.events.remove("styledata", r.addToMap), r.listenerEnabled = !1);
    }, this.map = e;
  },
  __extends$i = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  Incident = function (o) {
    function a(e, t, r) {
      var n = null != (n = null != (n = null != (n = null != (n = null != (n = null != (n = null != (n = null != (n = null != (n = null != (n = null != (n = null != (n = null != (n = e.icon_category_12) ? n : e.icon_category_11) ? n : e.icon_category_10) ? n : e.icon_category_9) ? n : e.icon_category_8) ? n : e.icon_category_7) ? n : e.icon_category_6) ? n : e.icon_category_5) ? n : e.icon_category_4) ? n : e.icon_category_3) ? n : e.icon_category_2) ? n : e.icon_category_1) ? n : e.icon_category_0) ? n : e.icon_category,
        i = null != (i = null != (i = null != (i = null != (i = null != (i = null != (i = null != (i = null != (i = null != (i = null != (i = null != (i = null != (i = null != (i = e.description_12) ? i : e.description_11) ? i : e.description_10) ? i : e.description_9) ? i : e.description_8) ? i : e.description_7) ? i : e.description_6) ? i : e.description_5) ? i : e.description_4) ? i : e.description_3) ? i : e.description_2) ? i : e.description_1) ? i : e.description_0) ? i : e.description,
        n = {
          icon: "".concat(a.getSeverityColorName(e.magnitude), "-").concat(a.getIncidentTypeIconName(n)),
          incidentType: a.getIncidentTypeName(n, r),
          description: i,
          delay: e.delay,
          color: a.getSeverityColorHexCode(e.magnitude),
          id: e.id
        };
      return o.call(this, t, n) || this;
    }
    return __extends$i(a, o), a.getIncidentTypeName = function (e, t) {
      switch (e) {
        case 0:
          return t.Unknown;
        case 1:
          return t.Accident;
        case 2:
          return t.Fog;
        case 3:
          return t.Danger;
        case 4:
          return t.Rain;
        case 5:
          return t.Ice;
        case 6:
          return t.Jam;
        case 7:
          return t.LaneClosed;
        case 8:
          return t.RoadClosed;
        case 9:
          return t.RoadWorks;
        case 10:
          return t.Wind;
        case 11:
          return t.Flood;
        case 12:
          return t.Detour;
        default:
          return t.Unknown;
      }
    }, a.getIncidentTypeIconName = function (e) {
      switch (e) {
        case 0:
          return "unknown";
        case 1:
          return "accident";
        case 2:
          return "fog";
        case 3:
          return "danger";
        case 4:
          return "rain";
        case 5:
          return "ice";
        case 6:
          return "jam";
        case 7:
          return "lane-closed";
        case 8:
          return "road-closed";
        case 9:
          return "road-work";
        case 10:
          return "wind";
        case 11:
          return "flood";
        case 12:
          return "detour";
        default:
          return "unknown";
      }
    }, a.getSeverityColorName = function (e) {
      switch (e) {
        case 0:
          return "grey";
        case 1:
          return "yellow";
        case 2:
          return "orange";
        case 3:
          return "red";
        default:
          return "grey";
      }
    }, a.getSeverityColorHexCode = function (e) {
      switch (e) {
        case 0:
          return "#B5B6B7";
        case 1:
          return "#F4C951";
        case 2:
          return "#F4873F";
        case 3:
          return "#F04F4E";
        default:
          return "#B5B6B7";
      }
    }, a;
  }(Feature),
  IncidentPopupFactory = (!function (e) {
    e.DELAY = "delay", e.LENGTH = "length", e.FROM = "from", e.TO = "to";
  }(IncidentPopupIconName = IncidentPopupIconName || {}), function () {
    function e() {}
    return e.build = function (e, t) {
      void 0 === t && (t = "en-US");
      var r,
        n = document.createElement("div"),
        i = (n.classList.add("incident-popup-title"), n.classList.add("font-segoeui-b"), n.innerText = e.properties.incidentType, n.setAttribute("aria-label", "Incident Type ".concat(e.properties.incidentType)), document.createElement("div")),
        o = (i.classList.add("incident-popup-subtitle"), i.classList.add("font-segoeui-b"), i.setAttribute("aria-label", "Incident Description ".concat(e.properties.description)), i.innerText = e.properties.description, document.createElement("div")),
        n = (o.classList.add("incident-popup-header"), o.style.backgroundColor = e.properties.color, o.appendChild(n), o.appendChild(i), document.createElement("div")),
        i = (n.classList.add("incident-popup-body"), e.properties.delay && (i = "".concat(Math.floor(e.properties.delay / 60), " min"), i = this.createInfoSection(i, IncidentPopupIconName.DELAY), n.appendChild(i)), e.properties.length && (i = new Intl.NumberFormat([t, "en-US"], {
          maximumFractionDigits: 2
        }), r = void 0, r = "en-US" === t ? (t = convertDistance(e.properties.length, "meters", "miles"), "".concat(i.format(t), " miles")) : (t = convertDistance(e.properties.length, "meters", "kilometers"), "".concat(i.format(t), " km")), i = this.createInfoSection(r, IncidentPopupIconName.LENGTH), n.appendChild(i)), e.properties.from && (t = this.createInfoSection(e.properties.from, IncidentPopupIconName.FROM), n.appendChild(t)), e.properties.to && (r = this.createInfoSection(e.properties.to, IncidentPopupIconName.TO), n.appendChild(r)), document.createElement("div"));
      return i.classList.add("incident-popup-content"), i.appendChild(o), i.appendChild(n), new Popup({
        content: i,
        position: e.geometry.coordinates
      });
    }, e.createInfoSection = function (e, t) {
      var r = document.createElement("div"),
        n = (r.classList.add("incident-popup-info"), document.createElement("div")),
        i = (n.classList.add("icon"), n.classList.add(t), document.createElement("span"));
      return i.classList.add("message"), i.classList.add("font-segoeui"), i.setAttribute("aria-label", "Incident ".concat(t, " ").concat(e)), i.innerText = e, r.appendChild(n), r.appendChild(i), r;
    }, e;
  }()),
  __awaiter$4 = window && window.__awaiter || function (e, a, s, l) {
    return new (s = s || Promise)(function (r, t) {
      function n(e) {
        try {
          o(l.next(e));
        } catch (e) {
          t(e);
        }
      }
      function i(e) {
        try {
          o(l.throw(e));
        } catch (e) {
          t(e);
        }
      }
      function o(e) {
        var t;
        e.done ? r(e.value) : ((t = e.value) instanceof s ? t : new s(function (e) {
          e(t);
        })).then(n, i);
      }
      o((l = l.apply(e, a || [])).next());
    });
  },
  __generator$4 = window && window.__generator || function (n, i) {
    var o,
      a,
      s,
      l = {
        label: 0,
        sent: function () {
          if (1 & s[0]) throw s[1];
          return s[1];
        },
        trys: [],
        ops: []
      },
      c = {
        next: e(0),
        throw: e(1),
        return: e(2)
      };
    return "function" == typeof Symbol && (c[Symbol.iterator] = function () {
      return this;
    }), c;
    function e(r) {
      return function (e) {
        var t = [r, e];
        if (o) throw new TypeError("Generator is already executing.");
        for (; l = c && t[c = 0] ? 0 : l;) try {
          if (o = 1, a && (s = 2 & t[0] ? a.return : t[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, t[1])).done) return s;
          switch (a = 0, (t = s ? [2 & t[0], s.value] : t)[0]) {
            case 0:
            case 1:
              s = t;
              break;
            case 4:
              return l.label++, {
                value: t[1],
                done: !1
              };
            case 5:
              l.label++, a = t[1], t = [0];
              continue;
            case 7:
              t = l.ops.pop(), l.trys.pop();
              continue;
            default:
              if (!(s = 0 < (s = l.trys).length && s[s.length - 1]) && (6 === t[0] || 2 === t[0])) {
                l = 0;
                continue;
              }
              if (3 === t[0] && (!s || t[1] > s[0] && t[1] < s[3])) l.label = t[1];else if (6 === t[0] && l.label < s[1]) l.label = s[1], s = t;else {
                if (!(s && l.label < s[2])) {
                  s[2] && l.ops.pop(), l.trys.pop();
                  continue;
                }
                l.label = s[2], l.ops.push(t);
              }
          }
          t = i.call(n, l);
        } catch (e) {
          t = [6, e], a = 0;
        } finally {
          o = s = 0;
        }
        if (5 & t[0]) throw t[1];
        return {
          value: t[0] ? t[1] : void 0,
          done: !0
        };
      };
    }
  },
  IncidentServiceDelegate = function () {
    function e(e) {
      var i = this,
        e = (this.incidentLayerName = "incidents", this.incidentSourceName = "mapcontrol_traffic_incident", this.addToMap = function () {
          i.map.sources.getById(i.incidentSourceName) || i.map.sources.add(i.vectorTileSource), i.map.layers.getLayerById(i.incidentLayerName) || i.map.layers.add(i.incidentLayer, "labels"), i.clickPopup = new Popup({
            position: [0, 0],
            pixelOffset: [0, -18]
          }), i.map.addEventListener("mouseover", i.incidentLayerName, i.cursorToPointer), i.map.addEventListener("mouseleave", i.incidentLayerName, i.cursorToDefault), i.map.addEventListener("click", i.incidentLayerName, i.openIncidentPopup), i.map.events.addOnce("idle", i.setAccessiblePopups), i.map.events.add("moveend", i.setAccessiblePopups);
        }, this.accessiblePopups = [], this.setAccessiblePopups = function () {
          return __awaiter$4(i, void 0, void 0, function () {
            var t,
              o,
              a,
              s,
              l,
              c,
              u = this;
            return __generator$4(this, function (e) {
              switch (e.label) {
                case 0:
                  return this.accessiblePopups.forEach(function (e) {
                    return e.remove();
                  }), this.accessiblePopups = [], t = this.map.layers.getRenderedShapes(this.map.getCamera().bounds, this.incidentLayer), [4, this.map._getLocalizedStrings()];
                case 1:
                  return o = e.sent(), a = function (t, r) {
                    var e = t[r],
                      n = e.geometry.coordinates,
                      n = new Point(new Position(n[0], n[1])),
                      e = new Incident(e.properties, n, o),
                      i = IncidentPopupFactory.build(e, u.incidentLanguage),
                      n = i.getPopupContainer();
                    return n.addEventListener("focusin", function (e) {
                      u.clickPopup.remove(), u.accessiblePopups.filter(function (e) {
                        return e !== i;
                      }).forEach(function (e) {
                        return e.remove();
                      }), 0 <= r - 1 && s(i, a(t, r - 1)), r + 1 < t.length && c(a(t, r + 1)), 2 <= r && r == t.length - 1 && l(a(t, 0)), 0 == r && 2 <= t.length && c(a(t, t.length - 1));
                    }), r == t.length - 1 && n.addEventListener("focusout", function (e) {
                      null === e.relatedTarget && i.close();
                    }), u.accessiblePopups.push(i), i;
                  }, s = function (e, t) {
                    t.open(u.map), t.close();
                    t = t.getPopupContainer(), e = e.getPopupContainer();
                    e.parentElement.insertBefore(t, e);
                  }, l = function (e) {
                    e.open(u.map), e.close();
                    var e = e.getPopupContainer(),
                      t = e.parentElement;
                    t.insertBefore(e, t.firstElementChild);
                  }, c = function (e) {
                    e.open(u.map), e.close();
                  }, 0 < t.length && c(a(t, 0)), 1 < t.length && c(a(t, t.length - 1)), [2];
              }
            });
          });
        }, this.removeFromMap = function () {
          var e;
          i.map.removeEventListener("mouseover", i.incidentLayerName, i.cursorToPointer), i.map.removeEventListener("mouseleave", i.incidentLayerName, i.cursorToDefault), i.map.removeEventListener("click", i.incidentLayerName, i.openIncidentPopup), i.map.events.remove("idle", i.setAccessiblePopups), i.map.events.remove("moveend", i.setAccessiblePopups), i.accessiblePopups.forEach(function (e) {
            return e.remove();
          }), i.accessiblePopups = [], null != (e = i.clickPopup) && e.remove(), null != i.map.layers.getLayerById(i.incidentLayerName) && i.map.layers.remove(i.incidentLayerName), null != i.map.sources.getById(i.incidentSourceName) && i.map.sources.remove(i.incidentSourceName);
        }, this.cursorToPointer = function (e) {
          i.map.getCanvas().style.cursor = "pointer";
        }, this.cursorToDefault = function (e) {
          i.map.getCanvas().style.cursor = "";
        }, this.openIncidentPopup = function (e) {
          i.clickPopup.remove(), i.accessiblePopups.forEach(function (e) {
            return e.close();
          });
          var r = e.position,
            n = e.features[0];
          i.map._getLocalizedStrings().then(function (e) {
            var t = new Point(new Position(r[0], r[1])),
              t = new Incident(n.properties, t, e);
            i.clickPopup = IncidentPopupFactory.build(t, i.incidentLanguage), i.clickPopup.open(i.map), i.clickPopup.getPopupContainer().addEventListener("focusout", function (e) {
              null === e.relatedTarget && i.clickPopup.close();
            });
          });
        }, this.map = e, this.vectorTileSource = new VectorTileSource(this.incidentSourceName, {
          maxZoom: 22,
          tiles: ["https://".concat(constants.domainPlaceHolder, "/traffic/incident/tile/pbf?api-version=1.0&zoom={z}&x={x}&y={y}")]
        }), this.getIncidentIconImageExpression());
      this.incidentLayer = new SymbolLayer(this.incidentSourceName, this.incidentLayerName, {
        sourceLayer: "Traffic incident POI",
        iconOptions: {
          ignorePlacement: !0,
          allowOverlap: !0,
          image: e,
          size: .75
        }
      });
    }
    return e.prototype.getIncidentIconImageExpression = function () {
      return ["concat", ["let", "magnitude", ["get", "magnitude"], ["case", ["==", ["var", "magnitude"], 0], "grey", ["==", ["var", "magnitude"], 1], "yellow", ["==", ["var", "magnitude"], 2], "orange", ["==", ["var", "magnitude"], 3], "red", ["==", ["var", "magnitude"], 4], "grey", "grey"]], "-", ["let", "category", ["coalesce", ["get", "icon_category_12"], ["get", "icon_category_11"], ["get", "icon_category_10"], ["get", "icon_category_9"], ["get", "icon_category_8"], ["get", "icon_category_7"], ["get", "icon_category_6"], ["get", "icon_category_5"], ["get", "icon_category_4"], ["get", "icon_category_3"], ["get", "icon_category_2"], ["get", "icon_category_0"], ["get", "icon_category"], 0], ["case", ["==", ["var", "category"], 0], "unknown", ["==", ["var", "category"], 1], "accident", ["==", ["var", "category"], 2], "fog", ["==", ["var", "category"], 3], "danger", ["==", ["var", "category"], 4], "rain", ["==", ["var", "category"], 5], "ice", ["==", ["var", "category"], 6], "jam", ["==", ["var", "category"], 7], "lane-closed", ["==", ["var", "category"], 8], "road-closed", ["==", ["var", "category"], 9], "road-work", ["==", ["var", "category"], 10], "wind", ["==", ["var", "category"], 11], "flood", ["==", ["var", "category"], 12], "detour", "unknown"]]];
    }, e;
  }(),
  __extends$h = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  UserInteractionOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.interactive = !0, e.scrollZoomInteraction = !0, e.boxZoomInteraction = !0, e.dragRotateInteraction = !0, e.dragPanInteraction = !0, e.keyboardInteraction = !0, e.dblClickZoomInteraction = !0, e.touchInteraction = !0, e.touchRotate = !0, e.wheelZoomRate = 1 / 450, e;
    }
    return __extends$h(e, t), e;
  }(Options),
  FocusShortcutHandler = function () {
    function e(e) {
      var t = this;
      this._onKeyDown = function (e) {
        27 === e.keyCode && t.map.getCanvas().focus();
      }, this.map = e;
    }
    return e.prototype.enable = function () {
      this.map.getMapContainer().addEventListener("keydown", this._onKeyDown);
    }, e.prototype.disable = function () {
      this.map.getMapContainer().removeEventListener("keydown", this._onKeyDown);
    }, e;
  }(),
  PinchZoomHandler = function () {
    function e(e) {
      var t = this;
      this._onGestureStart = function (e) {
        t.hasTouch || (e.preventDefault(), t.initZoom = t.map.getCamera().zoom);
      }, this._onGestureChange = function (e) {
        t.hasTouch || (e.preventDefault(), t.map.setCamera({
          zoom: t.initZoom + e.scale - 1
        }));
      }, this._onTouchStart = function (e) {
        t.hasTouch = !0;
      }, this._onTouchEnd = function (e) {
        0 === e.touches.length && (t.hasTouch = !1);
      }, this.map = e;
    }
    return e.prototype.enable = function () {
      this.map.getCanvasContainer().addEventListener("gesturestart", this._onGestureStart), this.map.getCanvasContainer().addEventListener("gesturechange", this._onGestureChange), this.map.getCanvasContainer().addEventListener("touchstart", this._onTouchStart), this.map.getCanvasContainer().addEventListener("touchend", this._onTouchEnd);
    }, e.prototype.disable = function () {
      this.map.getCanvasContainer().removeEventListener("gesturestart", this._onGestureStart), this.map.getCanvasContainer().removeEventListener("gesturechange", this._onGestureChange), this.map.getCanvasContainer().removeEventListener("touchstart", this._onTouchStart), this.map.getCanvasContainer().removeEventListener("touchend", this._onTouchEnd);
    }, e;
  }(),
  UserInteractionDelegate = function () {
    function e(e, t) {
      this.added = !1, this.map = e, this.focusShortcut = new FocusShortcutHandler(e), this.pinchZoom = new PinchZoomHandler(e), this.options = new UserInteractionOptions().merge(t);
    }
    return e.prototype.addToMap = function () {
      this.added || (this.added = !0, this._setInteractions(this.options));
    }, e.prototype.removeFromMap = function () {
      this.added && (this.added = !1, this._setInteractions({
        interactive: !1
      }));
    }, e.prototype.setOptions = function (e) {
      this.options = new UserInteractionOptions().merge(this.options, e), this.added && this._setInteractions(this.options);
    }, e.prototype.getOptions = function () {
      return Object.assign({}, this.options);
    }, e.prototype._setInteractions = function (e) {
      var t;
      e.interactive ? (e.boxZoomInteraction ? this.map._getMap().boxZoom.enable() : this.map._getMap().boxZoom.disable(), e.dblClickZoomInteraction ? this.map._getMap().doubleClickZoom.enable() : this.map._getMap().doubleClickZoom.disable(), e.dragPanInteraction ? this.map._getMap().dragPan.enable() : this.map._getMap().dragPan.disable(), e.dragRotateInteraction ? this.map._getMap().dragRotate.enable() : this.map._getMap().dragRotate.disable(), e.keyboardInteraction ? (this.map._getMap().keyboard.enable(), this.focusShortcut.enable()) : (this.map._getMap().keyboard.disable(), this.focusShortcut.disable()), e.scrollZoomInteraction ? (this.map._getMap().scrollZoom.enable(), this.map._getMap().scrollZoom.setWheelZoomRate(e.wheelZoomRate)) : this.map._getMap().scrollZoom.disable(), t = this.map._getMap().touchZoomRotate, e.touchInteraction ? (t.enable(), e.touchRotate ? t.enableRotation() : t.disableRotation()) : t.disable(), this.pinchZoom.enable()) : (this.map._getMap().boxZoom.disable(), this.map._getMap().doubleClickZoom.disable(), this.map._getMap().dragPan.disable(), this.map._getMap().dragRotate.disable(), this.map._getMap().keyboard.disable(), this.focusShortcut.disable(), this.map._getMap().scrollZoom.disable(), this.map._getMap().touchZoomRotate.disable(), this.pinchZoom.disable());
    }, e;
  }();
function feature(e, t, r) {
  var n = {
    type: "Feature"
  };
  return 0 !== (r = void 0 === r ? {} : r).id && !r.id || (n.id = r.id), r.bbox && (n.bbox = r.bbox), n.properties = t || {}, n.geometry = e, n;
}
function polygon(e, t, r) {
  void 0 === r && (r = {});
  for (var n = 0, i = e; n < i.length; n++) {
    var o = i[n];
    if (o.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    for (var a = 0; a < o[o.length - 1].length; a++) if (o[o.length - 1][a] !== o[0][a]) throw new Error("First and last Position are not equivalent.");
  }
  return feature({
    type: "Polygon",
    coordinates: e
  }, t, r);
}
function multiPolygon(e, t, r) {
  return feature({
    type: "MultiPolygon",
    coordinates: e
  }, t, r = void 0 === r ? {} : r);
}
function getGeom(e) {
  return "Feature" === e.type ? e.geometry : e;
}
var polygonClipping_umd = {
    exports: {}
  },
  polygonClipping_umdExports = (polygonClipping_umd.exports = function () {
    function c(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }
    function n(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];
        n.enumerable = n.enumerable || false;
        n.configurable = true;
        if ("value" in n) n.writable = true;
        Object.defineProperty(e, n.key, n);
      }
    }
    function a(e, t, r) {
      if (t) n(e.prototype, t);
      if (r) n(e, r);
      return e;
    }
    var u = function () {
      function e(e, t) {
        this.next = null;
        this.key = e;
        this.data = t;
        this.left = null;
        this.right = null;
      }
      return e;
    }();
    function t(e, t) {
      return e > t ? 1 : e < t ? -1 : 0;
    }
    function s(e, t, r) {
      var n = new u(null, null);
      var i = n;
      var o = n;
      while (true) {
        var a = r(e, t.key);
        if (a < 0) {
          if (t.left === null) break;
          if (r(e, t.left.key) < 0) {
            var s = t.left;
            t.left = s.right;
            s.right = t;
            t = s;
            if (t.left === null) break;
          }
          o.left = t;
          o = t;
          t = t.left;
        } else if (a > 0) {
          if (t.right === null) break;
          if (r(e, t.right.key) > 0) {
            var s = t.right;
            t.right = s.left;
            s.left = t;
            t = s;
            if (t.right === null) break;
          }
          i.right = t;
          i = t;
          t = t.right;
        } else break;
      }
      i.right = t.left;
      o.left = t.right;
      t.left = n.right;
      t.right = n.left;
      return t;
    }
    function l(e, t, r, n) {
      var i = new u(e, t);
      if (r === null) {
        i.left = i.right = null;
        return i;
      }
      r = s(e, r, n);
      var o = n(e, r.key);
      if (o < 0) {
        i.left = r.left;
        i.right = r;
        r.left = null;
      } else if (o >= 0) {
        i.right = r.right;
        i.left = r;
        r.right = null;
      }
      return i;
    }
    function h(e, t, r) {
      var n = null;
      var i = null;
      if (t) {
        t = s(e, t, r);
        var o = r(t.key, e);
        if (o === 0) {
          n = t.left;
          i = t.right;
        } else if (o < 0) {
          i = t.right;
          t.right = null;
          n = t;
        } else {
          n = t.left;
          t.left = null;
          i = t;
        }
      }
      return {
        left: n,
        right: i
      };
    }
    function d(e, t, r) {
      if (t === null) return e;
      if (e === null) return t;
      t = s(e.key, t, r);
      t.left = e;
      return t;
    }
    function p(e, t, r, n, i) {
      if (e) {
        n("" + t + (r ? "└── " : "├── ") + i(e) + "\n");
        var o = t + (r ? "    " : "│   ");
        if (e.left) p(e.left, o, false, n, i);
        if (e.right) p(e.right, o, true, n, i);
      }
    }
    var D = function () {
      function e(e) {
        if (e === void 0) e = t;
        this._root = null;
        this._size = 0;
        this._comparator = e;
      }
      e.prototype.insert = function (e, t) {
        this._size++;
        return this._root = l(e, t, this._root, this._comparator);
      };
      e.prototype.add = function (e, t) {
        var r = new u(e, t);
        if (this._root === null) {
          r.left = r.right = null;
          this._size++;
          this._root = r;
        }
        var n = this._comparator;
        var i = s(e, this._root, n);
        var o = n(e, i.key);
        if (o === 0) this._root = i;else {
          if (o < 0) {
            r.left = i.left;
            r.right = i;
            i.left = null;
          } else if (o > 0) {
            r.right = i.right;
            r.left = i;
            i.right = null;
          }
          this._size++;
          this._root = r;
        }
        return this._root;
      };
      e.prototype.remove = function (e) {
        this._root = this._remove(e, this._root, this._comparator);
      };
      e.prototype._remove = function (e, t, r) {
        var n;
        if (t === null) return null;
        t = s(e, t, r);
        var i = r(e, t.key);
        if (i === 0) {
          if (t.left === null) n = t.right;else {
            n = s(e, t.left, r);
            n.right = t.right;
          }
          this._size--;
          return n;
        }
        return t;
      };
      e.prototype.pop = function () {
        var e = this._root;
        if (e) {
          while (e.left) e = e.left;
          this._root = s(e.key, this._root, this._comparator);
          this._root = this._remove(e.key, this._root, this._comparator);
          return {
            key: e.key,
            data: e.data
          };
        }
        return null;
      };
      e.prototype.findStatic = function (e) {
        var t = this._root;
        var r = this._comparator;
        while (t) {
          var n = r(e, t.key);
          if (n === 0) return t;else if (n < 0) t = t.left;else t = t.right;
        }
        return null;
      };
      e.prototype.find = function (e) {
        if (this._root) {
          this._root = s(e, this._root, this._comparator);
          if (this._comparator(e, this._root.key) !== 0) return null;
        }
        return this._root;
      };
      e.prototype.contains = function (e) {
        var t = this._root;
        var r = this._comparator;
        while (t) {
          var n = r(e, t.key);
          if (n === 0) return true;else if (n < 0) t = t.left;else t = t.right;
        }
        return false;
      };
      e.prototype.forEach = function (e, t) {
        var r = this._root;
        var n = [];
        var i = false;
        while (!i) if (r !== null) {
          n.push(r);
          r = r.left;
        } else if (n.length !== 0) {
          r = n.pop();
          e.call(t, r);
          r = r.right;
        } else i = true;
        return this;
      };
      e.prototype.range = function (e, t, r, n) {
        var i = [];
        var o = this._comparator;
        var a = this._root;
        var s;
        while (i.length !== 0 || a) if (a) {
          i.push(a);
          a = a.left;
        } else {
          a = i.pop();
          s = o(a.key, t);
          if (s > 0) break;else if (o(a.key, e) >= 0) if (r.call(n, a)) return this;
          a = a.right;
        }
        return this;
      };
      e.prototype.keys = function () {
        var r = [];
        this.forEach(function (e) {
          var t = e.key;
          return r.push(t);
        });
        return r;
      };
      e.prototype.values = function () {
        var r = [];
        this.forEach(function (e) {
          var t = e.data;
          return r.push(t);
        });
        return r;
      };
      e.prototype.min = function () {
        if (this._root) return this.minNode(this._root).key;
        return null;
      };
      e.prototype.max = function () {
        if (this._root) return this.maxNode(this._root).key;
        return null;
      };
      e.prototype.minNode = function (e) {
        if (e === void 0) e = this._root;
        if (e) while (e.left) e = e.left;
        return e;
      };
      e.prototype.maxNode = function (e) {
        if (e === void 0) e = this._root;
        if (e) while (e.right) e = e.right;
        return e;
      };
      e.prototype.at = function (e) {
        var t = this._root;
        var r = false;
        var n = 0;
        var i = [];
        while (!r) if (t) {
          i.push(t);
          t = t.left;
        } else if (i.length > 0) {
          t = i.pop();
          if (n === e) return t;
          n++;
          t = t.right;
        } else r = true;
        return null;
      };
      e.prototype.next = function (e) {
        var t = this._root;
        var r = null;
        if (e.right) {
          r = e.right;
          while (r.left) r = r.left;
          return r;
        }
        var n = this._comparator;
        while (t) {
          var i = n(e.key, t.key);
          if (i === 0) break;else if (i < 0) {
            r = t;
            t = t.left;
          } else t = t.right;
        }
        return r;
      };
      e.prototype.prev = function (e) {
        var t = this._root;
        var r = null;
        if (e.left !== null) {
          r = e.left;
          while (r.right) r = r.right;
          return r;
        }
        var n = this._comparator;
        while (t) {
          var i = n(e.key, t.key);
          if (i === 0) break;else if (i < 0) t = t.left;else {
            r = t;
            t = t.right;
          }
        }
        return r;
      };
      e.prototype.clear = function () {
        this._root = null;
        this._size = 0;
        return this;
      };
      e.prototype.toList = function () {
        return r(this._root);
      };
      e.prototype.load = function (e, t, r) {
        if (t === void 0) t = [];
        if (r === void 0) r = false;
        var n = e.length;
        var i = this._comparator;
        if (r) y(e, t, 0, n - 1, i);
        if (this._root === null) {
          this._root = f(e, t, 0, n);
          this._size = n;
        } else {
          var o = g(this.toList(), _(e, t), i);
          n = this._size + n;
          this._root = m({
            head: o
          }, 0, n);
        }
        return this;
      };
      e.prototype.isEmpty = function () {
        return this._root === null;
      };
      Object.defineProperty(e.prototype, "size", {
        get: function e() {
          return this._size;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(e.prototype, "root", {
        get: function e() {
          return this._root;
        },
        enumerable: true,
        configurable: true
      });
      e.prototype.toString = function (e) {
        if (e === void 0) e = function e(t) {
          return String(t.key);
        };
        var t = [];
        p(this._root, "", true, function (e) {
          return t.push(e);
        }, e);
        return t.join("");
      };
      e.prototype.update = function (e, t, r) {
        var n = this._comparator;
        var i = h(e, this._root, n),
          o = i.left,
          a = i.right;
        if (n(e, t) < 0) a = l(t, r, a, n);else o = l(t, r, o, n);
        this._root = d(o, a, n);
      };
      e.prototype.split = function (e) {
        return h(e, this._root, this._comparator);
      };
      return e;
    }();
    function f(e, t, r, n) {
      var i = n - r;
      if (i > 0) {
        var o = r + Math.floor(i / 2);
        var a = e[o];
        var s = t[o];
        var l = new u(a, s);
        l.left = f(e, t, r, o);
        l.right = f(e, t, o + 1, n);
        return l;
      }
      return null;
    }
    function _(e, t) {
      var r = new u(null, null);
      var n = r;
      for (var i = 0; i < e.length; i++) n = n.next = new u(e[i], t[i]);
      n.next = null;
      return r.next;
    }
    function r(e) {
      var t = e;
      var r = [];
      var n = false;
      var i = new u(null, null);
      var o = i;
      while (!n) if (t) {
        r.push(t);
        t = t.left;
      } else if (r.length > 0) {
        t = o = o.next = r.pop();
        t = t.right;
      } else n = true;
      o.next = null;
      return i.next;
    }
    function m(e, t, r) {
      var n = r - t;
      if (n > 0) {
        var i = t + Math.floor(n / 2);
        var o = m(e, t, i);
        var a = e.head;
        a.left = o;
        e.head = e.head.next;
        a.right = m(e, i + 1, r);
        return a;
      }
      return null;
    }
    function g(e, t, r) {
      var n = new u(null, null);
      var i = n;
      var o = e;
      var a = t;
      while (o !== null && a !== null) {
        if (r(o.key, a.key) < 0) {
          i.next = o;
          o = o.next;
        } else {
          i.next = a;
          a = a.next;
        }
        i = i.next;
      }
      if (o !== null) i.next = o;else if (a !== null) i.next = a;
      return n.next;
    }
    function y(e, t, r, n, i) {
      if (r >= n) return;
      var o = e[r + n >> 1];
      var a = r - 1;
      var s = n + 1;
      while (true) {
        do {
          a++;
        } while (i(e[a], o) < 0);
        do {
          s--;
        } while (i(e[s], o) > 0);
        if (a >= s) break;
        var l = e[a];
        e[a] = e[s];
        e[s] = l;
        l = t[a];
        t[a] = t[s];
        t[s] = l;
      }
      y(e, t, r, s, i);
      y(e, t, s + 1, n, i);
    }
    var v = function e(t, r) {
        return t.ll.x <= r.x && r.x <= t.ur.x && t.ll.y <= r.y && r.y <= t.ur.y;
      },
      R = function e(t, r) {
        if (r.ur.x < t.ll.x || t.ur.x < r.ll.x || r.ur.y < t.ll.y || t.ur.y < r.ll.y) return null;
        var n = t.ll.x < r.ll.x ? r.ll.x : t.ll.x;
        var i = t.ur.x < r.ur.x ? t.ur.x : r.ur.x;
        var o = t.ll.y < r.ll.y ? r.ll.y : t.ll.y;
        var a = t.ur.y < r.ur.y ? t.ur.y : r.ur.y;
        return {
          ll: {
            x: n,
            y: o
          },
          ur: {
            x: i,
            y: a
          }
        };
      },
      i = Number.EPSILON;
    if (i === undefined) i = Math.pow(2, -52);
    var P = i * i,
      E = function e(t, r) {
        if (-i < t && t < i) if (-i < r && r < i) return 0;
        var n = t - r;
        if (n * n < P * t * r) return 0;
        return t < r ? -1 : 1;
      },
      e = function () {
        function e() {
          c(this, e);
          this.reset();
        }
        a(e, [{
          key: "reset",
          value: function e() {
            this.xRounder = new o();
            this.yRounder = new o();
          }
        }, {
          key: "round",
          value: function e(t, r) {
            return {
              x: this.xRounder.round(t),
              y: this.yRounder.round(r)
            };
          }
        }]);
        return e;
      }(),
      o = function () {
        function e() {
          c(this, e);
          this.tree = new D();
          this.round(0);
        }
        a(e, [{
          key: "round",
          value: function e(t) {
            var r = this.tree.add(t);
            var n = this.tree.prev(r);
            if (n !== null && E(r.key, n.key) === 0) {
              this.tree.remove(t);
              return n.key;
            }
            var i = this.tree.next(r);
            if (i !== null && E(r.key, i.key) === 0) {
              this.tree.remove(t);
              return i.key;
            }
            return t;
          }
        }]);
        return e;
      }(),
      O = new e(),
      b = function e(t, r) {
        return t.x * r.y - t.y * r.x;
      },
      w = function e(t, r) {
        return t.x * r.x + t.y * r.y;
      },
      T = function e(t, r, n) {
        var i = {
          x: r.x - t.x,
          y: r.y - t.y
        };
        var o = {
          x: n.x - t.x,
          y: n.y - t.y
        };
        var a = b(i, o);
        return E(a, 0);
      },
      S = function e(t) {
        return Math.sqrt(w(t, t));
      },
      F = function e(t, r, n) {
        var i = {
          x: r.x - t.x,
          y: r.y - t.y
        };
        var o = {
          x: n.x - t.x,
          y: n.y - t.y
        };
        return b(o, i) / S(o) / S(i);
      },
      B = function e(t, r, n) {
        var i = {
          x: r.x - t.x,
          y: r.y - t.y
        };
        var o = {
          x: n.x - t.x,
          y: n.y - t.y
        };
        return w(o, i) / S(o) / S(i);
      },
      x = function e(t, r, n) {
        if (r.y === 0) return null;
        return {
          x: t.x + r.x / r.y * (n - t.y),
          y: n
        };
      },
      C = function e(t, r, n) {
        if (r.x === 0) return null;
        return {
          x: n,
          y: t.y + r.y / r.x * (n - t.x)
        };
      },
      $ = function e(t, r, n, i) {
        if (r.x === 0) return C(n, i, t.x);
        if (i.x === 0) return C(t, r, n.x);
        if (r.y === 0) return x(n, i, t.y);
        if (i.y === 0) return x(t, r, n.y);
        var o = b(r, i);
        if (o == 0) return null;
        var a = {
          x: n.x - t.x,
          y: n.y - t.y
        };
        var s = b(a, r) / o;
        var l = b(a, i) / o;
        var c = t.x + l * r.x,
          u = n.x + s * i.x;
        var h = t.y + l * r.y,
          d = n.y + s * i.y;
        var p = (c + u) / 2;
        var f = (h + d) / 2;
        return {
          x: p,
          y: f
        };
      },
      M = function () {
        a(i, null, [{
          key: "compare",
          value: function e(t, r) {
            var n = i.comparePoints(t.point, r.point);
            if (n !== 0) return n;
            if (t.point !== r.point) t.link(r);
            if (t.isLeft !== r.isLeft) return t.isLeft ? 1 : -1;
            return A.compare(t.segment, r.segment);
          }
        }, {
          key: "comparePoints",
          value: function e(t, r) {
            if (t.x < r.x) return -1;
            if (t.x > r.x) return 1;
            if (t.y < r.y) return -1;
            if (t.y > r.y) return 1;
            return 0;
          }
        }]);
        function i(e, t) {
          c(this, i);
          if (e.events === undefined) e.events = [this];else e.events.push(this);
          this.point = e;
          this.isLeft = t;
        }
        a(i, [{
          key: "link",
          value: function e(t) {
            if (t.point === this.point) throw new Error("Tried to link already linked events");
            var r = t.point.events;
            for (var n = 0, i = r.length; n < i; n++) {
              var o = r[n];
              this.point.events.push(o);
              o.point = this.point;
            }
            this.checkForConsuming();
          }
        }, {
          key: "checkForConsuming",
          value: function e() {
            var t = this.point.events.length;
            for (var r = 0; r < t; r++) {
              var n = this.point.events[r];
              if (n.segment.consumedBy !== undefined) continue;
              for (var i = r + 1; i < t; i++) {
                var o = this.point.events[i];
                if (o.consumedBy !== undefined) continue;
                if (n.otherSE.point.events !== o.otherSE.point.events) continue;
                n.segment.consume(o.segment);
              }
            }
          }
        }, {
          key: "getAvailableLinkedEvents",
          value: function e() {
            var t = [];
            for (var r = 0, n = this.point.events.length; r < n; r++) {
              var i = this.point.events[r];
              if (i !== this && !i.segment.ringOut && i.segment.isInResult()) t.push(i);
            }
            return t;
          }
        }, {
          key: "getLeftmostComparator",
          value: function e(n) {
            var i = this;
            var l = new Map();
            var c = function e(t) {
              var r = t.otherSE;
              l.set(t, {
                sine: F(i.point, n.point, r.point),
                cosine: B(i.point, n.point, r.point)
              });
            };
            return function (e, t) {
              if (!l.has(e)) c(e);
              if (!l.has(t)) c(t);
              var r = l.get(e),
                n = r.sine,
                i = r.cosine;
              var o = l.get(t),
                a = o.sine,
                s = o.cosine;
              if (n >= 0 && a >= 0) {
                if (i < s) return 1;
                if (i > s) return -1;
                return 0;
              }
              if (n < 0 && a < 0) {
                if (i < s) return -1;
                if (i > s) return 1;
                return 0;
              }
              if (a < n) return -1;
              if (a > n) return 1;
              return 0;
            };
          }
        }]);
        return i;
      }(),
      z = 0,
      A = function () {
        a(d, null, [{
          key: "compare",
          value: function e(t, r) {
            var n = t.leftSE.point.x;
            var i = r.leftSE.point.x;
            var o = t.rightSE.point.x;
            var a = r.rightSE.point.x;
            if (a < n) return 1;
            if (o < i) return -1;
            var s = t.leftSE.point.y;
            var l = r.leftSE.point.y;
            var c = t.rightSE.point.y;
            var u = r.rightSE.point.y;
            if (n < i) {
              if (l < s && l < c) return 1;
              if (l > s && l > c) return -1;
              var h = t.comparePoint(r.leftSE.point);
              if (h < 0) return 1;
              if (h > 0) return -1;
              var d = r.comparePoint(t.rightSE.point);
              if (d !== 0) return d;
              return -1;
            }
            if (n > i) {
              if (s < l && s < u) return -1;
              if (s > l && s > u) return 1;
              var p = r.comparePoint(t.leftSE.point);
              if (p !== 0) return p;
              var f = t.comparePoint(r.rightSE.point);
              if (f < 0) return 1;
              if (f > 0) return -1;
              return 1;
            }
            if (s < l) return -1;
            if (s > l) return 1;
            if (o < a) {
              var _ = r.comparePoint(t.rightSE.point);
              if (_ !== 0) return _;
            }
            if (o > a) {
              var m = t.comparePoint(r.rightSE.point);
              if (m < 0) return 1;
              if (m > 0) return -1;
            }
            if (o !== a) {
              var g = c - s;
              var y = o - n;
              var v = u - l;
              var E = a - i;
              if (g > y && v < E) return 1;
              if (g < y && v > E) return -1;
            }
            if (o > a) return 1;
            if (o < a) return -1;
            if (c < u) return -1;
            if (c > u) return 1;
            if (t.id < r.id) return -1;
            if (t.id > r.id) return 1;
            return 0;
          }
        }]);
        function d(e, t, r, n) {
          c(this, d);
          this.id = ++z;
          this.leftSE = e;
          e.segment = this;
          e.otherSE = t;
          this.rightSE = t;
          t.segment = this;
          t.otherSE = e;
          this.rings = r;
          this.windings = n;
        }
        a(d, [{
          key: "replaceRightSE",
          value: function e(t) {
            this.rightSE = t;
            this.rightSE.segment = this;
            this.rightSE.otherSE = this.leftSE;
            this.leftSE.otherSE = this.rightSE;
          }
        }, {
          key: "bbox",
          value: function e() {
            var t = this.leftSE.point.y;
            var r = this.rightSE.point.y;
            return {
              ll: {
                x: this.leftSE.point.x,
                y: t < r ? t : r
              },
              ur: {
                x: this.rightSE.point.x,
                y: t > r ? t : r
              }
            };
          }
        }, {
          key: "vector",
          value: function e() {
            return {
              x: this.rightSE.point.x - this.leftSE.point.x,
              y: this.rightSE.point.y - this.leftSE.point.y
            };
          }
        }, {
          key: "isAnEndpoint",
          value: function e(t) {
            return t.x === this.leftSE.point.x && t.y === this.leftSE.point.y || t.x === this.rightSE.point.x && t.y === this.rightSE.point.y;
          }
        }, {
          key: "comparePoint",
          value: function e(t) {
            if (this.isAnEndpoint(t)) return 0;
            var r = this.leftSE.point;
            var n = this.rightSE.point;
            var i = this.vector();
            if (r.x === n.x) {
              if (t.x === r.x) return 0;
              return t.x < r.x ? 1 : -1;
            }
            var o = (t.y - r.y) / i.y;
            var a = r.x + o * i.x;
            if (t.x === a) return 0;
            var s = (t.x - r.x) / i.x;
            var l = r.y + s * i.y;
            if (t.y === l) return 0;
            return t.y < l ? -1 : 1;
          }
        }, {
          key: "getIntersection",
          value: function e(t) {
            var r = this.bbox();
            var n = t.bbox();
            var i = R(r, n);
            if (i === null) return null;
            var o = this.leftSE.point;
            var a = this.rightSE.point;
            var s = t.leftSE.point;
            var l = t.rightSE.point;
            var c = v(r, s) && this.comparePoint(s) === 0;
            var u = v(n, o) && t.comparePoint(o) === 0;
            var h = v(r, l) && this.comparePoint(l) === 0;
            var d = v(n, a) && t.comparePoint(a) === 0;
            if (u && c) {
              if (d && !h) return a;
              if (!d && h) return l;
              return null;
            }
            if (u) {
              if (h) if (o.x === l.x && o.y === l.y) return null;
              return o;
            }
            if (c) {
              if (d) if (a.x === s.x && a.y === s.y) return null;
              return s;
            }
            if (d && h) return null;
            if (d) return a;
            if (h) return l;
            var p = $(o, this.vector(), s, t.vector());
            if (p === null) return null;
            if (!v(i, p)) return null;
            return O.round(p.x, p.y);
          }
        }, {
          key: "split",
          value: function e(t) {
            var r = [];
            var n = t.events !== undefined;
            var i = new M(t, true);
            var o = new M(t, false);
            var a = this.rightSE;
            this.replaceRightSE(o);
            r.push(o);
            r.push(i);
            var s = new d(i, a, this.rings.slice(), this.windings.slice());
            if (M.comparePoints(s.leftSE.point, s.rightSE.point) > 0) s.swapEvents();
            if (M.comparePoints(this.leftSE.point, this.rightSE.point) > 0) this.swapEvents();
            if (n) {
              i.checkForConsuming();
              o.checkForConsuming();
            }
            return r;
          }
        }, {
          key: "swapEvents",
          value: function e() {
            var t = this.rightSE;
            this.rightSE = this.leftSE;
            this.leftSE = t;
            this.leftSE.isLeft = true;
            this.rightSE.isLeft = false;
            for (var r = 0, n = this.windings.length; r < n; r++) this.windings[r] *= -1;
          }
        }, {
          key: "consume",
          value: function e(t) {
            var r = this;
            var n = t;
            while (r.consumedBy) r = r.consumedBy;
            while (n.consumedBy) n = n.consumedBy;
            var i = d.compare(r, n);
            if (i === 0) return;
            if (i > 0) {
              var o = r;
              r = n;
              n = o;
            }
            if (r.prev === n) {
              var a = r;
              r = n;
              n = a;
            }
            for (var s = 0, l = n.rings.length; s < l; s++) {
              var c = n.rings[s];
              var u = n.windings[s];
              var h = r.rings.indexOf(c);
              if (h === -1) {
                r.rings.push(c);
                r.windings.push(u);
              } else r.windings[h] += u;
            }
            n.rings = null;
            n.windings = null;
            n.consumedBy = r;
            n.leftSE.consumedBy = r.leftSE;
            n.rightSE.consumedBy = r.rightSE;
          }
        }, {
          key: "prevInResult",
          value: function e() {
            if (this._prevInResult !== undefined) return this._prevInResult;
            if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();
            return this._prevInResult;
          }
        }, {
          key: "beforeState",
          value: function e() {
            if (this._beforeState !== undefined) return this._beforeState;
            if (!this.prev) this._beforeState = {
              rings: [],
              windings: [],
              multiPolys: []
            };else {
              var t = this.prev.consumedBy || this.prev;
              this._beforeState = t.afterState();
            }
            return this._beforeState;
          }
        }, {
          key: "afterState",
          value: function e() {
            if (this._afterState !== undefined) return this._afterState;
            var t = this.beforeState();
            this._afterState = {
              rings: t.rings.slice(0),
              windings: t.windings.slice(0),
              multiPolys: []
            };
            var r = this._afterState.rings;
            var n = this._afterState.windings;
            var i = this._afterState.multiPolys;
            for (var o = 0, a = this.rings.length; o < a; o++) {
              var s = this.rings[o];
              var l = this.windings[o];
              var c = r.indexOf(s);
              if (c === -1) {
                r.push(s);
                n.push(l);
              } else n[c] += l;
            }
            var u = [];
            var h = [];
            for (var d = 0, p = r.length; d < p; d++) {
              if (n[d] === 0) continue;
              var f = r[d];
              var _ = f.poly;
              if (h.indexOf(_) !== -1) continue;
              if (f.isExterior) u.push(_);else {
                if (h.indexOf(_) === -1) h.push(_);
                var m = u.indexOf(f.poly);
                if (m !== -1) u.splice(m, 1);
              }
            }
            for (var g = 0, y = u.length; g < y; g++) {
              var v = u[g].multiPoly;
              if (i.indexOf(v) === -1) i.push(v);
            }
            return this._afterState;
          }
        }, {
          key: "isInResult",
          value: function e() {
            if (this.consumedBy) return false;
            if (this._isInResult !== undefined) return this._isInResult;
            var t = this.beforeState().multiPolys;
            var r = this.afterState().multiPolys;
            switch (U.type) {
              case "union":
                {
                  var n = t.length === 0;
                  var i = r.length === 0;
                  this._isInResult = n !== i;
                  break;
                }
              case "intersection":
                {
                  var o;
                  var a;
                  if (t.length < r.length) {
                    o = t.length;
                    a = r.length;
                  } else {
                    o = r.length;
                    a = t.length;
                  }
                  this._isInResult = a === U.numMultiPolys && o < a;
                  break;
                }
              case "xor":
                {
                  var s = Math.abs(t.length - r.length);
                  this._isInResult = s % 2 === 1;
                  break;
                }
              case "difference":
                {
                  var l = function e(t) {
                    return t.length === 1 && t[0].isSubject;
                  };
                  this._isInResult = l(t) !== l(r);
                  break;
                }
              default:
                throw new Error("Unrecognized operation type found ".concat(U.type));
            }
            return this._isInResult;
          }
        }], [{
          key: "fromRing",
          value: function e(t, r, n) {
            var i, o, a;
            var s = M.comparePoints(t, r);
            if (s < 0) {
              i = t;
              o = r;
              a = 1;
            } else if (s > 0) {
              i = r;
              o = t;
              a = -1;
            } else throw new Error("Tried to create degenerate segment at [".concat(t.x, ", ").concat(t.y, "]"));
            var l = new M(i, true);
            var c = new M(o, false);
            return new d(l, c, [n], [a]);
          }
        }]);
        return d;
      }(),
      I = function () {
        function l(e, t, r) {
          c(this, l);
          if (!Array.isArray(e) || e.length === 0) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
          this.poly = t;
          this.isExterior = r;
          this.segments = [];
          if (typeof e[0][0] !== "number" || typeof e[0][1] !== "number") throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
          var n = O.round(e[0][0], e[0][1]);
          this.bbox = {
            ll: {
              x: n.x,
              y: n.y
            },
            ur: {
              x: n.x,
              y: n.y
            }
          };
          var i = n;
          for (var o = 1, a = e.length; o < a; o++) {
            if (typeof e[o][0] !== "number" || typeof e[o][1] !== "number") throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            var s = O.round(e[o][0], e[o][1]);
            if (s.x === i.x && s.y === i.y) continue;
            this.segments.push(A.fromRing(i, s, this));
            if (s.x < this.bbox.ll.x) this.bbox.ll.x = s.x;
            if (s.y < this.bbox.ll.y) this.bbox.ll.y = s.y;
            if (s.x > this.bbox.ur.x) this.bbox.ur.x = s.x;
            if (s.y > this.bbox.ur.y) this.bbox.ur.y = s.y;
            i = s;
          }
          if (n.x !== i.x || n.y !== i.y) this.segments.push(A.fromRing(i, n, this));
        }
        a(l, [{
          key: "getSweepEvents",
          value: function e() {
            var t = [];
            for (var r = 0, n = this.segments.length; r < n; r++) {
              var i = this.segments[r];
              t.push(i.leftSE);
              t.push(i.rightSE);
            }
            return t;
          }
        }]);
        return l;
      }(),
      Y = function () {
        function o(e, t) {
          c(this, o);
          if (!Array.isArray(e)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
          this.exteriorRing = new I(e[0], this, true);
          this.bbox = {
            ll: {
              x: this.exteriorRing.bbox.ll.x,
              y: this.exteriorRing.bbox.ll.y
            },
            ur: {
              x: this.exteriorRing.bbox.ur.x,
              y: this.exteriorRing.bbox.ur.y
            }
          };
          this.interiorRings = [];
          for (var r = 1, n = e.length; r < n; r++) {
            var i = new I(e[r], this, false);
            if (i.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = i.bbox.ll.x;
            if (i.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = i.bbox.ll.y;
            if (i.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = i.bbox.ur.x;
            if (i.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = i.bbox.ur.y;
            this.interiorRings.push(i);
          }
          this.multiPoly = t;
        }
        a(o, [{
          key: "getSweepEvents",
          value: function e() {
            var t = this.exteriorRing.getSweepEvents();
            for (var r = 0, n = this.interiorRings.length; r < n; r++) {
              var i = this.interiorRings[r].getSweepEvents();
              for (var o = 0, a = i.length; o < a; o++) t.push(i[o]);
            }
            return t;
          }
        }]);
        return o;
      }(),
      k = function () {
        function o(e, t) {
          c(this, o);
          if (!Array.isArray(e)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
          try {
            if (typeof e[0][0][0] === "number") e = [e];
          } catch (e) {}
          this.polys = [];
          this.bbox = {
            ll: {
              x: Number.POSITIVE_INFINITY,
              y: Number.POSITIVE_INFINITY
            },
            ur: {
              x: Number.NEGATIVE_INFINITY,
              y: Number.NEGATIVE_INFINITY
            }
          };
          for (var r = 0, n = e.length; r < n; r++) {
            var i = new Y(e[r], this);
            if (i.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = i.bbox.ll.x;
            if (i.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = i.bbox.ll.y;
            if (i.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = i.bbox.ur.x;
            if (i.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = i.bbox.ur.y;
            this.polys.push(i);
          }
          this.isSubject = t;
        }
        a(o, [{
          key: "getSweepEvents",
          value: function e() {
            var t = [];
            for (var r = 0, n = this.polys.length; r < n; r++) {
              var i = this.polys[r].getSweepEvents();
              for (var o = 0, a = i.length; o < a; o++) t.push(i[o]);
            }
            return t;
          }
        }]);
        return o;
      }(),
      H = function () {
        a(b, null, [{
          key: "factory",
          value: function e(t) {
            var r = [];
            for (var n = 0, i = t.length; n < i; n++) {
              var o = t[n];
              if (!o.isInResult() || o.ringOut) continue;
              var a = null;
              var s = o.leftSE;
              var l = o.rightSE;
              var c = [s];
              var u = s.point;
              var h = [];
              while (true) {
                a = s;
                s = l;
                c.push(s);
                if (s.point === u) break;
                while (true) {
                  var d = s.getAvailableLinkedEvents();
                  if (d.length === 0) {
                    var p = c[0].point;
                    var f = c[c.length - 1].point;
                    throw new Error("Unable to complete output ring starting at [".concat(p.x, ",") + " ".concat(p.y, "]. Last matching segment found ends at") + " [".concat(f.x, ", ").concat(f.y, "]."));
                  }
                  if (d.length === 1) {
                    l = d[0].otherSE;
                    break;
                  }
                  var _ = null;
                  for (var m = 0, g = h.length; m < g; m++) if (h[m].point === s.point) {
                    _ = m;
                    break;
                  }
                  if (_ !== null) {
                    var y = h.splice(_)[0];
                    var v = c.splice(y.index);
                    v.unshift(v[0].otherSE);
                    r.push(new b(v.reverse()));
                    continue;
                  }
                  h.push({
                    index: c.length,
                    point: s.point
                  });
                  var E = s.getLeftmostComparator(a);
                  l = d.sort(E)[0].otherSE;
                  break;
                }
              }
              r.push(new b(c));
            }
            return r;
          }
        }]);
        function b(e) {
          c(this, b);
          this.events = e;
          for (var t = 0, r = e.length; t < r; t++) e[t].segment.ringOut = this;
          this.poly = null;
        }
        a(b, [{
          key: "getGeom",
          value: function e() {
            var t = this.events[0].point;
            var r = [t];
            for (var n = 1, i = this.events.length - 1; n < i; n++) {
              var o = this.events[n].point;
              var a = this.events[n + 1].point;
              if (T(o, t, a) === 0) continue;
              r.push(o);
              t = o;
            }
            if (r.length === 1) return null;
            var s = r[0];
            var l = r[1];
            if (T(s, t, l) === 0) r.shift();
            r.push(r[0]);
            var c = this.isExteriorRing() ? 1 : -1;
            var u = this.isExteriorRing() ? 0 : r.length - 1;
            var h = this.isExteriorRing() ? r.length : -1;
            var d = [];
            for (var p = u; p != h; p += c) d.push([r[p].x, r[p].y]);
            return d;
          }
        }, {
          key: "isExteriorRing",
          value: function e() {
            if (this._isExteriorRing === undefined) {
              var t = this.enclosingRing();
              this._isExteriorRing = t ? !t.isExteriorRing() : true;
            }
            return this._isExteriorRing;
          }
        }, {
          key: "enclosingRing",
          value: function e() {
            if (this._enclosingRing === undefined) this._enclosingRing = this._calcEnclosingRing();
            return this._enclosingRing;
          }
        }, {
          key: "_calcEnclosingRing",
          value: function e() {
            var t = this.events[0];
            for (var r = 1, n = this.events.length; r < n; r++) {
              var i = this.events[r];
              if (M.compare(t, i) > 0) t = i;
            }
            var o = t.segment.prevInResult();
            var a = o ? o.prevInResult() : null;
            while (true) {
              if (!o) return null;
              if (!a) return o.ringOut;
              if (a.ringOut !== o.ringOut) if (a.ringOut.enclosingRing() !== o.ringOut) return o.ringOut;else return o.ringOut.enclosingRing();
              o = a.prevInResult();
              a = o ? o.prevInResult() : null;
            }
          }
        }]);
        return b;
      }(),
      N = function () {
        function t(e) {
          c(this, t);
          this.exteriorRing = e;
          e.poly = this;
          this.interiorRings = [];
        }
        a(t, [{
          key: "addInterior",
          value: function e(t) {
            this.interiorRings.push(t);
            t.poly = this;
          }
        }, {
          key: "getGeom",
          value: function e() {
            var t = [this.exteriorRing.getGeom()];
            if (t[0] === null) return null;
            for (var r = 0, n = this.interiorRings.length; r < n; r++) {
              var i = this.interiorRings[r].getGeom();
              if (i === null) continue;
              t.push(i);
            }
            return t;
          }
        }]);
        return t;
      }(),
      j = function () {
        function t(e) {
          c(this, t);
          this.rings = e;
          this.polys = this._composePolys(e);
        }
        a(t, [{
          key: "getGeom",
          value: function e() {
            var t = [];
            for (var r = 0, n = this.polys.length; r < n; r++) {
              var i = this.polys[r].getGeom();
              if (i === null) continue;
              t.push(i);
            }
            return t;
          }
        }, {
          key: "_composePolys",
          value: function e(t) {
            var r = [];
            for (var n = 0, i = t.length; n < i; n++) {
              var o = t[n];
              if (o.poly) continue;
              if (o.isExteriorRing()) r.push(new N(o));else {
                var a = o.enclosingRing();
                if (!a.poly) r.push(new N(a));
                a.poly.addInterior(o);
              }
            }
            return r;
          }
        }]);
        return t;
      }(),
      G = function () {
        function r(e) {
          var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : A.compare;
          c(this, r);
          this.queue = e;
          this.tree = new D(t);
          this.segments = [];
        }
        a(r, [{
          key: "process",
          value: function e(t) {
            var r = t.segment;
            var n = [];
            if (t.consumedBy) {
              if (t.isLeft) this.queue.remove(t.otherSE);else this.tree.remove(r);
              return n;
            }
            var i = t.isLeft ? this.tree.insert(r) : this.tree.find(r);
            if (!i) throw new Error("Unable to find segment #".concat(r.id, " ") + "[".concat(r.leftSE.point.x, ", ").concat(r.leftSE.point.y, "] -> ") + "[".concat(r.rightSE.point.x, ", ").concat(r.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report.");
            var o = i;
            var a = i;
            var s = undefined;
            var l = undefined;
            while (s === undefined) {
              o = this.tree.prev(o);
              if (o === null) s = null;else if (o.key.consumedBy === undefined) s = o.key;
            }
            while (l === undefined) {
              a = this.tree.next(a);
              if (a === null) l = null;else if (a.key.consumedBy === undefined) l = a.key;
            }
            if (t.isLeft) {
              var c = null;
              if (s) {
                var u = s.getIntersection(r);
                if (u !== null) {
                  if (!r.isAnEndpoint(u)) c = u;
                  if (!s.isAnEndpoint(u)) {
                    var h = this._splitSafely(s, u);
                    for (var d = 0, p = h.length; d < p; d++) n.push(h[d]);
                  }
                }
              }
              var f = null;
              if (l) {
                var _ = l.getIntersection(r);
                if (_ !== null) {
                  if (!r.isAnEndpoint(_)) f = _;
                  if (!l.isAnEndpoint(_)) {
                    var m = this._splitSafely(l, _);
                    for (var g = 0, y = m.length; g < y; g++) n.push(m[g]);
                  }
                }
              }
              if (c !== null || f !== null) {
                var v = null;
                if (c === null) v = f;else if (f === null) v = c;else {
                  var E = M.comparePoints(c, f);
                  v = E <= 0 ? c : f;
                }
                this.queue.remove(r.rightSE);
                n.push(r.rightSE);
                var b = r.split(v);
                for (var w = 0, T = b.length; w < T; w++) n.push(b[w]);
              }
              if (n.length > 0) {
                this.tree.remove(r);
                n.push(t);
              } else {
                this.segments.push(r);
                r.prev = s;
              }
            } else {
              if (s && l) {
                var S = s.getIntersection(l);
                if (S !== null) {
                  if (!s.isAnEndpoint(S)) {
                    var x = this._splitSafely(s, S);
                    for (var C = 0, A = x.length; C < A; C++) n.push(x[C]);
                  }
                  if (!l.isAnEndpoint(S)) {
                    var I = this._splitSafely(l, S);
                    for (var N = 0, P = I.length; N < P; N++) n.push(I[N]);
                  }
                }
              }
              this.tree.remove(r);
            }
            return n;
          }
        }, {
          key: "_splitSafely",
          value: function e(t, r) {
            this.tree.remove(t);
            var n = t.rightSE;
            this.queue.remove(n);
            var i = t.split(r);
            i.push(n);
            if (t.consumedBy === undefined) this.tree.insert(t);
            return i;
          }
        }]);
        return r;
      }(),
      L = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6,
      q = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6,
      U = new (function () {
        function e() {
          c(this, e);
        }
        a(e, [{
          key: "run",
          value: function e(t, r, n) {
            U.type = t;
            O.reset();
            var i = [new k(r, true)];
            for (var o = 0, a = n.length; o < a; o++) i.push(new k(n[o], false));
            U.numMultiPolys = i.length;
            if (U.type === "difference") {
              var s = i[0];
              var l = 1;
              while (l < i.length) if (R(i[l].bbox, s.bbox) !== null) l++;else i.splice(l, 1);
            }
            if (U.type === "intersection") for (var c = 0, u = i.length; c < u; c++) {
              var h = i[c];
              for (var d = c + 1, p = i.length; d < p; d++) if (R(h.bbox, i[d].bbox) === null) return [];
            }
            var f = new D(M.compare);
            for (var _ = 0, m = i.length; _ < m; _++) {
              var g = i[_].getSweepEvents();
              for (var y = 0, v = g.length; y < v; y++) {
                f.insert(g[y]);
                if (f.size > L) throw new Error("Infinite loop when putting segment endpoints in a priority queue " + "(queue size too big). Please file a bug report.");
              }
            }
            var E = new G(f);
            var b = f.size;
            var w = f.pop();
            while (w) {
              var T = w.key;
              if (f.size === b) {
                var S = T.segment;
                throw new Error("Unable to pop() ".concat(T.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(T.point.x, ", ").concat(T.point.y, "] from segment #").concat(S.id, " ") + "[".concat(S.leftSE.point.x, ", ").concat(S.leftSE.point.y, "] -> ") + "[".concat(S.rightSE.point.x, ", ").concat(S.rightSE.point.y, "] from queue. ") + "Please file a bug report.");
              }
              if (f.size > L) throw new Error("Infinite loop when passing sweep line over endpoints " + "(queue size too big). Please file a bug report.");
              if (E.segments.length > q) throw new Error("Infinite loop when passing sweep line over endpoints " + "(too many sweep line segments). Please file a bug report.");
              var x = E.process(T);
              for (var C = 0, A = x.length; C < A; C++) {
                var I = x[C];
                if (I.consumedBy === undefined) f.insert(I);
              }
              b = f.size;
              w = f.pop();
            }
            O.reset();
            var N = H.factory(E.segments);
            var P = new j(N);
            return P.getGeom();
          }
        }]);
        return e;
      }())();
    return {
      union: function e(t) {
        for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) n[i - 1] = arguments[i];
        return U.run("union", t, n);
      },
      intersection: function e(t) {
        for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) n[i - 1] = arguments[i];
        return U.run("intersection", t, n);
      },
      xor: function e(t) {
        for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) n[i - 1] = arguments[i];
        return U.run("xor", t, n);
      },
      difference: function e(t) {
        for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) n[i - 1] = arguments[i];
        return U.run("difference", t, n);
      }
    };
  }(), polygonClipping_umd.exports),
  polygonClipping = getDefaultExportFromCjs(polygonClipping_umdExports);
function intersect(e, t, r) {
  void 0 === r && (r = {});
  e = getGeom(e), t = getGeom(t), e = polygonClipping.intersection(e.coordinates, t.coordinates);
  return 0 === e.length ? null : 1 === e.length ? polygon(e[0], r.properties) : multiPolygon(e, r.properties);
}
var throttleTime = function (o) {
    return function (e, t, r) {
      var n = r.value,
        i = new Map();
      return r.value = function () {
        var e = this,
          t = arguments;
        !i.get(e) && 1 && (n.apply(e, t), i.set(e, !0), setTimeout(function () {
          return i.delete(e);
        }, o));
      }, r;
    };
  },
  __decorate = window && window.__decorate || function (e, t, r, n) {
    var i,
      o = arguments.length,
      a = o < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, n);else for (var s = e.length - 1; 0 <= s; s--) (i = e[s]) && (a = (o < 3 ? i(a) : 3 < o ? i(t, r, a) : i(t, r)) || a);
    return 3 < o && a && Object.defineProperty(t, r, a), a;
  },
  __read$a = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  __spreadArray$8 = window && window.__spreadArray || function (e, t, r) {
    if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++) !n && i in t || ((n = n || Array.prototype.slice.call(t, 0, i))[i] = t[i]);
    return e.concat(n || Array.prototype.slice.call(t));
  },
  allowedAttributionTags = ["DIV", "SPAN", "A"],
  attributionRuleAttributes = ["data-azure-maps-attribution-minzoom", "data-azure-maps-attribution-maxzoom", "data-azure-maps-attribution-geometry", "data-azure-maps-attribution-tileset", "data-azure-maps-attribution-order", "data-azure-maps-attribution-dynamic"],
  allowedAttributionAttributes = __spreadArray$8(["href"], __read$a(attributionRuleAttributes), !1),
  AttributionRuleProxy = function () {
    function a(e, t) {
      var r = this;
      this.lastFetchState = {
        bounds: null,
        zoom: null
      }, this.getElement = function () {
        return r.element;
      }, this.element = e, this.attributionChangeCallback = t;
    }
    return a.prototype.equals = function (e) {
      return this.stringRepresentation === e.stringRepresentation;
    }, Object.defineProperty(a.prototype, "stringRepresentation", {
      get: function () {
        return [void 0 !== this.minZoom ? "minzoom=".concat(this.minZoom) : "", void 0 !== this.maxZoom ? "maxzoom=".concat(this.maxZoom) : "", void 0 !== this.geometry ? this.element.attributes.getNamedItem("data-azure-maps-attribution-geometry").value : "", void 0 !== this.tilesetId ? "tilesetId=".concat(this.tilesetId) : "", this.dynamic ? "dynamic" : ""].filter(function (e) {
          return 0 < e.length;
        }).join(";");
      },
      enumerable: !1,
      configurable: !0
    }), a.applicable = function (e) {
      return Array.from(e.attributes).map(function (e) {
        return attributionRuleAttributes.includes(e.name);
      }).reduce(function (e, t) {
        return e || t;
      }, !1);
    }, Object.defineProperty(a.prototype, "minZoom", {
      get: function () {
        var e = this.element.attributes.getNamedItem("data-azure-maps-attribution-minzoom");
        return e && !isNaN(e.value) ? parseInt(e.value) : void 0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(a.prototype, "maxZoom", {
      get: function () {
        var e = this.element.attributes.getNamedItem("data-azure-maps-attribution-maxzoom");
        return e && !isNaN(e.value) ? parseInt(e.value) : void 0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(a.prototype, "geometry", {
      get: function () {
        var e = this.element.attributes.getNamedItem("data-azure-maps-attribution-geometry");
        if (e && e.value) try {
          return JSON.parse(e.value);
        } catch (e) {}
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(a.prototype, "tilesetId", {
      get: function () {
        var e = this.element.attributes.getNamedItem("data-azure-maps-attribution-tileset");
        return e && e.value ? e.value : void 0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(a.prototype, "order", {
      get: function () {
        var e = this.element.attributes.getNamedItem("data-azure-maps-attribution-order");
        return e && !isNaN(e.value) ? parseInt(e.value) : void 0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(a.prototype, "dynamic", {
      get: function () {
        return null !== this.element.attributes.getNamedItem("data-azure-maps-attribution-dynamic");
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(a.prototype, "hidesElement", {
      get: function () {
        return "none" == this.element.style.display;
      },
      enumerable: !1,
      configurable: !0
    }), a.prototype.forceHide = function () {
      this.element.style.display = "none";
    }, a.prototype.satisfied = function (e) {
      var t = !this.minZoom || !e.zoom || e.zoom >= this.minZoom,
        r = !this.maxZoom || !e.zoom || e.zoom <= this.maxZoom,
        n = !0;
      return this.geometry && e.bounds && (n = null !== intersect({
        type: "Feature",
        geometry: this.geometry,
        properties: {}
      }, {
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: [[BoundingBox.getNorthWest(e.bounds), BoundingBox.getNorthEast(e.bounds), BoundingBox.getSouthEast(e.bounds), BoundingBox.getSouthWest(e.bounds), BoundingBox.getNorthWest(e.bounds)]]
        },
        properties: {}
      })), t && r && n;
    }, a.prototype.apply = function (t, e) {
      var r = this,
        n = (void 0 === e && (e = null), this.satisfied(t.getCamera())),
        i = this.dynamic && this.tilesetId,
        o = this.hidesElement,
        e = e && ["dragend", "zoomend", "pitchend"].includes(e.type);
      return n || o ? n && (o || i) && (n && o && this.element.style.removeProperty("display"), i) && (e ? t.events.addOnce("idle", function (e) {
        return r.fetchAndApplyDynamicAttribution(t);
      }) : this.fetchAndApplyDynamicAttribution(t)) : this.element.style.display = "none", n === o;
    }, a.prototype.fetchAndApplyDynamicAttribution = function (n) {
      var t,
        r,
        e,
        i = this,
        o = n.getCamera();
      this.lastFetchState && BoundingBox.containsBoundingBox(this.lastFetchState.bounds, o.bounds) && Math.floor(this.lastFetchState.zoom) == Math.floor(o.zoom) || (t = interpolate(o.center, BoundingBox.getSouthWest(o.bounds), a.viewportBufferExpansionRatio), e = ((r = interpolate(o.center, BoundingBox.getNorthEast(o.bounds), a.viewportBufferExpansionRatio))[0] < t[0] ? [[t[0], t[1], 180, r[1]], [-180, t[1], r[0], r[1]]] : [[t[0], t[1], r[0], r[1]]]).map(function (e) {
        var e = new URLSearchParams({
            "api-version": "2.1",
            tilesetId: i.tilesetId,
            zoom: void 0 !== o.zoom ? "".concat(Math.floor(o.zoom)) : void 0,
            bounds: e.join(",")
          }),
          t = "".concat("https://{{azMapsDomain}}", "/map/attribution"),
          r = {
            url: t,
            headers: {}
          },
          t = (n._substituteDomainLanguageViewAndSignInRequest(t, r), "".concat(r.url).concat(r.url.includes("?") ? "&" : "?").concat(e.toString()));
        return n._sendRequest(t, "Attribution", r.headers).then(function (e) {
          return e.json();
        });
      }), Promise.all(e).then(function (e) {
        i.applyAttributionResponse(e), i.lastFetchState = {
          bounds: new BoundingBox([t[0], t[1], r[0], r[1]]),
          zoom: o.zoom
        };
      }).catch(function (e) {
        return console.error(e);
      }));
    }, a.prototype.applyAttributionResponse = function (e) {
      var t,
        r,
        n,
        i = this,
        e = e.map(function (e) {
          return e.copyrights || [];
        }).reduce(function (e, t) {
          return __spreadArray$8(__spreadArray$8([], __read$a(e), !1), __read$a(t), !1);
        }, []);
      0 != e.length && (null === (e = Html.parseWithFilter(e.join(""), function (e) {
        return !0;
      }, function (e) {
        return e;
      }, function () {
        return i.element.innerHTML = "", i.element;
      })) ? console.warn("Dynamic attribution is empty after filtering") : (t = "string" == typeof e ? ((t = document.createElement("span")).innerHTML = e, t) : e, n = t === this.element ? (r = document.createElement("span"), Array.from(this.element.childNodes).forEach(function (e) {
        return r.appendChild(e);
      }), r) : t, Array.from(this.element.attributes).filter(function (e) {
        return attributionRuleAttributes.includes(e.name);
      }).forEach(function (e) {
        return n.attributes.setNamedItem(e.cloneNode());
      }), n.style.display = this.element.style.display, e = this.element.parentElement, this.element.remove(), e.append(n), this.element = n, this.attributionChangeCallback(this)));
    }, a.viewportBufferExpansionRatio = 2, __decorate([throttleTime(1e3)], a.prototype, "fetchAndApplyDynamicAttribution", null), a;
  }(),
  __read$9 = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  __spreadArray$7 = window && window.__spreadArray || function (e, t, r) {
    if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++) !n && i in t || ((n = n || Array.prototype.slice.call(t, 0, i))[i] = t[i]);
    return e.concat(n || Array.prototype.slice.call(t));
  },
  attributionFilters = [/all rights reserved/gi],
  CopyrightDelegate = function () {
    function e(e, t, r) {
      var n,
        s = this;
      this.rules = [], this.virtualContext = ((n = document.createElement("span")).className = "azure-map-copyright-context", n), this.renderContext = this.virtualContext.cloneNode(!1), this.addAttributionFromSource = function (e) {}, this.removeAttributionFromSource = function (e) {}, this.getMapStyleVisibleSources = function () {
        var t = s.map._getMap(),
          r = t.getStyle();
        return Object.entries(r.sources).filter(function (e) {
          var t = __read$9(e, 1)[0];
          return r.layers.filter(function (e) {
            return e && e.source == t;
          }).reduce(function (e, t) {
            return !(t.layout && "none" === t.layout.visibility || t.paint && 0 === t.paint["icon-opacity"] && 0 === t.paint["text-opacity"]) || e;
          }, !1);
        }).map(function (e) {
          e = __read$9(e, 1)[0];
          return t.getSource(e);
        });
      }, this.loadAttributionOnceSourcesLoaded = function () {
        var e = s.getMapStyleVisibleSources();
        Promise.all(e.map(function (o) {
          return new Promise(function (r, n) {
            var i;
            "tiles" in o ? r(o) : ((i = o).on("data", function e(t) {
              "metadata" == t.sourceDataType && (i.off("data", e), r(o));
            }), i.on("error", function e(t) {
              i.off("error", e), n(t);
            }));
          }).then(function (e) {
            return {
              status: "fulfilled",
              value: e
            };
          }).catch(function (e) {
            return {
              status: "rejected",
              reason: e
            };
          });
        })).then(function (e) {
          s.reloadAttribution();
        });
      }, this.reloadAttribution = function () {
        var e = s.getMapStyleVisibleSources(),
          n = new Set(),
          i = {},
          e = e.filter(function (e) {
            return "attribution" in e && e.attribution && "tiles" in e && e.tiles instanceof Array && 0 < e.tiles.length;
          }).map(function (e) {
            return Html.parseWithFilter(null != (e = e.attribution) ? e : "", function (e) {
              return allowedAttributionTags.includes(e.tagName) && Array.from(e.attributes).map(function (e) {
                return allowedAttributionAttributes.includes(e.name);
              }).reduce(function (e, t) {
                return e && t;
              }, !0);
            }, function (e) {
              var t,
                r = null;
              return e instanceof HTMLElement && AttributionRuleProxy.applicable(e) && (r = new AttributionRuleProxy(e, function () {
                return s.renderAttribution();
              }), n.add(r), void 0 !== r.order) && (e.style.order = "".concat(r.order)), r && e instanceof HTMLElement && (!((t = r.stringRepresentation) in i) || void 0 !== r.order && void 0 !== i[t].order && r.order < i[t].order || void 0 !== r.order && void 0 === i[t].order) && (i[t] = r), e;
            }, function () {
              return document.createElement("span");
            });
          }),
          t = new Set(Object.values(i)),
          r = new Set(__spreadArray$7([], __read$9(n), !1).filter(function (e) {
            return !t.has(e);
          })),
          o = new Set(__spreadArray$7([], __read$9(r), !1).map(function (e) {
            return e.getElement();
          })),
          r = (__spreadArray$7([], __read$9(o), !1).filter(function (e) {
            return null !== e.parentElement;
          }).forEach(function (e) {
            return e.parentElement.removeChild(e);
          }), s.rules = Object.values(i), e.filter(function (e) {
            return "string" == typeof e || !o.has(e);
          }).map(function (e) {
            return "string" == typeof e ? new Text(e) : e;
          })),
          a = document.createElement("span");
        0 < r.length ? r.forEach(function (e) {
          return a.appendChild(e);
        }) : s.getDefaultAttribution().forEach(function (e) {
          return a.appendChild(e);
        }), s.virtualContext = a, s.copyrightControl.setOptions({
          copyrightContent: s.renderContext
        }), s.applyRules(), s.renderAttribution();
      }, this.applyRules = function (r) {
        void 0 === r && (r = null), s.rules.reduce(function (e, t) {
          t = t.apply(s.map, r);
          return e || t;
        }, !1) && s.renderAttribution();
      }, this.renderAttribution = function () {
        var t = function (e) {
            return Array.from("none" != e.style.display ? e.children : []).map(function (e) {
              return t(e);
            }).reduce(function (e, t) {
              return __spreadArray$7(__spreadArray$7([], __read$9(e), !1), __read$9(t), !1);
            }, Array.from("none" != e.style.display ? e.childNodes : []).filter(function (e) {
              return e.nodeType == e.TEXT_NODE;
            }));
          },
          e = s.virtualContext.cloneNode(!0),
          r = t(e);
        r.forEach(function (e) {
          return e.textContent = __spreadArray$7([], __read$9(attributionFilters), !1).reduce(function (e, t) {
            return e.replace(t, "").trim();
          }, e.textContent);
        }), r.reduce(function (e, t) {
          return e.has(t.textContent) ? (t.textContent = "", t.parentElement && t.parentElement.removeChild(t)) : e.add(t.textContent), e;
        }, new Set()), s.renderContext.innerHTML = "", Array.from(e.childNodes).forEach(function (e) {
          return s.renderContext.appendChild(e);
        });
      }, this.map = e, this.copyrightControl = t, this.options = r;
    }
    return e.prototype.addToMap = function () {
      this.map.events.add("stylechanged", this.loadAttributionOnceSourcesLoaded), this.map.events.add("dragend", this.applyRules), this.map.events.add("zoomend", this.applyRules), this.map.events.add("pitchend", this.applyRules);
    }, e.prototype.removeFromMap = function () {
      this.map.events.remove("stylechanged", this.loadAttributionOnceSourcesLoaded), this.map.events.remove("dragend", this.applyRules), this.map.events.remove("zoomend", this.applyRules), this.map.events.remove("pitchend", this.applyRules);
    }, e.prototype.getDefaultAttribution = function () {
      return this.copyrightControl.getDefaultAttributions().map(function (e) {
        return e = e, (t = document.createElement("a")).textContent = e, t;
        var t;
      });
    }, e;
  }(),
  extendStatics$1 = function (e, t) {
    return (extendStatics$1 = Object.setPrototypeOf || ({
      __proto__: []
    } instanceof Array ? function (e, t) {
      e.__proto__ = t;
    } : function (e, t) {
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
    }))(e, t);
  };
function __extends$g(e, t) {
  function r() {
    this.constructor = e;
  }
  extendStatics$1(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var __assign$5 = function () {
  return (__assign$5 = Object.assign || function (e) {
    for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    return e;
  }).apply(this, arguments);
};
function __rest(e, t) {
  var r = {};
  for (i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (r[i] = e[i]);
  if (null != e && "function" == typeof Object.getOwnPropertySymbols) for (var n = 0, i = Object.getOwnPropertySymbols(e); n < i.length; n++) t.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[n]) && (r[i[n]] = e[i[n]]);
  return r;
}
function __awaiter$3(e, a, s, l) {
  return new (s = s || Promise)(function (r, t) {
    function n(e) {
      try {
        o(l.next(e));
      } catch (e) {
        t(e);
      }
    }
    function i(e) {
      try {
        o(l.throw(e));
      } catch (e) {
        t(e);
      }
    }
    function o(e) {
      var t;
      e.done ? r(e.value) : ((t = e.value) instanceof s ? t : new s(function (e) {
        e(t);
      })).then(n, i);
    }
    o((l = l.apply(e, [])).next());
  });
}
function __generator$3(n, i) {
  var o,
    a,
    s,
    l = {
      label: 0,
      sent: function () {
        if (1 & s[0]) throw s[1];
        return s[1];
      },
      trys: [],
      ops: []
    },
    e = {
      next: t(0),
      throw: t(1),
      return: t(2)
    };
  return "function" == typeof Symbol && (e[Symbol.iterator] = function () {
    return this;
  }), e;
  function t(r) {
    return function (e) {
      var t = [r, e];
      if (o) throw new TypeError("Generator is already executing.");
      for (; l;) try {
        if (o = 1, a && (s = 2 & t[0] ? a.return : t[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, t[1])).done) return s;
        switch (a = 0, (t = s ? [2 & t[0], s.value] : t)[0]) {
          case 0:
          case 1:
            s = t;
            break;
          case 4:
            return l.label++, {
              value: t[1],
              done: !1
            };
          case 5:
            l.label++, a = t[1], t = [0];
            continue;
          case 7:
            t = l.ops.pop(), l.trys.pop();
            continue;
          default:
            if (!(s = 0 < (s = l.trys).length && s[s.length - 1]) && (6 === t[0] || 2 === t[0])) {
              l = 0;
              continue;
            }
            if (3 === t[0] && (!s || t[1] > s[0] && t[1] < s[3])) l.label = t[1];else if (6 === t[0] && l.label < s[1]) l.label = s[1], s = t;else {
              if (!(s && l.label < s[2])) {
                s[2] && l.ops.pop(), l.trys.pop();
                continue;
              }
              l.label = s[2], l.ops.push(t);
            }
        }
        t = i.call(n, l);
      } catch (e) {
        t = [6, e], a = 0;
      } finally {
        o = s = 0;
      }
      if (5 & t[0]) throw t[1];
      return {
        value: t[0] ? t[1] : void 0,
        done: !0
      };
    };
  }
}
function __read$8(e, t) {
  var r = "function" == typeof Symbol && e[Symbol.iterator];
  if (!r) return e;
  var n,
    i,
    o = r.call(e),
    a = [];
  try {
    for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
  } catch (e) {
    i = {
      error: e
    };
  } finally {
    try {
      n && !n.done && (r = o.return) && r.call(o);
    } finally {
      if (i) throw i.error;
    }
  }
  return a;
}
function __spread() {
  for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(__read$8(arguments[t]));
  return e;
}
var extendStatics = function (e, t) {
  return (extendStatics = Object.setPrototypeOf || ({
    __proto__: []
  } instanceof Array ? function (e, t) {
    e.__proto__ = t;
  } : function (e, t) {
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  }))(e, t);
};
function __extends$f(e, t) {
  function r() {
    this.constructor = e;
  }
  extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var __assign$4 = function () {
  return (__assign$4 = Object.assign || function (e) {
    for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    return e;
  }).apply(this, arguments);
};
function __awaiter$2(e, a, s, l) {
  return new (s = s || Promise)(function (r, t) {
    function n(e) {
      try {
        o(l.next(e));
      } catch (e) {
        t(e);
      }
    }
    function i(e) {
      try {
        o(l.throw(e));
      } catch (e) {
        t(e);
      }
    }
    function o(e) {
      var t;
      e.done ? r(e.value) : ((t = e.value) instanceof s ? t : new s(function (e) {
        e(t);
      })).then(n, i);
    }
    o((l = l.apply(e, [])).next());
  });
}
function __generator$2(n, i) {
  var o,
    a,
    s,
    l = {
      label: 0,
      sent: function () {
        if (1 & s[0]) throw s[1];
        return s[1];
      },
      trys: [],
      ops: []
    },
    e = {
      next: t(0),
      throw: t(1),
      return: t(2)
    };
  return "function" == typeof Symbol && (e[Symbol.iterator] = function () {
    return this;
  }), e;
  function t(r) {
    return function (e) {
      var t = [r, e];
      if (o) throw new TypeError("Generator is already executing.");
      for (; l;) try {
        if (o = 1, a && (s = 2 & t[0] ? a.return : t[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, t[1])).done) return s;
        switch (a = 0, (t = s ? [2 & t[0], s.value] : t)[0]) {
          case 0:
          case 1:
            s = t;
            break;
          case 4:
            return l.label++, {
              value: t[1],
              done: !1
            };
          case 5:
            l.label++, a = t[1], t = [0];
            continue;
          case 7:
            t = l.ops.pop(), l.trys.pop();
            continue;
          default:
            if (!(s = 0 < (s = l.trys).length && s[s.length - 1]) && (6 === t[0] || 2 === t[0])) {
              l = 0;
              continue;
            }
            if (3 === t[0] && (!s || t[1] > s[0] && t[1] < s[3])) l.label = t[1];else if (6 === t[0] && l.label < s[1]) l.label = s[1], s = t;else {
              if (!(s && l.label < s[2])) {
                s[2] && l.ops.pop(), l.trys.pop();
                continue;
              }
              l.label = s[2], l.ops.push(t);
            }
        }
        t = i.call(n, l);
      } catch (e) {
        t = [6, e], a = 0;
      } finally {
        o = s = 0;
      }
      if (5 & t[0]) throw t[1];
      return {
        value: t[0] ? t[1] : void 0,
        done: !0
      };
    };
  }
}
function __spreadArrays() {
  for (var e = 0, t = 0, r = arguments.length; t < r; t++) e += arguments[t].length;
  for (var n = Array(e), i = 0, t = 0; t < r; t++) for (var o = arguments[t], a = 0, s = o.length; a < s; a++, i++) n[i] = o[a];
  return n;
}
var HeaderNames,
  PersistentCacheKeys,
  AADAuthorityConstants,
  AADServerParamKeys,
  ClaimsRequestKeys,
  SSOTypes,
  ResponseMode,
  GrantType,
  CacheAccountType,
  Separators,
  CredentialType,
  CacheType,
  AuthorityMetadataSource,
  AuthenticationScheme,
  PasswordGrantConstants,
  ResponseCodes,
  RegionDiscoverySources,
  RegionDiscoveryOutcomes,
  CacheOutcome,
  JsonTypes,
  LogLevel,
  AzureCloudInstance,
  AuthorityType,
  Constants = {
    LIBRARY_NAME: "MSAL.JS",
    SKU: "msal.js.common",
    CACHE_PREFIX: "msal",
    DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
    DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
    DEFAULT_COMMON_TENANT: "common",
    ADFS: "adfs",
    DSTS: "dstsv2",
    AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
    CIAM_AUTH_URL: ".ciamlogin.com",
    AAD_TENANT_DOMAIN_SUFFIX: ".onmicrosoft.com",
    RESOURCE_DELIM: "|",
    NO_ACCOUNT: "NO_ACCOUNT",
    CLAIMS: "claims",
    CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
    OPENID_SCOPE: "openid",
    PROFILE_SCOPE: "profile",
    OFFLINE_ACCESS_SCOPE: "offline_access",
    EMAIL_SCOPE: "email",
    CODE_RESPONSE_TYPE: "code",
    CODE_GRANT_TYPE: "authorization_code",
    RT_GRANT_TYPE: "refresh_token",
    FRAGMENT_RESPONSE_MODE: "fragment",
    S256_CODE_CHALLENGE_METHOD: "S256",
    URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
    AUTHORIZATION_PENDING: "authorization_pending",
    NOT_DEFINED: "not_defined",
    EMPTY_STRING: "",
    NOT_APPLICABLE: "N/A",
    FORWARD_SLASH: "/",
    IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
    IMDS_VERSION: "2020-06-01",
    IMDS_TIMEOUT: 2e3,
    AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
    REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
    REGIONAL_AUTH_NON_MSI_QUERY_STRING: "allowestsrnonmsi=true",
    KNOWN_PUBLIC_CLOUDS: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"],
    TOKEN_RESPONSE_TYPE: "token",
    ID_TOKEN_RESPONSE_TYPE: "id_token",
    SHR_NONCE_VALIDITY: 240,
    INVALID_INSTANCE: "invalid_instance"
  },
  OIDC_DEFAULT_SCOPES = [Constants.OPENID_SCOPE, Constants.PROFILE_SCOPE, Constants.OFFLINE_ACCESS_SCOPE],
  OIDC_SCOPES = __spreadArrays(OIDC_DEFAULT_SCOPES, [Constants.EMAIL_SCOPE]),
  PromptValue = (!function (e) {
    e.CONTENT_TYPE = "Content-Type", e.RETRY_AFTER = "Retry-After", e.CCS_HEADER = "X-AnchorMailbox", e.WWWAuthenticate = "WWW-Authenticate", e.AuthenticationInfo = "Authentication-Info", e.X_MS_REQUEST_ID = "x-ms-request-id", e.X_MS_HTTP_VERSION = "x-ms-httpver";
  }(HeaderNames = HeaderNames || {}), !function (e) {
    e.ID_TOKEN = "idtoken", e.CLIENT_INFO = "client.info", e.ADAL_ID_TOKEN = "adal.idtoken", e.ERROR = "error", e.ERROR_DESC = "error.description", e.ACTIVE_ACCOUNT = "active-account", e.ACTIVE_ACCOUNT_FILTERS = "active-account-filters";
  }(PersistentCacheKeys = PersistentCacheKeys || {}), !function (e) {
    e.COMMON = "common", e.ORGANIZATIONS = "organizations", e.CONSUMERS = "consumers";
  }(AADAuthorityConstants = AADAuthorityConstants || {}), !function (e) {
    e.CLIENT_ID = "client_id", e.REDIRECT_URI = "redirect_uri", e.RESPONSE_TYPE = "response_type", e.RESPONSE_MODE = "response_mode", e.GRANT_TYPE = "grant_type", e.CLAIMS = "claims", e.SCOPE = "scope", e.ERROR = "error", e.ERROR_DESCRIPTION = "error_description", e.ACCESS_TOKEN = "access_token", e.ID_TOKEN = "id_token", e.REFRESH_TOKEN = "refresh_token", e.EXPIRES_IN = "expires_in", e.STATE = "state", e.NONCE = "nonce", e.PROMPT = "prompt", e.SESSION_STATE = "session_state", e.CLIENT_INFO = "client_info", e.CODE = "code", e.CODE_CHALLENGE = "code_challenge", e.CODE_CHALLENGE_METHOD = "code_challenge_method", e.CODE_VERIFIER = "code_verifier", e.CLIENT_REQUEST_ID = "client-request-id", e.X_CLIENT_SKU = "x-client-SKU", e.X_CLIENT_VER = "x-client-VER", e.X_CLIENT_OS = "x-client-OS", e.X_CLIENT_CPU = "x-client-CPU", e.X_CLIENT_CURR_TELEM = "x-client-current-telemetry", e.X_CLIENT_LAST_TELEM = "x-client-last-telemetry", e.X_MS_LIB_CAPABILITY = "x-ms-lib-capability", e.X_APP_NAME = "x-app-name", e.X_APP_VER = "x-app-ver", e.POST_LOGOUT_URI = "post_logout_redirect_uri", e.ID_TOKEN_HINT = "id_token_hint", e.DEVICE_CODE = "device_code", e.CLIENT_SECRET = "client_secret", e.CLIENT_ASSERTION = "client_assertion", e.CLIENT_ASSERTION_TYPE = "client_assertion_type", e.TOKEN_TYPE = "token_type", e.REQ_CNF = "req_cnf", e.OBO_ASSERTION = "assertion", e.REQUESTED_TOKEN_USE = "requested_token_use", e.ON_BEHALF_OF = "on_behalf_of", e.FOCI = "foci", e.CCS_HEADER = "X-AnchorMailbox", e.RETURN_SPA_CODE = "return_spa_code", e.NATIVE_BROKER = "nativebroker", e.LOGOUT_HINT = "logout_hint";
  }(AADServerParamKeys = AADServerParamKeys || {}), !function (e) {
    e.ACCESS_TOKEN = "access_token", e.XMS_CC = "xms_cc";
  }(ClaimsRequestKeys = ClaimsRequestKeys || {}), {
    LOGIN: "login",
    SELECT_ACCOUNT: "select_account",
    CONSENT: "consent",
    NONE: "none",
    CREATE: "create",
    NO_SESSION: "no_session"
  }),
  CodeChallengeMethodValues = (!function (e) {
    e.ACCOUNT = "account", e.SID = "sid", e.LOGIN_HINT = "login_hint", e.ID_TOKEN = "id_token", e.DOMAIN_HINT = "domain_hint", e.ORGANIZATIONS = "organizations", e.CONSUMERS = "consumers", e.ACCOUNT_ID = "accountIdentifier", e.HOMEACCOUNT_ID = "homeAccountIdentifier";
  }(SSOTypes = SSOTypes || {}), {
    PLAIN: "plain",
    S256: "S256"
  }),
  APP_METADATA = (!function (e) {
    e.QUERY = "query", e.FRAGMENT = "fragment", e.FORM_POST = "form_post";
  }(ResponseMode = ResponseMode || {}), !function (e) {
    e.IMPLICIT_GRANT = "implicit", e.AUTHORIZATION_CODE_GRANT = "authorization_code", e.CLIENT_CREDENTIALS_GRANT = "client_credentials", e.RESOURCE_OWNER_PASSWORD_GRANT = "password", e.REFRESH_TOKEN_GRANT = "refresh_token", e.DEVICE_CODE_GRANT = "device_code", e.JWT_BEARER = "urn:ietf:params:oauth:grant-type:jwt-bearer";
  }(GrantType = GrantType || {}), !function (e) {
    e.MSSTS_ACCOUNT_TYPE = "MSSTS", e.ADFS_ACCOUNT_TYPE = "ADFS", e.MSAV1_ACCOUNT_TYPE = "MSA", e.GENERIC_ACCOUNT_TYPE = "Generic";
  }(CacheAccountType = CacheAccountType || {}), !function (e) {
    e.CACHE_KEY_SEPARATOR = "-", e.CLIENT_INFO_SEPARATOR = ".";
  }(Separators = Separators || {}), !function (e) {
    e.ID_TOKEN = "IdToken", e.ACCESS_TOKEN = "AccessToken", e.ACCESS_TOKEN_WITH_AUTH_SCHEME = "AccessToken_With_AuthScheme", e.REFRESH_TOKEN = "RefreshToken";
  }(CredentialType = CredentialType || {}), !function (e) {
    e[e.ADFS = 1001] = "ADFS", e[e.MSA = 1002] = "MSA", e[e.MSSTS = 1003] = "MSSTS", e[e.GENERIC = 1004] = "GENERIC", e[e.ACCESS_TOKEN = 2001] = "ACCESS_TOKEN", e[e.REFRESH_TOKEN = 2002] = "REFRESH_TOKEN", e[e.ID_TOKEN = 2003] = "ID_TOKEN", e[e.APP_METADATA = 3001] = "APP_METADATA", e[e.UNDEFINED = 9999] = "UNDEFINED";
  }(CacheType = CacheType || {}), "appmetadata"),
  CLIENT_INFO = "client_info",
  THE_FAMILY_ID = "1",
  AUTHORITY_METADATA_CONSTANTS = {
    CACHE_KEY: "authority-metadata",
    REFRESH_TIME_SECONDS: 86400
  },
  SERVER_TELEM_CONSTANTS = (!function (e) {
    e.CONFIG = "config", e.CACHE = "cache", e.NETWORK = "network", e.HARDCODED_VALUES = "hardcoded_values";
  }(AuthorityMetadataSource = AuthorityMetadataSource || {}), {
    SCHEMA_VERSION: 5,
    MAX_CUR_HEADER_BYTES: 80,
    MAX_LAST_HEADER_BYTES: 330,
    MAX_CACHED_ERRORS: 50,
    CACHE_KEY: "server-telemetry",
    CATEGORY_SEPARATOR: "|",
    VALUE_SEPARATOR: ",",
    OVERFLOW_TRUE: "1",
    OVERFLOW_FALSE: "0",
    UNKNOWN_ERROR: "unknown_error"
  }),
  ThrottlingConstants = (!function (e) {
    e.BEARER = "Bearer", e.POP = "pop", e.SSH = "ssh-cert";
  }(AuthenticationScheme = AuthenticationScheme || {}), {
    DEFAULT_THROTTLE_TIME_SECONDS: 60,
    DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
    THROTTLING_PREFIX: "throttling",
    X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
  }),
  Errors = {
    INVALID_GRANT_ERROR: "invalid_grant",
    CLIENT_MISMATCH_ERROR: "client_mismatch"
  },
  AuthErrorMessage = (!function (e) {
    e.username = "username", e.password = "password";
  }(PasswordGrantConstants = PasswordGrantConstants || {}), !function (e) {
    e[e.httpSuccess = 200] = "httpSuccess", e[e.httpBadRequest = 400] = "httpBadRequest";
  }(ResponseCodes = ResponseCodes || {}), !function (e) {
    e.FAILED_AUTO_DETECTION = "1", e.INTERNAL_CACHE = "2", e.ENVIRONMENT_VARIABLE = "3", e.IMDS = "4";
  }(RegionDiscoverySources = RegionDiscoverySources || {}), !function (e) {
    e.CONFIGURED_MATCHES_DETECTED = "1", e.CONFIGURED_NO_AUTO_DETECTION = "2", e.CONFIGURED_NOT_DETECTED = "3", e.AUTO_DETECTION_REQUESTED_SUCCESSFUL = "4", e.AUTO_DETECTION_REQUESTED_FAILED = "5";
  }(RegionDiscoveryOutcomes = RegionDiscoveryOutcomes || {}), !function (e) {
    e.NO_CACHE_HIT = "0", e.FORCE_REFRESH = "1", e.NO_CACHED_ACCESS_TOKEN = "2", e.CACHED_ACCESS_TOKEN_EXPIRED = "3", e.REFRESH_CACHED_ACCESS_TOKEN = "4", e.CLAIMS_REQUESTED_CACHE_SKIPPED = "5";
  }(CacheOutcome = CacheOutcome || {}), !function (e) {
    e.Jwt = "JWT", e.Jwk = "JWK", e.Pop = "pop";
  }(JsonTypes = JsonTypes || {}), {
    unexpectedError: {
      code: "unexpected_error",
      desc: "Unexpected error in authentication."
    },
    postRequestFailed: {
      code: "post_request_failed",
      desc: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
    }
  }),
  AuthError = function (i) {
    function o(e, t, r) {
      var n = this,
        n = i.call(this, t ? e + ": " + t : e) || this;
      return Object.setPrototypeOf(n, o.prototype), n.errorCode = e || Constants.EMPTY_STRING, n.errorMessage = t || Constants.EMPTY_STRING, n.subError = r || Constants.EMPTY_STRING, n.name = "AuthError", n;
    }
    return __extends$f(o, i), o.prototype.setCorrelationId = function (e) {
      this.correlationId = e;
    }, o.createUnexpectedError = function (e) {
      return new o(AuthErrorMessage.unexpectedError.code, AuthErrorMessage.unexpectedError.desc + ": " + e);
    }, o.createPostRequestFailed = function (e) {
      return new o(AuthErrorMessage.postRequestFailed.code, AuthErrorMessage.postRequestFailed.desc + ": " + e);
    }, o;
  }(Error),
  DEFAULT_CRYPTO_IMPLEMENTATION = {
    createNewGuid: function () {
      throw AuthError.createUnexpectedError("Crypto interface - createNewGuid() has not been implemented");
    },
    base64Decode: function () {
      throw AuthError.createUnexpectedError("Crypto interface - base64Decode() has not been implemented");
    },
    base64Encode: function () {
      throw AuthError.createUnexpectedError("Crypto interface - base64Encode() has not been implemented");
    },
    generatePkceCodes: function () {
      return __awaiter$2(this, void 0, void 0, function () {
        return __generator$2(this, function (e) {
          throw AuthError.createUnexpectedError("Crypto interface - generatePkceCodes() has not been implemented");
        });
      });
    },
    getPublicKeyThumbprint: function () {
      return __awaiter$2(this, void 0, void 0, function () {
        return __generator$2(this, function (e) {
          throw AuthError.createUnexpectedError("Crypto interface - getPublicKeyThumbprint() has not been implemented");
        });
      });
    },
    removeTokenBindingKey: function () {
      return __awaiter$2(this, void 0, void 0, function () {
        return __generator$2(this, function (e) {
          throw AuthError.createUnexpectedError("Crypto interface - removeTokenBindingKey() has not been implemented");
        });
      });
    },
    clearKeystore: function () {
      return __awaiter$2(this, void 0, void 0, function () {
        return __generator$2(this, function (e) {
          throw AuthError.createUnexpectedError("Crypto interface - clearKeystore() has not been implemented");
        });
      });
    },
    signJwt: function () {
      return __awaiter$2(this, void 0, void 0, function () {
        return __generator$2(this, function (e) {
          throw AuthError.createUnexpectedError("Crypto interface - signJwt() has not been implemented");
        });
      });
    },
    hashString: function () {
      return __awaiter$2(this, void 0, void 0, function () {
        return __generator$2(this, function (e) {
          throw AuthError.createUnexpectedError("Crypto interface - hashString() has not been implemented");
        });
      });
    }
  },
  ClientAuthErrorMessage = {
    clientInfoDecodingError: {
      code: "client_info_decoding_error",
      desc: "The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause."
    },
    clientInfoEmptyError: {
      code: "client_info_empty_error",
      desc: "The client info was empty. Please review the trace to determine the root cause."
    },
    tokenParsingError: {
      code: "token_parsing_error",
      desc: "Token cannot be parsed. Please review stack trace to determine root cause."
    },
    nullOrEmptyToken: {
      code: "null_or_empty_token",
      desc: "The token is null or empty. Please review the trace to determine the root cause."
    },
    endpointResolutionError: {
      code: "endpoints_resolution_error",
      desc: "Error: could not resolve endpoints. Please check network and try again."
    },
    networkError: {
      code: "network_error",
      desc: "Network request failed. Please check network trace to determine root cause."
    },
    unableToGetOpenidConfigError: {
      code: "openid_config_error",
      desc: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints."
    },
    hashNotDeserialized: {
      code: "hash_not_deserialized",
      desc: "The hash parameters could not be deserialized. Please review the trace to determine the root cause."
    },
    blankGuidGenerated: {
      code: "blank_guid_generated",
      desc: "The guid generated was blank. Please review the trace to determine the root cause."
    },
    invalidStateError: {
      code: "invalid_state",
      desc: "State was not the expected format. Please check the logs to determine whether the request was sent using ProtocolUtils.setRequestState()."
    },
    stateMismatchError: {
      code: "state_mismatch",
      desc: "State mismatch error. Please check your network. Continued requests may cause cache overflow."
    },
    stateNotFoundError: {
      code: "state_not_found",
      desc: "State not found"
    },
    nonceMismatchError: {
      code: "nonce_mismatch",
      desc: "Nonce mismatch error. This may be caused by a race condition in concurrent requests."
    },
    nonceNotFoundError: {
      code: "nonce_not_found",
      desc: "nonce not found"
    },
    authTimeNotFoundError: {
      code: "auth_time_not_found",
      desc: "Max Age was requested and the ID token is missing the auth_time variable. auth_time is an optional claim and is not enabled by default - it must be enabled. See https://aka.ms/msaljs/optional-claims for more information."
    },
    maxAgeTranspiredError: {
      code: "max_age_transpired",
      desc: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication."
    },
    noTokensFoundError: {
      code: "no_tokens_found",
      desc: "No tokens were found for the given scopes, and no authorization code was passed to acquireToken. You must retrieve an authorization code before making a call to acquireToken()."
    },
    multipleMatchingTokens: {
      code: "multiple_matching_tokens",
      desc: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account."
    },
    multipleMatchingAccounts: {
      code: "multiple_matching_accounts",
      desc: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account"
    },
    multipleMatchingAppMetadata: {
      code: "multiple_matching_appMetadata",
      desc: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata"
    },
    tokenRequestCannotBeMade: {
      code: "request_cannot_be_made",
      desc: "Token request cannot be made without authorization code or refresh token."
    },
    appendEmptyScopeError: {
      code: "cannot_append_empty_scope",
      desc: "Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info."
    },
    removeEmptyScopeError: {
      code: "cannot_remove_empty_scope",
      desc: "Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info."
    },
    appendScopeSetError: {
      code: "cannot_append_scopeset",
      desc: "Cannot append ScopeSet due to error."
    },
    emptyInputScopeSetError: {
      code: "empty_input_scopeset",
      desc: "Empty input ScopeSet cannot be processed."
    },
    DeviceCodePollingCancelled: {
      code: "device_code_polling_cancelled",
      desc: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true."
    },
    DeviceCodeExpired: {
      code: "device_code_expired",
      desc: "Device code is expired."
    },
    DeviceCodeUnknownError: {
      code: "device_code_unknown_error",
      desc: "Device code stopped polling for unknown reasons."
    },
    NoAccountInSilentRequest: {
      code: "no_account_in_silent_request",
      desc: "Please pass an account object, silent flow is not supported without account information"
    },
    invalidCacheRecord: {
      code: "invalid_cache_record",
      desc: "Cache record object was null or undefined."
    },
    invalidCacheEnvironment: {
      code: "invalid_cache_environment",
      desc: "Invalid environment when attempting to create cache entry"
    },
    noAccountFound: {
      code: "no_account_found",
      desc: "No account found in cache for given key."
    },
    CachePluginError: {
      code: "no cache plugin set on CacheManager",
      desc: "ICachePlugin needs to be set before using readFromStorage or writeFromStorage"
    },
    noCryptoObj: {
      code: "no_crypto_object",
      desc: "No crypto object detected. This is required for the following operation: "
    },
    invalidCacheType: {
      code: "invalid_cache_type",
      desc: "Invalid cache type"
    },
    unexpectedAccountType: {
      code: "unexpected_account_type",
      desc: "Unexpected account type."
    },
    unexpectedCredentialType: {
      code: "unexpected_credential_type",
      desc: "Unexpected credential type."
    },
    invalidAssertion: {
      code: "invalid_assertion",
      desc: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515"
    },
    invalidClientCredential: {
      code: "invalid_client_credential",
      desc: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential"
    },
    tokenRefreshRequired: {
      code: "token_refresh_required",
      desc: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired."
    },
    userTimeoutReached: {
      code: "user_timeout_reached",
      desc: "User defined timeout for device code polling reached"
    },
    tokenClaimsRequired: {
      code: "token_claims_cnf_required_for_signedjwt",
      desc: "Cannot generate a POP jwt if the token_claims are not populated"
    },
    noAuthorizationCodeFromServer: {
      code: "authorization_code_missing_from_server_response",
      desc: "Server response does not contain an authorization code to proceed"
    },
    noAzureRegionDetected: {
      code: "no_azure_region_detected",
      desc: "No azure region was detected and no fallback was made available"
    },
    accessTokenEntityNullError: {
      code: "access_token_entity_null",
      desc: "Access token entity is null, please check logs and cache to ensure a valid access token is present."
    },
    bindingKeyNotRemovedError: {
      code: "binding_key_not_removed",
      desc: "Could not remove the credential's binding key from storage."
    },
    logoutNotSupported: {
      code: "end_session_endpoint_not_supported",
      desc: "Provided authority does not support logout."
    },
    keyIdMissing: {
      code: "key_id_missing",
      desc: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key."
    },
    noNetworkConnectivity: {
      code: "no_network_connectivity",
      desc: "No network connectivity. Check your internet connection."
    },
    userCanceledError: {
      code: "user_canceled",
      desc: "User canceled the flow."
    }
  },
  ClientAuthError = function (r) {
    function n(e, t) {
      e = r.call(this, e, t) || this;
      return e.name = "ClientAuthError", Object.setPrototypeOf(e, n.prototype), e;
    }
    return __extends$f(n, r), n.createClientInfoDecodingError = function (e) {
      return new n(ClientAuthErrorMessage.clientInfoDecodingError.code, ClientAuthErrorMessage.clientInfoDecodingError.desc + " Failed with error: " + e);
    }, n.createClientInfoEmptyError = function () {
      return new n(ClientAuthErrorMessage.clientInfoEmptyError.code, "" + ClientAuthErrorMessage.clientInfoEmptyError.desc);
    }, n.createTokenParsingError = function (e) {
      return new n(ClientAuthErrorMessage.tokenParsingError.code, ClientAuthErrorMessage.tokenParsingError.desc + " Failed with error: " + e);
    }, n.createTokenNullOrEmptyError = function (e) {
      return new n(ClientAuthErrorMessage.nullOrEmptyToken.code, ClientAuthErrorMessage.nullOrEmptyToken.desc + " Raw Token Value: " + e);
    }, n.createEndpointDiscoveryIncompleteError = function (e) {
      return new n(ClientAuthErrorMessage.endpointResolutionError.code, ClientAuthErrorMessage.endpointResolutionError.desc + " Detail: " + e);
    }, n.createNetworkError = function (e, t) {
      return new n(ClientAuthErrorMessage.networkError.code, ClientAuthErrorMessage.networkError.desc + " | Fetch client threw: " + t + " | Attempted to reach: " + e.split("?")[0]);
    }, n.createUnableToGetOpenidConfigError = function (e) {
      return new n(ClientAuthErrorMessage.unableToGetOpenidConfigError.code, ClientAuthErrorMessage.unableToGetOpenidConfigError.desc + " Attempted to retrieve endpoints from: " + e);
    }, n.createHashNotDeserializedError = function (e) {
      return new n(ClientAuthErrorMessage.hashNotDeserialized.code, ClientAuthErrorMessage.hashNotDeserialized.desc + " Given Object: " + e);
    }, n.createInvalidStateError = function (e, t) {
      return new n(ClientAuthErrorMessage.invalidStateError.code, ClientAuthErrorMessage.invalidStateError.desc + " Invalid State: " + e + ", Root Err: " + t);
    }, n.createStateMismatchError = function () {
      return new n(ClientAuthErrorMessage.stateMismatchError.code, ClientAuthErrorMessage.stateMismatchError.desc);
    }, n.createStateNotFoundError = function (e) {
      return new n(ClientAuthErrorMessage.stateNotFoundError.code, ClientAuthErrorMessage.stateNotFoundError.desc + ":  " + e);
    }, n.createNonceMismatchError = function () {
      return new n(ClientAuthErrorMessage.nonceMismatchError.code, ClientAuthErrorMessage.nonceMismatchError.desc);
    }, n.createAuthTimeNotFoundError = function () {
      return new n(ClientAuthErrorMessage.authTimeNotFoundError.code, ClientAuthErrorMessage.authTimeNotFoundError.desc);
    }, n.createMaxAgeTranspiredError = function () {
      return new n(ClientAuthErrorMessage.maxAgeTranspiredError.code, ClientAuthErrorMessage.maxAgeTranspiredError.desc);
    }, n.createNonceNotFoundError = function (e) {
      return new n(ClientAuthErrorMessage.nonceNotFoundError.code, ClientAuthErrorMessage.nonceNotFoundError.desc + ":  " + e);
    }, n.createMultipleMatchingTokensInCacheError = function () {
      return new n(ClientAuthErrorMessage.multipleMatchingTokens.code, ClientAuthErrorMessage.multipleMatchingTokens.desc + ".");
    }, n.createMultipleMatchingAccountsInCacheError = function () {
      return new n(ClientAuthErrorMessage.multipleMatchingAccounts.code, ClientAuthErrorMessage.multipleMatchingAccounts.desc);
    }, n.createMultipleMatchingAppMetadataInCacheError = function () {
      return new n(ClientAuthErrorMessage.multipleMatchingAppMetadata.code, ClientAuthErrorMessage.multipleMatchingAppMetadata.desc);
    }, n.createTokenRequestCannotBeMadeError = function () {
      return new n(ClientAuthErrorMessage.tokenRequestCannotBeMade.code, ClientAuthErrorMessage.tokenRequestCannotBeMade.desc);
    }, n.createAppendEmptyScopeToSetError = function (e) {
      return new n(ClientAuthErrorMessage.appendEmptyScopeError.code, ClientAuthErrorMessage.appendEmptyScopeError.desc + " Given Scope: " + e);
    }, n.createRemoveEmptyScopeFromSetError = function (e) {
      return new n(ClientAuthErrorMessage.removeEmptyScopeError.code, ClientAuthErrorMessage.removeEmptyScopeError.desc + " Given Scope: " + e);
    }, n.createAppendScopeSetError = function (e) {
      return new n(ClientAuthErrorMessage.appendScopeSetError.code, ClientAuthErrorMessage.appendScopeSetError.desc + " Detail Error: " + e);
    }, n.createEmptyInputScopeSetError = function () {
      return new n(ClientAuthErrorMessage.emptyInputScopeSetError.code, "" + ClientAuthErrorMessage.emptyInputScopeSetError.desc);
    }, n.createDeviceCodeCancelledError = function () {
      return new n(ClientAuthErrorMessage.DeviceCodePollingCancelled.code, "" + ClientAuthErrorMessage.DeviceCodePollingCancelled.desc);
    }, n.createDeviceCodeExpiredError = function () {
      return new n(ClientAuthErrorMessage.DeviceCodeExpired.code, "" + ClientAuthErrorMessage.DeviceCodeExpired.desc);
    }, n.createDeviceCodeUnknownError = function () {
      return new n(ClientAuthErrorMessage.DeviceCodeUnknownError.code, "" + ClientAuthErrorMessage.DeviceCodeUnknownError.desc);
    }, n.createNoAccountInSilentRequestError = function () {
      return new n(ClientAuthErrorMessage.NoAccountInSilentRequest.code, "" + ClientAuthErrorMessage.NoAccountInSilentRequest.desc);
    }, n.createNullOrUndefinedCacheRecord = function () {
      return new n(ClientAuthErrorMessage.invalidCacheRecord.code, ClientAuthErrorMessage.invalidCacheRecord.desc);
    }, n.createInvalidCacheEnvironmentError = function () {
      return new n(ClientAuthErrorMessage.invalidCacheEnvironment.code, ClientAuthErrorMessage.invalidCacheEnvironment.desc);
    }, n.createNoAccountFoundError = function () {
      return new n(ClientAuthErrorMessage.noAccountFound.code, ClientAuthErrorMessage.noAccountFound.desc);
    }, n.createCachePluginError = function () {
      return new n(ClientAuthErrorMessage.CachePluginError.code, "" + ClientAuthErrorMessage.CachePluginError.desc);
    }, n.createNoCryptoObjectError = function (e) {
      return new n(ClientAuthErrorMessage.noCryptoObj.code, "" + ClientAuthErrorMessage.noCryptoObj.desc + e);
    }, n.createInvalidCacheTypeError = function () {
      return new n(ClientAuthErrorMessage.invalidCacheType.code, "" + ClientAuthErrorMessage.invalidCacheType.desc);
    }, n.createUnexpectedAccountTypeError = function () {
      return new n(ClientAuthErrorMessage.unexpectedAccountType.code, "" + ClientAuthErrorMessage.unexpectedAccountType.desc);
    }, n.createUnexpectedCredentialTypeError = function () {
      return new n(ClientAuthErrorMessage.unexpectedCredentialType.code, "" + ClientAuthErrorMessage.unexpectedCredentialType.desc);
    }, n.createInvalidAssertionError = function () {
      return new n(ClientAuthErrorMessage.invalidAssertion.code, "" + ClientAuthErrorMessage.invalidAssertion.desc);
    }, n.createInvalidCredentialError = function () {
      return new n(ClientAuthErrorMessage.invalidClientCredential.code, "" + ClientAuthErrorMessage.invalidClientCredential.desc);
    }, n.createRefreshRequiredError = function () {
      return new n(ClientAuthErrorMessage.tokenRefreshRequired.code, ClientAuthErrorMessage.tokenRefreshRequired.desc);
    }, n.createUserTimeoutReachedError = function () {
      return new n(ClientAuthErrorMessage.userTimeoutReached.code, ClientAuthErrorMessage.userTimeoutReached.desc);
    }, n.createTokenClaimsRequiredError = function () {
      return new n(ClientAuthErrorMessage.tokenClaimsRequired.code, ClientAuthErrorMessage.tokenClaimsRequired.desc);
    }, n.createNoAuthCodeInServerResponseError = function () {
      return new n(ClientAuthErrorMessage.noAuthorizationCodeFromServer.code, ClientAuthErrorMessage.noAuthorizationCodeFromServer.desc);
    }, n.createBindingKeyNotRemovedError = function () {
      return new n(ClientAuthErrorMessage.bindingKeyNotRemovedError.code, ClientAuthErrorMessage.bindingKeyNotRemovedError.desc);
    }, n.createLogoutNotSupportedError = function () {
      return new n(ClientAuthErrorMessage.logoutNotSupported.code, ClientAuthErrorMessage.logoutNotSupported.desc);
    }, n.createKeyIdMissingError = function () {
      return new n(ClientAuthErrorMessage.keyIdMissing.code, ClientAuthErrorMessage.keyIdMissing.desc);
    }, n.createNoNetworkConnectivityError = function () {
      return new n(ClientAuthErrorMessage.noNetworkConnectivity.code, ClientAuthErrorMessage.noNetworkConnectivity.desc);
    }, n.createUserCanceledError = function () {
      return new n(ClientAuthErrorMessage.userCanceledError.code, ClientAuthErrorMessage.userCanceledError.desc);
    }, n;
  }(AuthError),
  StringUtils = function () {
    function r() {}
    return r.decodeAuthToken = function (e) {
      if (r.isEmpty(e)) throw ClientAuthError.createTokenNullOrEmptyError(e);
      var t = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/.exec(e);
      if (!t || t.length < 4) throw ClientAuthError.createTokenParsingError("Given token is malformed: " + JSON.stringify(e));
      return {
        header: t[1],
        JWSPayload: t[2],
        JWSSig: t[3]
      };
    }, r.isEmpty = function (e) {
      return void 0 === e || !e || 0 === e.length;
    }, r.isEmptyObj = function (e) {
      if (e && !r.isEmpty(e)) try {
        var t = JSON.parse(e);
        return 0 === Object.keys(t).length;
      } catch (e) {}
      return !0;
    }, r.startsWith = function (e, t) {
      return 0 === e.indexOf(t);
    }, r.endsWith = function (e, t) {
      return e.length >= t.length && e.lastIndexOf(t) === e.length - t.length;
    }, r.queryStringToObject = function (e) {
      function r(e) {
        return decodeURIComponent(e.replace(/\+/g, " "));
      }
      var n = {},
        e = e.split("&");
      return e.forEach(function (e) {
        var t;
        e.trim() && (t = (e = e.split(/=(.+)/g, 2))[0], e = e[1], t) && e && (n[r(t)] = r(e));
      }), n;
    }, r.trimArrayEntries = function (e) {
      return e.map(function (e) {
        return e.trim();
      });
    }, r.removeEmptyStringsFromArray = function (e) {
      return e.filter(function (e) {
        return !r.isEmpty(e);
      });
    }, r.jsonParseHelper = function (e) {
      try {
        return JSON.parse(e);
      } catch (e) {
        return null;
      }
    }, r.matchPattern = function (e, t) {
      return new RegExp(e.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?")).test(t);
    }, r;
  }(),
  Logger = (!function (e) {
    e[e.Error = 0] = "Error", e[e.Warning = 1] = "Warning", e[e.Info = 2] = "Info", e[e.Verbose = 3] = "Verbose", e[e.Trace = 4] = "Trace";
  }(LogLevel = LogLevel || {}), function () {
    function n(e, t, r) {
      this.level = LogLevel.Info;
      e = e || n.createDefaultLoggerOptions();
      this.localCallback = e.loggerCallback || function () {}, this.piiLoggingEnabled = e.piiLoggingEnabled || !1, this.level = "number" == typeof e.logLevel ? e.logLevel : LogLevel.Info, this.correlationId = e.correlationId || Constants.EMPTY_STRING, this.packageName = t || Constants.EMPTY_STRING, this.packageVersion = r || Constants.EMPTY_STRING;
    }
    return n.createDefaultLoggerOptions = function () {
      return {
        loggerCallback: function () {},
        piiLoggingEnabled: !1,
        logLevel: LogLevel.Info
      };
    }, n.prototype.clone = function (e, t, r) {
      return new n({
        loggerCallback: this.localCallback,
        piiLoggingEnabled: this.piiLoggingEnabled,
        logLevel: this.level,
        correlationId: r || this.correlationId
      }, e, t);
    }, n.prototype.logMessage = function (e, t) {
      var r;
      t.logLevel > this.level || !this.piiLoggingEnabled && t.containsPii || (r = new Date().toUTCString(), r = (StringUtils.isEmpty(t.correlationId) ? StringUtils.isEmpty(this.correlationId) ? "[" + r + "]" : "[" + r + "] : [" + this.correlationId + "]" : "[" + r + "] : [" + t.correlationId + "]") + " : " + this.packageName + "@" + this.packageVersion + " : " + LogLevel[t.logLevel] + " - " + e, this.executeCallback(t.logLevel, r, t.containsPii || !1));
    }, n.prototype.executeCallback = function (e, t, r) {
      this.localCallback && this.localCallback(e, t, r);
    }, n.prototype.error = function (e, t) {
      this.logMessage(e, {
        logLevel: LogLevel.Error,
        containsPii: !1,
        correlationId: t || Constants.EMPTY_STRING
      });
    }, n.prototype.errorPii = function (e, t) {
      this.logMessage(e, {
        logLevel: LogLevel.Error,
        containsPii: !0,
        correlationId: t || Constants.EMPTY_STRING
      });
    }, n.prototype.warning = function (e, t) {
      this.logMessage(e, {
        logLevel: LogLevel.Warning,
        containsPii: !1,
        correlationId: t || Constants.EMPTY_STRING
      });
    }, n.prototype.warningPii = function (e, t) {
      this.logMessage(e, {
        logLevel: LogLevel.Warning,
        containsPii: !0,
        correlationId: t || Constants.EMPTY_STRING
      });
    }, n.prototype.info = function (e, t) {
      this.logMessage(e, {
        logLevel: LogLevel.Info,
        containsPii: !1,
        correlationId: t || Constants.EMPTY_STRING
      });
    }, n.prototype.infoPii = function (e, t) {
      this.logMessage(e, {
        logLevel: LogLevel.Info,
        containsPii: !0,
        correlationId: t || Constants.EMPTY_STRING
      });
    }, n.prototype.verbose = function (e, t) {
      this.logMessage(e, {
        logLevel: LogLevel.Verbose,
        containsPii: !1,
        correlationId: t || Constants.EMPTY_STRING
      });
    }, n.prototype.verbosePii = function (e, t) {
      this.logMessage(e, {
        logLevel: LogLevel.Verbose,
        containsPii: !0,
        correlationId: t || Constants.EMPTY_STRING
      });
    }, n.prototype.trace = function (e, t) {
      this.logMessage(e, {
        logLevel: LogLevel.Trace,
        containsPii: !1,
        correlationId: t || Constants.EMPTY_STRING
      });
    }, n.prototype.tracePii = function (e, t) {
      this.logMessage(e, {
        logLevel: LogLevel.Trace,
        containsPii: !0,
        correlationId: t || Constants.EMPTY_STRING
      });
    }, n.prototype.isPiiLoggingEnabled = function () {
      return this.piiLoggingEnabled || !1;
    }, n;
  }()),
  name$1 = "@azure/msal-common",
  version$1 = "13.3.1",
  ClientConfigurationErrorMessage = (!function (e) {
    e[e.None = 0] = "None", e.AzurePublic = "https://login.microsoftonline.com", e.AzurePpe = "https://login.windows-ppe.net", e.AzureChina = "https://login.chinacloudapi.cn", e.AzureGermany = "https://login.microsoftonline.de", e.AzureUsGovernment = "https://login.microsoftonline.us";
  }(AzureCloudInstance = AzureCloudInstance || {}), {
    redirectUriNotSet: {
      code: "redirect_uri_empty",
      desc: "A redirect URI is required for all calls, and none has been set."
    },
    postLogoutUriNotSet: {
      code: "post_logout_uri_empty",
      desc: "A post logout redirect has not been set."
    },
    claimsRequestParsingError: {
      code: "claims_request_parsing_error",
      desc: "Could not parse the given claims request object."
    },
    authorityUriInsecure: {
      code: "authority_uri_insecure",
      desc: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options"
    },
    urlParseError: {
      code: "url_parse_error",
      desc: "URL could not be parsed into appropriate segments."
    },
    urlEmptyError: {
      code: "empty_url_error",
      desc: "URL was empty or null."
    },
    emptyScopesError: {
      code: "empty_input_scopes_error",
      desc: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token."
    },
    nonArrayScopesError: {
      code: "nonarray_input_scopes_error",
      desc: "Scopes cannot be passed as non-array."
    },
    clientIdSingleScopeError: {
      code: "clientid_input_scopes_error",
      desc: "Client ID can only be provided as a single scope."
    },
    invalidPrompt: {
      code: "invalid_prompt_value",
      desc: "Supported prompt values are 'login', 'select_account', 'consent', 'create', 'none' and 'no_session'.  Please see here for valid configuration options: https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal_common.html#commonauthorizationurlrequest"
    },
    invalidClaimsRequest: {
      code: "invalid_claims",
      desc: "Given claims parameter must be a stringified JSON object."
    },
    tokenRequestEmptyError: {
      code: "token_request_empty",
      desc: "Token request was empty and not found in cache."
    },
    logoutRequestEmptyError: {
      code: "logout_request_empty",
      desc: "The logout request was null or undefined."
    },
    invalidCodeChallengeMethod: {
      code: "invalid_code_challenge_method",
      desc: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".'
    },
    invalidCodeChallengeParams: {
      code: "pkce_params_missing",
      desc: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request"
    },
    invalidCloudDiscoveryMetadata: {
      code: "invalid_cloud_discovery_metadata",
      desc: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields"
    },
    invalidAuthorityMetadata: {
      code: "invalid_authority_metadata",
      desc: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields."
    },
    untrustedAuthority: {
      code: "untrusted_authority",
      desc: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter."
    },
    invalidAzureCloudInstance: {
      code: "invalid_azure_cloud_instance",
      desc: "Invalid AzureCloudInstance provided. Please refer MSAL JS docs: aks.ms/msaljs/azure_cloud_instance for valid values"
    },
    missingSshJwk: {
      code: "missing_ssh_jwk",
      desc: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme."
    },
    missingSshKid: {
      code: "missing_ssh_kid",
      desc: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme."
    },
    missingNonceAuthenticationHeader: {
      code: "missing_nonce_authentication_header",
      desc: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce."
    },
    invalidAuthenticationHeader: {
      code: "invalid_authentication_header",
      desc: "Invalid authentication header provided"
    },
    authorityMismatch: {
      code: "authority_mismatch",
      desc: "Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority."
    }
  }),
  ClientConfigurationError = function (r) {
    function n(e, t) {
      e = r.call(this, e, t) || this;
      return e.name = "ClientConfigurationError", Object.setPrototypeOf(e, n.prototype), e;
    }
    return __extends$f(n, r), n.createRedirectUriEmptyError = function () {
      return new n(ClientConfigurationErrorMessage.redirectUriNotSet.code, ClientConfigurationErrorMessage.redirectUriNotSet.desc);
    }, n.createPostLogoutRedirectUriEmptyError = function () {
      return new n(ClientConfigurationErrorMessage.postLogoutUriNotSet.code, ClientConfigurationErrorMessage.postLogoutUriNotSet.desc);
    }, n.createClaimsRequestParsingError = function (e) {
      return new n(ClientConfigurationErrorMessage.claimsRequestParsingError.code, ClientConfigurationErrorMessage.claimsRequestParsingError.desc + " Given value: " + e);
    }, n.createInsecureAuthorityUriError = function (e) {
      return new n(ClientConfigurationErrorMessage.authorityUriInsecure.code, ClientConfigurationErrorMessage.authorityUriInsecure.desc + " Given URI: " + e);
    }, n.createUrlParseError = function (e) {
      return new n(ClientConfigurationErrorMessage.urlParseError.code, ClientConfigurationErrorMessage.urlParseError.desc + " Given Error: " + e);
    }, n.createUrlEmptyError = function () {
      return new n(ClientConfigurationErrorMessage.urlEmptyError.code, ClientConfigurationErrorMessage.urlEmptyError.desc);
    }, n.createEmptyScopesArrayError = function () {
      return new n(ClientConfigurationErrorMessage.emptyScopesError.code, "" + ClientConfigurationErrorMessage.emptyScopesError.desc);
    }, n.createClientIdSingleScopeError = function (e) {
      return new n(ClientConfigurationErrorMessage.clientIdSingleScopeError.code, ClientConfigurationErrorMessage.clientIdSingleScopeError.desc + " Given Scopes: " + e);
    }, n.createInvalidPromptError = function (e) {
      return new n(ClientConfigurationErrorMessage.invalidPrompt.code, ClientConfigurationErrorMessage.invalidPrompt.desc + " Given value: " + e);
    }, n.createInvalidClaimsRequestError = function () {
      return new n(ClientConfigurationErrorMessage.invalidClaimsRequest.code, ClientConfigurationErrorMessage.invalidClaimsRequest.desc);
    }, n.createEmptyLogoutRequestError = function () {
      return new n(ClientConfigurationErrorMessage.logoutRequestEmptyError.code, ClientConfigurationErrorMessage.logoutRequestEmptyError.desc);
    }, n.createEmptyTokenRequestError = function () {
      return new n(ClientConfigurationErrorMessage.tokenRequestEmptyError.code, ClientConfigurationErrorMessage.tokenRequestEmptyError.desc);
    }, n.createInvalidCodeChallengeMethodError = function () {
      return new n(ClientConfigurationErrorMessage.invalidCodeChallengeMethod.code, ClientConfigurationErrorMessage.invalidCodeChallengeMethod.desc);
    }, n.createInvalidCodeChallengeParamsError = function () {
      return new n(ClientConfigurationErrorMessage.invalidCodeChallengeParams.code, ClientConfigurationErrorMessage.invalidCodeChallengeParams.desc);
    }, n.createInvalidCloudDiscoveryMetadataError = function () {
      return new n(ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.code, ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.desc);
    }, n.createInvalidAuthorityMetadataError = function () {
      return new n(ClientConfigurationErrorMessage.invalidAuthorityMetadata.code, ClientConfigurationErrorMessage.invalidAuthorityMetadata.desc);
    }, n.createUntrustedAuthorityError = function () {
      return new n(ClientConfigurationErrorMessage.untrustedAuthority.code, ClientConfigurationErrorMessage.untrustedAuthority.desc);
    }, n.createInvalidAzureCloudInstanceError = function () {
      return new n(ClientConfigurationErrorMessage.invalidAzureCloudInstance.code, ClientConfigurationErrorMessage.invalidAzureCloudInstance.desc);
    }, n.createMissingSshJwkError = function () {
      return new n(ClientConfigurationErrorMessage.missingSshJwk.code, ClientConfigurationErrorMessage.missingSshJwk.desc);
    }, n.createMissingSshKidError = function () {
      return new n(ClientConfigurationErrorMessage.missingSshKid.code, ClientConfigurationErrorMessage.missingSshKid.desc);
    }, n.createMissingNonceAuthenticationHeadersError = function () {
      return new n(ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.code, ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.desc);
    }, n.createInvalidAuthenticationHeaderError = function (e, t) {
      return new n(ClientConfigurationErrorMessage.invalidAuthenticationHeader.code, ClientConfigurationErrorMessage.invalidAuthenticationHeader.desc + ". Invalid header: " + e + ". Details: " + t);
    }, n.createAuthorityMismatchError = function () {
      return new n(ClientConfigurationErrorMessage.authorityMismatch.code, ClientConfigurationErrorMessage.authorityMismatch.desc);
    }, n;
  }(ClientAuthError),
  ScopeSet = function () {
    function r(e) {
      var t = this,
        e = e ? StringUtils.trimArrayEntries(__spreadArrays(e)) : [],
        e = e ? StringUtils.removeEmptyStringsFromArray(e) : [];
      this.validateInputScopes(e), this.scopes = new Set(), e.forEach(function (e) {
        return t.scopes.add(e);
      });
    }
    return r.fromString = function (e) {
      return new r((e || Constants.EMPTY_STRING).split(" "));
    }, r.createSearchScopes = function (e) {
      e = new r(e);
      return e.containsOnlyOIDCScopes() ? e.removeScope(Constants.OFFLINE_ACCESS_SCOPE) : e.removeOIDCScopes(), e;
    }, r.prototype.validateInputScopes = function (e) {
      if (!e || e.length < 1) throw ClientConfigurationError.createEmptyScopesArrayError();
    }, r.prototype.containsScope = function (e) {
      var t = new r(this.printScopesLowerCase().split(" "));
      return !StringUtils.isEmpty(e) && t.scopes.has(e.toLowerCase());
    }, r.prototype.containsScopeSet = function (e) {
      var t = this;
      return !(!e || e.scopes.size <= 0) && this.scopes.size >= e.scopes.size && e.asArray().every(function (e) {
        return t.containsScope(e);
      });
    }, r.prototype.containsOnlyOIDCScopes = function () {
      var t = this,
        r = 0;
      return OIDC_SCOPES.forEach(function (e) {
        t.containsScope(e) && (r += 1);
      }), this.scopes.size === r;
    }, r.prototype.appendScope = function (e) {
      StringUtils.isEmpty(e) || this.scopes.add(e.trim());
    }, r.prototype.appendScopes = function (e) {
      var t = this;
      try {
        e.forEach(function (e) {
          return t.appendScope(e);
        });
      } catch (e) {
        throw ClientAuthError.createAppendScopeSetError(e);
      }
    }, r.prototype.removeScope = function (e) {
      if (StringUtils.isEmpty(e)) throw ClientAuthError.createRemoveEmptyScopeFromSetError(e);
      this.scopes.delete(e.trim());
    }, r.prototype.removeOIDCScopes = function () {
      var t = this;
      OIDC_SCOPES.forEach(function (e) {
        t.scopes.delete(e);
      });
    }, r.prototype.unionScopeSets = function (e) {
      var t;
      if (e) return t = new Set(), e.scopes.forEach(function (e) {
        return t.add(e.toLowerCase());
      }), this.scopes.forEach(function (e) {
        return t.add(e.toLowerCase());
      }), t;
      throw ClientAuthError.createEmptyInputScopeSetError();
    }, r.prototype.intersectingScopeSets = function (e) {
      if (!e) throw ClientAuthError.createEmptyInputScopeSetError();
      e.containsOnlyOIDCScopes() || e.removeOIDCScopes();
      var t = this.unionScopeSets(e),
        e = e.getScopeCount(),
        r = this.getScopeCount();
      return t.size < r + e;
    }, r.prototype.getScopeCount = function () {
      return this.scopes.size;
    }, r.prototype.asArray = function () {
      var t = [];
      return this.scopes.forEach(function (e) {
        return t.push(e);
      }), t;
    }, r.prototype.printScopes = function () {
      return this.scopes ? this.asArray().join(" ") : Constants.EMPTY_STRING;
    }, r.prototype.printScopesLowerCase = function () {
      return this.printScopes().toLowerCase();
    }, r;
  }();
function buildClientInfo(e, t) {
  if (StringUtils.isEmpty(e)) throw ClientAuthError.createClientInfoEmptyError();
  try {
    var r = t.base64Decode(e);
    return JSON.parse(r);
  } catch (e) {
    throw ClientAuthError.createClientInfoDecodingError(e.message);
  }
}
function buildClientInfoFromHomeAccountId(e) {
  if (StringUtils.isEmpty(e)) throw ClientAuthError.createClientInfoDecodingError("Home account ID was empty.");
  e = e.split(Separators.CLIENT_INFO_SEPARATOR, 2);
  return {
    uid: e[0],
    utid: e.length < 2 ? Constants.EMPTY_STRING : e[1]
  };
}
!function (e) {
  e[e.Default = 0] = "Default", e[e.Adfs = 1] = "Adfs", e[e.Dsts = 2] = "Dsts", e[e.Ciam = 3] = "Ciam";
}(AuthorityType = AuthorityType || {});
var AccountEntity = function () {
    function c() {}
    return c.prototype.generateAccountId = function () {
      return [this.homeAccountId, this.environment].join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    }, c.prototype.generateAccountKey = function () {
      return c.generateAccountCacheKey({
        homeAccountId: this.homeAccountId,
        environment: this.environment,
        tenantId: this.realm,
        username: this.username,
        localAccountId: this.localAccountId
      });
    }, c.prototype.generateType = function () {
      switch (this.authorityType) {
        case CacheAccountType.ADFS_ACCOUNT_TYPE:
          return CacheType.ADFS;
        case CacheAccountType.MSAV1_ACCOUNT_TYPE:
          return CacheType.MSA;
        case CacheAccountType.MSSTS_ACCOUNT_TYPE:
          return CacheType.MSSTS;
        case CacheAccountType.GENERIC_ACCOUNT_TYPE:
          return CacheType.GENERIC;
        default:
          throw ClientAuthError.createUnexpectedAccountTypeError();
      }
    }, c.prototype.getAccountInfo = function () {
      return {
        homeAccountId: this.homeAccountId,
        environment: this.environment,
        tenantId: this.realm,
        username: this.username,
        localAccountId: this.localAccountId,
        name: this.name,
        idTokenClaims: this.idTokenClaims,
        nativeAccountId: this.nativeAccountId
      };
    }, c.generateAccountCacheKey = function (e) {
      return [e.homeAccountId, e.environment || Constants.EMPTY_STRING, e.tenantId || Constants.EMPTY_STRING].join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    }, c.createAccount = function (e, t, r, n, i, o, a, s) {
      var l = new c(),
        e = (l.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE, l.clientInfo = e, l.homeAccountId = t, l.nativeAccountId = s, a || n && n.getPreferredCache());
      if (e) return l.environment = e, l.realm = (null == (t = null == r ? void 0 : r.claims) ? void 0 : t.tid) || Constants.EMPTY_STRING, r && (l.idTokenClaims = r.claims, l.localAccountId = (null == (s = null == r ? void 0 : r.claims) ? void 0 : s.oid) || (null == (a = null == r ? void 0 : r.claims) ? void 0 : a.sub) || Constants.EMPTY_STRING, e = null == (n = null == r ? void 0 : r.claims) ? void 0 : n.preferred_username, s = null != (t = null == r ? void 0 : r.claims) && t.emails ? r.claims.emails[0] : null, l.username = e || s || Constants.EMPTY_STRING, l.name = null == (a = null == r ? void 0 : r.claims) ? void 0 : a.name), l.cloudGraphHostName = i, l.msGraphHost = o, l;
      throw ClientAuthError.createInvalidCacheEnvironmentError();
    }, c.createGenericAccount = function (e, t, r, n, i, o) {
      var a = new c(),
        e = (a.authorityType = r && r.authorityType === AuthorityType.Adfs ? CacheAccountType.ADFS_ACCOUNT_TYPE : CacheAccountType.GENERIC_ACCOUNT_TYPE, a.homeAccountId = e, a.realm = Constants.EMPTY_STRING, o || r && r.getPreferredCache());
      if (e) return t && (a.localAccountId = (null == (o = null == t ? void 0 : t.claims) ? void 0 : o.oid) || (null == (r = null == t ? void 0 : t.claims) ? void 0 : r.sub) || Constants.EMPTY_STRING, a.username = (null == (o = null == t ? void 0 : t.claims) ? void 0 : o.upn) || Constants.EMPTY_STRING, a.name = (null == (r = null == t ? void 0 : t.claims) ? void 0 : r.name) || Constants.EMPTY_STRING, a.idTokenClaims = null == t ? void 0 : t.claims), a.environment = e, a.cloudGraphHostName = n, a.msGraphHost = i, a;
      throw ClientAuthError.createInvalidCacheEnvironmentError();
    }, c.generateHomeAccountId = function (e, t, r, n, i) {
      var o = null != (o = null == i ? void 0 : i.claims) && o.sub ? i.claims.sub : Constants.EMPTY_STRING;
      if (t !== AuthorityType.Adfs && t !== AuthorityType.Dsts) {
        if (e) try {
          var a = buildClientInfo(e, n);
          if (!StringUtils.isEmpty(a.uid) && !StringUtils.isEmpty(a.utid)) return "" + a.uid + Separators.CLIENT_INFO_SEPARATOR + a.utid;
        } catch (e) {}
        r.verbose("No client info in response");
      }
      return o;
    }, c.isAccountEntity = function (e) {
      return !!e && e.hasOwnProperty("homeAccountId") && e.hasOwnProperty("environment") && e.hasOwnProperty("realm") && e.hasOwnProperty("localAccountId") && e.hasOwnProperty("username") && e.hasOwnProperty("authorityType");
    }, c.accountInfoIsEqual = function (e, t, r) {
      var n, i;
      return !(!e || !t) && (i = !0, r && (r = e.idTokenClaims || {}, n = t.idTokenClaims || {}, i = r.iat === n.iat && r.nonce === n.nonce), e.homeAccountId === t.homeAccountId) && e.localAccountId === t.localAccountId && e.username === t.username && e.tenantId === t.tenantId && e.environment === t.environment && e.nativeAccountId === t.nativeAccountId && i;
    }, c;
  }(),
  AuthToken = function () {
    function r(e, t) {
      if (StringUtils.isEmpty(e)) throw ClientAuthError.createTokenNullOrEmptyError(e);
      this.rawToken = e, this.claims = r.extractTokenClaims(e, t);
    }
    return r.extractTokenClaims = function (e, t) {
      e = StringUtils.decodeAuthToken(e);
      try {
        var r = e.JWSPayload,
          n = t.base64Decode(r);
        return JSON.parse(n);
      } catch (e) {
        throw ClientAuthError.createTokenParsingError(e);
      }
    }, r.checkMaxAge = function (e, t) {
      if (0 === t || Date.now() - 3e5 > e + t) throw ClientAuthError.createMaxAgeTranspiredError();
    }, r;
  }(),
  CacheManager = function () {
    function e(e, t, r) {
      this.clientId = e, this.cryptoImpl = t, this.commonLogger = r.clone(name$1, version$1);
    }
    return e.prototype.getAllAccounts = function () {
      var r = this,
        e = this.getAccountKeys();
      return e.length < 1 || (e = e.reduce(function (e, t) {
        t = r.getAccount(t);
        return t && e.push(t), e;
      }, [])).length < 1 ? [] : e.map(function (e) {
        return r.getAccountInfoFromEntity(e);
      });
    }, e.prototype.getAccountInfoFilteredBy = function (e) {
      e = this.getAccountsFilteredBy(e);
      return 0 < e.length ? this.getAccountInfoFromEntity(e[0]) : null;
    }, e.prototype.getAccountInfoFromEntity = function (e) {
      var e = e.getAccountInfo(),
        t = this.getIdToken(e);
      return t && (e.idToken = t.secret, e.idTokenClaims = new AuthToken(t.secret, this.cryptoImpl).claims), e;
    }, e.prototype.saveCacheRecord = function (t) {
      return __awaiter$2(this, void 0, void 0, function () {
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              if (t) return t.account && this.setAccount(t.account), t.idToken && this.setIdTokenCredential(t.idToken), t.accessToken ? [4, this.saveAccessToken(t.accessToken)] : [3, 2];
              throw ClientAuthError.createNullOrUndefinedCacheRecord();
            case 1:
              e.sent(), e.label = 2;
            case 2:
              return t.refreshToken && this.setRefreshTokenCredential(t.refreshToken), t.appMetadata && this.setAppMetadata(t.appMetadata), [2];
          }
        });
      });
    }, e.prototype.saveAccessToken = function (a) {
      return __awaiter$2(this, void 0, void 0, function () {
        var r,
          t,
          n,
          i,
          o = this;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return r = {
                clientId: a.clientId,
                credentialType: a.credentialType,
                environment: a.environment,
                homeAccountId: a.homeAccountId,
                realm: a.realm,
                tokenType: a.tokenType,
                requestedClaimsHash: a.requestedClaimsHash
              }, t = this.getTokenKeys(), n = ScopeSet.fromString(a.target), i = [], t.accessToken.forEach(function (e) {
                var t;
                o.accessTokenKeyMatchesFilter(e, r, !1) && (t = o.getAccessTokenCredential(e)) && o.credentialMatchesFilter(t, r) && ScopeSet.fromString(t.target).intersectingScopeSets(n) && i.push(o.removeAccessToken(e));
              }), [4, Promise.all(i)];
            case 1:
              return e.sent(), this.setAccessTokenCredential(a), [2];
          }
        });
      });
    }, e.prototype.getAccountsFilteredBy = function (t) {
      var r = this,
        e = this.getAccountKeys(),
        n = [];
      return e.forEach(function (e) {
        !r.isAccountKey(e, t.homeAccountId, t.realm) || !(e = r.getAccount(e)) || t.homeAccountId && !r.matchHomeAccountId(e, t.homeAccountId) || t.localAccountId && !r.matchLocalAccountId(e, t.localAccountId) || t.username && !r.matchUsername(e, t.username) || t.environment && !r.matchEnvironment(e, t.environment) || t.realm && !r.matchRealm(e, t.realm) || t.nativeAccountId && !r.matchNativeAccountId(e, t.nativeAccountId) || n.push(e);
      }), n;
    }, e.prototype.isAccountKey = function (e, t, r) {
      return !(e.split(Separators.CACHE_KEY_SEPARATOR).length < 3 || t && !e.toLowerCase().includes(t.toLowerCase()) || r && !e.toLowerCase().includes(r.toLowerCase()));
    }, e.prototype.isCredentialKey = function (e) {
      if (e.split(Separators.CACHE_KEY_SEPARATOR).length < 6) return !1;
      e = e.toLowerCase();
      if (-1 === e.indexOf(CredentialType.ID_TOKEN.toLowerCase()) && -1 === e.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) && -1 === e.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) && -1 === e.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase())) return !1;
      if (-1 < e.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase())) {
        var t = "" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + this.clientId + Separators.CACHE_KEY_SEPARATOR,
          r = "" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + THE_FAMILY_ID + Separators.CACHE_KEY_SEPARATOR;
        if (-1 === e.indexOf(t.toLowerCase()) && -1 === e.indexOf(r.toLowerCase())) return !1;
      } else if (-1 === e.indexOf(this.clientId.toLowerCase())) return !1;
      return !0;
    }, e.prototype.credentialMatchesFilter = function (e, t) {
      if (t.clientId && !this.matchClientId(e, t.clientId)) return !1;
      if (t.userAssertionHash && !this.matchUserAssertionHash(e, t.userAssertionHash)) return !1;
      if ("string" == typeof t.homeAccountId && !this.matchHomeAccountId(e, t.homeAccountId)) return !1;
      if (t.environment && !this.matchEnvironment(e, t.environment)) return !1;
      if (t.realm && !this.matchRealm(e, t.realm)) return !1;
      if (t.credentialType && !this.matchCredentialType(e, t.credentialType)) return !1;
      if (t.familyId && !this.matchFamilyId(e, t.familyId)) return !1;
      if (t.target && !this.matchTarget(e, t.target)) return !1;
      if ((t.requestedClaimsHash || e.requestedClaimsHash) && e.requestedClaimsHash !== t.requestedClaimsHash) return !1;
      if (e.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
        if (t.tokenType && !this.matchTokenType(e, t.tokenType)) return !1;
        if (t.tokenType === AuthenticationScheme.SSH && t.keyId && !this.matchKeyId(e, t.keyId)) return !1;
      }
      return !0;
    }, e.prototype.getAppMetadataFilteredBy = function (e) {
      return this.getAppMetadataFilteredByInternal(e.environment, e.clientId);
    }, e.prototype.getAppMetadataFilteredByInternal = function (r, n) {
      var i = this,
        e = this.getKeys(),
        o = {};
      return e.forEach(function (e) {
        var t;
        !i.isAppMetadata(e) || !(t = i.getAppMetadata(e)) || r && !i.matchEnvironment(t, r) || n && !i.matchClientId(t, n) || (o[e] = t);
      }), o;
    }, e.prototype.getAuthorityMetadataByAlias = function (t) {
      var r = this,
        e = this.getAuthorityMetadataKeys(),
        n = null;
      return e.forEach(function (e) {
        r.isAuthorityMetadata(e) && -1 !== e.indexOf(r.clientId) && (e = r.getAuthorityMetadata(e)) && -1 !== e.aliases.indexOf(t) && (n = e);
      }), n;
    }, e.prototype.removeAllAccounts = function () {
      return __awaiter$2(this, void 0, void 0, function () {
        var t,
          r,
          n = this;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return t = this.getAccountKeys(), r = [], t.forEach(function (e) {
                r.push(n.removeAccount(e));
              }), [4, Promise.all(r)];
            case 1:
              return e.sent(), [2];
          }
        });
      });
    }, e.prototype.removeAccount = function (r) {
      return __awaiter$2(this, void 0, void 0, function () {
        var t;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              if (t = this.getAccount(r)) return [4, this.removeAccountContext(t)];
              throw ClientAuthError.createNoAccountFoundError();
            case 1:
              return e.sent(), this.removeItem(r), [2];
          }
        });
      });
    }, e.prototype.removeAccountContext = function (o) {
      return __awaiter$2(this, void 0, void 0, function () {
        var t,
          r,
          n,
          i = this;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return t = this.getTokenKeys(), r = o.generateAccountId(), n = [], t.idToken.forEach(function (e) {
                0 === e.indexOf(r) && i.removeIdToken(e);
              }), t.accessToken.forEach(function (e) {
                0 === e.indexOf(r) && n.push(i.removeAccessToken(e));
              }), t.refreshToken.forEach(function (e) {
                0 === e.indexOf(r) && i.removeRefreshToken(e);
              }), [4, Promise.all(n)];
            case 1:
              return e.sent(), [2];
          }
        });
      });
    }, e.prototype.removeAccessToken = function (r) {
      return __awaiter$2(this, void 0, void 0, function () {
        var t;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              if (!(t = this.getAccessTokenCredential(r))) return [2];
              if (t.credentialType.toLowerCase() !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) return [3, 4];
              if (t.tokenType !== AuthenticationScheme.POP) return [3, 4];
              if (!(t = t.keyId)) return [3, 4];
              e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), [4, this.cryptoImpl.removeTokenBindingKey(t)];
            case 2:
              return e.sent(), [3, 4];
            case 3:
              throw e.sent(), ClientAuthError.createBindingKeyNotRemovedError();
            case 4:
              return [2, this.removeItem(r)];
          }
        });
      });
    }, e.prototype.removeAppMetadata = function () {
      var t = this;
      return this.getKeys().forEach(function (e) {
        t.isAppMetadata(e) && t.removeItem(e);
      }), !0;
    }, e.prototype.readCacheRecord = function (e, t, r) {
      var n = this.getTokenKeys(),
        i = this.readAccountFromCache(e),
        o = this.getIdToken(e, n),
        t = this.getAccessToken(e, t, n),
        e = this.getRefreshToken(e, !1, n),
        n = this.readAppMetadataFromCache(r);
      return i && o && (i.idTokenClaims = new AuthToken(o.secret, this.cryptoImpl).claims), {
        account: i,
        idToken: o,
        accessToken: t,
        refreshToken: e,
        appMetadata: n
      };
    }, e.prototype.readAccountFromCache = function (e) {
      e = AccountEntity.generateAccountCacheKey(e);
      return this.getAccount(e);
    }, e.prototype.getIdToken = function (e, t) {
      var r = this,
        e = (this.commonLogger.trace("CacheManager - getIdToken called"), {
          homeAccountId: e.homeAccountId,
          environment: e.environment,
          credentialType: CredentialType.ID_TOKEN,
          clientId: this.clientId,
          realm: e.tenantId
        }),
        e = this.getIdTokensByFilter(e, t),
        t = e.length;
      return t < 1 ? (this.commonLogger.info("CacheManager:getIdToken - No token found"), null) : 1 < t ? (this.commonLogger.info("CacheManager:getIdToken - Multiple id tokens found, clearing them"), e.forEach(function (e) {
        r.removeIdToken(e.generateCredentialKey());
      }), null) : (this.commonLogger.info("CacheManager:getIdToken - Returning id token"), e[0]);
    }, e.prototype.getIdTokensByFilter = function (t, e) {
      var r = this,
        e = e && e.idToken || this.getTokenKeys().idToken,
        n = [];
      return e.forEach(function (e) {
        r.idTokenKeyMatchesFilter(e, __assign$4({
          clientId: r.clientId
        }, t)) && (e = r.getIdTokenCredential(e)) && r.credentialMatchesFilter(e, t) && n.push(e);
      }), n;
    }, e.prototype.idTokenKeyMatchesFilter = function (e, t) {
      e = e.toLowerCase();
      return !(t.clientId && -1 === e.indexOf(t.clientId.toLowerCase()) || t.homeAccountId && -1 === e.indexOf(t.homeAccountId.toLowerCase()));
    }, e.prototype.removeIdToken = function (e) {
      this.removeItem(e);
    }, e.prototype.removeRefreshToken = function (e) {
      this.removeItem(e);
    }, e.prototype.getAccessToken = function (e, t, r) {
      var n = this,
        i = (this.commonLogger.trace("CacheManager - getAccessToken called"), ScopeSet.createSearchScopes(t.scopes)),
        o = t.authenticationScheme || AuthenticationScheme.BEARER,
        a = o && o.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN,
        s = {
          homeAccountId: e.homeAccountId,
          environment: e.environment,
          credentialType: a,
          clientId: this.clientId,
          realm: e.tenantId,
          target: i,
          tokenType: o,
          keyId: t.sshKid,
          requestedClaimsHash: t.requestedClaimsHash
        },
        a = r && r.accessToken || this.getTokenKeys().accessToken,
        l = [],
        e = (a.forEach(function (e) {
          n.accessTokenKeyMatchesFilter(e, s, !0) && (e = n.getAccessTokenCredential(e)) && n.credentialMatchesFilter(e, s) && l.push(e);
        }), l.length);
      return e < 1 ? (this.commonLogger.info("CacheManager:getAccessToken - No token found"), null) : 1 < e ? (this.commonLogger.info("CacheManager:getAccessToken - Multiple access tokens found, clearing them"), l.forEach(function (e) {
        n.removeAccessToken(e.generateCredentialKey());
      }), null) : (this.commonLogger.info("CacheManager:getAccessToken - Returning access token"), l[0]);
    }, e.prototype.accessTokenKeyMatchesFilter = function (e, t, r) {
      var n = e.toLowerCase();
      if (t.clientId && -1 === n.indexOf(t.clientId.toLowerCase())) return !1;
      if (t.homeAccountId && -1 === n.indexOf(t.homeAccountId.toLowerCase())) return !1;
      if (t.realm && -1 === n.indexOf(t.realm.toLowerCase())) return !1;
      if (t.requestedClaimsHash && -1 === n.indexOf(t.requestedClaimsHash.toLowerCase())) return !1;
      if (t.target) for (var i = t.target.asArray(), o = 0; o < i.length; o++) {
        if (r && !n.includes(i[o].toLowerCase())) return !1;
        if (!r && n.includes(i[o].toLowerCase())) return !0;
      }
      return !0;
    }, e.prototype.getAccessTokensByFilter = function (t) {
      var r = this,
        e = this.getTokenKeys(),
        n = [];
      return e.accessToken.forEach(function (e) {
        r.accessTokenKeyMatchesFilter(e, t, !0) && (e = r.getAccessTokenCredential(e)) && r.credentialMatchesFilter(e, t) && n.push(e);
      }), n;
    }, e.prototype.getRefreshToken = function (e, t, r) {
      var n = this,
        t = (this.commonLogger.trace("CacheManager - getRefreshToken called"), t ? THE_FAMILY_ID : void 0),
        i = {
          homeAccountId: e.homeAccountId,
          environment: e.environment,
          credentialType: CredentialType.REFRESH_TOKEN,
          clientId: this.clientId,
          familyId: t
        },
        e = r && r.refreshToken || this.getTokenKeys().refreshToken,
        o = [];
      return e.forEach(function (e) {
        n.refreshTokenKeyMatchesFilter(e, i) && (e = n.getRefreshTokenCredential(e)) && n.credentialMatchesFilter(e, i) && o.push(e);
      }), o.length < 1 ? (this.commonLogger.info("CacheManager:getRefreshToken - No refresh token found."), null) : (this.commonLogger.info("CacheManager:getRefreshToken - returning refresh token"), o[0]);
    }, e.prototype.refreshTokenKeyMatchesFilter = function (e, t) {
      e = e.toLowerCase();
      return !(t.familyId && -1 === e.indexOf(t.familyId.toLowerCase()) || !t.familyId && t.clientId && -1 === e.indexOf(t.clientId.toLowerCase()) || t.homeAccountId && -1 === e.indexOf(t.homeAccountId.toLowerCase()));
    }, e.prototype.readAppMetadataFromCache = function (e) {
      var e = {
          environment: e,
          clientId: this.clientId
        },
        t = this.getAppMetadataFilteredBy(e),
        e = Object.keys(t).map(function (e) {
          return t[e];
        }),
        r = e.length;
      if (r < 1) return null;
      if (1 < r) throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();
      return e[0];
    }, e.prototype.isAppMetadataFOCI = function (e) {
      e = this.readAppMetadataFromCache(e);
      return !(!e || e.familyId !== THE_FAMILY_ID);
    }, e.prototype.matchHomeAccountId = function (e, t) {
      return !("string" != typeof e.homeAccountId || t !== e.homeAccountId);
    }, e.prototype.matchLocalAccountId = function (e, t) {
      return !("string" != typeof e.localAccountId || t !== e.localAccountId);
    }, e.prototype.matchUsername = function (e, t) {
      return !("string" != typeof e.username || t.toLowerCase() !== e.username.toLowerCase());
    }, e.prototype.matchUserAssertionHash = function (e, t) {
      return !(!e.userAssertionHash || t !== e.userAssertionHash);
    }, e.prototype.matchEnvironment = function (e, t) {
      t = this.getAuthorityMetadataByAlias(t);
      return !!(t && -1 < t.aliases.indexOf(e.environment));
    }, e.prototype.matchCredentialType = function (e, t) {
      return e.credentialType && t.toLowerCase() === e.credentialType.toLowerCase();
    }, e.prototype.matchClientId = function (e, t) {
      return !(!e.clientId || t !== e.clientId);
    }, e.prototype.matchFamilyId = function (e, t) {
      return !(!e.familyId || t !== e.familyId);
    }, e.prototype.matchRealm = function (e, t) {
      return !(!e.realm || t !== e.realm);
    }, e.prototype.matchNativeAccountId = function (e, t) {
      return !(!e.nativeAccountId || t !== e.nativeAccountId);
    }, e.prototype.matchTarget = function (e, t) {
      return !(e.credentialType !== CredentialType.ACCESS_TOKEN && e.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME || !e.target) && ScopeSet.fromString(e.target).containsScopeSet(t);
    }, e.prototype.matchTokenType = function (e, t) {
      return !(!e.tokenType || e.tokenType !== t);
    }, e.prototype.matchKeyId = function (e, t) {
      return !(!e.keyId || e.keyId !== t);
    }, e.prototype.isAppMetadata = function (e) {
      return -1 !== e.indexOf(APP_METADATA);
    }, e.prototype.isAuthorityMetadata = function (e) {
      return -1 !== e.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY);
    }, e.prototype.generateAuthorityMetadataCacheKey = function (e) {
      return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + "-" + this.clientId + "-" + e;
    }, e.toObject = function (e, t) {
      for (var r in t) e[r] = t[r];
      return e;
    }, e;
  }(),
  DefaultStorageClass = function (e) {
    function t() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends$f(t, e), t.prototype.setAccount = function () {
      throw AuthError.createUnexpectedError("Storage interface - setAccount() has not been implemented for the cacheStorage interface.");
    }, t.prototype.getAccount = function () {
      throw AuthError.createUnexpectedError("Storage interface - getAccount() has not been implemented for the cacheStorage interface.");
    }, t.prototype.setIdTokenCredential = function () {
      throw AuthError.createUnexpectedError("Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.");
    }, t.prototype.getIdTokenCredential = function () {
      throw AuthError.createUnexpectedError("Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.");
    }, t.prototype.setAccessTokenCredential = function () {
      throw AuthError.createUnexpectedError("Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.");
    }, t.prototype.getAccessTokenCredential = function () {
      throw AuthError.createUnexpectedError("Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.");
    }, t.prototype.setRefreshTokenCredential = function () {
      throw AuthError.createUnexpectedError("Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.");
    }, t.prototype.getRefreshTokenCredential = function () {
      throw AuthError.createUnexpectedError("Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.");
    }, t.prototype.setAppMetadata = function () {
      throw AuthError.createUnexpectedError("Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.");
    }, t.prototype.getAppMetadata = function () {
      throw AuthError.createUnexpectedError("Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.");
    }, t.prototype.setServerTelemetry = function () {
      throw AuthError.createUnexpectedError("Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.");
    }, t.prototype.getServerTelemetry = function () {
      throw AuthError.createUnexpectedError("Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.");
    }, t.prototype.setAuthorityMetadata = function () {
      throw AuthError.createUnexpectedError("Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.");
    }, t.prototype.getAuthorityMetadata = function () {
      throw AuthError.createUnexpectedError("Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.");
    }, t.prototype.getAuthorityMetadataKeys = function () {
      throw AuthError.createUnexpectedError("Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.");
    }, t.prototype.setThrottlingCache = function () {
      throw AuthError.createUnexpectedError("Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.");
    }, t.prototype.getThrottlingCache = function () {
      throw AuthError.createUnexpectedError("Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.");
    }, t.prototype.removeItem = function () {
      throw AuthError.createUnexpectedError("Storage interface - removeItem() has not been implemented for the cacheStorage interface.");
    }, t.prototype.containsKey = function () {
      throw AuthError.createUnexpectedError("Storage interface - containsKey() has not been implemented for the cacheStorage interface.");
    }, t.prototype.getKeys = function () {
      throw AuthError.createUnexpectedError("Storage interface - getKeys() has not been implemented for the cacheStorage interface.");
    }, t.prototype.getAccountKeys = function () {
      throw AuthError.createUnexpectedError("Storage interface - getAccountKeys() has not been implemented for the cacheStorage interface.");
    }, t.prototype.getTokenKeys = function () {
      throw AuthError.createUnexpectedError("Storage interface - getTokenKeys() has not been implemented for the cacheStorage interface.");
    }, t.prototype.clear = function () {
      return __awaiter$2(this, void 0, void 0, function () {
        return __generator$2(this, function (e) {
          throw AuthError.createUnexpectedError("Storage interface - clear() has not been implemented for the cacheStorage interface.");
        });
      });
    }, t.prototype.updateCredentialCacheKey = function () {
      throw AuthError.createUnexpectedError("Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.");
    }, t;
  }(CacheManager),
  DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300,
  DEFAULT_SYSTEM_OPTIONS = {
    tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
    preventCorsPreflight: !1
  },
  DEFAULT_LOGGER_IMPLEMENTATION = {
    loggerCallback: function () {},
    piiLoggingEnabled: !1,
    logLevel: LogLevel.Info,
    correlationId: Constants.EMPTY_STRING
  },
  DEFAULT_CACHE_OPTIONS = {
    claimsBasedCachingEnabled: !0
  },
  DEFAULT_NETWORK_IMPLEMENTATION = {
    sendGetRequestAsync: function () {
      return __awaiter$2(this, void 0, void 0, function () {
        return __generator$2(this, function (e) {
          throw AuthError.createUnexpectedError("Network interface - sendGetRequestAsync() has not been implemented");
        });
      });
    },
    sendPostRequestAsync: function () {
      return __awaiter$2(this, void 0, void 0, function () {
        return __generator$2(this, function (e) {
          throw AuthError.createUnexpectedError("Network interface - sendPostRequestAsync() has not been implemented");
        });
      });
    }
  },
  DEFAULT_LIBRARY_INFO = {
    sku: Constants.SKU,
    version: version$1,
    cpu: Constants.EMPTY_STRING,
    os: Constants.EMPTY_STRING
  },
  DEFAULT_CLIENT_CREDENTIALS = {
    clientSecret: Constants.EMPTY_STRING,
    clientAssertion: void 0
  },
  DEFAULT_AZURE_CLOUD_OPTIONS = {
    azureCloudInstance: AzureCloudInstance.None,
    tenant: "" + Constants.DEFAULT_COMMON_TENANT
  },
  DEFAULT_TELEMETRY_OPTIONS = {
    application: {
      appName: "",
      appVersion: ""
    }
  };
function buildClientConfiguration(e) {
  var t = e.authOptions,
    r = e.systemOptions,
    n = e.loggerOptions,
    i = e.cacheOptions,
    o = e.storageInterface,
    a = e.networkInterface,
    s = e.cryptoInterface,
    l = e.clientCredentials,
    c = e.libraryInfo,
    u = e.telemetry,
    h = e.serverTelemetryManager,
    d = e.persistencePlugin,
    e = e.serializableCache,
    n = __assign$4(__assign$4({}, DEFAULT_LOGGER_IMPLEMENTATION), n);
  return {
    authOptions: buildAuthOptions(t),
    systemOptions: __assign$4(__assign$4({}, DEFAULT_SYSTEM_OPTIONS), r),
    loggerOptions: n,
    cacheOptions: __assign$4(__assign$4({}, DEFAULT_CACHE_OPTIONS), i),
    storageInterface: o || new DefaultStorageClass(t.clientId, DEFAULT_CRYPTO_IMPLEMENTATION, new Logger(n)),
    networkInterface: a || DEFAULT_NETWORK_IMPLEMENTATION,
    cryptoInterface: s || DEFAULT_CRYPTO_IMPLEMENTATION,
    clientCredentials: l || DEFAULT_CLIENT_CREDENTIALS,
    libraryInfo: __assign$4(__assign$4({}, DEFAULT_LIBRARY_INFO), c),
    telemetry: __assign$4(__assign$4({}, DEFAULT_TELEMETRY_OPTIONS), u),
    serverTelemetryManager: h || null,
    persistencePlugin: d || null,
    serializableCache: e || null
  };
}
function buildAuthOptions(e) {
  return __assign$4({
    clientCapabilities: [],
    azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS,
    skipAuthorityMetadataCache: !1
  }, e);
}
var CcsCredentialType,
  PerformanceEvents,
  PerformanceEventStatus,
  KeyLocation,
  ServerError = function (n) {
    function i(e, t, r) {
      e = n.call(this, e, t, r) || this;
      return e.name = "ServerError", Object.setPrototypeOf(e, i.prototype), e;
    }
    return __extends$f(i, n), i;
  }(AuthError),
  ThrottlingUtils = function () {
    function i() {}
    return i.generateThrottlingStorageKey = function (e) {
      return ThrottlingConstants.THROTTLING_PREFIX + "." + JSON.stringify(e);
    }, i.preProcess = function (e, t) {
      var r,
        t = i.generateThrottlingStorageKey(t),
        n = e.getThrottlingCache(t);
      if (n) {
        if (!(n.throttleTime < Date.now())) throw new ServerError((null == (r = n.errorCodes) ? void 0 : r.join(" ")) || Constants.EMPTY_STRING, n.errorMessage, n.subError);
        e.removeItem(t);
      }
    }, i.postProcess = function (e, t, r) {
      (i.checkResponseStatus(r) || i.checkResponseForRetryAfter(r)) && (r = {
        throttleTime: i.calculateThrottleTime(parseInt(r.headers[HeaderNames.RETRY_AFTER])),
        error: r.body.error,
        errorCodes: r.body.error_codes,
        errorMessage: r.body.error_description,
        subError: r.body.suberror
      }, e.setThrottlingCache(i.generateThrottlingStorageKey(t), r));
    }, i.checkResponseStatus = function (e) {
      return 429 === e.status || 500 <= e.status && e.status < 600;
    }, i.checkResponseForRetryAfter = function (e) {
      return !!e.headers && e.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (e.status < 200 || 300 <= e.status);
    }, i.calculateThrottleTime = function (e) {
      var e = e <= 0 ? 0 : e,
        t = Date.now() / 1e3;
      return Math.floor(1e3 * Math.min(t + (e || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), t + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS));
    }, i.removeThrottle = function (e, t, r, n) {
      t = {
        clientId: t,
        authority: r.authority,
        scopes: r.scopes,
        homeAccountIdentifier: n,
        claims: r.claims,
        authenticationScheme: r.authenticationScheme,
        resourceRequestMethod: r.resourceRequestMethod,
        resourceRequestUri: r.resourceRequestUri,
        shrClaims: r.shrClaims,
        sshKid: r.sshKid
      }, n = this.generateThrottlingStorageKey(t);
      e.removeItem(n);
    }, i;
  }(),
  NetworkManager = function () {
    function e(e, t) {
      this.networkClient = e, this.cacheManager = t;
    }
    return e.prototype.sendPostRequest = function (n, i, o) {
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              ThrottlingUtils.preProcess(this.cacheManager, n), e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), [4, this.networkClient.sendPostRequestAsync(i, o)];
            case 2:
              return t = e.sent(), [3, 4];
            case 3:
              throw (r = e.sent()) instanceof AuthError ? r : ClientAuthError.createNetworkError(i, r);
            case 4:
              return ThrottlingUtils.postProcess(this.cacheManager, n, t), [2, t];
          }
        });
      });
    }, e;
  }(),
  RequestValidator = (!function (e) {
    e.HOME_ACCOUNT_ID = "home_account_id", e.UPN = "UPN";
  }(CcsCredentialType = CcsCredentialType || {}), function () {
    function e() {}
    return e.validateRedirectUri = function (e) {
      if (StringUtils.isEmpty(e)) throw ClientConfigurationError.createRedirectUriEmptyError();
    }, e.validatePrompt = function (e) {
      var t,
        r = [];
      for (t in PromptValue) r.push(PromptValue[t]);
      if (r.indexOf(e) < 0) throw ClientConfigurationError.createInvalidPromptError(e);
    }, e.validateClaims = function (e) {
      try {
        JSON.parse(e);
      } catch (e) {
        throw ClientConfigurationError.createInvalidClaimsRequestError();
      }
    }, e.validateCodeChallengeParams = function (e, t) {
      if (StringUtils.isEmpty(e) || StringUtils.isEmpty(t)) throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
      this.validateCodeChallengeMethod(t);
    }, e.validateCodeChallengeMethod = function (e) {
      if ([CodeChallengeMethodValues.PLAIN, CodeChallengeMethodValues.S256].indexOf(e) < 0) throw ClientConfigurationError.createInvalidCodeChallengeMethodError();
    }, e.sanitizeEQParams = function (r, e) {
      return r ? (e.forEach(function (e, t) {
        r[t] && delete r[t];
      }), Object.fromEntries(Object.entries(r).filter(function (e) {
        return "" !== e[1];
      }))) : {};
    }, e;
  }()),
  RequestParameterBuilder = function () {
    function e() {
      this.parameters = new Map();
    }
    return e.prototype.addResponseTypeCode = function () {
      this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.CODE_RESPONSE_TYPE));
    }, e.prototype.addResponseTypeForTokenAndIdToken = function () {
      this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.TOKEN_RESPONSE_TYPE + " " + Constants.ID_TOKEN_RESPONSE_TYPE));
    }, e.prototype.addResponseMode = function (e) {
      this.parameters.set(AADServerParamKeys.RESPONSE_MODE, encodeURIComponent(e || ResponseMode.QUERY));
    }, e.prototype.addNativeBroker = function () {
      this.parameters.set(AADServerParamKeys.NATIVE_BROKER, encodeURIComponent("1"));
    }, e.prototype.addScopes = function (e, t) {
      t = (t = void 0 === t ? !0 : t) ? __spreadArrays(e || [], OIDC_DEFAULT_SCOPES) : e || [], e = new ScopeSet(t);
      this.parameters.set(AADServerParamKeys.SCOPE, encodeURIComponent(e.printScopes()));
    }, e.prototype.addClientId = function (e) {
      this.parameters.set(AADServerParamKeys.CLIENT_ID, encodeURIComponent(e));
    }, e.prototype.addRedirectUri = function (e) {
      RequestValidator.validateRedirectUri(e), this.parameters.set(AADServerParamKeys.REDIRECT_URI, encodeURIComponent(e));
    }, e.prototype.addPostLogoutRedirectUri = function (e) {
      RequestValidator.validateRedirectUri(e), this.parameters.set(AADServerParamKeys.POST_LOGOUT_URI, encodeURIComponent(e));
    }, e.prototype.addIdTokenHint = function (e) {
      this.parameters.set(AADServerParamKeys.ID_TOKEN_HINT, encodeURIComponent(e));
    }, e.prototype.addDomainHint = function (e) {
      this.parameters.set(SSOTypes.DOMAIN_HINT, encodeURIComponent(e));
    }, e.prototype.addLoginHint = function (e) {
      this.parameters.set(SSOTypes.LOGIN_HINT, encodeURIComponent(e));
    }, e.prototype.addCcsUpn = function (e) {
      this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("UPN:" + e));
    }, e.prototype.addCcsOid = function (e) {
      this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("Oid:" + e.uid + "@" + e.utid));
    }, e.prototype.addSid = function (e) {
      this.parameters.set(SSOTypes.SID, encodeURIComponent(e));
    }, e.prototype.addClaims = function (e, t) {
      e = this.addClientCapabilitiesToClaims(e, t);
      RequestValidator.validateClaims(e), this.parameters.set(AADServerParamKeys.CLAIMS, encodeURIComponent(e));
    }, e.prototype.addCorrelationId = function (e) {
      this.parameters.set(AADServerParamKeys.CLIENT_REQUEST_ID, encodeURIComponent(e));
    }, e.prototype.addLibraryInfo = function (e) {
      this.parameters.set(AADServerParamKeys.X_CLIENT_SKU, e.sku), this.parameters.set(AADServerParamKeys.X_CLIENT_VER, e.version), e.os && this.parameters.set(AADServerParamKeys.X_CLIENT_OS, e.os), e.cpu && this.parameters.set(AADServerParamKeys.X_CLIENT_CPU, e.cpu);
    }, e.prototype.addApplicationTelemetry = function (e) {
      null != e && e.appName && this.parameters.set(AADServerParamKeys.X_APP_NAME, e.appName), null != e && e.appVersion && this.parameters.set(AADServerParamKeys.X_APP_VER, e.appVersion);
    }, e.prototype.addPrompt = function (e) {
      RequestValidator.validatePrompt(e), this.parameters.set("" + AADServerParamKeys.PROMPT, encodeURIComponent(e));
    }, e.prototype.addState = function (e) {
      StringUtils.isEmpty(e) || this.parameters.set(AADServerParamKeys.STATE, encodeURIComponent(e));
    }, e.prototype.addNonce = function (e) {
      this.parameters.set(AADServerParamKeys.NONCE, encodeURIComponent(e));
    }, e.prototype.addCodeChallengeParams = function (e, t) {
      if (RequestValidator.validateCodeChallengeParams(e, t), !e || !t) throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
      this.parameters.set(AADServerParamKeys.CODE_CHALLENGE, encodeURIComponent(e)), this.parameters.set(AADServerParamKeys.CODE_CHALLENGE_METHOD, encodeURIComponent(t));
    }, e.prototype.addAuthorizationCode = function (e) {
      this.parameters.set(AADServerParamKeys.CODE, encodeURIComponent(e));
    }, e.prototype.addDeviceCode = function (e) {
      this.parameters.set(AADServerParamKeys.DEVICE_CODE, encodeURIComponent(e));
    }, e.prototype.addRefreshToken = function (e) {
      this.parameters.set(AADServerParamKeys.REFRESH_TOKEN, encodeURIComponent(e));
    }, e.prototype.addCodeVerifier = function (e) {
      this.parameters.set(AADServerParamKeys.CODE_VERIFIER, encodeURIComponent(e));
    }, e.prototype.addClientSecret = function (e) {
      this.parameters.set(AADServerParamKeys.CLIENT_SECRET, encodeURIComponent(e));
    }, e.prototype.addClientAssertion = function (e) {
      StringUtils.isEmpty(e) || this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION, encodeURIComponent(e));
    }, e.prototype.addClientAssertionType = function (e) {
      StringUtils.isEmpty(e) || this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION_TYPE, encodeURIComponent(e));
    }, e.prototype.addOboAssertion = function (e) {
      this.parameters.set(AADServerParamKeys.OBO_ASSERTION, encodeURIComponent(e));
    }, e.prototype.addRequestTokenUse = function (e) {
      this.parameters.set(AADServerParamKeys.REQUESTED_TOKEN_USE, encodeURIComponent(e));
    }, e.prototype.addGrantType = function (e) {
      this.parameters.set(AADServerParamKeys.GRANT_TYPE, encodeURIComponent(e));
    }, e.prototype.addClientInfo = function () {
      this.parameters.set(CLIENT_INFO, "1");
    }, e.prototype.addExtraQueryParameters = function (t) {
      var r = this,
        e = RequestValidator.sanitizeEQParams(t, this.parameters);
      Object.keys(e).forEach(function (e) {
        r.parameters.set(e, t[e]);
      });
    }, e.prototype.addClientCapabilitiesToClaims = function (e, t) {
      var r;
      if (e) try {
        r = JSON.parse(e);
      } catch (e) {
        throw ClientConfigurationError.createInvalidClaimsRequestError();
      } else r = {};
      return t && 0 < t.length && (r.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN) || (r[ClaimsRequestKeys.ACCESS_TOKEN] = {}), r[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
        values: t
      }), JSON.stringify(r);
    }, e.prototype.addUsername = function (e) {
      this.parameters.set(PasswordGrantConstants.username, encodeURIComponent(e));
    }, e.prototype.addPassword = function (e) {
      this.parameters.set(PasswordGrantConstants.password, encodeURIComponent(e));
    }, e.prototype.addPopToken = function (e) {
      StringUtils.isEmpty(e) || (this.parameters.set(AADServerParamKeys.TOKEN_TYPE, AuthenticationScheme.POP), this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(e)));
    }, e.prototype.addSshJwk = function (e) {
      StringUtils.isEmpty(e) || (this.parameters.set(AADServerParamKeys.TOKEN_TYPE, AuthenticationScheme.SSH), this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(e)));
    }, e.prototype.addServerTelemetry = function (e) {
      this.parameters.set(AADServerParamKeys.X_CLIENT_CURR_TELEM, e.generateCurrentRequestHeaderValue()), this.parameters.set(AADServerParamKeys.X_CLIENT_LAST_TELEM, e.generateLastRequestHeaderValue());
    }, e.prototype.addThrottling = function () {
      this.parameters.set(AADServerParamKeys.X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
    }, e.prototype.addLogoutHint = function (e) {
      this.parameters.set(AADServerParamKeys.LOGOUT_HINT, encodeURIComponent(e));
    }, e.prototype.createQueryString = function () {
      var r = new Array();
      return this.parameters.forEach(function (e, t) {
        r.push(t + "=" + e);
      }), r.join("&");
    }, e;
  }(),
  BaseClient = function () {
    function e(e, t) {
      this.config = buildClientConfiguration(e), this.logger = new Logger(this.config.loggerOptions, name$1, version$1), this.cryptoUtils = this.config.cryptoInterface, this.cacheManager = this.config.storageInterface, this.networkClient = this.config.networkInterface, this.networkManager = new NetworkManager(this.networkClient, this.cacheManager), this.serverTelemetryManager = this.config.serverTelemetryManager, this.authority = this.config.authOptions.authority, this.performanceClient = t;
    }
    return e.prototype.createTokenRequestHeaders = function (e) {
      var t = {};
      if (t[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE, !this.config.systemOptions.preventCorsPreflight && e) switch (e.type) {
        case CcsCredentialType.HOME_ACCOUNT_ID:
          try {
            var r = buildClientInfoFromHomeAccountId(e.credential);
            t[HeaderNames.CCS_HEADER] = "Oid:" + r.uid + "@" + r.utid;
          } catch (e) {
            this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
          }
          break;
        case CcsCredentialType.UPN:
          t[HeaderNames.CCS_HEADER] = "UPN: " + e.credential;
      }
      return t;
    }, e.prototype.executePostToTokenEndpoint = function (r, n, i, o) {
      return __awaiter$2(this, void 0, void 0, function () {
        var t;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.networkManager.sendPostRequest(o, r, {
                body: n,
                headers: i
              })];
            case 1:
              return t = e.sent(), this.config.serverTelemetryManager && t.status < 500 && 429 !== t.status && this.config.serverTelemetryManager.clearTelemetryCache(), [2, t];
          }
        });
      });
    }, e.prototype.updateAuthority = function (e) {
      if (!e.discoveryComplete()) throw ClientAuthError.createEndpointDiscoveryIncompleteError("Updated authority has not completed endpoint discovery.");
      this.authority = e;
    }, e.prototype.createTokenQueryParameters = function (e) {
      var t = new RequestParameterBuilder();
      return e.tokenQueryParameters && t.addExtraQueryParameters(e.tokenQueryParameters), t.createQueryString();
    }, e;
  }(),
  CredentialEntity = function () {
    function e() {}
    return e.prototype.generateAccountId = function () {
      return e.generateAccountIdForCacheKey(this.homeAccountId, this.environment);
    }, e.prototype.generateCredentialId = function () {
      return e.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId);
    }, e.prototype.generateTarget = function () {
      return e.generateTargetForCacheKey(this.target);
    }, e.prototype.generateCredentialKey = function () {
      return e.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId, this.tokenType, this.requestedClaimsHash);
    }, e.prototype.generateType = function () {
      switch (this.credentialType) {
        case CredentialType.ID_TOKEN:
          return CacheType.ID_TOKEN;
        case CredentialType.ACCESS_TOKEN:
        case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
          return CacheType.ACCESS_TOKEN;
        case CredentialType.REFRESH_TOKEN:
          return CacheType.REFRESH_TOKEN;
        default:
          throw ClientAuthError.createUnexpectedCredentialTypeError();
      }
    }, e.generateCredentialCacheKey = function (e, t, r, n, i, o, a, s, l) {
      return [this.generateAccountIdForCacheKey(e, t), this.generateCredentialIdForCacheKey(r, n, i, a), this.generateTargetForCacheKey(o), this.generateClaimsHashForCacheKey(l), this.generateSchemeForCacheKey(s)].join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    }, e.generateAccountIdForCacheKey = function (e, t) {
      return [e, t].join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    }, e.generateCredentialIdForCacheKey = function (e, t, r, n) {
      return [e, e === CredentialType.REFRESH_TOKEN && n || t, r || Constants.EMPTY_STRING].join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    }, e.generateTargetForCacheKey = function (e) {
      return (e || Constants.EMPTY_STRING).toLowerCase();
    }, e.generateClaimsHashForCacheKey = function (e) {
      return (e || Constants.EMPTY_STRING).toLowerCase();
    }, e.generateSchemeForCacheKey = function (e) {
      return e && e.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? e.toLowerCase() : Constants.EMPTY_STRING;
    }, e;
  }(),
  IdTokenEntity = function (e) {
    function a() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends$f(a, e), a.createIdTokenEntity = function (e, t, r, n, i) {
      var o = new a();
      return o.credentialType = CredentialType.ID_TOKEN, o.homeAccountId = e, o.environment = t, o.clientId = n, o.secret = r, o.realm = i, o;
    }, a.isIdTokenEntity = function (e) {
      return !!e && e.hasOwnProperty("homeAccountId") && e.hasOwnProperty("environment") && e.hasOwnProperty("credentialType") && e.hasOwnProperty("realm") && e.hasOwnProperty("clientId") && e.hasOwnProperty("secret") && e.credentialType === CredentialType.ID_TOKEN;
    }, a;
  }(CredentialEntity),
  TimeUtils = function () {
    function r() {}
    return r.nowSeconds = function () {
      return Math.round(new Date().getTime() / 1e3);
    }, r.isTokenExpired = function (e, t) {
      return (Number(e) || 0) < r.nowSeconds() + t;
    }, r.wasClockTurnedBack = function (e) {
      return Number(e) > r.nowSeconds();
    }, r.delay = function (t, r) {
      return new Promise(function (e) {
        return setTimeout(function () {
          return e(r);
        }, t);
      });
    }, r;
  }(),
  AccessTokenEntity = function (e) {
    function y() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends$f(y, e), y.createAccessTokenEntity = function (e, t, r, n, i, o, a, s, l, c, u, h, d, p, f) {
      var _,
        m = new y(),
        e = (m.homeAccountId = e, m.credentialType = CredentialType.ACCESS_TOKEN, m.secret = r, TimeUtils.nowSeconds());
      if (m.cachedAt = e.toString(), m.expiresOn = a.toString(), m.extendedExpiresOn = s.toString(), c && (m.refreshOn = c.toString()), m.environment = t, m.clientId = n, m.realm = i, m.target = o, m.userAssertionHash = h, m.tokenType = StringUtils.isEmpty(u) ? AuthenticationScheme.BEARER : u, p && (m.requestedClaims = p, m.requestedClaimsHash = f), (null == (e = m.tokenType) ? void 0 : e.toLowerCase()) !== AuthenticationScheme.BEARER.toLowerCase()) switch (m.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME, m.tokenType) {
        case AuthenticationScheme.POP:
          var g = AuthToken.extractTokenClaims(r, l);
          if (null == (_ = null == g ? void 0 : g.cnf) || !_.kid) throw ClientAuthError.createTokenClaimsRequiredError();
          m.keyId = g.cnf.kid;
          break;
        case AuthenticationScheme.SSH:
          m.keyId = d;
      }
      return m;
    }, y.isAccessTokenEntity = function (e) {
      return !!e && e.hasOwnProperty("homeAccountId") && e.hasOwnProperty("environment") && e.hasOwnProperty("credentialType") && e.hasOwnProperty("realm") && e.hasOwnProperty("clientId") && e.hasOwnProperty("secret") && e.hasOwnProperty("target") && (e.credentialType === CredentialType.ACCESS_TOKEN || e.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
    }, y;
  }(CredentialEntity),
  RefreshTokenEntity = function (e) {
    function s() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends$f(s, e), s.createRefreshTokenEntity = function (e, t, r, n, i, o) {
      var a = new s();
      return a.clientId = n, a.credentialType = CredentialType.REFRESH_TOKEN, a.environment = t, a.homeAccountId = e, a.secret = r, a.userAssertionHash = o, i && (a.familyId = i), a;
    }, s.isRefreshTokenEntity = function (e) {
      return !!e && e.hasOwnProperty("homeAccountId") && e.hasOwnProperty("environment") && e.hasOwnProperty("credentialType") && e.hasOwnProperty("clientId") && e.hasOwnProperty("secret") && e.credentialType === CredentialType.REFRESH_TOKEN;
    }, s;
  }(CredentialEntity),
  InteractionRequiredServerErrorMessage = ["interaction_required", "consent_required", "login_required"],
  InteractionRequiredAuthSubErrorMessage = ["message_only", "additional_action", "basic_action", "user_password_expired", "consent_required"],
  InteractionRequiredAuthErrorMessage = {
    noTokensFoundError: {
      code: "no_tokens_found",
      desc: "No refresh token found in the cache. Please sign-in."
    },
    native_account_unavailable: {
      code: "native_account_unavailable",
      desc: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API."
    }
  },
  InteractionRequiredAuthError = function (s) {
    function l(e, t, r, n, i, o, a) {
      e = s.call(this, e, t, r) || this;
      return Object.setPrototypeOf(e, l.prototype), e.timestamp = n || Constants.EMPTY_STRING, e.traceId = i || Constants.EMPTY_STRING, e.correlationId = o || Constants.EMPTY_STRING, e.claims = a || Constants.EMPTY_STRING, e.name = "InteractionRequiredAuthError", e;
    }
    return __extends$f(l, s), l.isInteractionRequiredError = function (e, t, r) {
      var e = !!e && -1 < InteractionRequiredServerErrorMessage.indexOf(e),
        r = !!r && -1 < InteractionRequiredAuthSubErrorMessage.indexOf(r),
        n = !!t && InteractionRequiredServerErrorMessage.some(function (e) {
          return -1 < t.indexOf(e);
        });
      return e || n || r;
    }, l.createNoTokensFoundError = function () {
      return new l(InteractionRequiredAuthErrorMessage.noTokensFoundError.code, InteractionRequiredAuthErrorMessage.noTokensFoundError.desc);
    }, l.createNativeAccountUnavailableError = function () {
      return new l(InteractionRequiredAuthErrorMessage.native_account_unavailable.code, InteractionRequiredAuthErrorMessage.native_account_unavailable.desc);
    }, l;
  }(AuthError),
  CacheRecord = function (e, t, r, n, i) {
    this.account = e || null, this.idToken = t || null, this.accessToken = r || null, this.refreshToken = n || null, this.appMetadata = i || null;
  },
  ProtocolUtils = function () {
    function n() {}
    return n.setRequestState = function (e, t, r) {
      e = n.generateLibraryState(e, r);
      return StringUtils.isEmpty(t) ? e : "" + e + Constants.RESOURCE_DELIM + t;
    }, n.generateLibraryState = function (e, t) {
      var r;
      if (e) return r = {
        id: e.createNewGuid()
      }, t && (r.meta = t), t = JSON.stringify(r), e.base64Encode(t);
      throw ClientAuthError.createNoCryptoObjectError("generateLibraryState");
    }, n.parseRequestState = function (e, t) {
      if (!e) throw ClientAuthError.createNoCryptoObjectError("parseRequestState");
      if (StringUtils.isEmpty(t)) throw ClientAuthError.createInvalidStateError(t, "Null, undefined or empty state");
      try {
        var r = t.split(Constants.RESOURCE_DELIM),
          n = r[0],
          i = 1 < r.length ? r.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING,
          o = e.base64Decode(n),
          a = JSON.parse(o);
        return {
          userRequestState: StringUtils.isEmpty(i) ? Constants.EMPTY_STRING : i,
          libraryState: a
        };
      } catch (e) {
        throw ClientAuthError.createInvalidStateError(t, e);
      }
    }, n;
  }(),
  UrlString = function () {
    function n(e) {
      if (this._urlString = e, StringUtils.isEmpty(this._urlString)) throw ClientConfigurationError.createUrlEmptyError();
      StringUtils.isEmpty(this.getHash()) && (this._urlString = n.canonicalizeUri(e));
    }
    return Object.defineProperty(n.prototype, "urlString", {
      get: function () {
        return this._urlString;
      },
      enumerable: !1,
      configurable: !0
    }), n.canonicalizeUri = function (e) {
      var t;
      return e && (t = e.toLowerCase(), StringUtils.endsWith(t, "?") ? t = t.slice(0, -1) : StringUtils.endsWith(t, "?/") && (t = t.slice(0, -2)), StringUtils.endsWith(t, "/") || (t += "/"), t);
    }, n.prototype.validateAsUri = function () {
      var e;
      try {
        e = this.getUrlComponents();
      } catch (e) {
        throw ClientConfigurationError.createUrlParseError(e);
      }
      if (!e.HostNameAndPort || !e.PathSegments) throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
      if (!e.Protocol || "https:" !== e.Protocol.toLowerCase()) throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);
    }, n.appendQueryString = function (e, t) {
      return StringUtils.isEmpty(t) ? e : e.indexOf("?") < 0 ? e + "?" + t : e + "&" + t;
    }, n.removeHashFromUrl = function (e) {
      return n.canonicalizeUri(e.split("#")[0]);
    }, n.prototype.replaceTenantPath = function (e) {
      var t = this.getUrlComponents(),
        r = t.PathSegments;
      return !e || 0 === r.length || r[0] !== AADAuthorityConstants.COMMON && r[0] !== AADAuthorityConstants.ORGANIZATIONS || (r[0] = e), n.constructAuthorityUriFromObject(t);
    }, n.prototype.getHash = function () {
      return n.parseHash(this.urlString);
    }, n.prototype.getUrlComponents = function () {
      var e,
        t = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?"),
        t = this.urlString.match(t);
      if (t) return e = (e = (t = {
        Protocol: t[1],
        HostNameAndPort: t[4],
        AbsolutePath: t[5],
        QueryString: t[7]
      }).AbsolutePath.split("/")).filter(function (e) {
        return e && 0 < e.length;
      }), t.PathSegments = e, !StringUtils.isEmpty(t.QueryString) && t.QueryString.endsWith("/") && (t.QueryString = t.QueryString.substring(0, t.QueryString.length - 1)), t;
      throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
    }, n.getDomainFromUrl = function (e) {
      var t = RegExp("^([^:/?#]+://)?([^/?#]*)"),
        t = e.match(t);
      if (t) return t[2];
      throw ClientConfigurationError.createUrlParseError("Given url string: " + e);
    }, n.getAbsoluteUrl = function (e, t) {
      return e[0] === Constants.FORWARD_SLASH ? (t = new n(t).getUrlComponents()).Protocol + "//" + t.HostNameAndPort + e : e;
    }, n.parseHash = function (e) {
      var t = e.indexOf("#"),
        r = e.indexOf("#/");
      return -1 < r ? e.substring(r + 2) : -1 < t ? e.substring(t + 1) : Constants.EMPTY_STRING;
    }, n.parseQueryString = function (e) {
      var t = e.indexOf("?"),
        r = e.indexOf("/?");
      return -1 < r ? e.substring(r + 2) : -1 < t ? e.substring(t + 1) : Constants.EMPTY_STRING;
    }, n.constructAuthorityUriFromObject = function (e) {
      return new n(e.Protocol + "//" + e.HostNameAndPort + "/" + e.PathSegments.join("/"));
    }, n.getDeserializedHash = function (e) {
      if (StringUtils.isEmpty(e)) return {};
      var t = n.parseHash(e),
        e = StringUtils.queryStringToObject(StringUtils.isEmpty(t) ? e : t);
      if (e) return e;
      throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(e));
    }, n.getDeserializedQueryString = function (e) {
      if (StringUtils.isEmpty(e)) return {};
      var t = n.parseQueryString(e),
        e = StringUtils.queryStringToObject(StringUtils.isEmpty(t) ? e : t);
      if (e) return e;
      throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(e));
    }, n.hashContainsKnownProperties = function (e) {
      return !(StringUtils.isEmpty(e) || e.indexOf("=") < 0 || !((e = n.getDeserializedHash(e)).code || e.error_description || e.error || e.state));
    }, n;
  }(),
  IntFields = (!function (e) {
    e.AcquireTokenByCode = "acquireTokenByCode", e.AcquireTokenByRefreshToken = "acquireTokenByRefreshToken", e.AcquireTokenSilent = "acquireTokenSilent", e.AcquireTokenSilentAsync = "acquireTokenSilentAsync", e.AcquireTokenPopup = "acquireTokenPopup", e.CryptoOptsGetPublicKeyThumbprint = "cryptoOptsGetPublicKeyThumbprint", e.CryptoOptsSignJwt = "cryptoOptsSignJwt", e.SilentCacheClientAcquireToken = "silentCacheClientAcquireToken", e.SilentIframeClientAcquireToken = "silentIframeClientAcquireToken", e.SilentRefreshClientAcquireToken = "silentRefreshClientAcquireToken", e.SsoSilent = "ssoSilent", e.StandardInteractionClientGetDiscoveredAuthority = "standardInteractionClientGetDiscoveredAuthority", e.FetchAccountIdWithNativeBroker = "fetchAccountIdWithNativeBroker", e.NativeInteractionClientAcquireToken = "nativeInteractionClientAcquireToken", e.BaseClientCreateTokenRequestHeaders = "baseClientCreateTokenRequestHeaders", e.BrokerHandhshake = "brokerHandshake", e.AcquireTokenByRefreshTokenInBroker = "acquireTokenByRefreshTokenInBroker", e.AcquireTokenByBroker = "acquireTokenByBroker", e.RefreshTokenClientExecuteTokenRequest = "refreshTokenClientExecuteTokenRequest", e.RefreshTokenClientAcquireToken = "refreshTokenClientAcquireToken", e.RefreshTokenClientAcquireTokenWithCachedRefreshToken = "refreshTokenClientAcquireTokenWithCachedRefreshToken", e.RefreshTokenClientAcquireTokenByRefreshToken = "refreshTokenClientAcquireTokenByRefreshToken", e.RefreshTokenClientCreateTokenRequestBody = "refreshTokenClientCreateTokenRequestBody", e.AcquireTokenFromCache = "acquireTokenFromCache", e.AcquireTokenBySilentIframe = "acquireTokenBySilentIframe", e.InitializeBaseRequest = "initializeBaseRequest", e.InitializeSilentRequest = "initializeSilentRequest", e.InitializeClientApplication = "initializeClientApplication", e.SilentIframeClientTokenHelper = "silentIframeClientTokenHelper", e.SilentHandlerInitiateAuthRequest = "silentHandlerInitiateAuthRequest", e.SilentHandlerMonitorIframeForHash = "silentHandlerMonitorIframeForHash", e.SilentHandlerLoadFrame = "silentHandlerLoadFrame", e.StandardInteractionClientCreateAuthCodeClient = "standardInteractionClientCreateAuthCodeClient", e.StandardInteractionClientGetClientConfiguration = "standardInteractionClientGetClientConfiguration", e.StandardInteractionClientInitializeAuthorizationRequest = "standardInteractionClientInitializeAuthorizationRequest", e.StandardInteractionClientInitializeAuthorizationCodeRequest = "standardInteractionClientInitializeAuthorizationCodeRequest", e.GetAuthCodeUrl = "getAuthCodeUrl", e.HandleCodeResponseFromServer = "handleCodeResponseFromServer", e.HandleCodeResponseFromHash = "handleCodeResponseFromHash", e.UpdateTokenEndpointAuthority = "updateTokenEndpointAuthority", e.AuthClientAcquireToken = "authClientAcquireToken", e.AuthClientExecuteTokenRequest = "authClientExecuteTokenRequest", e.AuthClientCreateTokenRequestBody = "authClientCreateTokenRequestBody", e.AuthClientCreateQueryString = "authClientCreateQueryString", e.PopTokenGenerateCnf = "popTokenGenerateCnf", e.PopTokenGenerateKid = "popTokenGenerateKid", e.HandleServerTokenResponse = "handleServerTokenResponse", e.AuthorityFactoryCreateDiscoveredInstance = "authorityFactoryCreateDiscoveredInstance", e.AuthorityResolveEndpointsAsync = "authorityResolveEndpointsAsync", e.AuthorityGetCloudDiscoveryMetadataFromNetwork = "authorityGetCloudDiscoveryMetadataFromNetwork", e.AuthorityUpdateCloudDiscoveryMetadata = "authorityUpdateCloudDiscoveryMetadata", e.AuthorityGetEndpointMetadataFromNetwork = "authorityGetEndpointMetadataFromNetwork", e.AuthorityUpdateEndpointMetadata = "authorityUpdateEndpointMetadata", e.AuthorityUpdateMetadataWithRegionalInformation = "authorityUpdateMetadataWithRegionalInformation", e.RegionDiscoveryDetectRegion = "regionDiscoveryDetectRegion", e.RegionDiscoveryGetRegionFromIMDS = "regionDiscoveryGetRegionFromIMDS", e.RegionDiscoveryGetCurrentVersion = "regionDiscoveryGetCurrentVersion", e.AcquireTokenByCodeAsync = "acquireTokenByCodeAsync", e.GetEndpointMetadataFromNetwork = "getEndpointMetadataFromNetwork", e.GetCloudDiscoveryMetadataFromNetworkMeasurement = "getCloudDiscoveryMetadataFromNetworkMeasurement", e.HandleRedirectPromiseMeasurement = "handleRedirectPromiseMeasurement", e.UpdateCloudDiscoveryMetadataMeasurement = "updateCloudDiscoveryMetadataMeasurement", e.UsernamePasswordClientAcquireToken = "usernamePasswordClientAcquireToken", e.NativeMessageHandlerHandshake = "nativeMessageHandlerHandshake", e.ClearTokensAndKeysWithClaims = "clearTokensAndKeysWithClaims";
  }(PerformanceEvents = PerformanceEvents || {}), !function (e) {
    e[e.NotStarted = 0] = "NotStarted", e[e.InProgress = 1] = "InProgress", e[e.Completed = 2] = "Completed";
  }(PerformanceEventStatus = PerformanceEventStatus || {}), new Set(["accessTokenSize", "durationMs", "idTokenSize", "matsSilentStatus", "matsHttpStatus", "refreshTokenSize", "queuedTimeMs", "startTimeMs", "status"])),
  PopTokenGenerator = (!function (e) {
    e.SW = "sw", e.UHW = "uhw";
  }(KeyLocation = KeyLocation || {}), function () {
    function e(e, t) {
      this.cryptoUtils = e, this.performanceClient = t;
    }
    return e.prototype.generateCnf = function (n) {
      var i;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return null != (i = this.performanceClient) && i.addQueueMeasurement(PerformanceEvents.PopTokenGenerateCnf, n.correlationId), null != (i = this.performanceClient) && i.setPreQueueTime(PerformanceEvents.PopTokenGenerateKid, n.correlationId), [4, this.generateKid(n)];
            case 1:
              return r = e.sent(), t = this.cryptoUtils.base64Encode(JSON.stringify(r)), r = {
                kid: r.kid,
                reqCnfString: t
              }, [4, this.cryptoUtils.hashString(t)];
            case 2:
              return [2, (r.reqCnfHash = e.sent(), r)];
          }
        });
      });
    }, e.prototype.generateKid = function (t) {
      var r;
      return __awaiter$2(this, void 0, void 0, function () {
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return null != (r = this.performanceClient) && r.addQueueMeasurement(PerformanceEvents.PopTokenGenerateKid, t.correlationId), [4, this.cryptoUtils.getPublicKeyThumbprint(t)];
            case 1:
              return [2, {
                kid: e.sent(),
                xms_ksl: KeyLocation.SW
              }];
          }
        });
      });
    }, e.prototype.signPopToken = function (t, r, n) {
      return __awaiter$2(this, void 0, void 0, function () {
        return __generator$2(this, function (e) {
          return [2, this.signPayload(t, r, n)];
        });
      });
    }, e.prototype.signPayload = function (o, a, s, l) {
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r, n, i;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return t = s.resourceRequestMethod, i = s.resourceRequestUri, r = s.shrClaims, n = s.shrNonce, i = i ? new UrlString(i) : void 0, i = null == i ? void 0 : i.getUrlComponents(), [4, this.cryptoUtils.signJwt(__assign$4({
                at: o,
                ts: TimeUtils.nowSeconds(),
                m: null == t ? void 0 : t.toUpperCase(),
                u: null == i ? void 0 : i.HostNameAndPort,
                nonce: n || this.cryptoUtils.createNewGuid(),
                p: null == i ? void 0 : i.AbsolutePath,
                q: null != i && i.QueryString ? [[], i.QueryString] : void 0,
                client_claims: r || void 0
              }, l), a, s.correlationId)];
            case 1:
              return [2, e.sent()];
          }
        });
      });
    }, e;
  }()),
  AppMetadataEntity = function () {
    function i() {}
    return i.prototype.generateAppMetadataKey = function () {
      return i.generateAppMetadataCacheKey(this.environment, this.clientId);
    }, i.generateAppMetadataCacheKey = function (e, t) {
      return [APP_METADATA, e, t].join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    }, i.createAppMetadataEntity = function (e, t, r) {
      var n = new i();
      return n.clientId = e, n.environment = t, r && (n.familyId = r), n;
    }, i.isAppMetadataEntity = function (e, t) {
      return !!t && 0 === e.indexOf(APP_METADATA) && t.hasOwnProperty("clientId") && t.hasOwnProperty("environment");
    }, i;
  }(),
  TokenCacheContext = function () {
    function e(e, t) {
      this.cache = e, this.hasChanged = t;
    }
    return Object.defineProperty(e.prototype, "cacheHasChanged", {
      get: function () {
        return this.hasChanged;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "tokenCache", {
      get: function () {
        return this.cache;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(),
  ResponseHandler = function () {
    function m(e, t, r, n, i, o, a) {
      this.clientId = e, this.cacheStorage = t, this.cryptoObj = r, this.logger = n, this.serializableCache = i, this.persistencePlugin = o, this.performanceClient = a;
    }
    return m.prototype.validateServerAuthorizationCodeResponse = function (e, t, r) {
      if (!e.state || !t) throw e.state ? ClientAuthError.createStateNotFoundError("Cached State") : ClientAuthError.createStateNotFoundError("Server State");
      if (decodeURIComponent(e.state) !== decodeURIComponent(t)) throw ClientAuthError.createStateMismatchError();
      if (e.error || e.error_description || e.suberror) {
        if (InteractionRequiredAuthError.isInteractionRequiredError(e.error, e.error_description, e.suberror)) throw new InteractionRequiredAuthError(e.error || Constants.EMPTY_STRING, e.error_description, e.suberror, e.timestamp || Constants.EMPTY_STRING, e.trace_id || Constants.EMPTY_STRING, e.correlation_id || Constants.EMPTY_STRING, e.claims || Constants.EMPTY_STRING);
        throw new ServerError(e.error || Constants.EMPTY_STRING, e.error_description, e.suberror);
      }
      e.client_info && buildClientInfo(e.client_info, r);
    }, m.prototype.validateTokenResponse = function (e) {
      if (e.error || e.error_description || e.suberror) {
        if (InteractionRequiredAuthError.isInteractionRequiredError(e.error, e.error_description, e.suberror)) throw new InteractionRequiredAuthError(e.error, e.error_description, e.suberror, e.timestamp || Constants.EMPTY_STRING, e.trace_id || Constants.EMPTY_STRING, e.correlation_id || Constants.EMPTY_STRING, e.claims || Constants.EMPTY_STRING);
        var t = e.error_codes + " - [" + e.timestamp + "]: " + e.error_description + " - Correlation ID: " + e.correlation_id + " - Trace ID: " + e.trace_id;
        throw new ServerError(e.error, t, e.suberror);
      }
    }, m.prototype.handleServerTokenResponse = function (a, s, l, c, u, h, d, p, f) {
      var _;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r, n, i, o;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              if (null != (_ = this.performanceClient) && _.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, a.correlation_id), a.id_token) {
                if (t = new AuthToken(a.id_token || Constants.EMPTY_STRING, this.cryptoObj), u && !StringUtils.isEmpty(u.nonce) && t.claims.nonce !== u.nonce) throw ClientAuthError.createNonceMismatchError();
                if (c.maxAge || 0 === c.maxAge) {
                  if (!(n = t.claims.auth_time)) throw ClientAuthError.createAuthTimeNotFoundError();
                  AuthToken.checkMaxAge(n, c.maxAge);
                }
              }
              this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(a.client_info || Constants.EMPTY_STRING, s.authorityType, this.logger, this.cryptoObj, t), u && u.state && (r = ProtocolUtils.parseRequestState(this.cryptoObj, u.state)), a.key_id = a.key_id || c.sshKid || void 0, n = this.generateCacheRecord(a, s, l, c, t, h, u), e.label = 1;
            case 1:
              return (e.trys.push([1,, 5, 8]), this.persistencePlugin && this.serializableCache) ? (this.logger.verbose("Persistence enabled, calling beforeCacheAccess"), i = new TokenCacheContext(this.serializableCache, !0), [4, this.persistencePlugin.beforeCacheAccess(i)]) : [3, 3];
            case 2:
              e.sent(), e.label = 3;
            case 3:
              return !d || p || !n.account || (o = n.account.generateAccountKey(), this.cacheStorage.getAccount(o)) ? [4, this.cacheStorage.saveCacheRecord(n)] : (this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache"), [2, m.generateAuthenticationResult(this.cryptoObj, s, n, !1, c, t, r, void 0, f)]);
            case 4:
              return e.sent(), [3, 8];
            case 5:
              return this.persistencePlugin && this.serializableCache && i ? (this.logger.verbose("Persistence enabled, calling afterCacheAccess"), [4, this.persistencePlugin.afterCacheAccess(i)]) : [3, 7];
            case 6:
              e.sent(), e.label = 7;
            case 7:
              return [7];
            case 8:
              return [2, m.generateAuthenticationResult(this.cryptoObj, s, n, !1, c, t, r, a, f)];
          }
        });
      });
    }, m.prototype.generateCacheRecord = function (e, t, r, n, i, o, a) {
      var s,
        l,
        c = t.getPreferredCache();
      if (StringUtils.isEmpty(c)) throw ClientAuthError.createInvalidCacheEnvironmentError();
      !StringUtils.isEmpty(e.id_token) && i && (s = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, c, e.id_token || Constants.EMPTY_STRING, this.clientId, i.claims.tid || Constants.EMPTY_STRING), l = this.generateAccountEntity(e, i, t, a));
      var u,
        h,
        d,
        a = null,
        p = (StringUtils.isEmpty(e.access_token) || (u = e.scope ? ScopeSet.fromString(e.scope) : new ScopeSet(n.scopes || []), d = (h = r + (("string" == typeof e.expires_in ? parseInt(e.expires_in, 10) : e.expires_in) || 0)) + (("string" == typeof e.ext_expires_in ? parseInt(e.ext_expires_in, 10) : e.ext_expires_in) || 0), r = (p = ("string" == typeof e.refresh_in ? parseInt(e.refresh_in, 10) : e.refresh_in) || void 0) && 0 < p ? r + p : void 0, a = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, c, e.access_token || Constants.EMPTY_STRING, this.clientId, i ? i.claims.tid || Constants.EMPTY_STRING : t.tenant, u.printScopes(), h, d, this.cryptoObj, r, e.token_type, o, e.key_id, n.claims, n.requestedClaimsHash)), null),
        i = (StringUtils.isEmpty(e.refresh_token) || (p = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, c, e.refresh_token || Constants.EMPTY_STRING, this.clientId, e.foci, o)), null);
      return StringUtils.isEmpty(e.foci) || (i = AppMetadataEntity.createAppMetadataEntity(this.clientId, c, e.foci)), new CacheRecord(l, s, a, p, i);
    }, m.prototype.generateAccountEntity = function (e, t, r, n) {
      var i = r.authorityType,
        o = n ? n.cloud_graph_host_name : Constants.EMPTY_STRING,
        n = n ? n.msgraph_host : Constants.EMPTY_STRING;
      if (i === AuthorityType.Adfs) return this.logger.verbose("Authority type is ADFS, creating ADFS account"), AccountEntity.createGenericAccount(this.homeAccountIdentifier, t, r, o, n);
      if (StringUtils.isEmpty(e.client_info) && "AAD" === r.protocolMode) throw ClientAuthError.createClientInfoEmptyError();
      return e.client_info ? AccountEntity.createAccount(e.client_info, this.homeAccountIdentifier, t, r, o, n) : AccountEntity.createGenericAccount(this.homeAccountIdentifier, t, r, o, n);
    }, m.generateAuthenticationResult = function (c, u, h, d, p, f, _, m, g) {
      var y;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r, n, i, o, a, s, l;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              if (t = Constants.EMPTY_STRING, r = [], n = null, o = Constants.EMPTY_STRING, !h.accessToken) return [3, 4];
              if (h.accessToken.tokenType !== AuthenticationScheme.POP) return [3, 2];
              if (s = new PopTokenGenerator(c), a = h.accessToken, l = a.secret, a = a.keyId) return [4, s.signPopToken(l, a, p)];
              throw ClientAuthError.createKeyIdMissingError();
            case 1:
              return t = e.sent(), [3, 3];
            case 2:
              t = h.accessToken.secret, e.label = 3;
            case 3:
              r = ScopeSet.fromString(h.accessToken.target).asArray(), n = new Date(1e3 * Number(h.accessToken.expiresOn)), i = new Date(1e3 * Number(h.accessToken.extendedExpiresOn)), e.label = 4;
            case 4:
              return h.appMetadata && (o = h.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING), s = (null == f ? void 0 : f.claims.oid) || (null == f ? void 0 : f.claims.sub) || Constants.EMPTY_STRING, l = (null == f ? void 0 : f.claims.tid) || Constants.EMPTY_STRING, null != m && m.spa_accountid && h.account && (h.account.nativeAccountId = null == m ? void 0 : m.spa_accountid), [2, {
                authority: u.canonicalAuthority,
                uniqueId: s,
                tenantId: l,
                scopes: r,
                account: h.account ? h.account.getAccountInfo() : null,
                idToken: f ? f.rawToken : Constants.EMPTY_STRING,
                idTokenClaims: f ? f.claims : {},
                accessToken: t,
                fromCache: d,
                expiresOn: n,
                correlationId: p.correlationId,
                requestId: g || Constants.EMPTY_STRING,
                extExpiresOn: i,
                familyId: o,
                tokenType: (null == (y = h.accessToken) ? void 0 : y.tokenType) || Constants.EMPTY_STRING,
                state: _ ? _.userRequestState : Constants.EMPTY_STRING,
                cloudGraphHostName: (null == (y = h.account) ? void 0 : y.cloudGraphHostName) || Constants.EMPTY_STRING,
                msGraphHost: (null == (y = h.account) ? void 0 : y.msGraphHost) || Constants.EMPTY_STRING,
                code: null == m ? void 0 : m.spa_code,
                fromNativeBroker: !1
              }];
          }
        });
      });
    }, m;
  }(),
  AuthorizationCodeClient = function (r) {
    function e(e, t) {
      e = r.call(this, e, t) || this;
      return e.includeRedirectUri = !0, e;
    }
    return __extends$f(e, r), e.prototype.getAuthCodeUrl = function (r) {
      var n;
      return __awaiter$2(this, void 0, void 0, function () {
        var t;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return null != (n = this.performanceClient) && n.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, r.correlationId), null != (n = this.performanceClient) && n.setPreQueueTime(PerformanceEvents.AuthClientCreateQueryString, r.correlationId), [4, this.createAuthCodeUrlQueryString(r)];
            case 1:
              return t = e.sent(), [2, UrlString.appendQueryString(this.authority.authorizationEndpoint, t)];
          }
        });
      });
    }, e.prototype.acquireToken = function (s, l) {
      var c, u;
      return __awaiter$2(this, void 0, void 0, function () {
        var t,
          r,
          n,
          i,
          o,
          a = this;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              if (s && s.code) return null != (c = this.performanceClient) && c.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, s.correlationId), t = null == (c = this.performanceClient) ? void 0 : c.startMeasurement("AuthCodeClientAcquireToken", s.correlationId), this.logger.info("in acquireToken call in auth-code client"), r = TimeUtils.nowSeconds(), null != (c = this.performanceClient) && c.setPreQueueTime(PerformanceEvents.AuthClientExecuteTokenRequest, s.correlationId), [4, this.executeTokenRequest(this.authority, s)];
              throw ClientAuthError.createTokenRequestCannotBeMadeError();
            case 1:
              return n = e.sent(), i = null == (c = n.headers) ? void 0 : c[HeaderNames.X_MS_REQUEST_ID], (o = null == (u = n.headers) ? void 0 : u[HeaderNames.X_MS_HTTP_VERSION]) && null != t && t.addStaticFields({
                httpVerAuthority: o
              }), (o = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient)).validateTokenResponse(n.body), null != (u = this.performanceClient) && u.setPreQueueTime(PerformanceEvents.HandleServerTokenResponse, s.correlationId), [2, o.handleServerTokenResponse(n.body, this.authority, r, s, l, void 0, void 0, void 0, i).then(function (e) {
                return null != t && t.endMeasurement({
                  success: !0
                }), e;
              }).catch(function (e) {
                throw a.logger.verbose("Error in fetching token in ACC", s.correlationId), null != t && t.endMeasurement({
                  errorCode: e.errorCode,
                  subErrorCode: e.subError,
                  success: !1
                }), e;
              })];
          }
        });
      });
    }, e.prototype.handleFragmentResponse = function (e, t) {
      var r = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null),
        e = new UrlString(e),
        e = UrlString.getDeserializedHash(e.getHash());
      if (r.validateServerAuthorizationCodeResponse(e, t, this.cryptoUtils), e.code) return __assign$4(__assign$4({}, e), {
        code: e.code
      });
      throw ClientAuthError.createNoAuthCodeInServerResponseError();
    }, e.prototype.getLogoutUri = function (e) {
      if (e) return e = this.createLogoutUrlQueryString(e), UrlString.appendQueryString(this.authority.endSessionEndpoint, e);
      throw ClientConfigurationError.createEmptyLogoutRequestError();
    }, e.prototype.executeTokenRequest = function (a, s) {
      var l;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r, n, i, o;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return null != (l = this.performanceClient) && l.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, s.correlationId), null != (l = this.performanceClient) && l.setPreQueueTime(PerformanceEvents.AuthClientCreateTokenRequestBody, s.correlationId), t = this.createTokenQueryParameters(s), t = UrlString.appendQueryString(a.tokenEndpoint, t), [4, this.createTokenRequestBody(s)];
            case 1:
              if (r = e.sent(), i = void 0, s.clientInfo) try {
                n = buildClientInfo(s.clientInfo, this.cryptoUtils), i = {
                  credential: "" + n.uid + Separators.CLIENT_INFO_SEPARATOR + n.utid,
                  type: CcsCredentialType.HOME_ACCOUNT_ID
                };
              } catch (e) {
                this.logger.verbose("Could not parse client info for CCS Header: " + e);
              }
              return i = this.createTokenRequestHeaders(i || s.ccsCredential), o = {
                clientId: this.config.authOptions.clientId,
                authority: a.canonicalAuthority,
                scopes: s.scopes,
                claims: s.claims,
                authenticationScheme: s.authenticationScheme,
                resourceRequestMethod: s.resourceRequestMethod,
                resourceRequestUri: s.resourceRequestUri,
                shrClaims: s.shrClaims,
                sshKid: s.sshKid
              }, [2, this.executePostToTokenEndpoint(t, r, i, o)];
          }
        });
      });
    }, e.prototype.createTokenRequestBody = function (s) {
      var l;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r, n, i, o, a;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return (null != (l = this.performanceClient) && l.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, s.correlationId), (t = new RequestParameterBuilder()).addClientId(this.config.authOptions.clientId), this.includeRedirectUri ? t.addRedirectUri(s.redirectUri) : RequestValidator.validateRedirectUri(s.redirectUri), t.addScopes(s.scopes), t.addAuthorizationCode(s.code), t.addLibraryInfo(this.config.libraryInfo), t.addApplicationTelemetry(this.config.telemetry.application), t.addThrottling(), this.serverTelemetryManager && t.addServerTelemetry(this.serverTelemetryManager), s.codeVerifier && t.addCodeVerifier(s.codeVerifier), this.config.clientCredentials.clientSecret && t.addClientSecret(this.config.clientCredentials.clientSecret), this.config.clientCredentials.clientAssertion && (r = this.config.clientCredentials.clientAssertion, t.addClientAssertion(r.assertion), t.addClientAssertionType(r.assertionType)), t.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT), t.addClientInfo(), s.authenticationScheme !== AuthenticationScheme.POP) ? [3, 2] : (r = new PopTokenGenerator(this.cryptoUtils, this.performanceClient), null != (l = this.performanceClient) && l.setPreQueueTime(PerformanceEvents.PopTokenGenerateCnf, s.correlationId), [4, r.generateCnf(s)]);
            case 1:
              return n = e.sent(), t.addPopToken(n.reqCnfString), [3, 3];
            case 2:
              if (s.authenticationScheme === AuthenticationScheme.SSH) {
                if (!s.sshJwk) throw ClientConfigurationError.createMissingSshJwkError();
                t.addSshJwk(s.sshJwk);
              }
              e.label = 3;
            case 3:
              if (n = s.correlationId || this.config.cryptoInterface.createNewGuid(), t.addCorrelationId(n), (!StringUtils.isEmptyObj(s.claims) || this.config.authOptions.clientCapabilities && 0 < this.config.authOptions.clientCapabilities.length) && t.addClaims(s.claims, this.config.authOptions.clientCapabilities), i = void 0, s.clientInfo) try {
                o = buildClientInfo(s.clientInfo, this.cryptoUtils), i = {
                  credential: "" + o.uid + Separators.CLIENT_INFO_SEPARATOR + o.utid,
                  type: CcsCredentialType.HOME_ACCOUNT_ID
                };
              } catch (e) {
                this.logger.verbose("Could not parse client info for CCS Header: " + e);
              } else i = s.ccsCredential;
              if (this.config.systemOptions.preventCorsPreflight && i) switch (i.type) {
                case CcsCredentialType.HOME_ACCOUNT_ID:
                  try {
                    o = buildClientInfoFromHomeAccountId(i.credential), t.addCcsOid(o);
                  } catch (e) {
                    this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
                  }
                  break;
                case CcsCredentialType.UPN:
                  t.addCcsUpn(i.credential);
              }
              return s.tokenBodyParameters && t.addExtraQueryParameters(s.tokenBodyParameters), !s.enableSpaAuthorizationCode || s.tokenBodyParameters && s.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE] || t.addExtraQueryParameters(((a = {})[AADServerParamKeys.RETURN_SPA_CODE] = "1", a)), [2, t.createQueryString()];
          }
        });
      });
    }, e.prototype.createAuthCodeUrlQueryString = function (o) {
      var a;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r, n, i;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              if (null != (a = this.performanceClient) && a.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, o.correlationId), (t = new RequestParameterBuilder()).addClientId(this.config.authOptions.clientId), r = __spreadArrays(o.scopes || [], o.extraScopesToConsent || []), t.addScopes(r), t.addRedirectUri(o.redirectUri), r = o.correlationId || this.config.cryptoInterface.createNewGuid(), t.addCorrelationId(r), t.addResponseMode(o.responseMode), t.addResponseTypeCode(), t.addLibraryInfo(this.config.libraryInfo), t.addApplicationTelemetry(this.config.telemetry.application), t.addClientInfo(), o.codeChallenge && o.codeChallengeMethod && t.addCodeChallengeParams(o.codeChallenge, o.codeChallengeMethod), o.prompt && t.addPrompt(o.prompt), o.domainHint && t.addDomainHint(o.domainHint), o.prompt !== PromptValue.SELECT_ACCOUNT) {
                if (o.sid && o.prompt === PromptValue.NONE) this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request"), t.addSid(o.sid);else if (o.account) {
                  if (r = this.extractAccountSid(o.account), i = this.extractLoginHint(o.account)) {
                    this.logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account"), t.addLoginHint(i);
                    try {
                      n = buildClientInfoFromHomeAccountId(o.account.homeAccountId), t.addCcsOid(n);
                    } catch (e) {
                      this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                    }
                  } else if (r && o.prompt === PromptValue.NONE) {
                    this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account"), t.addSid(r);
                    try {
                      n = buildClientInfoFromHomeAccountId(o.account.homeAccountId), t.addCcsOid(n);
                    } catch (e) {
                      this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                    }
                  } else if (o.loginHint) this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request"), t.addLoginHint(o.loginHint), t.addCcsUpn(o.loginHint);else if (o.account.username) {
                    this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account"), t.addLoginHint(o.account.username);
                    try {
                      n = buildClientInfoFromHomeAccountId(o.account.homeAccountId), t.addCcsOid(n);
                    } catch (e) {
                      this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                    }
                  }
                } else o.loginHint && (this.logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request"), t.addLoginHint(o.loginHint), t.addCcsUpn(o.loginHint));
              } else this.logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
              return (o.nonce && t.addNonce(o.nonce), o.state && t.addState(o.state), (!StringUtils.isEmpty(o.claims) || this.config.authOptions.clientCapabilities && 0 < this.config.authOptions.clientCapabilities.length) && t.addClaims(o.claims, this.config.authOptions.clientCapabilities), o.extraQueryParameters && t.addExtraQueryParameters(o.extraQueryParameters), o.nativeBroker) ? (t.addNativeBroker(), o.authenticationScheme !== AuthenticationScheme.POP ? [3, 2] : [4, new PopTokenGenerator(this.cryptoUtils).generateCnf(o)]) : [3, 2];
            case 1:
              i = e.sent(), t.addPopToken(i.reqCnfString), e.label = 2;
            case 2:
              return [2, t.createQueryString()];
          }
        });
      });
    }, e.prototype.createLogoutUrlQueryString = function (e) {
      var t = new RequestParameterBuilder();
      return e.postLogoutRedirectUri && t.addPostLogoutRedirectUri(e.postLogoutRedirectUri), e.correlationId && t.addCorrelationId(e.correlationId), e.idTokenHint && t.addIdTokenHint(e.idTokenHint), e.state && t.addState(e.state), e.logoutHint && t.addLogoutHint(e.logoutHint), e.extraQueryParameters && t.addExtraQueryParameters(e.extraQueryParameters), t.createQueryString();
    }, e.prototype.extractAccountSid = function (e) {
      return (null == (e = e.idTokenClaims) ? void 0 : e.sid) || null;
    }, e.prototype.extractLoginHint = function (e) {
      return (null == (e = e.idTokenClaims) ? void 0 : e.login_hint) || null;
    }, e;
  }(BaseClient),
  RefreshTokenClient = function (r) {
    function e(e, t) {
      return r.call(this, e, t) || this;
    }
    return __extends$f(e, r), e.prototype.acquireToken = function (s) {
      var l, c, u;
      return __awaiter$2(this, void 0, void 0, function () {
        var t,
          r,
          n,
          i,
          o,
          a = this;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return null != (l = this.performanceClient) && l.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, s.correlationId), t = null == (l = this.performanceClient) ? void 0 : l.startMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, s.correlationId), this.logger.verbose("RefreshTokenClientAcquireToken called", s.correlationId), r = TimeUtils.nowSeconds(), null != (l = this.performanceClient) && l.setPreQueueTime(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, s.correlationId), [4, this.executeTokenRequest(s, this.authority)];
            case 1:
              return n = e.sent(), i = null == (l = n.headers) ? void 0 : l[HeaderNames.X_MS_HTTP_VERSION], null != t && t.addStaticFields({
                refreshTokenSize: (null == (c = n.body.refresh_token) ? void 0 : c.length) || 0
              }), i && null != t && t.addStaticFields({
                httpVerToken: i
              }), i = null == (c = n.headers) ? void 0 : c[HeaderNames.X_MS_REQUEST_ID], (o = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin)).validateTokenResponse(n.body), null != (u = this.performanceClient) && u.setPreQueueTime(PerformanceEvents.HandleServerTokenResponse, s.correlationId), [2, o.handleServerTokenResponse(n.body, this.authority, r, s, void 0, void 0, !0, s.forceCache, i).then(function (e) {
                return null != t && t.endMeasurement({
                  success: !0
                }), e;
              }).catch(function (e) {
                throw a.logger.verbose("Error in fetching refresh token", s.correlationId), null != t && t.endMeasurement({
                  errorCode: e.errorCode,
                  subErrorCode: e.subError,
                  success: !1
                }), e;
              })];
          }
        });
      });
    }, e.prototype.acquireTokenByRefreshToken = function (n) {
      var i, o;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r;
        return __generator$2(this, function (e) {
          if (!n) throw ClientConfigurationError.createEmptyTokenRequestError();
          if (null != (o = this.performanceClient) && o.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, n.correlationId), !n.account) throw ClientAuthError.createNoAccountInSilentRequestError();
          if (this.cacheManager.isAppMetadataFOCI(n.account.environment)) try {
            return null != (i = this.performanceClient) && i.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, n.correlationId), [2, this.acquireTokenWithCachedRefreshToken(n, !0)];
          } catch (e) {
            if (t = e instanceof InteractionRequiredAuthError && e.errorCode === InteractionRequiredAuthErrorMessage.noTokensFoundError.code, r = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR, t || r) return null != (o = this.performanceClient) && o.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, n.correlationId), [2, this.acquireTokenWithCachedRefreshToken(n, !1)];
            throw e;
          }
          return null != (o = this.performanceClient) && o.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, n.correlationId), [2, this.acquireTokenWithCachedRefreshToken(n, !1)];
        });
      });
    }, e.prototype.acquireTokenWithCachedRefreshToken = function (n, i) {
      var o;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r;
        return __generator$2(this, function (e) {
          if (null != (o = this.performanceClient) && o.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, n.correlationId), t = null == (o = this.performanceClient) ? void 0 : o.startMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, n.correlationId), this.logger.verbose("RefreshTokenClientAcquireTokenWithCachedRefreshToken called", n.correlationId), r = this.cacheManager.getRefreshToken(n.account, i)) return null != t && t.endMeasurement({
            success: !0
          }), r = __assign$4(__assign$4({}, n), {
            refreshToken: r.secret,
            authenticationScheme: n.authenticationScheme || AuthenticationScheme.BEARER,
            ccsCredential: {
              credential: n.account.homeAccountId,
              type: CcsCredentialType.HOME_ACCOUNT_ID
            }
          }), null != (o = this.performanceClient) && o.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireToken, n.correlationId), [2, this.acquireToken(r)];
          throw null != t && t.discardMeasurement(), InteractionRequiredAuthError.createNoTokensFoundError();
        });
      });
    }, e.prototype.executeTokenRequest = function (a, s) {
      var l;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r, n, i, o;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return null != (l = this.performanceClient) && l.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, a.correlationId), t = null == (l = this.performanceClient) ? void 0 : l.startMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, a.correlationId), null != (l = this.performanceClient) && l.setPreQueueTime(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, a.correlationId), r = this.createTokenQueryParameters(a), r = UrlString.appendQueryString(s.tokenEndpoint, r), [4, this.createTokenRequestBody(a)];
            case 1:
              return n = e.sent(), i = this.createTokenRequestHeaders(a.ccsCredential), o = {
                clientId: this.config.authOptions.clientId,
                authority: s.canonicalAuthority,
                scopes: a.scopes,
                claims: a.claims,
                authenticationScheme: a.authenticationScheme,
                resourceRequestMethod: a.resourceRequestMethod,
                resourceRequestUri: a.resourceRequestUri,
                shrClaims: a.shrClaims,
                sshKid: a.sshKid
              }, [2, this.executePostToTokenEndpoint(r, n, i, o).then(function (e) {
                return null != t && t.endMeasurement({
                  success: !0
                }), e;
              }).catch(function (e) {
                throw null != t && t.endMeasurement({
                  success: !1
                }), e;
              })];
          }
        });
      });
    }, e.prototype.createTokenRequestBody = function (o) {
      var a;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r, n, i;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return (null != (a = this.performanceClient) && a.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, o.correlationId), n = o.correlationId, t = null == (a = this.performanceClient) ? void 0 : a.startMeasurement(PerformanceEvents.BaseClientCreateTokenRequestHeaders, n), (r = new RequestParameterBuilder()).addClientId(this.config.authOptions.clientId), r.addScopes(o.scopes), r.addGrantType(GrantType.REFRESH_TOKEN_GRANT), r.addClientInfo(), r.addLibraryInfo(this.config.libraryInfo), r.addApplicationTelemetry(this.config.telemetry.application), r.addThrottling(), this.serverTelemetryManager && r.addServerTelemetry(this.serverTelemetryManager), r.addCorrelationId(n), r.addRefreshToken(o.refreshToken), this.config.clientCredentials.clientSecret && r.addClientSecret(this.config.clientCredentials.clientSecret), this.config.clientCredentials.clientAssertion && (n = this.config.clientCredentials.clientAssertion, r.addClientAssertion(n.assertion), r.addClientAssertionType(n.assertionType)), o.authenticationScheme !== AuthenticationScheme.POP) ? [3, 2] : (n = new PopTokenGenerator(this.cryptoUtils, this.performanceClient), null != (a = this.performanceClient) && a.setPreQueueTime(PerformanceEvents.PopTokenGenerateCnf, o.correlationId), [4, n.generateCnf(o)]);
            case 1:
              return n = e.sent(), r.addPopToken(n.reqCnfString), [3, 3];
            case 2:
              if (o.authenticationScheme === AuthenticationScheme.SSH) {
                if (!o.sshJwk) throw null != t && t.endMeasurement({
                  success: !1
                }), ClientConfigurationError.createMissingSshJwkError();
                r.addSshJwk(o.sshJwk);
              }
              e.label = 3;
            case 3:
              if ((!StringUtils.isEmptyObj(o.claims) || this.config.authOptions.clientCapabilities && 0 < this.config.authOptions.clientCapabilities.length) && r.addClaims(o.claims, this.config.authOptions.clientCapabilities), this.config.systemOptions.preventCorsPreflight && o.ccsCredential) switch (o.ccsCredential.type) {
                case CcsCredentialType.HOME_ACCOUNT_ID:
                  try {
                    i = buildClientInfoFromHomeAccountId(o.ccsCredential.credential), r.addCcsOid(i);
                  } catch (e) {
                    this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
                  }
                  break;
                case CcsCredentialType.UPN:
                  r.addCcsUpn(o.ccsCredential.credential);
              }
              return null != t && t.endMeasurement({
                success: !0
              }), [2, r.createQueryString()];
          }
        });
      });
    }, e;
  }(BaseClient),
  SilentFlowClient = function (r) {
    function e(e, t) {
      return r.call(this, e, t) || this;
    }
    return __extends$f(e, r), e.prototype.acquireToken = function (r) {
      return __awaiter$2(this, void 0, void 0, function () {
        var t;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return e.trys.push([0, 2,, 3]), [4, this.acquireCachedToken(r)];
            case 1:
              return [2, e.sent()];
            case 2:
              if ((t = e.sent()) instanceof ClientAuthError && t.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) return [2, new RefreshTokenClient(this.config, this.performanceClient).acquireTokenByRefreshToken(r)];
              throw t;
            case 3:
              return [2];
          }
        });
      });
    }, e.prototype.acquireCachedToken = function (r) {
      var n, i, o;
      return __awaiter$2(this, void 0, void 0, function () {
        var t;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              if (!r) throw ClientConfigurationError.createEmptyTokenRequestError();
              if (r.forceRefresh) throw null != (n = this.serverTelemetryManager) && n.setCacheOutcome(CacheOutcome.FORCE_REFRESH), this.logger.info("SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true."), ClientAuthError.createRefreshRequiredError();
              if (!this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(r.claims)) throw null != (n = this.serverTelemetryManager) && n.setCacheOutcome(CacheOutcome.CLAIMS_REQUESTED_CACHE_SKIPPED), this.logger.info("SilentFlowClient:acquireCachedToken - Skipping cache because claims-based caching is disabled and claims were requested."), ClientAuthError.createRefreshRequiredError();
              if (!r.account) throw ClientAuthError.createNoAccountInSilentRequestError();
              if (t = r.authority || this.authority.getPreferredCache(), !(t = this.cacheManager.readCacheRecord(r.account, r, t)).accessToken) throw null != (i = this.serverTelemetryManager) && i.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN), this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties."), ClientAuthError.createRefreshRequiredError();
              if (TimeUtils.wasClockTurnedBack(t.accessToken.cachedAt) || TimeUtils.isTokenExpired(t.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) throw null != (i = this.serverTelemetryManager) && i.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED), this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within " + this.config.systemOptions.tokenRenewalOffsetSeconds + " seconds."), ClientAuthError.createRefreshRequiredError();
              if (t.accessToken.refreshOn && TimeUtils.isTokenExpired(t.accessToken.refreshOn, 0)) throw null != (o = this.serverTelemetryManager) && o.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN), this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'."), ClientAuthError.createRefreshRequiredError();
              return this.config.serverTelemetryManager && this.config.serverTelemetryManager.incrementCacheHits(), [4, this.generateResultFromCacheRecord(t, r)];
            case 1:
              return [2, e.sent()];
          }
        });
      });
    }, e.prototype.generateResultFromCacheRecord = function (n, i) {
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              if (n.idToken && (t = new AuthToken(n.idToken.secret, this.config.cryptoInterface)), i.maxAge || 0 === i.maxAge) {
                if (!(r = null == t ? void 0 : t.claims.auth_time)) throw ClientAuthError.createAuthTimeNotFoundError();
                AuthToken.checkMaxAge(r, i.maxAge);
              }
              return [4, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, n, !0, i, t)];
            case 1:
              return [2, e.sent()];
          }
        });
      });
    }, e;
  }(BaseClient);
function isOpenIdConfigResponse(e) {
  return e.hasOwnProperty("authorization_endpoint") && e.hasOwnProperty("token_endpoint") && e.hasOwnProperty("issuer") && e.hasOwnProperty("jwks_uri");
}
var ProtocolMode,
  rawMetdataJSON = {
    endpointMetadata: {
      "https://login.microsoftonline.com/common/": {
        token_endpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/token",
        token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
        jwks_uri: "https://login.microsoftonline.com/common/discovery/v2.0/keys",
        response_modes_supported: ["query", "fragment", "form_post"],
        subject_types_supported: ["pairwise"],
        id_token_signing_alg_values_supported: ["RS256"],
        response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
        scopes_supported: ["openid", "profile", "email", "offline_access"],
        issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",
        request_uri_parameter_supported: !1,
        userinfo_endpoint: "https://graph.microsoft.com/oidc/userinfo",
        authorization_endpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/authorize",
        device_authorization_endpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/devicecode",
        http_logout_supported: !0,
        frontchannel_logout_supported: !0,
        end_session_endpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/logout",
        claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
        kerberos_endpoint: "https://login.microsoftonline.com/common/kerberos",
        tenant_region_scope: null,
        cloud_instance_name: "microsoftonline.com",
        cloud_graph_host_name: "graph.windows.net",
        msgraph_host: "graph.microsoft.com",
        rbac_url: "https://pas.windows.net"
      },
      "https://login.chinacloudapi.cn/common/": {
        token_endpoint: "https://login.chinacloudapi.cn/common/oauth2/v2.0/token",
        token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
        jwks_uri: "https://login.chinacloudapi.cn/common/discovery/v2.0/keys",
        response_modes_supported: ["query", "fragment", "form_post"],
        subject_types_supported: ["pairwise"],
        id_token_signing_alg_values_supported: ["RS256"],
        response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
        scopes_supported: ["openid", "profile", "email", "offline_access"],
        issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",
        request_uri_parameter_supported: !1,
        userinfo_endpoint: "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo",
        authorization_endpoint: "https://login.chinacloudapi.cn/common/oauth2/v2.0/authorize",
        device_authorization_endpoint: "https://login.chinacloudapi.cn/common/oauth2/v2.0/devicecode",
        http_logout_supported: !0,
        frontchannel_logout_supported: !0,
        end_session_endpoint: "https://login.chinacloudapi.cn/common/oauth2/v2.0/logout",
        claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
        kerberos_endpoint: "https://login.chinacloudapi.cn/common/kerberos",
        tenant_region_scope: null,
        cloud_instance_name: "partner.microsoftonline.cn",
        cloud_graph_host_name: "graph.chinacloudapi.cn",
        msgraph_host: "microsoftgraph.chinacloudapi.cn",
        rbac_url: "https://pas.chinacloudapi.cn"
      },
      "https://login.microsoftonline.us/common/": {
        token_endpoint: "https://login.microsoftonline.us/common/oauth2/v2.0/token",
        token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
        jwks_uri: "https://login.microsoftonline.us/common/discovery/v2.0/keys",
        response_modes_supported: ["query", "fragment", "form_post"],
        subject_types_supported: ["pairwise"],
        id_token_signing_alg_values_supported: ["RS256"],
        response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
        scopes_supported: ["openid", "profile", "email", "offline_access"],
        issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",
        request_uri_parameter_supported: !1,
        userinfo_endpoint: "https://graph.microsoft.com/oidc/userinfo",
        authorization_endpoint: "https://login.microsoftonline.us/common/oauth2/v2.0/authorize",
        device_authorization_endpoint: "https://login.microsoftonline.us/common/oauth2/v2.0/devicecode",
        http_logout_supported: !0,
        frontchannel_logout_supported: !0,
        end_session_endpoint: "https://login.microsoftonline.us/common/oauth2/v2.0/logout",
        claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
        kerberos_endpoint: "https://login.microsoftonline.us/common/kerberos",
        tenant_region_scope: null,
        cloud_instance_name: "microsoftonline.us",
        cloud_graph_host_name: "graph.windows.net",
        msgraph_host: "graph.microsoft.com",
        rbac_url: "https://pasff.usgovcloudapi.net"
      },
      "https://login.microsoftonline.com/consumers/": {
        token_endpoint: "https://login.microsoftonline.com/consumers/oauth2/v2.0/token",
        token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
        jwks_uri: "https://login.microsoftonline.com/consumers/discovery/v2.0/keys",
        response_modes_supported: ["query", "fragment", "form_post"],
        subject_types_supported: ["pairwise"],
        id_token_signing_alg_values_supported: ["RS256"],
        response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
        scopes_supported: ["openid", "profile", "email", "offline_access"],
        issuer: "https://login.microsoftonline.com/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0",
        request_uri_parameter_supported: !1,
        userinfo_endpoint: "https://graph.microsoft.com/oidc/userinfo",
        authorization_endpoint: "https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize",
        device_authorization_endpoint: "https://login.microsoftonline.com/consumers/oauth2/v2.0/devicecode",
        http_logout_supported: !0,
        frontchannel_logout_supported: !0,
        end_session_endpoint: "https://login.microsoftonline.com/consumers/oauth2/v2.0/logout",
        claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
        kerberos_endpoint: "https://login.microsoftonline.com/consumers/kerberos",
        tenant_region_scope: null,
        cloud_instance_name: "microsoftonline.com",
        cloud_graph_host_name: "graph.windows.net",
        msgraph_host: "graph.microsoft.com",
        rbac_url: "https://pas.windows.net"
      },
      "https://login.chinacloudapi.cn/consumers/": {
        token_endpoint: "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/token",
        token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
        jwks_uri: "https://login.chinacloudapi.cn/consumers/discovery/v2.0/keys",
        response_modes_supported: ["query", "fragment", "form_post"],
        subject_types_supported: ["pairwise"],
        id_token_signing_alg_values_supported: ["RS256"],
        response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
        scopes_supported: ["openid", "profile", "email", "offline_access"],
        issuer: "https://login.partner.microsoftonline.cn/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0",
        request_uri_parameter_supported: !1,
        userinfo_endpoint: "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo",
        authorization_endpoint: "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/authorize",
        device_authorization_endpoint: "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/devicecode",
        http_logout_supported: !0,
        frontchannel_logout_supported: !0,
        end_session_endpoint: "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/logout",
        claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
        kerberos_endpoint: "https://login.chinacloudapi.cn/consumers/kerberos",
        tenant_region_scope: null,
        cloud_instance_name: "partner.microsoftonline.cn",
        cloud_graph_host_name: "graph.chinacloudapi.cn",
        msgraph_host: "microsoftgraph.chinacloudapi.cn",
        rbac_url: "https://pas.chinacloudapi.cn"
      },
      "https://login.microsoftonline.us/consumers/": {
        token_endpoint: "https://login.microsoftonline.us/consumers/oauth2/v2.0/token",
        token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
        jwks_uri: "https://login.microsoftonline.us/consumers/discovery/v2.0/keys",
        response_modes_supported: ["query", "fragment", "form_post"],
        subject_types_supported: ["pairwise"],
        id_token_signing_alg_values_supported: ["RS256"],
        response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
        scopes_supported: ["openid", "profile", "email", "offline_access"],
        issuer: "https://login.microsoftonline.us/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0",
        request_uri_parameter_supported: !1,
        userinfo_endpoint: "https://graph.microsoft.com/oidc/userinfo",
        authorization_endpoint: "https://login.microsoftonline.us/consumers/oauth2/v2.0/authorize",
        device_authorization_endpoint: "https://login.microsoftonline.us/consumers/oauth2/v2.0/devicecode",
        http_logout_supported: !0,
        frontchannel_logout_supported: !0,
        end_session_endpoint: "https://login.microsoftonline.us/consumers/oauth2/v2.0/logout",
        claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
        kerberos_endpoint: "https://login.microsoftonline.us/consumers/kerberos",
        tenant_region_scope: null,
        cloud_instance_name: "microsoftonline.us",
        cloud_graph_host_name: "graph.windows.net",
        msgraph_host: "graph.microsoft.com",
        rbac_url: "https://pasff.usgovcloudapi.net"
      },
      "https://login.microsoftonline.com/organizations/": {
        token_endpoint: "https://login.microsoftonline.com/organizations/oauth2/v2.0/token",
        token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
        jwks_uri: "https://login.microsoftonline.com/organizations/discovery/v2.0/keys",
        response_modes_supported: ["query", "fragment", "form_post"],
        subject_types_supported: ["pairwise"],
        id_token_signing_alg_values_supported: ["RS256"],
        response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
        scopes_supported: ["openid", "profile", "email", "offline_access"],
        issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",
        request_uri_parameter_supported: !1,
        userinfo_endpoint: "https://graph.microsoft.com/oidc/userinfo",
        authorization_endpoint: "https://login.microsoftonline.com/organizations/oauth2/v2.0/authorize",
        device_authorization_endpoint: "https://login.microsoftonline.com/organizations/oauth2/v2.0/devicecode",
        http_logout_supported: !0,
        frontchannel_logout_supported: !0,
        end_session_endpoint: "https://login.microsoftonline.com/organizations/oauth2/v2.0/logout",
        claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
        kerberos_endpoint: "https://login.microsoftonline.com/organizations/kerberos",
        tenant_region_scope: null,
        cloud_instance_name: "microsoftonline.com",
        cloud_graph_host_name: "graph.windows.net",
        msgraph_host: "graph.microsoft.com",
        rbac_url: "https://pas.windows.net"
      },
      "https://login.chinacloudapi.cn/organizations/": {
        token_endpoint: "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/token",
        token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
        jwks_uri: "https://login.chinacloudapi.cn/organizations/discovery/v2.0/keys",
        response_modes_supported: ["query", "fragment", "form_post"],
        subject_types_supported: ["pairwise"],
        id_token_signing_alg_values_supported: ["RS256"],
        response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
        scopes_supported: ["openid", "profile", "email", "offline_access"],
        issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",
        request_uri_parameter_supported: !1,
        userinfo_endpoint: "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo",
        authorization_endpoint: "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/authorize",
        device_authorization_endpoint: "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/devicecode",
        http_logout_supported: !0,
        frontchannel_logout_supported: !0,
        end_session_endpoint: "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/logout",
        claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
        kerberos_endpoint: "https://login.chinacloudapi.cn/organizations/kerberos",
        tenant_region_scope: null,
        cloud_instance_name: "partner.microsoftonline.cn",
        cloud_graph_host_name: "graph.chinacloudapi.cn",
        msgraph_host: "microsoftgraph.chinacloudapi.cn",
        rbac_url: "https://pas.chinacloudapi.cn"
      },
      "https://login.microsoftonline.us/organizations/": {
        token_endpoint: "https://login.microsoftonline.us/organizations/oauth2/v2.0/token",
        token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
        jwks_uri: "https://login.microsoftonline.us/organizations/discovery/v2.0/keys",
        response_modes_supported: ["query", "fragment", "form_post"],
        subject_types_supported: ["pairwise"],
        id_token_signing_alg_values_supported: ["RS256"],
        response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
        scopes_supported: ["openid", "profile", "email", "offline_access"],
        issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",
        request_uri_parameter_supported: !1,
        userinfo_endpoint: "https://graph.microsoft.com/oidc/userinfo",
        authorization_endpoint: "https://login.microsoftonline.us/organizations/oauth2/v2.0/authorize",
        device_authorization_endpoint: "https://login.microsoftonline.us/organizations/oauth2/v2.0/devicecode",
        http_logout_supported: !0,
        frontchannel_logout_supported: !0,
        end_session_endpoint: "https://login.microsoftonline.us/organizations/oauth2/v2.0/logout",
        claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
        kerberos_endpoint: "https://login.microsoftonline.us/organizations/kerberos",
        tenant_region_scope: null,
        cloud_instance_name: "microsoftonline.us",
        cloud_graph_host_name: "graph.windows.net",
        msgraph_host: "graph.microsoft.com",
        rbac_url: "https://pasff.usgovcloudapi.net"
      }
    },
    instanceDiscoveryMetadata: {
      "https://login.microsoftonline.com/common/": {
        tenant_discovery_endpoint: "https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration",
        "api-version": "1.1",
        metadata: [{
          preferred_network: "login.microsoftonline.com",
          preferred_cache: "login.windows.net",
          aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
        }, {
          preferred_network: "login.partner.microsoftonline.cn",
          preferred_cache: "login.partner.microsoftonline.cn",
          aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
        }, {
          preferred_network: "login.microsoftonline.de",
          preferred_cache: "login.microsoftonline.de",
          aliases: ["login.microsoftonline.de"]
        }, {
          preferred_network: "login.microsoftonline.us",
          preferred_cache: "login.microsoftonline.us",
          aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
        }, {
          preferred_network: "login-us.microsoftonline.com",
          preferred_cache: "login-us.microsoftonline.com",
          aliases: ["login-us.microsoftonline.com"]
        }]
      },
      "https://login.chinacloudapi.cn/common/": {
        tenant_discovery_endpoint: "https://login.chinacloudapi.cn/common/v2.0/.well-known/openid-configuration",
        "api-version": "1.1",
        metadata: [{
          preferred_network: "login.microsoftonline.com",
          preferred_cache: "login.windows.net",
          aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
        }, {
          preferred_network: "login.partner.microsoftonline.cn",
          preferred_cache: "login.partner.microsoftonline.cn",
          aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
        }, {
          preferred_network: "login.microsoftonline.de",
          preferred_cache: "login.microsoftonline.de",
          aliases: ["login.microsoftonline.de"]
        }, {
          preferred_network: "login.microsoftonline.us",
          preferred_cache: "login.microsoftonline.us",
          aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
        }, {
          preferred_network: "login-us.microsoftonline.com",
          preferred_cache: "login-us.microsoftonline.com",
          aliases: ["login-us.microsoftonline.com"]
        }]
      },
      "https://login.microsoftonline.us/common/": {
        tenant_discovery_endpoint: "https://login.microsoftonline.us/common/v2.0/.well-known/openid-configuration",
        "api-version": "1.1",
        metadata: [{
          preferred_network: "login.microsoftonline.com",
          preferred_cache: "login.windows.net",
          aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
        }, {
          preferred_network: "login.partner.microsoftonline.cn",
          preferred_cache: "login.partner.microsoftonline.cn",
          aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
        }, {
          preferred_network: "login.microsoftonline.de",
          preferred_cache: "login.microsoftonline.de",
          aliases: ["login.microsoftonline.de"]
        }, {
          preferred_network: "login.microsoftonline.us",
          preferred_cache: "login.microsoftonline.us",
          aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
        }, {
          preferred_network: "login-us.microsoftonline.com",
          preferred_cache: "login-us.microsoftonline.com",
          aliases: ["login-us.microsoftonline.com"]
        }]
      },
      "https://login.microsoftonline.com/consumers/": {
        tenant_discovery_endpoint: "https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration",
        "api-version": "1.1",
        metadata: [{
          preferred_network: "login.microsoftonline.com",
          preferred_cache: "login.windows.net",
          aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
        }, {
          preferred_network: "login.partner.microsoftonline.cn",
          preferred_cache: "login.partner.microsoftonline.cn",
          aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
        }, {
          preferred_network: "login.microsoftonline.de",
          preferred_cache: "login.microsoftonline.de",
          aliases: ["login.microsoftonline.de"]
        }, {
          preferred_network: "login.microsoftonline.us",
          preferred_cache: "login.microsoftonline.us",
          aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
        }, {
          preferred_network: "login-us.microsoftonline.com",
          preferred_cache: "login-us.microsoftonline.com",
          aliases: ["login-us.microsoftonline.com"]
        }]
      },
      "https://login.chinacloudapi.cn/consumers/": {
        tenant_discovery_endpoint: "https://login.chinacloudapi.cn/consumers/v2.0/.well-known/openid-configuration",
        "api-version": "1.1",
        metadata: [{
          preferred_network: "login.microsoftonline.com",
          preferred_cache: "login.windows.net",
          aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
        }, {
          preferred_network: "login.partner.microsoftonline.cn",
          preferred_cache: "login.partner.microsoftonline.cn",
          aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
        }, {
          preferred_network: "login.microsoftonline.de",
          preferred_cache: "login.microsoftonline.de",
          aliases: ["login.microsoftonline.de"]
        }, {
          preferred_network: "login.microsoftonline.us",
          preferred_cache: "login.microsoftonline.us",
          aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
        }, {
          preferred_network: "login-us.microsoftonline.com",
          preferred_cache: "login-us.microsoftonline.com",
          aliases: ["login-us.microsoftonline.com"]
        }]
      },
      "https://login.microsoftonline.us/consumers/": {
        tenant_discovery_endpoint: "https://login.microsoftonline.us/consumers/v2.0/.well-known/openid-configuration",
        "api-version": "1.1",
        metadata: [{
          preferred_network: "login.microsoftonline.com",
          preferred_cache: "login.windows.net",
          aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
        }, {
          preferred_network: "login.partner.microsoftonline.cn",
          preferred_cache: "login.partner.microsoftonline.cn",
          aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
        }, {
          preferred_network: "login.microsoftonline.de",
          preferred_cache: "login.microsoftonline.de",
          aliases: ["login.microsoftonline.de"]
        }, {
          preferred_network: "login.microsoftonline.us",
          preferred_cache: "login.microsoftonline.us",
          aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
        }, {
          preferred_network: "login-us.microsoftonline.com",
          preferred_cache: "login-us.microsoftonline.com",
          aliases: ["login-us.microsoftonline.com"]
        }]
      },
      "https://login.microsoftonline.com/organizations/": {
        tenant_discovery_endpoint: "https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration",
        "api-version": "1.1",
        metadata: [{
          preferred_network: "login.microsoftonline.com",
          preferred_cache: "login.windows.net",
          aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
        }, {
          preferred_network: "login.partner.microsoftonline.cn",
          preferred_cache: "login.partner.microsoftonline.cn",
          aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
        }, {
          preferred_network: "login.microsoftonline.de",
          preferred_cache: "login.microsoftonline.de",
          aliases: ["login.microsoftonline.de"]
        }, {
          preferred_network: "login.microsoftonline.us",
          preferred_cache: "login.microsoftonline.us",
          aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
        }, {
          preferred_network: "login-us.microsoftonline.com",
          preferred_cache: "login-us.microsoftonline.com",
          aliases: ["login-us.microsoftonline.com"]
        }]
      },
      "https://login.chinacloudapi.cn/organizations/": {
        tenant_discovery_endpoint: "https://login.chinacloudapi.cn/organizations/v2.0/.well-known/openid-configuration",
        "api-version": "1.1",
        metadata: [{
          preferred_network: "login.microsoftonline.com",
          preferred_cache: "login.windows.net",
          aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
        }, {
          preferred_network: "login.partner.microsoftonline.cn",
          preferred_cache: "login.partner.microsoftonline.cn",
          aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
        }, {
          preferred_network: "login.microsoftonline.de",
          preferred_cache: "login.microsoftonline.de",
          aliases: ["login.microsoftonline.de"]
        }, {
          preferred_network: "login.microsoftonline.us",
          preferred_cache: "login.microsoftonline.us",
          aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
        }, {
          preferred_network: "login-us.microsoftonline.com",
          preferred_cache: "login-us.microsoftonline.com",
          aliases: ["login-us.microsoftonline.com"]
        }]
      },
      "https://login.microsoftonline.us/organizations/": {
        tenant_discovery_endpoint: "https://login.microsoftonline.us/organizations/v2.0/.well-known/openid-configuration",
        "api-version": "1.1",
        metadata: [{
          preferred_network: "login.microsoftonline.com",
          preferred_cache: "login.windows.net",
          aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
        }, {
          preferred_network: "login.partner.microsoftonline.cn",
          preferred_cache: "login.partner.microsoftonline.cn",
          aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
        }, {
          preferred_network: "login.microsoftonline.de",
          preferred_cache: "login.microsoftonline.de",
          aliases: ["login.microsoftonline.de"]
        }, {
          preferred_network: "login.microsoftonline.us",
          preferred_cache: "login.microsoftonline.us",
          aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
        }, {
          preferred_network: "login-us.microsoftonline.com",
          preferred_cache: "login-us.microsoftonline.com",
          aliases: ["login-us.microsoftonline.com"]
        }]
      }
    }
  },
  EndpointMetadata = rawMetdataJSON.endpointMetadata,
  InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata,
  AuthorityMetadataEntity = (!function (e) {
    e.AAD = "AAD", e.OIDC = "OIDC";
  }(ProtocolMode = ProtocolMode || {}), function () {
    function e() {
      this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
    }
    return e.prototype.updateCloudDiscoveryMetadata = function (e, t) {
      this.aliases = e.aliases, this.preferred_cache = e.preferred_cache, this.preferred_network = e.preferred_network, this.aliasesFromNetwork = t;
    }, e.prototype.updateEndpointMetadata = function (e, t) {
      this.authorization_endpoint = e.authorization_endpoint, this.token_endpoint = e.token_endpoint, this.end_session_endpoint = e.end_session_endpoint, this.issuer = e.issuer, this.endpointsFromNetwork = t, this.jwks_uri = e.jwks_uri;
    }, e.prototype.updateCanonicalAuthority = function (e) {
      this.canonical_authority = e;
    }, e.prototype.resetExpiresAt = function () {
      this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
    }, e.prototype.isExpired = function () {
      return this.expiresAt <= TimeUtils.nowSeconds();
    }, e.isAuthorityMetadataEntity = function (e, t) {
      return !!t && 0 === e.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) && t.hasOwnProperty("aliases") && t.hasOwnProperty("preferred_cache") && t.hasOwnProperty("preferred_network") && t.hasOwnProperty("canonical_authority") && t.hasOwnProperty("authorization_endpoint") && t.hasOwnProperty("token_endpoint") && t.hasOwnProperty("issuer") && t.hasOwnProperty("aliasesFromNetwork") && t.hasOwnProperty("endpointsFromNetwork") && t.hasOwnProperty("expiresAt") && t.hasOwnProperty("jwks_uri");
    }, e;
  }());
function isCloudInstanceDiscoveryResponse(e) {
  return e.hasOwnProperty("tenant_discovery_endpoint") && e.hasOwnProperty("metadata");
}
function isCloudInstanceDiscoveryErrorResponse(e) {
  return e.hasOwnProperty("error") && e.hasOwnProperty("error_description");
}
var NativeExtensionMethod,
  BrowserCacheLocation,
  HTTP_REQUEST_TYPE,
  TemporaryCacheKeys,
  StaticCacheKeys,
  InMemoryCacheKeys,
  ApiId,
  InteractionType,
  InteractionStatus,
  WrapperSKU,
  CacheLookupPolicy,
  EventType,
  NativeStatusCode,
  RegionDiscovery = function () {
    function c(e, t, r) {
      this.networkInterface = e, this.performanceClient = t, this.correlationId = r;
    }
    return c.prototype.detectRegion = function (o, a) {
      var s, l;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r, n, i;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              if (null != (s = this.performanceClient) && s.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId), t = o) return [3, 8];
              r = c.IMDS_OPTIONS, e.label = 1;
            case 1:
              return e.trys.push([1, 6,, 7]), null != (s = this.performanceClient) && s.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId), [4, this.getRegionFromIMDS(Constants.IMDS_VERSION, r)];
            case 2:
              return ((n = e.sent()).status === ResponseCodes.httpSuccess && (t = n.body, a.region_source = RegionDiscoverySources.IMDS), n.status !== ResponseCodes.httpBadRequest) ? [3, 5] : (null != (l = this.performanceClient) && l.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId), [4, this.getCurrentVersion(r)]);
            case 3:
              return (n = e.sent()) ? (null != (l = this.performanceClient) && l.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId), [4, this.getRegionFromIMDS(n, r)]) : (a.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION, [2, null]);
            case 4:
              (i = e.sent()).status === ResponseCodes.httpSuccess && (t = i.body, a.region_source = RegionDiscoverySources.IMDS), e.label = 5;
            case 5:
              return [3, 7];
            case 6:
              return e.sent(), a.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION, [2, null];
            case 7:
              return [3, 9];
            case 8:
              a.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE, e.label = 9;
            case 9:
              return t || (a.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION), [2, t || null];
          }
        });
      });
    }, c.prototype.getRegionFromIMDS = function (t, r) {
      var n;
      return __awaiter$2(this, void 0, void 0, function () {
        return __generator$2(this, function (e) {
          return null != (n = this.performanceClient) && n.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId), [2, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?api-version=" + t + "&format=text", r, Constants.IMDS_TIMEOUT)];
        });
      });
    }, c.prototype.getCurrentVersion = function (r) {
      var n;
      return __awaiter$2(this, void 0, void 0, function () {
        var t;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              null != (n = this.performanceClient) && n.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId), e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), [4, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?format=json", r)];
            case 2:
              return (t = e.sent()).status === ResponseCodes.httpBadRequest && t.body && t.body["newest-versions"] && 0 < t.body["newest-versions"].length ? [2, t.body["newest-versions"][0]] : [2, null];
            case 3:
              return e.sent(), [2, null];
            case 4:
              return [2];
          }
        });
      });
    }, c.IMDS_OPTIONS = {
      headers: {
        Metadata: "true"
      }
    }, c;
  }(),
  Authority = function () {
    function l(e, t, r, n, i, o, a) {
      this.canonicalAuthority = e, this._canonicalAuthority.validateAsUri(), this.networkInterface = t, this.cacheManager = r, this.authorityOptions = n, this.regionDiscoveryMetadata = {
        region_used: void 0,
        region_source: void 0,
        region_outcome: void 0
      }, this.logger = i, this.performanceClient = o, this.correlationId = a, this.regionDiscovery = new RegionDiscovery(t, this.performanceClient, this.correlationId);
    }
    return l.prototype.getAuthorityType = function (e) {
      if (e.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) return AuthorityType.Ciam;
      e = e.PathSegments;
      if (e.length) switch (e[0].toLowerCase()) {
        case Constants.ADFS:
          return AuthorityType.Adfs;
        case Constants.DSTS:
          return AuthorityType.Dsts;
      }
      return AuthorityType.Default;
    }, Object.defineProperty(l.prototype, "authorityType", {
      get: function () {
        return this.getAuthorityType(this.canonicalAuthorityUrlComponents);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l.prototype, "protocolMode", {
      get: function () {
        return this.authorityOptions.protocolMode;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l.prototype, "options", {
      get: function () {
        return this.authorityOptions;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l.prototype, "canonicalAuthority", {
      get: function () {
        return this._canonicalAuthority.urlString;
      },
      set: function (e) {
        this._canonicalAuthority = new UrlString(e), this._canonicalAuthority.validateAsUri(), this._canonicalAuthorityUrlComponents = null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l.prototype, "canonicalAuthorityUrlComponents", {
      get: function () {
        return this._canonicalAuthorityUrlComponents || (this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents()), this._canonicalAuthorityUrlComponents;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l.prototype, "hostnameAndPort", {
      get: function () {
        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l.prototype, "tenant", {
      get: function () {
        return this.canonicalAuthorityUrlComponents.PathSegments[0];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l.prototype, "authorizationEndpoint", {
      get: function () {
        if (this.discoveryComplete()) return this.replacePath(this.metadata.authorization_endpoint);
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l.prototype, "tokenEndpoint", {
      get: function () {
        if (this.discoveryComplete()) return this.replacePath(this.metadata.token_endpoint);
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l.prototype, "deviceCodeEndpoint", {
      get: function () {
        if (this.discoveryComplete()) return this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l.prototype, "endSessionEndpoint", {
      get: function () {
        if (this.discoveryComplete()) {
          if (this.metadata.end_session_endpoint) return this.replacePath(this.metadata.end_session_endpoint);
          throw ClientAuthError.createLogoutNotSupportedError();
        }
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l.prototype, "selfSignedJwtAudience", {
      get: function () {
        if (this.discoveryComplete()) return this.replacePath(this.metadata.issuer);
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l.prototype, "jwksUri", {
      get: function () {
        if (this.discoveryComplete()) return this.replacePath(this.metadata.jwks_uri);
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
      },
      enumerable: !1,
      configurable: !0
    }), l.prototype.canReplaceTenant = function (e) {
      return 1 === e.PathSegments.length && !l.reservedTenantDomains.has(e.PathSegments[0]) && this.getAuthorityType(e) === AuthorityType.Default && this.protocolMode === ProtocolMode.AAD;
    }, l.prototype.replaceTenant = function (e) {
      return e.replace(/{tenant}|{tenantid}/g, this.tenant);
    }, l.prototype.replacePath = function (e) {
      var n = this,
        i = e,
        o = new UrlString(this.metadata.canonical_authority).getUrlComponents(),
        a = o.PathSegments;
      return this.canonicalAuthorityUrlComponents.PathSegments.forEach(function (e, t) {
        var r = a[t];
        0 === t && n.canReplaceTenant(o) && r !== (t = new UrlString(n.metadata.authorization_endpoint).getUrlComponents().PathSegments[0]) && (n.logger.verbose("Replacing tenant domain name " + r + " with id " + t), r = t), e !== r && (i = i.replace("/" + r + "/", "/" + e + "/"));
      }), this.replaceTenant(i);
    }, Object.defineProperty(l.prototype, "defaultOpenIdConfigurationEndpoint", {
      get: function () {
        return this.authorityType === AuthorityType.Adfs || this.authorityType === AuthorityType.Dsts || this.protocolMode === ProtocolMode.OIDC ? this.canonicalAuthority + ".well-known/openid-configuration" : this.canonicalAuthority + "v2.0/.well-known/openid-configuration";
      },
      enumerable: !1,
      configurable: !0
    }), l.prototype.discoveryComplete = function () {
      return !!this.metadata;
    }, l.prototype.resolveEndpointsAsync = function () {
      var i;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r, n;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return null != (i = this.performanceClient) && i.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId), (t = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort)) || (t = new AuthorityMetadataEntity()).updateCanonicalAuthority(this.canonicalAuthority), null != (i = this.performanceClient) && i.setPreQueueTime(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId), [4, this.updateCloudDiscoveryMetadata(t)];
            case 1:
              return r = e.sent(), this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, t.preferred_network), null != (i = this.performanceClient) && i.setPreQueueTime(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId), [4, this.updateEndpointMetadata(t)];
            case 2:
              return n = e.sent(), r !== AuthorityMetadataSource.CACHE && n !== AuthorityMetadataSource.CACHE && (t.resetExpiresAt(), t.updateCanonicalAuthority(this.canonicalAuthority)), n = this.cacheManager.generateAuthorityMetadataCacheKey(t.preferred_cache), this.cacheManager.setAuthorityMetadata(n, t), this.metadata = t, [2];
          }
        });
      });
    }, l.prototype.updateEndpointMetadata = function (n) {
      var i, o, a;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return (null != (i = this.performanceClient) && i.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId), t = this.getEndpointMetadataFromConfig()) ? (n.updateEndpointMetadata(t, !1), [2, AuthorityMetadataSource.CONFIG]) : this.isAuthoritySameType(n) && n.endpointsFromNetwork && !n.isExpired() ? [2, AuthorityMetadataSource.CACHE] : (null != (i = this.performanceClient) && i.setPreQueueTime(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId), [4, this.getEndpointMetadataFromNetwork()]);
            case 1:
              return (t = e.sent()) ? null != (i = this.authorityOptions.azureRegionConfiguration) && i.azureRegion ? (null != (o = this.performanceClient) && o.setPreQueueTime(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId), [4, this.updateMetadataWithRegionalInformation(t)]) : [3, 3] : [3, 4];
            case 2:
              t = e.sent(), e.label = 3;
            case 3:
              return n.updateEndpointMetadata(t, !0), [2, AuthorityMetadataSource.NETWORK];
            case 4:
              return !(r = this.getEndpointMetadataFromHardcodedValues()) || this.authorityOptions.skipAuthorityMetadataCache ? [3, 7] : null != (o = this.authorityOptions.azureRegionConfiguration) && o.azureRegion ? (null != (a = this.performanceClient) && a.setPreQueueTime(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId), [4, this.updateMetadataWithRegionalInformation(r)]) : [3, 6];
            case 5:
              r = e.sent(), e.label = 6;
            case 6:
              return n.updateEndpointMetadata(r, !1), [2, AuthorityMetadataSource.HARDCODED_VALUES];
            case 7:
              throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);
          }
        });
      });
    }, l.prototype.isAuthoritySameType = function (e) {
      return new UrlString(e.canonical_authority).getUrlComponents().PathSegments.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
    }, l.prototype.getEndpointMetadataFromConfig = function () {
      if (this.authorityOptions.authorityMetadata) try {
        return JSON.parse(this.authorityOptions.authorityMetadata);
      } catch (e) {
        throw ClientConfigurationError.createInvalidAuthorityMetadataError();
      }
      return null;
    }, l.prototype.getEndpointMetadataFromNetwork = function () {
      var n;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              null != (n = this.performanceClient) && n.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId), t = {}, e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), [4, this.networkInterface.sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint, t)];
            case 2:
              return [2, isOpenIdConfigResponse((r = e.sent()).body) ? r.body : null];
            case 3:
              return e.sent(), [2, null];
            case 4:
              return [2];
          }
        });
      });
    }, l.prototype.getEndpointMetadataFromHardcodedValues = function () {
      return this.canonicalAuthority in EndpointMetadata ? EndpointMetadata[this.canonicalAuthority] : null;
    }, l.prototype.updateMetadataWithRegionalInformation = function (r) {
      var n;
      return __awaiter$2(this, void 0, void 0, function () {
        var t;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return (null != (n = this.performanceClient) && n.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId), t = null == (n = this.authorityOptions.azureRegionConfiguration) ? void 0 : n.azureRegion) ? t !== Constants.AZURE_REGION_AUTO_DISCOVER_FLAG ? (this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION, this.regionDiscoveryMetadata.region_used = t, [2, l.replaceWithRegionalInformation(r, t)]) : (null != (n = this.performanceClient) && n.setPreQueueTime(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId), [4, this.regionDiscovery.detectRegion(null == (n = this.authorityOptions.azureRegionConfiguration) ? void 0 : n.environmentRegion, this.regionDiscoveryMetadata)]) : [3, 2];
            case 1:
              if (t = e.sent()) return this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL, this.regionDiscoveryMetadata.region_used = t, [2, l.replaceWithRegionalInformation(r, t)];
              this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED, e.label = 2;
            case 2:
              return [2, r];
          }
        });
      });
    }, l.prototype.updateCloudDiscoveryMetadata = function (n) {
      var i;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              return (null != (i = this.performanceClient) && i.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId), this.logger.verbose("Attempting to get cloud discovery metadata in the config"), this.logger.verbosePii("Known Authorities: " + (this.authorityOptions.knownAuthorities || Constants.NOT_APPLICABLE)), this.logger.verbosePii("Authority Metadata: " + (this.authorityOptions.authorityMetadata || Constants.NOT_APPLICABLE)), this.logger.verbosePii("Canonical Authority: " + (n.canonical_authority || Constants.NOT_APPLICABLE)), t = this.getCloudDiscoveryMetadataFromConfig()) ? (this.logger.verbose("Found cloud discovery metadata in the config."), n.updateCloudDiscoveryMetadata(t, !1), [2, AuthorityMetadataSource.CONFIG]) : (this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the cache."), r = n.isExpired(), this.isAuthoritySameType(n) && n.aliasesFromNetwork && !r ? (this.logger.verbose("Found metadata in the cache."), [2, AuthorityMetadataSource.CACHE]) : (r && this.logger.verbose("The metadata entity is expired."), this.logger.verbose("Did not find cloud discovery metadata in the cache... Attempting to get cloud discovery metadata from the network."), null != (i = this.performanceClient) && i.setPreQueueTime(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId), [4, this.getCloudDiscoveryMetadataFromNetwork()]));
            case 1:
              if (t = e.sent()) return this.logger.verbose("cloud discovery metadata was successfully returned from getCloudDiscoveryMetadataFromNetwork()"), n.updateCloudDiscoveryMetadata(t, !0), [2, AuthorityMetadataSource.NETWORK];
              if (this.logger.verbose("Did not find cloud discovery metadata from the network... Attempting to get cloud discovery metadata from hardcoded values."), (r = this.getCloudDiscoveryMetadataFromHarcodedValues()) && !this.options.skipAuthorityMetadataCache) return this.logger.verbose("Found cloud discovery metadata from hardcoded values."), n.updateCloudDiscoveryMetadata(r, !1), [2, AuthorityMetadataSource.HARDCODED_VALUES];
              throw this.logger.error("Did not find cloud discovery metadata from hardcoded values... Metadata could not be obtained from config, cache, network or hardcoded values. Throwing Untrusted Authority Error."), ClientConfigurationError.createUntrustedAuthorityError();
          }
        });
      });
    }, l.prototype.getCloudDiscoveryMetadataFromConfig = function () {
      if (this.authorityType === AuthorityType.Ciam) return this.logger.verbose("CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host."), l.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
      if (this.authorityOptions.cloudDiscoveryMetadata) {
        this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");
        try {
          this.logger.verbose("Attempting to parse the cloud discovery metadata.");
          var e = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata),
            t = l.getCloudDiscoveryMetadataFromNetworkResponse(e.metadata, this.hostnameAndPort);
          if (this.logger.verbose("Parsed the cloud discovery metadata."), t) return this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata."), t;
          this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.");
        } catch (e) {
          throw this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error."), ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();
        }
      }
      return this.isInKnownAuthorities() ? (this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host."), l.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort)) : null;
    }, l.prototype.getCloudDiscoveryMetadataFromNetwork = function () {
      var s;
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r, n, i, o, a;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              null != (s = this.performanceClient) && s.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId), t = "" + Constants.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + "oauth2/v2.0/authorize", r = {}, n = null, e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), [4, this.networkInterface.sendGetRequestAsync(t, r)];
            case 2:
              if (a = e.sent(), o = i = void 0, isCloudInstanceDiscoveryResponse(a.body)) i = a.body, o = i.metadata, this.logger.verbosePii("tenant_discovery_endpoint is: " + i.tenant_discovery_endpoint);else {
                if (!isCloudInstanceDiscoveryErrorResponse(a.body)) return this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse"), [2, null];
                if (this.logger.warning("A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: " + a.status), (i = a.body).error === Constants.INVALID_INSTANCE) return this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance."), [2, null];
                this.logger.warning("The CloudInstanceDiscoveryErrorResponse error is " + i.error), this.logger.warning("The CloudInstanceDiscoveryErrorResponse error description is " + i.error_description), this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []"), o = [];
              }
              return this.logger.verbose("Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request."), n = l.getCloudDiscoveryMetadataFromNetworkResponse(o, this.hostnameAndPort), [3, 4];
            case 3:
              return (a = e.sent()) instanceof AuthError ? this.logger.error("There was a network error while attempting to get the cloud discovery instance metadata.\nError: " + a.errorCode + "\nError Description: " + a.errorMessage) : this.logger.error("A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.\nError: " + a.name + "\nError Description: " + a.message), [2, null];
            case 4:
              return n || (this.logger.warning("The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request."), this.logger.verbose("Creating custom Authority for custom domain scenario."), n = l.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort)), [2, n];
          }
        });
      });
    }, l.prototype.getCloudDiscoveryMetadataFromHarcodedValues = function () {
      return this.canonicalAuthority in InstanceDiscoveryMetadata ? InstanceDiscoveryMetadata[this.canonicalAuthority] : null;
    }, l.prototype.isInKnownAuthorities = function () {
      var t = this;
      return 0 < this.authorityOptions.knownAuthorities.filter(function (e) {
        return UrlString.getDomainFromUrl(e).toLowerCase() === t.hostnameAndPort;
      }).length;
    }, l.generateAuthority = function (e, t) {
      var r;
      return t && t.azureCloudInstance !== AzureCloudInstance.None && (r = t.tenant || Constants.DEFAULT_COMMON_TENANT, r = t.azureCloudInstance + "/" + r + "/"), r || e;
    }, l.createCloudDiscoveryMetadataFromHost = function (e) {
      return {
        preferred_network: e,
        preferred_cache: e,
        aliases: [e]
      };
    }, l.getCloudDiscoveryMetadataFromNetworkResponse = function (e, t) {
      for (var r = 0; r < e.length; r++) {
        var n = e[r];
        if (-1 < n.aliases.indexOf(t)) return n;
      }
      return null;
    }, l.prototype.getPreferredCache = function () {
      if (this.discoveryComplete()) return this.metadata.preferred_cache;
      throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
    }, l.prototype.isAlias = function (e) {
      return -1 < this.metadata.aliases.indexOf(e);
    }, l.isPublicCloudAuthority = function (e) {
      return 0 <= Constants.KNOWN_PUBLIC_CLOUDS.indexOf(e);
    }, l.buildRegionalAuthorityString = function (e, t, r) {
      var e = new UrlString(e),
        n = (e.validateAsUri(), e.getUrlComponents()),
        i = t + "." + n.HostNameAndPort,
        n = (this.isPublicCloudAuthority(n.HostNameAndPort) && (i = t + "." + Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX), UrlString.constructAuthorityUriFromObject(__assign$4(__assign$4({}, e.getUrlComponents()), {
          HostNameAndPort: i
        })).urlString);
      return r ? n + "?" + r : n;
    }, l.replaceWithRegionalInformation = function (e, t) {
      return e.authorization_endpoint = l.buildRegionalAuthorityString(e.authorization_endpoint, t), e.token_endpoint = l.buildRegionalAuthorityString(e.token_endpoint, t, Constants.REGIONAL_AUTH_NON_MSI_QUERY_STRING), e.end_session_endpoint && (e.end_session_endpoint = l.buildRegionalAuthorityString(e.end_session_endpoint, t)), e;
    }, l.transformCIAMAuthority = function (e) {
      var t = e.endsWith(Constants.FORWARD_SLASH) ? e : "" + e + Constants.FORWARD_SLASH,
        e = new UrlString(e).getUrlComponents();
      return t = 0 === e.PathSegments.length && e.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL) ? "" + t + e.HostNameAndPort.split(".")[0] + Constants.AAD_TENANT_DOMAIN_SUFFIX : t;
    }, l.reservedTenantDomains = new Set(["{tenant}", "{tenantid}", AADAuthorityConstants.COMMON, AADAuthorityConstants.CONSUMERS, AADAuthorityConstants.ORGANIZATIONS]), l;
  }(),
  AuthorityFactory = function () {
    function u() {}
    return u.createDiscoveredInstance = function (n, i, o, a, s, l, c) {
      return __awaiter$2(this, void 0, void 0, function () {
        var t, r;
        return __generator$2(this, function (e) {
          switch (e.label) {
            case 0:
              null != l && l.addQueueMeasurement(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, c), t = Authority.transformCIAMAuthority(n), t = u.createInstance(t, i, o, a, s, l, c), e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), null != l && l.setPreQueueTime(PerformanceEvents.AuthorityResolveEndpointsAsync, c), [4, t.resolveEndpointsAsync()];
            case 2:
              return e.sent(), [2, t];
            case 3:
              throw r = e.sent(), ClientAuthError.createEndpointDiscoveryIncompleteError(r);
            case 4:
              return [2];
          }
        });
      });
    }, u.createInstance = function (e, t, r, n, i, o, a) {
      if (StringUtils.isEmpty(e)) throw ClientConfigurationError.createUrlEmptyError();
      return new Authority(e, t, r, n, i, o, a);
    }, u;
  }(),
  ServerTelemetryEntity = function () {
    function e() {
      this.failedRequests = [], this.errors = [], this.cacheHits = 0;
    }
    return e.isServerTelemetryEntity = function (e, t) {
      var e = 0 === e.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY),
        r = !0;
      return t && (r = t.hasOwnProperty("failedRequests") && t.hasOwnProperty("errors") && t.hasOwnProperty("cacheHits")), e && r;
    }, e;
  }(),
  ThrottlingEntity = function () {
    function e() {}
    return e.isThrottlingEntity = function (e, t) {
      var r = !1,
        e = (e && (r = 0 === e.indexOf(ThrottlingConstants.THROTTLING_PREFIX)), !0);
      return t && (e = t.hasOwnProperty("throttleTime")), r && e;
    }, e;
  }(),
  StubbedNetworkModule = {
    sendGetRequestAsync: function () {
      return Promise.reject(AuthError.createUnexpectedError("Network interface - sendGetRequestAsync() has not been implemented for the Network interface."));
    },
    sendPostRequestAsync: function () {
      return Promise.reject(AuthError.createUnexpectedError("Network interface - sendPostRequestAsync() has not been implemented for the Network interface."));
    }
  },
  JoseHeaderErrorMessage = {
    missingKidError: {
      code: "missing_kid_error",
      desc: "The JOSE Header for the requested JWT, JWS or JWK object requires a keyId to be configured as the 'kid' header claim. No 'kid' value was provided."
    },
    missingAlgError: {
      code: "missing_alg_error",
      desc: "The JOSE Header for the requested JWT, JWS or JWK object requires an algorithm to be specified as the 'alg' header claim. No 'alg' value was provided."
    }
  },
  JoseHeaderError = function (r) {
    function n(e, t) {
      e = r.call(this, e, t) || this;
      return e.name = "JoseHeaderError", Object.setPrototypeOf(e, n.prototype), e;
    }
    return __extends$f(n, r), n.createMissingKidError = function () {
      return new n(JoseHeaderErrorMessage.missingKidError.code, JoseHeaderErrorMessage.missingKidError.desc);
    }, n.createMissingAlgError = function () {
      return new n(JoseHeaderErrorMessage.missingAlgError.code, JoseHeaderErrorMessage.missingAlgError.desc);
    }, n;
  }(AuthError),
  JoseHeader = function () {
    function t(e) {
      this.typ = e.typ, this.alg = e.alg, this.kid = e.kid;
    }
    return t.getShrHeaderString = function (e) {
      if (!e.kid) throw JoseHeaderError.createMissingKidError();
      if (e.alg) return e = new t({
        typ: e.typ || JsonTypes.Pop,
        kid: e.kid,
        alg: e.alg
      }), JSON.stringify(e);
      throw JoseHeaderError.createMissingAlgError();
    }, t;
  }(),
  ServerTelemetryManager = function () {
    function o(e, t) {
      this.cacheOutcome = CacheOutcome.NO_CACHE_HIT, this.cacheManager = t, this.apiId = e.apiId, this.correlationId = e.correlationId, this.wrapperSKU = e.wrapperSKU || Constants.EMPTY_STRING, this.wrapperVer = e.wrapperVer || Constants.EMPTY_STRING, this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + e.clientId;
    }
    return o.prototype.generateCurrentRequestHeaderValue = function () {
      var e = "" + this.apiId + SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR + this.cacheOutcome,
        t = [this.wrapperSKU, this.wrapperVer].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR),
        e = [e, this.getRegionDiscoveryFields()].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
      return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, e, t].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
    }, o.prototype.generateLastRequestHeaderValue = function () {
      var e = this.getLastRequests(),
        t = o.maxErrorsToSend(e),
        r = e.failedRequests.slice(0, 2 * t).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR),
        n = e.errors.slice(0, t).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR),
        i = e.errors.length,
        t = [i, t < i ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
      return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, e.cacheHits, r, n, t].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
    }, o.prototype.cacheFailedRequest = function (e) {
      var t = this.getLastRequests();
      t.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS && (t.failedRequests.shift(), t.failedRequests.shift(), t.errors.shift()), t.failedRequests.push(this.apiId, this.correlationId), StringUtils.isEmpty(e.subError) ? StringUtils.isEmpty(e.errorCode) ? e && e.toString() ? t.errors.push(e.toString()) : t.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR) : t.errors.push(e.errorCode) : t.errors.push(e.subError), this.cacheManager.setServerTelemetry(this.telemetryCacheKey, t);
    }, o.prototype.incrementCacheHits = function () {
      var e = this.getLastRequests();
      return e.cacheHits += 1, this.cacheManager.setServerTelemetry(this.telemetryCacheKey, e), e.cacheHits;
    }, o.prototype.getLastRequests = function () {
      var e = new ServerTelemetryEntity();
      return this.cacheManager.getServerTelemetry(this.telemetryCacheKey) || e;
    }, o.prototype.clearTelemetryCache = function () {
      var e,
        t = this.getLastRequests(),
        r = o.maxErrorsToSend(t);
      r === t.errors.length ? this.cacheManager.removeItem(this.telemetryCacheKey) : ((e = new ServerTelemetryEntity()).failedRequests = t.failedRequests.slice(2 * r), e.errors = t.errors.slice(r), this.cacheManager.setServerTelemetry(this.telemetryCacheKey, e));
    }, o.maxErrorsToSend = function (e) {
      for (var t = 0, r = 0, n = e.errors.length, i = 0; i < n; i++) {
        var o = e.failedRequests[2 * i] || Constants.EMPTY_STRING,
          a = e.failedRequests[2 * i + 1] || Constants.EMPTY_STRING,
          s = e.errors[i] || Constants.EMPTY_STRING;
        if (!((r += o.toString().length + a.toString().length + s.length + 3) < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES)) break;
        t += 1;
      }
      return t;
    }, o.prototype.getRegionDiscoveryFields = function () {
      var e = [];
      return e.push(this.regionUsed || Constants.EMPTY_STRING), e.push(this.regionSource || Constants.EMPTY_STRING), e.push(this.regionOutcome || Constants.EMPTY_STRING), e.join(",");
    }, o.prototype.updateRegionDiscoveryMetadata = function (e) {
      this.regionUsed = e.region_used, this.regionSource = e.region_source, this.regionOutcome = e.region_outcome;
    }, o.prototype.setCacheOutcome = function (e) {
      this.cacheOutcome = e;
    }, o;
  }(),
  PerformanceClient = function () {
    function e(e, t, r, n, i, o) {
      this.authority = t, this.libraryName = n, this.libraryVersion = i, this.applicationTelemetry = o, this.clientId = e, this.logger = r, this.callbacks = new Map(), this.eventsByCorrelationId = new Map(), this.queueMeasurements = new Map(), this.preQueueTimeByCorrelationId = new Map();
    }
    return e.prototype.startPerformanceMeasurement = function (e, t) {
      return {};
    }, e.prototype.startPerformanceMeasuremeant = function (e, t) {
      return {};
    }, e.prototype.getIntFields = function () {
      return IntFields;
    }, e.prototype.getPreQueueTime = function (e, t) {
      var r = this.preQueueTimeByCorrelationId.get(t);
      if (r) {
        if (r.name === e) return r.time;
        this.logger.trace("PerformanceClient.getPreQueueTime: no pre-queue time found for " + e + ", unable to add queue measurement");
      } else this.logger.trace("PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: " + t + ", unable to add queue measurement");
    }, e.prototype.calculateQueuedTime = function (e, t) {
      return e < 1 ? (this.logger.trace("PerformanceClient: preQueueTime should be a positive integer and not " + e), 0) : t < 1 ? (this.logger.trace("PerformanceClient: currentTime should be a positive integer and not " + t), 0) : t < e ? (this.logger.trace("PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved"), 0) : t - e;
    }, e.prototype.addQueueMeasurement = function (e, t, r, n) {
      if (t) {
        if (0 === r) this.logger.trace("PerformanceClient.addQueueMeasurement: queue time provided for " + e + " is " + r);else if (!r) return void this.logger.trace("PerformanceClient.addQueueMeasurement: no queue time provided for " + e);
        r = {
          eventName: e,
          queueTime: r,
          manuallyCompleted: n
        }, n = this.queueMeasurements.get(t);
        n ? (n.push(r), this.queueMeasurements.set(t, n)) : (this.logger.trace("PerformanceClient.addQueueMeasurement: adding correlationId " + t + " to queue measurements"), this.queueMeasurements.set(t, [r])), this.preQueueTimeByCorrelationId.delete(t);
      } else this.logger.trace("PerformanceClient.addQueueMeasurement: correlationId not provided for " + e + ", cannot add queue measurement");
    }, e.prototype.startMeasurement = function (e, t) {
      var r = this,
        n = t || this.generateId(),
        i = (t || this.logger.info("PerformanceClient: No correlation id provided for " + e + ", generating", n), this.logger.trace("PerformanceClient: Performance measurement started for " + e, n), this.startPerformanceMeasuremeant(e, n)),
        o = (i.startMeasurement(), {
          eventId: this.generateId(),
          status: PerformanceEventStatus.InProgress,
          authority: this.authority,
          libraryName: this.libraryName,
          libraryVersion: this.libraryVersion,
          clientId: this.clientId,
          name: e,
          startTimeMs: Date.now(),
          correlationId: n,
          appName: null == (t = this.applicationTelemetry) ? void 0 : t.appName,
          appVersion: null == (e = this.applicationTelemetry) ? void 0 : e.appVersion
        });
      return this.cacheEventByCorrelationId(o), {
        endMeasurement: function (e) {
          return r.endMeasurement(__assign$4(__assign$4({}, o), e), i);
        },
        discardMeasurement: function () {
          return r.discardMeasurements(o.correlationId);
        },
        addStaticFields: function (e) {
          return r.addStaticFields(e, o.correlationId);
        },
        increment: function (e) {
          return r.increment(e, o.correlationId);
        },
        measurement: i,
        event: o
      };
    }, e.prototype.endMeasurement = function (t, e) {
      var r,
        n,
        i,
        o,
        a,
        s = this,
        l = this.eventsByCorrelationId.get(t.correlationId);
      return l ? (n = {
        totalQueueTime: 0,
        totalQueueCount: 0,
        manuallyCompletedCount: 0
      }, (r = t.eventId === l.eventId) ? (n = this.getQueueInfo(t.correlationId), this.discardCache(l.correlationId)) : null != (i = l.incompleteSubMeasurements) && i.delete(t.eventId), null != e && e.endMeasurement(), (i = null == e ? void 0 : e.flushMeasurement()) ? (this.logger.trace("PerformanceClient: Performance measurement ended for " + t.name + ": " + i + " ms", t.correlationId), r ? (o = __assign$4(__assign$4({}, l), t), a = 0, null != (e = o.incompleteSubMeasurements) && e.forEach(function (e) {
        s.logger.trace("PerformanceClient: Incomplete submeasurement " + e.name + " found for " + t.name, o.correlationId), a++;
      }), o.incompleteSubMeasurements = void 0, o = __assign$4(__assign$4({}, o), {
        durationMs: Math.round(i),
        queuedTimeMs: n.totalQueueTime,
        queuedCount: n.totalQueueCount,
        queuedManuallyCompletedCount: n.manuallyCompletedCount,
        status: PerformanceEventStatus.Completed,
        incompleteSubsCount: a
      }), this.truncateIntegralFields(o, this.getIntFields()), this.emitEvents([o], t.correlationId), o) : (l[t.name + "DurationMs"] = Math.floor(i), __assign$4({}, l))) : (this.logger.trace("PerformanceClient: Performance measurement not taken", l.correlationId), null)) : (this.logger.trace("PerformanceClient: Measurement not found for " + t.eventId, t.correlationId), null);
    }, e.prototype.addStaticFields = function (e, t) {
      this.logger.trace("PerformanceClient: Updating static fields");
      var r = this.eventsByCorrelationId.get(t);
      r ? this.eventsByCorrelationId.set(t, __assign$4(__assign$4({}, r), e)) : this.logger.trace("PerformanceClient: Event not found for", t);
    }, e.prototype.increment = function (e, t) {
      this.logger.trace("PerformanceClient: Updating counters");
      var r = this.eventsByCorrelationId.get(t);
      if (r) for (var n in e) r.hasOwnProperty(n) || (r[n] = 0), r[n] += e[n];else this.logger.trace("PerformanceClient: Event not found for", t);
    }, e.prototype.cacheEventByCorrelationId = function (e) {
      var t = this.eventsByCorrelationId.get(e.correlationId);
      t ? (this.logger.trace("PerformanceClient: Performance measurement for " + e.name + " added/updated", e.correlationId), t.incompleteSubMeasurements = t.incompleteSubMeasurements || new Map(), t.incompleteSubMeasurements.set(e.eventId, {
        name: e.name,
        startTimeMs: e.startTimeMs
      })) : (this.logger.trace("PerformanceClient: Performance measurement for " + e.name + " started", e.correlationId), this.eventsByCorrelationId.set(e.correlationId, __assign$4({}, e)));
    }, e.prototype.getQueueInfo = function (e) {
      var t = this.queueMeasurements.get(e),
        r = (t || this.logger.trace("PerformanceClient: no queue measurements found for for correlationId: " + e), 0),
        n = 0,
        i = 0;
      return null != t && t.forEach(function (e) {
        r += e.queueTime, n++, i += e.manuallyCompleted ? 1 : 0;
      }), {
        totalQueueTime: r,
        totalQueueCount: n,
        manuallyCompletedCount: i
      };
    }, e.prototype.discardMeasurements = function (e) {
      this.logger.trace("PerformanceClient: Performance measurements discarded", e), this.eventsByCorrelationId.delete(e);
    }, e.prototype.discardCache = function (e) {
      this.discardMeasurements(e), this.logger.trace("PerformanceClient: QueueMeasurements discarded", e), this.queueMeasurements.delete(e), this.logger.trace("PerformanceClient: Pre-queue times discarded", e), this.preQueueTimeByCorrelationId.delete(e);
    }, e.prototype.addPerformanceCallback = function (e) {
      var t = this.generateId();
      return this.callbacks.set(t, e), this.logger.verbose("PerformanceClient: Performance callback registered with id: " + t), t;
    }, e.prototype.removePerformanceCallback = function (e) {
      var t = this.callbacks.delete(e);
      return t ? this.logger.verbose("PerformanceClient: Performance callback " + e + " removed.") : this.logger.verbose("PerformanceClient: Performance callback " + e + " not removed."), t;
    }, e.prototype.emitEvents = function (r, n) {
      var i = this;
      this.logger.verbose("PerformanceClient: Emitting performance events", n), this.callbacks.forEach(function (e, t) {
        i.logger.trace("PerformanceClient: Emitting event to callback " + t, n), e.apply(null, [r]);
      });
    }, e.prototype.truncateIntegralFields = function (t, e) {
      e.forEach(function (e) {
        e in t && "number" == typeof t[e] && (t[e] = Math.floor(t[e]));
      });
    }, e;
  }(),
  StubPerformanceMeasurement = function () {
    function e() {}
    return e.prototype.startMeasurement = function () {}, e.prototype.endMeasurement = function () {}, e.prototype.flushMeasurement = function () {
      return null;
    }, e;
  }(),
  StubPerformanceClient = function (e) {
    function t() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends$f(t, e), t.prototype.generateId = function () {
      return "callback-id";
    }, t.prototype.startPerformanceMeasuremeant = function () {
      return new StubPerformanceMeasurement();
    }, t.prototype.startPerformanceMeasurement = function () {
      return new StubPerformanceMeasurement();
    }, t.prototype.calculateQueuedTime = function (e, t) {
      return 0;
    }, t.prototype.addQueueMeasurement = function (e, t, r) {}, t.prototype.setPreQueueTime = function (e, t) {}, t;
  }(PerformanceClient),
  BrowserAuthErrorMessage = {
    pkceNotGenerated: {
      code: "pkce_not_created",
      desc: "The PKCE code challenge and verifier could not be generated."
    },
    cryptoDoesNotExist: {
      code: "crypto_nonexistent",
      desc: "The crypto object or function is not available."
    },
    httpMethodNotImplementedError: {
      code: "http_method_not_implemented",
      desc: "The HTTP method given has not been implemented in this library."
    },
    emptyNavigateUriError: {
      code: "empty_navigate_uri",
      desc: "Navigation URI is empty. Please check stack trace for more info."
    },
    hashEmptyError: {
      code: "hash_empty_error",
      desc: "Hash value cannot be processed because it is empty. Please verify that your redirectUri is not clearing the hash. For more visit: aka.ms/msaljs/browser-errors."
    },
    hashDoesNotContainStateError: {
      code: "no_state_in_hash",
      desc: "Hash does not contain state. Please verify that the request originated from msal."
    },
    hashDoesNotContainKnownPropertiesError: {
      code: "hash_does_not_contain_known_properties",
      desc: "Hash does not contain known properites. Please verify that your redirectUri is not changing the hash. For more visit: aka.ms/msaljs/browser-errors."
    },
    unableToParseStateError: {
      code: "unable_to_parse_state",
      desc: "Unable to parse state. Please verify that the request originated from msal."
    },
    stateInteractionTypeMismatchError: {
      code: "state_interaction_type_mismatch",
      desc: "Hash contains state but the interaction type does not match the caller."
    },
    interactionInProgress: {
      code: "interaction_in_progress",
      desc: "Interaction is currently in progress. Please ensure that this interaction has been completed before calling an interactive API.  For more visit: aka.ms/msaljs/browser-errors."
    },
    popupWindowError: {
      code: "popup_window_error",
      desc: "Error opening popup window. This can happen if you are using IE or if popups are blocked in the browser."
    },
    emptyWindowError: {
      code: "empty_window_error",
      desc: "window.open returned null or undefined window object."
    },
    userCancelledError: {
      code: "user_cancelled",
      desc: "User cancelled the flow."
    },
    monitorPopupTimeoutError: {
      code: "monitor_window_timeout",
      desc: "Token acquisition in popup failed due to timeout. For more visit: aka.ms/msaljs/browser-errors."
    },
    monitorIframeTimeoutError: {
      code: "monitor_window_timeout",
      desc: "Token acquisition in iframe failed due to timeout. For more visit: aka.ms/msaljs/browser-errors."
    },
    redirectInIframeError: {
      code: "redirect_in_iframe",
      desc: "Redirects are not supported for iframed or brokered applications. Please ensure you are using MSAL.js in a top frame of the window if using the redirect APIs, or use the popup APIs."
    },
    blockTokenRequestsInHiddenIframeError: {
      code: "block_iframe_reload",
      desc: "Request was blocked inside an iframe because MSAL detected an authentication response. For more visit: aka.ms/msaljs/browser-errors"
    },
    blockAcquireTokenInPopupsError: {
      code: "block_nested_popups",
      desc: "Request was blocked inside a popup because MSAL detected it was running in a popup."
    },
    iframeClosedPrematurelyError: {
      code: "iframe_closed_prematurely",
      desc: "The iframe being monitored was closed prematurely."
    },
    silentLogoutUnsupportedError: {
      code: "silent_logout_unsupported",
      desc: "Silent logout not supported. Please call logoutRedirect or logoutPopup instead."
    },
    noAccountError: {
      code: "no_account_error",
      desc: "No account object provided to acquireTokenSilent and no active account has been set. Please call setActiveAccount or provide an account on the request."
    },
    silentPromptValueError: {
      code: "silent_prompt_value_error",
      desc: "The value given for the prompt value is not valid for silent requests - must be set to 'none' or 'no_session'."
    },
    noTokenRequestCacheError: {
      code: "no_token_request_cache_error",
      desc: "No token request found in cache."
    },
    unableToParseTokenRequestCacheError: {
      code: "unable_to_parse_token_request_cache_error",
      desc: "The cached token request could not be parsed."
    },
    noCachedAuthorityError: {
      code: "no_cached_authority_error",
      desc: "No cached authority found."
    },
    authRequestNotSet: {
      code: "auth_request_not_set_error",
      desc: "Auth Request not set. Please ensure initiateAuthRequest was called from the InteractionHandler"
    },
    invalidCacheType: {
      code: "invalid_cache_type",
      desc: "Invalid cache type"
    },
    notInBrowserEnvironment: {
      code: "non_browser_environment",
      desc: "Login and token requests are not supported in non-browser environments."
    },
    databaseNotOpen: {
      code: "database_not_open",
      desc: "Database is not open!"
    },
    noNetworkConnectivity: {
      code: "no_network_connectivity",
      desc: "No network connectivity. Check your internet connection."
    },
    postRequestFailed: {
      code: "post_request_failed",
      desc: "Network request failed: If the browser threw a CORS error, check that the redirectUri is registered in the Azure App Portal as type 'SPA'"
    },
    getRequestFailed: {
      code: "get_request_failed",
      desc: "Network request failed. Please check the network trace to determine root cause."
    },
    failedToParseNetworkResponse: {
      code: "failed_to_parse_response",
      desc: "Failed to parse network response. Check network trace."
    },
    unableToLoadTokenError: {
      code: "unable_to_load_token",
      desc: "Error loading token to cache."
    },
    signingKeyNotFoundInStorage: {
      code: "crypto_key_not_found",
      desc: "Cryptographic Key or Keypair not found in browser storage."
    },
    authCodeRequired: {
      code: "auth_code_required",
      desc: "An authorization code must be provided (as the `code` property on the request) to this flow."
    },
    authCodeOrNativeAccountRequired: {
      code: "auth_code_or_nativeAccountId_required",
      desc: "An authorization code or nativeAccountId must be provided to this flow."
    },
    spaCodeAndNativeAccountPresent: {
      code: "spa_code_and_nativeAccountId_present",
      desc: "Request cannot contain both spa code and native account id."
    },
    databaseUnavailable: {
      code: "database_unavailable",
      desc: "IndexedDB, which is required for persistent cryptographic key storage, is unavailable. This may be caused by browser privacy features which block persistent storage in third-party contexts."
    },
    unableToAcquireTokenFromNativePlatform: {
      code: "unable_to_acquire_token_from_native_platform",
      desc: "Unable to acquire token from native platform. For a list of possible reasons visit aka.ms/msaljs/browser-errors."
    },
    nativeHandshakeTimeout: {
      code: "native_handshake_timeout",
      desc: "Timed out while attempting to establish connection to browser extension"
    },
    nativeExtensionNotInstalled: {
      code: "native_extension_not_installed",
      desc: "Native extension is not installed. If you think this is a mistake call the initialize function."
    },
    nativeConnectionNotEstablished: {
      code: "native_connection_not_established",
      desc: "Connection to native platform has not been established. Please install a compatible browser extension and run initialize(). For more please visit aka.ms/msaljs/browser-errors."
    },
    nativeBrokerCalledBeforeInitialize: {
      code: "native_broker_called_before_initialize",
      desc: "You must call and await the initialize function before attempting to call any other MSAL API when native brokering is enabled. For more please visit aka.ms/msaljs/browser-errors."
    },
    nativePromptNotSupported: {
      code: "native_prompt_not_supported",
      desc: "The provided prompt is not supported by the native platform. This request should be routed to the web based flow."
    }
  },
  BrowserAuthError = function (r) {
    function n(e, t) {
      e = r.call(this, e, t) || this;
      return Object.setPrototypeOf(e, n.prototype), e.name = "BrowserAuthError", e;
    }
    return __extends$g(n, r), n.createPkceNotGeneratedError = function (e) {
      return new n(BrowserAuthErrorMessage.pkceNotGenerated.code, BrowserAuthErrorMessage.pkceNotGenerated.desc + " Detail:" + e);
    }, n.createCryptoNotAvailableError = function (e) {
      return new n(BrowserAuthErrorMessage.cryptoDoesNotExist.code, BrowserAuthErrorMessage.cryptoDoesNotExist.desc + " Detail:" + e);
    }, n.createHttpMethodNotImplementedError = function (e) {
      return new n(BrowserAuthErrorMessage.httpMethodNotImplementedError.code, BrowserAuthErrorMessage.httpMethodNotImplementedError.desc + " Given Method: " + e);
    }, n.createEmptyNavigationUriError = function () {
      return new n(BrowserAuthErrorMessage.emptyNavigateUriError.code, BrowserAuthErrorMessage.emptyNavigateUriError.desc);
    }, n.createEmptyHashError = function (e) {
      return new n(BrowserAuthErrorMessage.hashEmptyError.code, BrowserAuthErrorMessage.hashEmptyError.desc + " Given Url: " + e);
    }, n.createHashDoesNotContainStateError = function () {
      return new n(BrowserAuthErrorMessage.hashDoesNotContainStateError.code, BrowserAuthErrorMessage.hashDoesNotContainStateError.desc);
    }, n.createHashDoesNotContainKnownPropertiesError = function () {
      return new n(BrowserAuthErrorMessage.hashDoesNotContainKnownPropertiesError.code, BrowserAuthErrorMessage.hashDoesNotContainKnownPropertiesError.desc);
    }, n.createUnableToParseStateError = function () {
      return new n(BrowserAuthErrorMessage.unableToParseStateError.code, BrowserAuthErrorMessage.unableToParseStateError.desc);
    }, n.createStateInteractionTypeMismatchError = function () {
      return new n(BrowserAuthErrorMessage.stateInteractionTypeMismatchError.code, BrowserAuthErrorMessage.stateInteractionTypeMismatchError.desc);
    }, n.createInteractionInProgressError = function () {
      return new n(BrowserAuthErrorMessage.interactionInProgress.code, BrowserAuthErrorMessage.interactionInProgress.desc);
    }, n.createPopupWindowError = function (e) {
      var t = BrowserAuthErrorMessage.popupWindowError.desc,
        t = StringUtils.isEmpty(e) ? t : t + " Details: " + e;
      return new n(BrowserAuthErrorMessage.popupWindowError.code, t);
    }, n.createEmptyWindowCreatedError = function () {
      return new n(BrowserAuthErrorMessage.emptyWindowError.code, BrowserAuthErrorMessage.emptyWindowError.desc);
    }, n.createUserCancelledError = function () {
      return new n(BrowserAuthErrorMessage.userCancelledError.code, BrowserAuthErrorMessage.userCancelledError.desc);
    }, n.createMonitorPopupTimeoutError = function () {
      return new n(BrowserAuthErrorMessage.monitorPopupTimeoutError.code, BrowserAuthErrorMessage.monitorPopupTimeoutError.desc);
    }, n.createMonitorIframeTimeoutError = function () {
      return new n(BrowserAuthErrorMessage.monitorIframeTimeoutError.code, BrowserAuthErrorMessage.monitorIframeTimeoutError.desc);
    }, n.createRedirectInIframeError = function (e) {
      return new n(BrowserAuthErrorMessage.redirectInIframeError.code, BrowserAuthErrorMessage.redirectInIframeError.desc + " (window.parent !== window) => " + e);
    }, n.createBlockReloadInHiddenIframeError = function () {
      return new n(BrowserAuthErrorMessage.blockTokenRequestsInHiddenIframeError.code, BrowserAuthErrorMessage.blockTokenRequestsInHiddenIframeError.desc);
    }, n.createBlockAcquireTokenInPopupsError = function () {
      return new n(BrowserAuthErrorMessage.blockAcquireTokenInPopupsError.code, BrowserAuthErrorMessage.blockAcquireTokenInPopupsError.desc);
    }, n.createIframeClosedPrematurelyError = function () {
      return new n(BrowserAuthErrorMessage.iframeClosedPrematurelyError.code, BrowserAuthErrorMessage.iframeClosedPrematurelyError.desc);
    }, n.createSilentLogoutUnsupportedError = function () {
      return new n(BrowserAuthErrorMessage.silentLogoutUnsupportedError.code, BrowserAuthErrorMessage.silentLogoutUnsupportedError.desc);
    }, n.createNoAccountError = function () {
      return new n(BrowserAuthErrorMessage.noAccountError.code, BrowserAuthErrorMessage.noAccountError.desc);
    }, n.createSilentPromptValueError = function (e) {
      return new n(BrowserAuthErrorMessage.silentPromptValueError.code, BrowserAuthErrorMessage.silentPromptValueError.desc + " Given value: " + e);
    }, n.createUnableToParseTokenRequestCacheError = function () {
      return new n(BrowserAuthErrorMessage.unableToParseTokenRequestCacheError.code, BrowserAuthErrorMessage.unableToParseTokenRequestCacheError.desc);
    }, n.createNoTokenRequestCacheError = function () {
      return new n(BrowserAuthErrorMessage.noTokenRequestCacheError.code, BrowserAuthErrorMessage.noTokenRequestCacheError.desc);
    }, n.createAuthRequestNotSetError = function () {
      return new n(BrowserAuthErrorMessage.authRequestNotSet.code, BrowserAuthErrorMessage.authRequestNotSet.desc);
    }, n.createNoCachedAuthorityError = function () {
      return new n(BrowserAuthErrorMessage.noCachedAuthorityError.code, BrowserAuthErrorMessage.noCachedAuthorityError.desc);
    }, n.createInvalidCacheTypeError = function () {
      return new n(BrowserAuthErrorMessage.invalidCacheType.code, "" + BrowserAuthErrorMessage.invalidCacheType.desc);
    }, n.createNonBrowserEnvironmentError = function () {
      return new n(BrowserAuthErrorMessage.notInBrowserEnvironment.code, BrowserAuthErrorMessage.notInBrowserEnvironment.desc);
    }, n.createDatabaseNotOpenError = function () {
      return new n(BrowserAuthErrorMessage.databaseNotOpen.code, BrowserAuthErrorMessage.databaseNotOpen.desc);
    }, n.createNoNetworkConnectivityError = function () {
      return new n(BrowserAuthErrorMessage.noNetworkConnectivity.code, BrowserAuthErrorMessage.noNetworkConnectivity.desc);
    }, n.createPostRequestFailedError = function (e, t) {
      return new n(BrowserAuthErrorMessage.postRequestFailed.code, BrowserAuthErrorMessage.postRequestFailed.desc + " | Network client threw: " + e + " | Attempted to reach: " + t.split("?")[0]);
    }, n.createGetRequestFailedError = function (e, t) {
      return new n(BrowserAuthErrorMessage.getRequestFailed.code, BrowserAuthErrorMessage.getRequestFailed.desc + " | Network client threw: " + e + " | Attempted to reach: " + t.split("?")[0]);
    }, n.createFailedToParseNetworkResponseError = function (e) {
      return new n(BrowserAuthErrorMessage.failedToParseNetworkResponse.code, BrowserAuthErrorMessage.failedToParseNetworkResponse.desc + " | Attempted to reach: " + e.split("?")[0]);
    }, n.createUnableToLoadTokenError = function (e) {
      return new n(BrowserAuthErrorMessage.unableToLoadTokenError.code, BrowserAuthErrorMessage.unableToLoadTokenError.desc + " | " + e);
    }, n.createSigningKeyNotFoundInStorageError = function (e) {
      return new n(BrowserAuthErrorMessage.signingKeyNotFoundInStorage.code, BrowserAuthErrorMessage.signingKeyNotFoundInStorage.desc + " | No match found for KeyId: " + e);
    }, n.createAuthCodeRequiredError = function () {
      return new n(BrowserAuthErrorMessage.authCodeRequired.code, BrowserAuthErrorMessage.authCodeRequired.desc);
    }, n.createAuthCodeOrNativeAccountIdRequiredError = function () {
      return new n(BrowserAuthErrorMessage.authCodeOrNativeAccountRequired.code, BrowserAuthErrorMessage.authCodeOrNativeAccountRequired.desc);
    }, n.createSpaCodeAndNativeAccountIdPresentError = function () {
      return new n(BrowserAuthErrorMessage.spaCodeAndNativeAccountPresent.code, BrowserAuthErrorMessage.spaCodeAndNativeAccountPresent.desc);
    }, n.createDatabaseUnavailableError = function () {
      return new n(BrowserAuthErrorMessage.databaseUnavailable.code, BrowserAuthErrorMessage.databaseUnavailable.desc);
    }, n.createUnableToAcquireTokenFromNativePlatformError = function () {
      return new n(BrowserAuthErrorMessage.unableToAcquireTokenFromNativePlatform.code, BrowserAuthErrorMessage.unableToAcquireTokenFromNativePlatform.desc);
    }, n.createNativeHandshakeTimeoutError = function () {
      return new n(BrowserAuthErrorMessage.nativeHandshakeTimeout.code, BrowserAuthErrorMessage.nativeHandshakeTimeout.desc);
    }, n.createNativeExtensionNotInstalledError = function () {
      return new n(BrowserAuthErrorMessage.nativeExtensionNotInstalled.code, BrowserAuthErrorMessage.nativeExtensionNotInstalled.desc);
    }, n.createNativeConnectionNotEstablishedError = function () {
      return new n(BrowserAuthErrorMessage.nativeConnectionNotEstablished.code, BrowserAuthErrorMessage.nativeConnectionNotEstablished.desc);
    }, n.createNativeBrokerCalledBeforeInitialize = function () {
      return new n(BrowserAuthErrorMessage.nativeBrokerCalledBeforeInitialize.code, BrowserAuthErrorMessage.nativeBrokerCalledBeforeInitialize.desc);
    }, n.createNativePromptParameterNotSupportedError = function () {
      return new n(BrowserAuthErrorMessage.nativePromptNotSupported.code, BrowserAuthErrorMessage.nativePromptNotSupported.desc);
    }, n;
  }(AuthError),
  BrowserConstants = {
    INTERACTION_IN_PROGRESS_VALUE: "interaction_in_progress",
    INVALID_GRANT_ERROR: "invalid_grant",
    POPUP_WIDTH: 483,
    POPUP_HEIGHT: 600,
    POPUP_NAME_PREFIX: "msal",
    DEFAULT_POLL_INTERVAL_MS: 30,
    MSAL_SKU: "msal.js.browser"
  },
  NativeConstants = {
    CHANNEL_ID: "53ee284d-920a-4b59-9d30-a60315b26836",
    PREFERRED_EXTENSION_ID: "ppnbnpeolgkicgegkbkbjmhlideopiji",
    MATS_TELEMETRY: "MATS"
  },
  DEFAULT_REQUEST = (!function (e) {
    e.HandshakeRequest = "Handshake", e.HandshakeResponse = "HandshakeResponse", e.GetToken = "GetToken", e.Response = "Response";
  }(NativeExtensionMethod = NativeExtensionMethod || {}), !function (e) {
    e.LocalStorage = "localStorage", e.SessionStorage = "sessionStorage", e.MemoryStorage = "memoryStorage";
  }(BrowserCacheLocation = BrowserCacheLocation || {}), !function (e) {
    e.GET = "GET", e.POST = "POST";
  }(HTTP_REQUEST_TYPE = HTTP_REQUEST_TYPE || {}), !function (e) {
    e.AUTHORITY = "authority", e.ACQUIRE_TOKEN_ACCOUNT = "acquireToken.account", e.SESSION_STATE = "session.state", e.REQUEST_STATE = "request.state", e.NONCE_IDTOKEN = "nonce.id_token", e.ORIGIN_URI = "request.origin", e.RENEW_STATUS = "token.renew.status", e.URL_HASH = "urlHash", e.REQUEST_PARAMS = "request.params", e.SCOPES = "scopes", e.INTERACTION_STATUS_KEY = "interaction.status", e.CCS_CREDENTIAL = "ccs.credential", e.CORRELATION_ID = "request.correlationId", e.NATIVE_REQUEST = "request.native", e.REDIRECT_CONTEXT = "request.redirect.context";
  }(TemporaryCacheKeys = TemporaryCacheKeys || {}), !function (e) {
    e.ACCOUNT_KEYS = "msal.account.keys", e.TOKEN_KEYS = "msal.token.keys";
  }(StaticCacheKeys = StaticCacheKeys || {}), !function (e) {
    e.WRAPPER_SKU = "wrapper.sku", e.WRAPPER_VER = "wrapper.version";
  }(InMemoryCacheKeys = InMemoryCacheKeys || {}), !function (e) {
    e[e.acquireTokenRedirect = 861] = "acquireTokenRedirect", e[e.acquireTokenPopup = 862] = "acquireTokenPopup", e[e.ssoSilent = 863] = "ssoSilent", e[e.acquireTokenSilent_authCode = 864] = "acquireTokenSilent_authCode", e[e.handleRedirectPromise = 865] = "handleRedirectPromise", e[e.acquireTokenByCode = 866] = "acquireTokenByCode", e[e.acquireTokenSilent_silentFlow = 61] = "acquireTokenSilent_silentFlow", e[e.logout = 961] = "logout", e[e.logoutPopup = 962] = "logoutPopup";
  }(ApiId = ApiId || {}), !function (e) {
    e.Redirect = "redirect", e.Popup = "popup", e.Silent = "silent", e.None = "none";
  }(InteractionType = InteractionType || {}), !function (e) {
    e.Startup = "startup", e.Login = "login", e.Logout = "logout", e.AcquireToken = "acquireToken", e.SsoSilent = "ssoSilent", e.HandleRedirect = "handleRedirect", e.None = "none";
  }(InteractionStatus = InteractionStatus || {}), {
    scopes: OIDC_DEFAULT_SCOPES
  }),
  KEY_FORMAT_JWK = "jwk",
  DB_NAME = (!function (e) {
    e.React = "@azure/msal-react", e.Angular = "@azure/msal-angular";
  }(WrapperSKU = WrapperSKU || {}), "msal.db"),
  DB_VERSION = 1,
  DB_TABLE_NAME = DB_NAME + ".keys",
  BrowserConfigurationAuthErrorMessage = (!function (e) {
    e[e.Default = 0] = "Default", e[e.AccessToken = 1] = "AccessToken", e[e.AccessTokenAndRefreshToken = 2] = "AccessTokenAndRefreshToken", e[e.RefreshToken = 3] = "RefreshToken", e[e.RefreshTokenAndNetwork = 4] = "RefreshTokenAndNetwork", e[e.Skip = 5] = "Skip";
  }(CacheLookupPolicy = CacheLookupPolicy || {}), {
    redirectUriNotSet: {
      code: "redirect_uri_empty",
      desc: "A redirect URI is required for all calls, and none has been set."
    },
    postLogoutUriNotSet: {
      code: "post_logout_uri_empty",
      desc: "A post logout redirect has not been set."
    },
    storageNotSupportedError: {
      code: "storage_not_supported",
      desc: "Given storage configuration option was not supported."
    },
    noRedirectCallbacksSet: {
      code: "no_redirect_callbacks",
      desc: "No redirect callbacks have been set. Please call setRedirectCallbacks() with the appropriate function arguments before continuing. More information is available here: https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL-basics."
    },
    invalidCallbackObject: {
      code: "invalid_callback_object",
      desc: "The object passed for the callback was invalid. More information is available here: https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL-basics."
    },
    stubPcaInstanceCalled: {
      code: "stubbed_public_client_application_called",
      desc: "Stub instance of Public Client Application was called. If using msal-react, please ensure context is not used without a provider. For more visit: aka.ms/msaljs/browser-errors"
    },
    inMemRedirectUnavailable: {
      code: "in_mem_redirect_unavailable",
      desc: "Redirect cannot be supported. In-memory storage was selected and storeAuthStateInCookie=false, which would cause the library to be unable to handle the incoming hash. If you would like to use the redirect API, please use session/localStorage or set storeAuthStateInCookie=true."
    },
    entropyNotProvided: {
      code: "entropy_not_provided",
      desc: "The available browser crypto interface requires entropy set via system.cryptoOptions.entropy configuration option."
    }
  }),
  BrowserConfigurationAuthError = function (r) {
    function n(e, t) {
      e = r.call(this, e, t) || this;
      return e.name = "BrowserConfigurationAuthError", Object.setPrototypeOf(e, n.prototype), e;
    }
    return __extends$g(n, r), n.createRedirectUriEmptyError = function () {
      return new n(BrowserConfigurationAuthErrorMessage.redirectUriNotSet.code, BrowserConfigurationAuthErrorMessage.redirectUriNotSet.desc);
    }, n.createPostLogoutRedirectUriEmptyError = function () {
      return new n(BrowserConfigurationAuthErrorMessage.postLogoutUriNotSet.code, BrowserConfigurationAuthErrorMessage.postLogoutUriNotSet.desc);
    }, n.createStorageNotSupportedError = function (e) {
      return new n(BrowserConfigurationAuthErrorMessage.storageNotSupportedError.code, BrowserConfigurationAuthErrorMessage.storageNotSupportedError.desc + " Given Location: " + e);
    }, n.createRedirectCallbacksNotSetError = function () {
      return new n(BrowserConfigurationAuthErrorMessage.noRedirectCallbacksSet.code, BrowserConfigurationAuthErrorMessage.noRedirectCallbacksSet.desc);
    }, n.createStubPcaInstanceCalledError = function () {
      return new n(BrowserConfigurationAuthErrorMessage.stubPcaInstanceCalled.code, BrowserConfigurationAuthErrorMessage.stubPcaInstanceCalled.desc);
    }, n.createInMemoryRedirectUnavailableError = function () {
      return new n(BrowserConfigurationAuthErrorMessage.inMemRedirectUnavailable.code, BrowserConfigurationAuthErrorMessage.inMemRedirectUnavailable.desc);
    }, n.createEntropyNotProvided = function () {
      return new n(BrowserConfigurationAuthErrorMessage.entropyNotProvided.code, BrowserConfigurationAuthErrorMessage.entropyNotProvided.desc);
    }, n;
  }(AuthError),
  BrowserStorage = function () {
    function e(e) {
      this.validateWindowStorage(e), this.windowStorage = window[e];
    }
    return e.prototype.validateWindowStorage = function (e) {
      if (e !== BrowserCacheLocation.LocalStorage && e !== BrowserCacheLocation.SessionStorage) throw BrowserConfigurationAuthError.createStorageNotSupportedError(e);
      if (!!!window[e]) throw BrowserConfigurationAuthError.createStorageNotSupportedError(e);
    }, e.prototype.getItem = function (e) {
      return this.windowStorage.getItem(e);
    }, e.prototype.setItem = function (e, t) {
      this.windowStorage.setItem(e, t);
    }, e.prototype.removeItem = function (e) {
      this.windowStorage.removeItem(e);
    }, e.prototype.getKeys = function () {
      return Object.keys(this.windowStorage);
    }, e.prototype.containsKey = function (e) {
      return this.windowStorage.hasOwnProperty(e);
    }, e;
  }(),
  MemoryStorage = function () {
    function e() {
      this.cache = new Map();
    }
    return e.prototype.getItem = function (e) {
      return this.cache.get(e) || null;
    }, e.prototype.setItem = function (e, t) {
      this.cache.set(e, t);
    }, e.prototype.removeItem = function (e) {
      this.cache.delete(e);
    }, e.prototype.getKeys = function () {
      var r = [];
      return this.cache.forEach(function (e, t) {
        r.push(t);
      }), r;
    }, e.prototype.containsKey = function (e) {
      return this.cache.has(e);
    }, e.prototype.clear = function () {
      this.cache.clear();
    }, e;
  }(),
  BrowserProtocolUtils = function () {
    function e() {}
    return e.extractBrowserRequestState = function (e, t) {
      if (StringUtils.isEmpty(t)) return null;
      try {
        return ProtocolUtils.parseRequestState(e, t).libraryState.meta;
      } catch (e) {
        throw ClientAuthError.createInvalidStateError(t, e);
      }
    }, e.parseServerResponseFromHash = function (e) {
      return e ? (e = new UrlString(e), UrlString.getDeserializedHash(e.getHash())) : {};
    }, e;
  }(),
  BrowserCacheManager = function (i) {
    function e(e, t, r, n) {
      e = i.call(this, e, r, n) || this;
      return e.COOKIE_LIFE_MULTIPLIER = 864e5, e.cacheConfig = t, e.logger = n, e.internalStorage = new MemoryStorage(), e.browserStorage = e.setupBrowserStorage(e.cacheConfig.cacheLocation), e.temporaryCacheStorage = e.setupTemporaryCacheStorage(e.cacheConfig.temporaryCacheLocation, e.cacheConfig.cacheLocation), t.cacheMigrationEnabled && (e.migrateCacheEntries(), e.createKeyMaps()), e;
    }
    return __extends$g(e, i), e.prototype.setupBrowserStorage = function (e) {
      switch (e) {
        case BrowserCacheLocation.LocalStorage:
        case BrowserCacheLocation.SessionStorage:
          try {
            return new BrowserStorage(e);
          } catch (e) {
            this.logger.verbose(e);
            break;
          }
      }
      return this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage, new MemoryStorage();
    }, e.prototype.setupTemporaryCacheStorage = function (e, t) {
      switch (t) {
        case BrowserCacheLocation.LocalStorage:
        case BrowserCacheLocation.SessionStorage:
          try {
            return new BrowserStorage(e || BrowserCacheLocation.SessionStorage);
          } catch (e) {
            return this.logger.verbose(e), this.internalStorage;
          }
        case BrowserCacheLocation.MemoryStorage:
        default:
          return this.internalStorage;
      }
    }, e.prototype.migrateCacheEntries = function () {
      var r = this,
        e = Constants.CACHE_PREFIX + "." + PersistentCacheKeys.ID_TOKEN,
        t = Constants.CACHE_PREFIX + "." + PersistentCacheKeys.CLIENT_INFO,
        n = Constants.CACHE_PREFIX + "." + PersistentCacheKeys.ERROR,
        i = Constants.CACHE_PREFIX + "." + PersistentCacheKeys.ERROR_DESC,
        o = [this.browserStorage.getItem(e), this.browserStorage.getItem(t), this.browserStorage.getItem(n), this.browserStorage.getItem(i)];
      [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC].forEach(function (e, t) {
        return r.migrateCacheEntry(e, o[t]);
      });
    }, e.prototype.migrateCacheEntry = function (e, t) {
      t && this.setTemporaryCache(e, t, !0);
    }, e.prototype.createKeyMaps = function () {
      var o = this,
        e = (this.logger.trace("BrowserCacheManager - createKeyMaps called."), this.getItem(StaticCacheKeys.ACCOUNT_KEYS)),
        t = this.getItem(StaticCacheKeys.TOKEN_KEYS + "." + this.clientId);
      e && t ? this.logger.verbose("BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.") : this.browserStorage.getKeys().forEach(function (e) {
        var t;
        if (o.isCredentialKey(e) && (t = o.getItem(e))) {
          var r,
            n,
            i = o.validateAndParseJson(t);
          if (i && i.hasOwnProperty("credentialType")) switch (i.credentialType) {
            case CredentialType.ID_TOKEN:
              if (IdTokenEntity.isIdTokenEntity(i)) return o.logger.trace("BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map"), o.logger.tracePii("BrowserCacheManager:createKeyMaps - idToken with key: " + e + " found, saving key to token key map"), n = CacheManager.toObject(new IdTokenEntity(), i), n = o.updateCredentialCacheKey(e, n), void o.addTokenKey(n, CredentialType.ID_TOKEN);
              o.logger.trace("BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping."), o.logger.tracePii("BrowserCacheManager:createKeyMaps - failed idToken validation on key: " + e);
              break;
            case CredentialType.ACCESS_TOKEN:
            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
              if (AccessTokenEntity.isAccessTokenEntity(i)) return o.logger.trace("BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map"), o.logger.tracePii("BrowserCacheManager:createKeyMaps - accessToken with key: " + e + " found, saving key to token key map"), r = CacheManager.toObject(new AccessTokenEntity(), i), n = o.updateCredentialCacheKey(e, r), void o.addTokenKey(n, CredentialType.ACCESS_TOKEN);
              o.logger.trace("BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping."), o.logger.tracePii("BrowserCacheManager:createKeyMaps - failed accessToken validation on key: " + e);
              break;
            case CredentialType.REFRESH_TOKEN:
              if (RefreshTokenEntity.isRefreshTokenEntity(i)) return o.logger.trace("BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map"), o.logger.tracePii("BrowserCacheManager:createKeyMaps - refreshToken with key: " + e + " found, saving key to token key map"), r = CacheManager.toObject(new RefreshTokenEntity(), i), n = o.updateCredentialCacheKey(e, r), void o.addTokenKey(n, CredentialType.REFRESH_TOKEN);
              o.logger.trace("BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping."), o.logger.tracePii("BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: " + e);
          }
        }
        o.isAccountKey(e) && (t = o.getItem(e)) && (t = o.validateAndParseJson(t)) && AccountEntity.isAccountEntity(t) && (o.logger.trace("BrowserCacheManager:createKeyMaps - account found, saving key to account key map"), o.logger.tracePii("BrowserCacheManager:createKeyMaps - account with key: " + e + " found, saving key to account key map"), o.addAccountKeyToMap(e));
      });
    }, e.prototype.validateAndParseJson = function (e) {
      try {
        var t = JSON.parse(e);
        return t && "object" == typeof t ? t : null;
      } catch (e) {
        return null;
      }
    }, e.prototype.getItem = function (e) {
      return this.browserStorage.getItem(e);
    }, e.prototype.setItem = function (e, t) {
      this.browserStorage.setItem(e, t);
    }, e.prototype.getAccount = function (e) {
      this.logger.trace("BrowserCacheManager.getAccount called");
      var t = this.getItem(e);
      return (t = t && this.validateAndParseJson(t)) && AccountEntity.isAccountEntity(t) ? CacheManager.toObject(new AccountEntity(), t) : (this.removeAccountKeyFromMap(e), null);
    }, e.prototype.setAccount = function (e) {
      this.logger.trace("BrowserCacheManager.setAccount called");
      var t = e.generateAccountKey();
      this.setItem(t, JSON.stringify(e)), this.addAccountKeyToMap(t);
    }, e.prototype.getAccountKeys = function () {
      this.logger.trace("BrowserCacheManager.getAccountKeys called");
      var e = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);
      return e ? JSON.parse(e) : (this.logger.verbose("BrowserCacheManager.getAccountKeys - No account keys found"), []);
    }, e.prototype.addAccountKeyToMap = function (e) {
      this.logger.trace("BrowserCacheManager.addAccountKeyToMap called"), this.logger.tracePii("BrowserCacheManager.addAccountKeyToMap called with key: " + e);
      var t = this.getAccountKeys();
      -1 === t.indexOf(e) ? (t.push(e), this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(t)), this.logger.verbose("BrowserCacheManager.addAccountKeyToMap account key added")) : this.logger.verbose("BrowserCacheManager.addAccountKeyToMap account key already exists in map");
    }, e.prototype.removeAccountKeyFromMap = function (e) {
      this.logger.trace("BrowserCacheManager.removeAccountKeyFromMap called"), this.logger.tracePii("BrowserCacheManager.removeAccountKeyFromMap called with key: " + e);
      var t = this.getAccountKeys(),
        e = t.indexOf(e);
      -1 < e ? (t.splice(e, 1), this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(t)), this.logger.trace("BrowserCacheManager.removeAccountKeyFromMap account key removed")) : this.logger.trace("BrowserCacheManager.removeAccountKeyFromMap key not found in existing map");
    }, e.prototype.removeAccount = function (t) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return i.prototype.removeAccount.call(this, t), this.removeAccountKeyFromMap(t), [2];
        });
      });
    }, e.prototype.removeIdToken = function (e) {
      i.prototype.removeIdToken.call(this, e), this.removeTokenKey(e, CredentialType.ID_TOKEN);
    }, e.prototype.removeAccessToken = function (t) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return i.prototype.removeAccessToken.call(this, t), this.removeTokenKey(t, CredentialType.ACCESS_TOKEN), [2];
        });
      });
    }, e.prototype.removeRefreshToken = function (e) {
      i.prototype.removeRefreshToken.call(this, e), this.removeTokenKey(e, CredentialType.REFRESH_TOKEN);
    }, e.prototype.getTokenKeys = function () {
      this.logger.trace("BrowserCacheManager.getTokenKeys called");
      var e = this.getItem(StaticCacheKeys.TOKEN_KEYS + "." + this.clientId);
      if (e) {
        e = this.validateAndParseJson(e);
        if (e && e.hasOwnProperty("idToken") && e.hasOwnProperty("accessToken") && e.hasOwnProperty("refreshToken")) return e;
        this.logger.error("BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.");
      } else this.logger.verbose("BrowserCacheManager.getTokenKeys - No token keys found");
      return {
        idToken: [],
        accessToken: [],
        refreshToken: []
      };
    }, e.prototype.addTokenKey = function (e, t) {
      this.logger.trace("BrowserCacheManager addTokenKey called");
      var r = this.getTokenKeys();
      switch (t) {
        case CredentialType.ID_TOKEN:
          -1 === r.idToken.indexOf(e) && (this.logger.info("BrowserCacheManager: addTokenKey - idToken added to map"), r.idToken.push(e));
          break;
        case CredentialType.ACCESS_TOKEN:
          -1 === r.accessToken.indexOf(e) && (this.logger.info("BrowserCacheManager: addTokenKey - accessToken added to map"), r.accessToken.push(e));
          break;
        case CredentialType.REFRESH_TOKEN:
          -1 === r.refreshToken.indexOf(e) && (this.logger.info("BrowserCacheManager: addTokenKey - refreshToken added to map"), r.refreshToken.push(e));
          break;
        default:
          this.logger.error("BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: " + t), ClientAuthError.createUnexpectedCredentialTypeError();
      }
      this.setItem(StaticCacheKeys.TOKEN_KEYS + "." + this.clientId, JSON.stringify(r));
    }, e.prototype.removeTokenKey = function (e, t) {
      this.logger.trace("BrowserCacheManager removeTokenKey called");
      var r = this.getTokenKeys();
      switch (t) {
        case CredentialType.ID_TOKEN:
          this.logger.infoPii("BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: " + e + " from map");
          var n = r.idToken.indexOf(e);
          -1 < n ? (this.logger.info("BrowserCacheManager: removeTokenKey - idToken removed from map"), r.idToken.splice(n, 1)) : this.logger.info("BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.");
          break;
        case CredentialType.ACCESS_TOKEN:
          this.logger.infoPii("BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: " + e + " from map");
          n = r.accessToken.indexOf(e);
          -1 < n ? (this.logger.info("BrowserCacheManager: removeTokenKey - accessToken removed from map"), r.accessToken.splice(n, 1)) : this.logger.info("BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.");
          break;
        case CredentialType.REFRESH_TOKEN:
          this.logger.infoPii("BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: " + e + " from map");
          n = r.refreshToken.indexOf(e);
          -1 < n ? (this.logger.info("BrowserCacheManager: removeTokenKey - refreshToken removed from map"), r.refreshToken.splice(n, 1)) : this.logger.info("BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.");
          break;
        default:
          this.logger.error("BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: " + t), ClientAuthError.createUnexpectedCredentialTypeError();
      }
      this.setItem(StaticCacheKeys.TOKEN_KEYS + "." + this.clientId, JSON.stringify(r));
    }, e.prototype.getIdTokenCredential = function (e) {
      var t = this.getItem(e);
      return (t = t && this.validateAndParseJson(t)) && IdTokenEntity.isIdTokenEntity(t) ? (this.logger.trace("BrowserCacheManager.getIdTokenCredential: cache hit"), CacheManager.toObject(new IdTokenEntity(), t)) : (this.logger.trace("BrowserCacheManager.getIdTokenCredential: called, no cache hit"), this.removeTokenKey(e, CredentialType.ID_TOKEN), null);
    }, e.prototype.setIdTokenCredential = function (e) {
      this.logger.trace("BrowserCacheManager.setIdTokenCredential called");
      var t = e.generateCredentialKey();
      this.setItem(t, JSON.stringify(e)), this.addTokenKey(t, CredentialType.ID_TOKEN);
    }, e.prototype.getAccessTokenCredential = function (e) {
      var t = this.getItem(e);
      return (t = t && this.validateAndParseJson(t)) && AccessTokenEntity.isAccessTokenEntity(t) ? (this.logger.trace("BrowserCacheManager.getAccessTokenCredential: cache hit"), CacheManager.toObject(new AccessTokenEntity(), t)) : (this.logger.trace("BrowserCacheManager.getAccessTokenCredential: called, no cache hit"), this.removeTokenKey(e, CredentialType.ACCESS_TOKEN), null);
    }, e.prototype.setAccessTokenCredential = function (e) {
      this.logger.trace("BrowserCacheManager.setAccessTokenCredential called");
      var t = e.generateCredentialKey();
      this.setItem(t, JSON.stringify(e)), this.addTokenKey(t, CredentialType.ACCESS_TOKEN);
    }, e.prototype.getRefreshTokenCredential = function (e) {
      var t = this.getItem(e);
      return (t = t && this.validateAndParseJson(t)) && RefreshTokenEntity.isRefreshTokenEntity(t) ? (this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: cache hit"), CacheManager.toObject(new RefreshTokenEntity(), t)) : (this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: called, no cache hit"), this.removeTokenKey(e, CredentialType.REFRESH_TOKEN), null);
    }, e.prototype.setRefreshTokenCredential = function (e) {
      this.logger.trace("BrowserCacheManager.setRefreshTokenCredential called");
      var t = e.generateCredentialKey();
      this.setItem(t, JSON.stringify(e)), this.addTokenKey(t, CredentialType.REFRESH_TOKEN);
    }, e.prototype.getAppMetadata = function (e) {
      var t = this.getItem(e);
      return (t = t && this.validateAndParseJson(t)) && AppMetadataEntity.isAppMetadataEntity(e, t) ? (this.logger.trace("BrowserCacheManager.getAppMetadata: cache hit"), CacheManager.toObject(new AppMetadataEntity(), t)) : (this.logger.trace("BrowserCacheManager.getAppMetadata: called, no cache hit"), null);
    }, e.prototype.setAppMetadata = function (e) {
      this.logger.trace("BrowserCacheManager.setAppMetadata called");
      var t = e.generateAppMetadataKey();
      this.setItem(t, JSON.stringify(e));
    }, e.prototype.getServerTelemetry = function (e) {
      var t = this.getItem(e);
      return (t = t && this.validateAndParseJson(t)) && ServerTelemetryEntity.isServerTelemetryEntity(e, t) ? (this.logger.trace("BrowserCacheManager.getServerTelemetry: cache hit"), CacheManager.toObject(new ServerTelemetryEntity(), t)) : (this.logger.trace("BrowserCacheManager.getServerTelemetry: called, no cache hit"), null);
    }, e.prototype.setServerTelemetry = function (e, t) {
      this.logger.trace("BrowserCacheManager.setServerTelemetry called"), this.setItem(e, JSON.stringify(t));
    }, e.prototype.getAuthorityMetadata = function (e) {
      var t = this.internalStorage.getItem(e);
      return t ? (t = this.validateAndParseJson(t)) && AuthorityMetadataEntity.isAuthorityMetadataEntity(e, t) ? (this.logger.trace("BrowserCacheManager.getAuthorityMetadata: cache hit"), CacheManager.toObject(new AuthorityMetadataEntity(), t)) : null : (this.logger.trace("BrowserCacheManager.getAuthorityMetadata: called, no cache hit"), null);
    }, e.prototype.getAuthorityMetadataKeys = function () {
      var t = this;
      return this.internalStorage.getKeys().filter(function (e) {
        return t.isAuthorityMetadata(e);
      });
    }, e.prototype.setWrapperMetadata = function (e, t) {
      this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, e), this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, t);
    }, e.prototype.getWrapperMetadata = function () {
      return [this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING, this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING];
    }, e.prototype.setAuthorityMetadata = function (e, t) {
      this.logger.trace("BrowserCacheManager.setAuthorityMetadata called"), this.internalStorage.setItem(e, JSON.stringify(t));
    }, e.prototype.getActiveAccount = function () {
      var e = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS),
        e = this.getItem(e);
      return e ? (e = this.validateAndParseJson(e)) ? (this.logger.trace("BrowserCacheManager.getActiveAccount: Active account filters schema found"), this.getAccountInfoByFilter({
        homeAccountId: e.homeAccountId,
        localAccountId: e.localAccountId
      })[0] || null) : (this.logger.trace("BrowserCacheManager.getActiveAccount: No active account found"), null) : (this.logger.trace("BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema"), e = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT), (e = this.getItem(e)) ? (e = this.getAccountInfoByFilter({
        localAccountId: e
      })[0] || null) ? (this.logger.trace("BrowserCacheManager.getActiveAccount: Legacy active account cache schema found"), this.logger.trace("BrowserCacheManager.getActiveAccount: Adding active account filters cache schema"), this.setActiveAccount(e), e) : null : (this.logger.trace("BrowserCacheManager.getActiveAccount: No active account found"), null));
    }, e.prototype.setActiveAccount = function (e) {
      var t,
        r = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS),
        n = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);
      e ? (this.logger.verbose("setActiveAccount: Active account set"), t = {
        homeAccountId: e.homeAccountId,
        localAccountId: e.localAccountId
      }, this.browserStorage.setItem(r, JSON.stringify(t)), this.browserStorage.setItem(n, e.localAccountId)) : (this.logger.verbose("setActiveAccount: No account passed, active account not set"), this.browserStorage.removeItem(r), this.browserStorage.removeItem(n));
    }, e.prototype.getAccountInfoByFilter = function (t) {
      var e = this.getAllAccounts();
      return this.logger.trace("BrowserCacheManager.getAccountInfoByFilter: total " + e.length + " accounts found"), e.filter(function (e) {
        return !(t.username && t.username.toLowerCase() !== e.username.toLowerCase() || t.homeAccountId && t.homeAccountId !== e.homeAccountId || t.localAccountId && t.localAccountId !== e.localAccountId || t.tenantId && t.tenantId !== e.tenantId || t.environment && t.environment !== e.environment);
      });
    }, e.prototype.getAccountInfoByHints = function (r, n) {
      var e = this.getAllAccounts().filter(function (e) {
        var t;
        return n ? (t = e.idTokenClaims && e.idTokenClaims.sid, n === t) : !!r && r === e.username;
      });
      if (1 === e.length) return e[0];
      if (1 < e.length) throw ClientAuthError.createMultipleMatchingAccountsInCacheError();
      return null;
    }, e.prototype.getThrottlingCache = function (e) {
      var t = this.getItem(e);
      return (t = t && this.validateAndParseJson(t)) && ThrottlingEntity.isThrottlingEntity(e, t) ? (this.logger.trace("BrowserCacheManager.getThrottlingCache: cache hit"), CacheManager.toObject(new ThrottlingEntity(), t)) : (this.logger.trace("BrowserCacheManager.getThrottlingCache: called, no cache hit"), null);
    }, e.prototype.setThrottlingCache = function (e, t) {
      this.logger.trace("BrowserCacheManager.setThrottlingCache called"), this.setItem(e, JSON.stringify(t));
    }, e.prototype.getTemporaryCache = function (e, t) {
      t = t ? this.generateCacheKey(e) : e;
      if (this.cacheConfig.storeAuthStateInCookie) {
        e = this.getItemCookie(t);
        if (e) return this.logger.trace("BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies"), e;
      }
      e = this.temporaryCacheStorage.getItem(t);
      if (e) return this.logger.trace("BrowserCacheManager.getTemporaryCache: Temporary cache item returned"), e;
      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {
        e = this.browserStorage.getItem(t);
        if (e) return this.logger.trace("BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage"), e;
      }
      return this.logger.trace("BrowserCacheManager.getTemporaryCache: No cache item found in local storage"), null;
    }, e.prototype.setTemporaryCache = function (e, t, r) {
      r = r ? this.generateCacheKey(e) : e;
      this.temporaryCacheStorage.setItem(r, t), this.cacheConfig.storeAuthStateInCookie && (this.logger.trace("BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie"), this.setItemCookie(r, t));
    }, e.prototype.removeItem = function (e) {
      this.browserStorage.removeItem(e), this.temporaryCacheStorage.removeItem(e), this.cacheConfig.storeAuthStateInCookie && (this.logger.trace("BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie"), this.clearItemCookie(e));
    }, e.prototype.containsKey = function (e) {
      return this.browserStorage.containsKey(e) || this.temporaryCacheStorage.containsKey(e);
    }, e.prototype.getKeys = function () {
      return __spread(this.browserStorage.getKeys(), this.temporaryCacheStorage.getKeys());
    }, e.prototype.clear = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        var t = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.removeAllAccounts()];
            case 1:
              return e.sent(), this.removeAppMetadata(), this.getKeys().forEach(function (e) {
                !t.browserStorage.containsKey(e) && !t.temporaryCacheStorage.containsKey(e) || -1 === e.indexOf(Constants.CACHE_PREFIX) && -1 === e.indexOf(t.clientId) || t.removeItem(e);
              }), this.internalStorage.clear(), [2];
          }
        });
      });
    }, e.prototype.clearTokensAndKeysWithClaims = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        var t,
          r,
          n = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.logger.trace("BrowserCacheManager.clearTokensAndKeysWithClaims called"), t = this.getTokenKeys(), r = [], t.accessToken.forEach(function (e) {
                var t = n.getAccessTokenCredential(e);
                null != t && t.requestedClaimsHash && e.includes(t.requestedClaimsHash.toLowerCase()) && r.push(n.removeAccessToken(e));
              }), [4, Promise.all(r)];
            case 1:
              return e.sent(), 0 < r.length && this.logger.warning(r.length + " access tokens with claims in the cache keys have been removed from the cache."), [2];
          }
        });
      });
    }, e.prototype.setItemCookie = function (e, t, r) {
      e = encodeURIComponent(e) + "=" + encodeURIComponent(t) + ";path=/;SameSite=Lax;";
      r && (e += "expires=" + this.getCookieExpirationTime(r) + ";"), this.cacheConfig.secureCookies && (e += "Secure;"), document.cookie = e;
    }, e.prototype.getItemCookie = function (e) {
      for (var t = encodeURIComponent(e) + "=", r = document.cookie.split(";"), n = 0; n < r.length; n++) {
        for (var i = r[n]; " " === i.charAt(0);) i = i.substring(1);
        if (0 === i.indexOf(t)) return decodeURIComponent(i.substring(t.length, i.length));
      }
      return Constants.EMPTY_STRING;
    }, e.prototype.clearMsalCookies = function () {
      var r = this,
        n = Constants.CACHE_PREFIX + "." + this.clientId;
      document.cookie.split(";").forEach(function (e) {
        for (; " " === e.charAt(0);) e = e.substring(1);
        var t;
        0 === e.indexOf(n) && (t = e.split("=")[0], r.clearItemCookie(t));
      });
    }, e.prototype.clearItemCookie = function (e) {
      this.setItemCookie(e, Constants.EMPTY_STRING, -1);
    }, e.prototype.getCookieExpirationTime = function (e) {
      var t = new Date();
      return new Date(t.getTime() + e * this.COOKIE_LIFE_MULTIPLIER).toUTCString();
    }, e.prototype.getCache = function () {
      return this.browserStorage;
    }, e.prototype.setCache = function () {}, e.prototype.generateCacheKey = function (e) {
      return this.validateAndParseJson(e) ? JSON.stringify(e) : StringUtils.startsWith(e, Constants.CACHE_PREFIX) || StringUtils.startsWith(e, PersistentCacheKeys.ADAL_ID_TOKEN) ? e : Constants.CACHE_PREFIX + "." + this.clientId + "." + e;
    }, e.prototype.generateAuthorityKey = function (e) {
      e = ProtocolUtils.parseRequestState(this.cryptoImpl, e).libraryState.id;
      return this.generateCacheKey(TemporaryCacheKeys.AUTHORITY + "." + e);
    }, e.prototype.generateNonceKey = function (e) {
      e = ProtocolUtils.parseRequestState(this.cryptoImpl, e).libraryState.id;
      return this.generateCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN + "." + e);
    }, e.prototype.generateStateKey = function (e) {
      e = ProtocolUtils.parseRequestState(this.cryptoImpl, e).libraryState.id;
      return this.generateCacheKey(TemporaryCacheKeys.REQUEST_STATE + "." + e);
    }, e.prototype.getCachedAuthority = function (e) {
      var e = this.generateStateKey(e),
        e = this.getTemporaryCache(e);
      return e ? (e = this.generateAuthorityKey(e), this.getTemporaryCache(e)) : null;
    }, e.prototype.updateCacheEntries = function (e, t, r, n, i) {
      this.logger.trace("BrowserCacheManager.updateCacheEntries called");
      var o,
        a = this.generateStateKey(e),
        a = (this.setTemporaryCache(a, e, !1), this.generateNonceKey(e)),
        a = (this.setTemporaryCache(a, t, !1), this.generateAuthorityKey(e));
      this.setTemporaryCache(a, r, !1), i ? (o = {
        credential: i.homeAccountId,
        type: CcsCredentialType.HOME_ACCOUNT_ID
      }, this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(o), !0)) : StringUtils.isEmpty(n) || (o = {
        credential: n,
        type: CcsCredentialType.UPN
      }, this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(o), !0));
    }, e.prototype.resetRequestCache = function (t) {
      var r = this;
      this.logger.trace("BrowserCacheManager.resetRequestCache called"), StringUtils.isEmpty(t) || this.getKeys().forEach(function (e) {
        -1 !== e.indexOf(t) && r.removeItem(e);
      }), t && (this.removeItem(this.generateStateKey(t)), this.removeItem(this.generateNonceKey(t)), this.removeItem(this.generateAuthorityKey(t))), this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)), this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI)), this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH)), this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID)), this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL)), this.removeItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST)), this.setInteractionInProgress(!1);
    }, e.prototype.cleanRequestByState = function (e) {
      this.logger.trace("BrowserCacheManager.cleanRequestByState called"), e && (e = this.generateStateKey(e), e = this.temporaryCacheStorage.getItem(e), this.logger.infoPii("BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: " + e), this.resetRequestCache(e || Constants.EMPTY_STRING)), this.clearMsalCookies();
    }, e.prototype.cleanRequestByInteractionType = function (r) {
      var n = this;
      this.logger.trace("BrowserCacheManager.cleanRequestByInteractionType called"), this.getKeys().forEach(function (e) {
        var t;
        -1 !== e.indexOf(TemporaryCacheKeys.REQUEST_STATE) && (e = n.temporaryCacheStorage.getItem(e)) && (t = BrowserProtocolUtils.extractBrowserRequestState(n.cryptoImpl, e)) && t.interactionType === r && (n.logger.infoPii("BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: " + e), n.resetRequestCache(e));
      }), this.clearMsalCookies(), this.setInteractionInProgress(!1);
    }, e.prototype.cacheCodeRequest = function (e, t) {
      this.logger.trace("BrowserCacheManager.cacheCodeRequest called");
      t = t.base64Encode(JSON.stringify(e));
      this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, t, !0);
    }, e.prototype.getCachedRequest = function (e, t) {
      this.logger.trace("BrowserCacheManager.getCachedRequest called");
      var r = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, !0);
      if (!r) throw BrowserAuthError.createNoTokenRequestCacheError();
      t = this.validateAndParseJson(t.base64Decode(r));
      if (!t) throw BrowserAuthError.createUnableToParseTokenRequestCacheError();
      if (this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)), StringUtils.isEmpty(t.authority)) {
        r = this.generateAuthorityKey(e), e = this.getTemporaryCache(r);
        if (!e) throw BrowserAuthError.createNoCachedAuthorityError();
        t.authority = e;
      }
      return t;
    }, e.prototype.getCachedNativeRequest = function () {
      this.logger.trace("BrowserCacheManager.getCachedNativeRequest called");
      var e = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, !0);
      return e ? this.validateAndParseJson(e) || (this.logger.error("BrowserCacheManager.getCachedNativeRequest: Unable to parse native request"), null) : (this.logger.trace("BrowserCacheManager.getCachedNativeRequest: No cached native request found"), null);
    }, e.prototype.isInteractionInProgress = function (e) {
      var t = this.getInteractionInProgress();
      return e ? t === this.clientId : !!t;
    }, e.prototype.getInteractionInProgress = function () {
      var e = Constants.CACHE_PREFIX + "." + TemporaryCacheKeys.INTERACTION_STATUS_KEY;
      return this.getTemporaryCache(e, !1);
    }, e.prototype.setInteractionInProgress = function (e) {
      var t = Constants.CACHE_PREFIX + "." + TemporaryCacheKeys.INTERACTION_STATUS_KEY;
      if (e) {
        if (this.getInteractionInProgress()) throw BrowserAuthError.createInteractionInProgressError();
        this.setTemporaryCache(t, this.clientId, !1);
      } else this.getInteractionInProgress() === this.clientId && this.removeItem(t);
    }, e.prototype.getLegacyLoginHint = function () {
      var e = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN),
        t = (e && (this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN), this.logger.verbose("Cached ADAL id token retrieved.")), this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, !0)),
        t = (t && (this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN)), this.logger.verbose("Cached MSAL.js v1 id token retrieved")), t || e);
      if (t) {
        e = new AuthToken(t, this.cryptoImpl);
        if (e.claims && e.claims.preferred_username) return this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint"), e.claims.preferred_username;
        if (e.claims && e.claims.upn) return this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint"), e.claims.upn;
        this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.");
      }
      return null;
    }, e.prototype.updateCredentialCacheKey = function (e, t) {
      var r = t.generateCredentialKey();
      if (e !== r) {
        var n = this.getItem(e);
        if (n) return this.removeItem(e), this.setItem(r, n), this.logger.verbose("Updated an outdated " + t.credentialType + " cache key"), r;
        this.logger.error("Attempted to update an outdated " + t.credentialType + " cache key but no item matching the outdated key was found in storage");
      }
      return e;
    }, e.prototype.getRedirectRequestContext = function () {
      return this.getTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, !0);
    }, e.prototype.setRedirectRequestContext = function (e) {
      this.setTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, e, !0);
    }, e;
  }(CacheManager),
  DEFAULT_BROWSER_CACHE_MANAGER = function (e, t) {
    var r = {
      cacheLocation: BrowserCacheLocation.MemoryStorage,
      temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,
      storeAuthStateInCookie: !1,
      secureCookies: !1,
      cacheMigrationEnabled: !1,
      claimsBasedCachingEnabled: !0
    };
    return new BrowserCacheManager(e, r, DEFAULT_CRYPTO_IMPLEMENTATION, t);
  },
  name$2 = "@azure/msal-browser",
  version$4 = "2.38.3",
  FetchClient = function () {
    function e() {}
    return e.prototype.sendGetRequestAsync = function (i, o) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return e.trys.push([0, 2,, 3]), [4, fetch(i, {
                method: HTTP_REQUEST_TYPE.GET,
                headers: this.getFetchHeaders(o)
              })];
            case 1:
              return t = e.sent(), [3, 3];
            case 2:
              throw r = e.sent(), window.navigator.onLine ? BrowserAuthError.createGetRequestFailedError(r, i) : BrowserAuthError.createNoNetworkConnectivityError();
            case 3:
              return e.trys.push([3, 5,, 6]), n = {
                headers: this.getHeaderDict(t.headers)
              }, [4, t.json()];
            case 4:
              return [2, (n.body = e.sent(), n.status = t.status, n)];
            case 5:
              throw e.sent(), BrowserAuthError.createFailedToParseNetworkResponseError(i);
            case 6:
              return [2];
          }
        });
      });
    }, e.prototype.sendPostRequestAsync = function (o, a) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              t = a && a.body || Constants.EMPTY_STRING, e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), [4, fetch(o, {
                method: HTTP_REQUEST_TYPE.POST,
                headers: this.getFetchHeaders(a),
                body: t
              })];
            case 2:
              return r = e.sent(), [3, 4];
            case 3:
              throw n = e.sent(), window.navigator.onLine ? BrowserAuthError.createPostRequestFailedError(n, o) : BrowserAuthError.createNoNetworkConnectivityError();
            case 4:
              return e.trys.push([4, 6,, 7]), i = {
                headers: this.getHeaderDict(r.headers)
              }, [4, r.json()];
            case 5:
              return [2, (i.body = e.sent(), i.status = r.status, i)];
            case 6:
              throw e.sent(), BrowserAuthError.createFailedToParseNetworkResponseError(o);
            case 7:
              return [2];
          }
        });
      });
    }, e.prototype.getFetchHeaders = function (e) {
      var t,
        r = new Headers();
      return e && e.headers && (t = e.headers, Object.keys(t).forEach(function (e) {
        r.append(e, t[e]);
      })), r;
    }, e.prototype.getHeaderDict = function (e) {
      var r = {};
      return e.forEach(function (e, t) {
        r[t] = e;
      }), r;
    }, e;
  }(),
  XhrClient = function () {
    function e() {}
    return e.prototype.sendGetRequestAsync = function (t, r) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, this.sendRequestAsync(t, HTTP_REQUEST_TYPE.GET, r)];
        });
      });
    }, e.prototype.sendPostRequestAsync = function (t, r) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, this.sendRequestAsync(t, HTTP_REQUEST_TYPE.POST, r)];
        });
      });
    }, e.prototype.sendRequestAsync = function (o, a, e) {
      var s = this;
      return new Promise(function (r, n) {
        var i = new XMLHttpRequest();
        if (i.open(a, o, !0), s.setXhrHeaders(i, e), i.onload = function () {
          (i.status < 200 || 300 <= i.status) && (a === HTTP_REQUEST_TYPE.POST ? n(BrowserAuthError.createPostRequestFailedError("Failed with status " + i.status, o)) : n(BrowserAuthError.createGetRequestFailedError("Failed with status " + i.status, o)));
          try {
            var e = JSON.parse(i.responseText),
              t = {
                headers: s.getHeaderDict(i),
                body: e,
                status: i.status
              };
            r(t);
          } catch (e) {
            n(BrowserAuthError.createFailedToParseNetworkResponseError(o));
          }
        }, i.onerror = function () {
          window.navigator.onLine ? a === HTTP_REQUEST_TYPE.POST ? n(BrowserAuthError.createPostRequestFailedError("Failed with status " + i.status, o)) : n(BrowserAuthError.createGetRequestFailedError("Failed with status " + i.status, o)) : n(BrowserAuthError.createNoNetworkConnectivityError());
        }, a === HTTP_REQUEST_TYPE.POST && e && e.body) i.send(e.body);else {
          if (a !== HTTP_REQUEST_TYPE.GET) throw BrowserAuthError.createHttpMethodNotImplementedError(a);
          i.send();
        }
      });
    }, e.prototype.setXhrHeaders = function (t, e) {
      var r;
      e && e.headers && (r = e.headers, Object.keys(r).forEach(function (e) {
        t.setRequestHeader(e, r[e]);
      }));
    }, e.prototype.getHeaderDict = function (e) {
      var e = e.getAllResponseHeaders().trim().split(/[\r\n]+/),
        r = {};
      return e.forEach(function (e) {
        var e = e.split(": "),
          t = e.shift(),
          e = e.join(": ");
        t && e && (r[t] = e);
      }), r;
    }, e;
  }(),
  BrowserUtils = function () {
    function n() {}
    return n.clearHash = function (e) {
      e.location.hash = Constants.EMPTY_STRING, "function" == typeof e.history.replaceState && e.history.replaceState(null, Constants.EMPTY_STRING, "" + e.location.origin + e.location.pathname + e.location.search);
    }, n.replaceHash = function (e) {
      e = e.split("#");
      e.shift(), window.location.hash = 0 < e.length ? e.join("#") : Constants.EMPTY_STRING;
    }, n.isInIframe = function () {
      return window.parent !== window;
    }, n.isInPopup = function () {
      return "undefined" != typeof window && !!window.opener && window.opener !== window && "string" == typeof window.name && 0 === window.name.indexOf(BrowserConstants.POPUP_NAME_PREFIX + ".");
    }, n.getCurrentUri = function () {
      return window.location.href.split("?")[0].split("#")[0];
    }, n.getHomepage = function () {
      var e = new UrlString(window.location.href).getUrlComponents();
      return e.Protocol + "//" + e.HostNameAndPort + "/";
    }, n.getBrowserNetworkClient = function () {
      return new (window.fetch && window.Headers ? FetchClient : XhrClient)();
    }, n.blockReloadInHiddenIframes = function () {
      if (UrlString.hashContainsKnownProperties(window.location.hash) && n.isInIframe()) throw BrowserAuthError.createBlockReloadInHiddenIframeError();
    }, n.blockRedirectInIframe = function (e, t) {
      var r = n.isInIframe();
      if (e === InteractionType.Redirect && r && !t) throw BrowserAuthError.createRedirectInIframeError(r);
    }, n.blockAcquireTokenInPopups = function () {
      if (n.isInPopup()) throw BrowserAuthError.createBlockAcquireTokenInPopupsError();
    }, n.blockNonBrowserEnvironment = function (e) {
      if (!e) throw BrowserAuthError.createNonBrowserEnvironmentError();
    }, n.blockNativeBrokerCalledBeforeInitialized = function (e, t) {
      if (e && !t) throw BrowserAuthError.createNativeBrokerCalledBeforeInitialize();
    }, n.detectIEOrEdge = function () {
      var e = window.navigator.userAgent,
        t = e.indexOf("MSIE "),
        r = e.indexOf("Trident/"),
        e = e.indexOf("Edge/");
      return 0 < t || 0 < r || 0 < e;
    }, n;
  }(),
  BaseInteractionClient = function () {
    function e(e, t, r, n, i, o, a, s, l) {
      this.config = e, this.browserStorage = t, this.browserCrypto = r, this.networkClient = this.config.system.networkClient, this.eventHandler = i, this.navigationClient = o, this.nativeMessageHandler = s, this.correlationId = l || this.browserCrypto.createNewGuid(), this.logger = n.clone(BrowserConstants.MSAL_SKU, version$4, this.correlationId), this.performanceClient = a;
    }
    return e.prototype.clearCacheOnLogout = function (t) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (!t) return [3, 5];
              AccountEntity.accountInfoIsEqual(t, this.browserStorage.getActiveAccount(), !1) && (this.logger.verbose("Setting active account to null"), this.browserStorage.setActiveAccount(null)), e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), [4, this.browserStorage.removeAccount(AccountEntity.generateAccountCacheKey(t))];
            case 2:
              return e.sent(), this.logger.verbose("Cleared cache items belonging to the account provided in the logout request."), [3, 4];
            case 3:
              return e.sent(), this.logger.error("Account provided in logout request was not found. Local cache unchanged."), [3, 4];
            case 4:
              return [3, 9];
            case 5:
              return e.trys.push([5, 8,, 9]), this.logger.verbose("No account provided in logout request, clearing all cache items.", this.correlationId), [4, this.browserStorage.clear()];
            case 6:
              return e.sent(), [4, this.browserCrypto.clearKeystore()];
            case 7:
              return e.sent(), [3, 9];
            case 8:
              return e.sent(), this.logger.error("Attempted to clear all MSAL cache items and failed. Local cache unchanged."), [3, 9];
            case 9:
              return [2];
          }
        });
      });
    }, e.prototype.initializeBaseRequest = function (i, o) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return (this.performanceClient.addQueueMeasurement(PerformanceEvents.InitializeBaseRequest, i.correlationId), this.logger.verbose("Initializing BaseAuthRequest"), t = i.authority || this.config.auth.authority, o) ? [4, this.validateRequestAuthority(t, o)] : [3, 2];
            case 1:
              e.sent(), e.label = 2;
            case 2:
              if (r = __spread(i && i.scopes || []), (r = __assign$5(__assign$5({}, i), {
                correlationId: this.correlationId,
                authority: t,
                scopes: r
              })).authenticationScheme) {
                if (r.authenticationScheme === AuthenticationScheme.SSH) {
                  if (!i.sshJwk) throw ClientConfigurationError.createMissingSshJwkError();
                  if (!i.sshKid) throw ClientConfigurationError.createMissingSshKidError();
                }
                this.logger.verbose('Authentication Scheme set to "' + r.authenticationScheme + '" as configured in Auth request');
              } else r.authenticationScheme = AuthenticationScheme.BEARER, this.logger.verbose('Authentication Scheme wasn\'t explicitly set in request, defaulting to "Bearer" request');
              return this.config.cache.claimsBasedCachingEnabled && i.claims && !StringUtils.isEmptyObj(i.claims) ? (n = r, [4, this.browserCrypto.hashString(i.claims)]) : [3, 4];
            case 3:
              n.requestedClaimsHash = e.sent(), e.label = 4;
            case 4:
              return [2, r];
          }
        });
      });
    }, e.prototype.getRedirectUri = function (e) {
      this.logger.verbose("getRedirectUri called");
      e = e || this.config.auth.redirectUri || BrowserUtils.getCurrentUri();
      return UrlString.getAbsoluteUrl(e, BrowserUtils.getCurrentUri());
    }, e.prototype.validateRequestAuthority = function (t, r) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.getDiscoveredAuthority(t)];
            case 1:
              if (e.sent().isAlias(r.environment)) return [2];
              throw ClientConfigurationError.createAuthorityMismatchError();
          }
        });
      });
    }, e.prototype.initializeServerTelemetryManager = function (e, t) {
      this.logger.verbose("initializeServerTelemetryManager called");
      e = {
        clientId: this.config.auth.clientId,
        correlationId: this.correlationId,
        apiId: e,
        forceRefresh: t || !1,
        wrapperSKU: this.browserStorage.getWrapperMetadata()[0],
        wrapperVer: this.browserStorage.getWrapperMetadata()[1]
      };
      return new ServerTelemetryManager(e, this.browserStorage);
    }, e.prototype.getDiscoveredAuthority = function (r) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return (this.logger.verbose("getDiscoveredAuthority called"), t = {
                protocolMode: this.config.auth.protocolMode,
                knownAuthorities: this.config.auth.knownAuthorities,
                cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
                authorityMetadata: this.config.auth.authorityMetadata
              }, r) ? (this.logger.verbose("Creating discovered authority with request authority"), [4, AuthorityFactory.createDiscoveredInstance(r, this.config.system.networkClient, this.browserStorage, t, this.logger)]) : [3, 2];
            case 1:
              return [2, e.sent()];
            case 2:
              return this.logger.verbose("Creating discovered authority with configured authority"), [4, AuthorityFactory.createDiscoveredInstance(this.config.auth.authority, this.config.system.networkClient, this.browserStorage, t, this.logger)];
            case 3:
              return [2, e.sent()];
          }
        });
      });
    }, e;
  }(),
  StandardInteractionClient = function (e) {
    function t() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends$g(t, e), t.prototype.initializeAuthorizationCodeRequest = function (n) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, n.correlationId), this.logger.verbose("initializeAuthorizationRequest called", n.correlationId), [4, this.browserCrypto.generatePkceCodes()];
            case 1:
              return t = e.sent(), r = __assign$5(__assign$5({}, n), {
                redirectUri: n.redirectUri,
                code: Constants.EMPTY_STRING,
                codeVerifier: t.verifier
              }), n.codeChallenge = t.challenge, n.codeChallengeMethod = Constants.S256_CODE_CHALLENGE_METHOD, [2, r];
          }
        });
      });
    }, t.prototype.initializeLogoutRequest = function (e) {
      this.logger.verbose("initializeLogoutRequest called", null == e ? void 0 : e.correlationId);
      var t,
        r = __assign$5({
          correlationId: this.correlationId || this.browserCrypto.createNewGuid()
        }, e);
      return e ? e.logoutHint ? this.logger.verbose("logoutHint has already been set in logoutRequest") : e.account ? (t = this.getLogoutHintFromIdTokenClaims(e.account)) && (this.logger.verbose("Setting logoutHint to login_hint ID Token Claim value for the account provided"), r.logoutHint = t) : this.logger.verbose("logoutHint was not set and account was not passed into logout request, logoutHint will not be set") : this.logger.verbose("logoutHint will not be set since no logout request was configured"), e && null === e.postLogoutRedirectUri ? this.logger.verbose("postLogoutRedirectUri passed as null, not setting post logout redirect uri", r.correlationId) : e && e.postLogoutRedirectUri ? (this.logger.verbose("Setting postLogoutRedirectUri to uri set on logout request", r.correlationId), r.postLogoutRedirectUri = UrlString.getAbsoluteUrl(e.postLogoutRedirectUri, BrowserUtils.getCurrentUri())) : null === this.config.auth.postLogoutRedirectUri ? this.logger.verbose("postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect", r.correlationId) : this.config.auth.postLogoutRedirectUri ? (this.logger.verbose("Setting postLogoutRedirectUri to configured uri", r.correlationId), r.postLogoutRedirectUri = UrlString.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, BrowserUtils.getCurrentUri())) : (this.logger.verbose("Setting postLogoutRedirectUri to current page", r.correlationId), r.postLogoutRedirectUri = UrlString.getAbsoluteUrl(BrowserUtils.getCurrentUri(), BrowserUtils.getCurrentUri())), r;
    }, t.prototype.getLogoutHintFromIdTokenClaims = function (e) {
      e = e.idTokenClaims;
      if (e) {
        if (e.login_hint) return e.login_hint;
        this.logger.verbose("The ID Token Claims tied to the provided account do not contain a login_hint claim, logoutHint will not be added to logout request");
      } else this.logger.verbose("The provided account does not contain ID Token Claims, logoutHint will not be added to logout request");
      return null;
    }, t.prototype.createAuthCodeClient = function (r, n, i) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.correlationId), this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId), [4, this.getClientConfiguration(r, n, i)];
            case 1:
              return t = e.sent(), [2, new AuthorizationCodeClient(t, this.performanceClient)];
          }
        });
      });
    }, t.prototype.getClientConfiguration = function (n, i, o) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId), this.logger.verbose("getClientConfiguration called", this.correlationId), this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId), [4, this.getDiscoveredAuthority(i, o)];
            case 1:
              return t = e.sent(), r = this.config.system.loggerOptions, [2, {
                authOptions: {
                  clientId: this.config.auth.clientId,
                  authority: t,
                  clientCapabilities: this.config.auth.clientCapabilities
                },
                systemOptions: {
                  tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds,
                  preventCorsPreflight: !0
                },
                loggerOptions: {
                  loggerCallback: r.loggerCallback,
                  piiLoggingEnabled: r.piiLoggingEnabled,
                  logLevel: r.logLevel,
                  correlationId: this.correlationId
                },
                cacheOptions: {
                  claimsBasedCachingEnabled: this.config.cache.claimsBasedCachingEnabled
                },
                cryptoInterface: this.browserCrypto,
                networkInterface: this.networkClient,
                storageInterface: this.browserStorage,
                serverTelemetryManager: n,
                libraryInfo: {
                  sku: BrowserConstants.MSAL_SKU,
                  version: version$4,
                  cpu: Constants.EMPTY_STRING,
                  os: Constants.EMPTY_STRING
                },
                telemetry: this.config.telemetry
              }];
          }
        });
      });
    }, t.prototype.validateAndExtractStateFromHash = function (e, t, r) {
      if (this.logger.verbose("validateAndExtractStateFromHash called", r), !e.state) throw BrowserAuthError.createHashDoesNotContainStateError();
      var n = BrowserProtocolUtils.extractBrowserRequestState(this.browserCrypto, e.state);
      if (!n) throw BrowserAuthError.createUnableToParseStateError();
      if (n.interactionType !== t) throw BrowserAuthError.createStateInteractionTypeMismatchError();
      return this.logger.verbose("Returning state from hash", r), e.state;
    }, t.prototype.getDiscoveredAuthority = function (i, o) {
      var a;
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId), this.logger.verbose("getDiscoveredAuthority called", this.correlationId), t = null == (a = this.performanceClient) ? void 0 : a.startMeasurement(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId), r = {
                protocolMode: this.config.auth.protocolMode,
                knownAuthorities: this.config.auth.knownAuthorities,
                cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
                authorityMetadata: this.config.auth.authorityMetadata,
                skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
              }, n = i || this.config.auth.authority, n = Authority.generateAuthority(n, o || this.config.auth.azureCloudOptions), this.logger.verbose("Creating discovered authority with configured authority", this.correlationId), this.performanceClient.setPreQueueTime(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, this.correlationId), [4, AuthorityFactory.createDiscoveredInstance(n, this.config.system.networkClient, this.browserStorage, r, this.logger, this.performanceClient, this.correlationId).then(function (e) {
                return t.endMeasurement({
                  success: !0
                }), e;
              }).catch(function (e) {
                throw t.endMeasurement({
                  errorCode: e.errorCode,
                  subErrorCode: e.subError,
                  success: !1
                }), e;
              })];
            case 1:
              return [2, e.sent()];
          }
        });
      });
    }, t.prototype.initializeAuthorizationRequest = function (a, s) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i, o;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.correlationId), this.logger.verbose("initializeAuthorizationRequest called", this.correlationId), t = this.getRedirectUri(a.redirectUri), r = {
                interactionType: s
              }, r = ProtocolUtils.setRequestState(this.browserCrypto, a && a.state || Constants.EMPTY_STRING, r), this.performanceClient.setPreQueueTime(PerformanceEvents.InitializeBaseRequest, this.correlationId), i = [{}], [4, this.initializeBaseRequest(a)];
            case 1:
              return n = __assign$5.apply(void 0, [__assign$5.apply(void 0, i.concat([e.sent()])), {
                redirectUri: t,
                state: r,
                nonce: a.nonce || this.browserCrypto.createNewGuid(),
                responseMode: ResponseMode.FRAGMENT
              }]), (o = a.account || this.browserStorage.getActiveAccount()) && (this.logger.verbose("Setting validated request account", this.correlationId), this.logger.verbosePii("Setting validated request account: " + o.homeAccountId, this.correlationId), n.account = o), StringUtils.isEmpty(n.loginHint) && !o && (o = this.browserStorage.getLegacyLoginHint()) && (n.loginHint = o), [2, n];
          }
        });
      });
    }, t;
  }(BaseInteractionClient),
  InteractionHandler = function () {
    function e(e, t, r, n, i) {
      this.authModule = e, this.browserStorage = t, this.authCodeRequest = r, this.logger = n, this.performanceClient = i;
    }
    return e.prototype.handleCodeResponseFromHash = function (n, i, o, a) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r;
        return __generator$3(this, function (e) {
          if (this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromHash, this.authCodeRequest.correlationId), this.logger.verbose("InteractionHandler.handleCodeResponse called"), StringUtils.isEmpty(n)) throw BrowserAuthError.createEmptyHashError(n);
          if (t = this.browserStorage.generateStateKey(i), !(t = this.browserStorage.getTemporaryCache(t))) throw ClientAuthError.createStateNotFoundError("Cached State");
          try {
            r = this.authModule.handleFragmentResponse(n, t);
          } catch (e) {
            throw e instanceof ServerError && e.subError === BrowserAuthErrorMessage.userCancelledError.code ? BrowserAuthError.createUserCancelledError() : e;
          }
          return this.performanceClient.setPreQueueTime(PerformanceEvents.HandleCodeResponseFromServer, this.authCodeRequest.correlationId), [2, this.handleCodeResponseFromServer(r, i, o, a)];
        });
      });
    }, e.prototype.handleCodeResponseFromServer = function (i, o, a, s, l) {
      return void 0 === l && (l = !0), __awaiter$3(this, void 0, void 0, function () {
        var t, r, n;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromServer, this.authCodeRequest.correlationId), this.logger.trace("InteractionHandler.handleCodeResponseFromServer called"), t = this.browserStorage.generateStateKey(o), t = this.browserStorage.getTemporaryCache(t)) return r = this.browserStorage.generateNonceKey(t), r = this.browserStorage.getTemporaryCache(r), this.authCodeRequest.code = i.code, i.cloud_instance_host_name ? (this.performanceClient.setPreQueueTime(PerformanceEvents.UpdateTokenEndpointAuthority, this.authCodeRequest.correlationId), [4, this.updateTokenEndpointAuthority(i.cloud_instance_host_name, a, s)]) : [3, 2];
              throw ClientAuthError.createStateNotFoundError("Cached State");
            case 1:
              e.sent(), e.label = 2;
            case 2:
              return l && (i.nonce = r || void 0), i.state = t, i.client_info ? this.authCodeRequest.clientInfo = i.client_info : (n = this.checkCcsCredentials()) && (this.authCodeRequest.ccsCredential = n), this.performanceClient.setPreQueueTime(PerformanceEvents.AuthClientAcquireToken, this.authCodeRequest.correlationId), [4, this.authModule.acquireToken(this.authCodeRequest, i)];
            case 3:
              return n = e.sent(), this.browserStorage.cleanRequestByState(o), [2, n];
          }
        });
      });
    }, e.prototype.updateTokenEndpointAuthority = function (r, n, i) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.performanceClient.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, this.authCodeRequest.correlationId), t = "https://" + r + "/" + n.tenant + "/", [4, AuthorityFactory.createDiscoveredInstance(t, i, this.browserStorage, n.options, this.logger, this.performanceClient, this.authCodeRequest.correlationId)];
            case 1:
              return t = e.sent(), this.authModule.updateAuthority(t), [2];
          }
        });
      });
    }, e.prototype.checkCcsCredentials = function () {
      var t = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, !0);
      if (t) try {
        return JSON.parse(t);
      } catch (e) {
        this.authModule.logger.error("Cache credential could not be parsed"), this.authModule.logger.errorPii("Cache credential could not be parsed: " + t);
      }
      return null;
    }, e;
  }(),
  RedirectHandler = function (a) {
    function e(e, t, r, n, i, o) {
      e = a.call(this, e, t, r, n, o) || this;
      return e.browserCrypto = i, e;
    }
    return __extends$g(e, a), e.prototype.initiateAuthRequest = function (r, n) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return (this.logger.verbose("RedirectHandler.initiateAuthRequest called"), StringUtils.isEmpty(r)) ? [3, 7] : (n.redirectStartPage && (this.logger.verbose("RedirectHandler.initiateAuthRequest: redirectStartPage set, caching start page"), this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, n.redirectStartPage, !0)), this.browserStorage.setTemporaryCache(TemporaryCacheKeys.CORRELATION_ID, this.authCodeRequest.correlationId, !0), this.browserStorage.cacheCodeRequest(this.authCodeRequest, this.browserCrypto), this.logger.infoPii("RedirectHandler.initiateAuthRequest: Navigate to: " + r), t = {
                apiId: ApiId.acquireTokenRedirect,
                timeout: n.redirectTimeout,
                noHistory: !1
              }, "function" != typeof n.onRedirectNavigate ? [3, 4] : (this.logger.verbose("RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback"), !1 === n.onRedirectNavigate(r) ? [3, 2] : (this.logger.verbose("RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating"), [4, n.navigationClient.navigateExternal(r, t)])));
            case 1:
              return e.sent(), [2];
            case 2:
              return this.logger.verbose("RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation"), [2];
            case 3:
              return [3, 6];
            case 4:
              return this.logger.verbose("RedirectHandler.initiateAuthRequest: Navigating window to navigate url"), [4, n.navigationClient.navigateExternal(r, t)];
            case 5:
              return e.sent(), [2];
            case 6:
              return [3, 8];
            case 7:
              throw this.logger.info("RedirectHandler.initiateAuthRequest: Navigate url is empty"), BrowserAuthError.createEmptyNavigationUriError();
            case 8:
              return [2];
          }
        });
      });
    }, e.prototype.handleCodeResponseFromHash = function (o, a, s, l) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (this.logger.verbose("RedirectHandler.handleCodeResponse called"), StringUtils.isEmpty(o)) throw BrowserAuthError.createEmptyHashError(o);
              if (this.browserStorage.setInteractionInProgress(!1), t = this.browserStorage.generateStateKey(a), !(t = this.browserStorage.getTemporaryCache(t))) throw ClientAuthError.createStateNotFoundError("Cached State");
              try {
                r = this.authModule.handleFragmentResponse(o, t);
              } catch (e) {
                throw e instanceof ServerError && e.subError === BrowserAuthErrorMessage.userCancelledError.code ? BrowserAuthError.createUserCancelledError() : e;
              }
              return (n = this.browserStorage.generateNonceKey(t), n = this.browserStorage.getTemporaryCache(n), this.authCodeRequest.code = r.code, r.cloud_instance_host_name) ? [4, this.updateTokenEndpointAuthority(r.cloud_instance_host_name, s, l)] : [3, 2];
            case 1:
              e.sent(), e.label = 2;
            case 2:
              return r.nonce = n || void 0, r.state = t, r.client_info ? this.authCodeRequest.clientInfo = r.client_info : (i = this.checkCcsCredentials()) && (this.authCodeRequest.ccsCredential = i), [4, this.authModule.acquireToken(this.authCodeRequest, r)];
            case 3:
              return i = e.sent(), this.browserStorage.cleanRequestByState(a), [2, i];
          }
        });
      });
    }, e;
  }(InteractionHandler),
  NativeAuthErrorMessage = (!function (e) {
    e.INITIALIZE_START = "msal:initializeStart", e.INITIALIZE_END = "msal:initializeEnd", e.ACCOUNT_ADDED = "msal:accountAdded", e.ACCOUNT_REMOVED = "msal:accountRemoved", e.LOGIN_START = "msal:loginStart", e.LOGIN_SUCCESS = "msal:loginSuccess", e.LOGIN_FAILURE = "msal:loginFailure", e.ACQUIRE_TOKEN_START = "msal:acquireTokenStart", e.ACQUIRE_TOKEN_SUCCESS = "msal:acquireTokenSuccess", e.ACQUIRE_TOKEN_FAILURE = "msal:acquireTokenFailure", e.ACQUIRE_TOKEN_NETWORK_START = "msal:acquireTokenFromNetworkStart", e.SSO_SILENT_START = "msal:ssoSilentStart", e.SSO_SILENT_SUCCESS = "msal:ssoSilentSuccess", e.SSO_SILENT_FAILURE = "msal:ssoSilentFailure", e.ACQUIRE_TOKEN_BY_CODE_START = "msal:acquireTokenByCodeStart", e.ACQUIRE_TOKEN_BY_CODE_SUCCESS = "msal:acquireTokenByCodeSuccess", e.ACQUIRE_TOKEN_BY_CODE_FAILURE = "msal:acquireTokenByCodeFailure", e.HANDLE_REDIRECT_START = "msal:handleRedirectStart", e.HANDLE_REDIRECT_END = "msal:handleRedirectEnd", e.POPUP_OPENED = "msal:popupOpened", e.LOGOUT_START = "msal:logoutStart", e.LOGOUT_SUCCESS = "msal:logoutSuccess", e.LOGOUT_FAILURE = "msal:logoutFailure", e.LOGOUT_END = "msal:logoutEnd", e.RESTORE_FROM_BFCACHE = "msal:restoreFromBFCache";
  }(EventType = EventType || {}), !function (e) {
    e.USER_INTERACTION_REQUIRED = "USER_INTERACTION_REQUIRED", e.USER_CANCEL = "USER_CANCEL", e.NO_NETWORK = "NO_NETWORK", e.TRANSIENT_ERROR = "TRANSIENT_ERROR", e.PERSISTENT_ERROR = "PERSISTENT_ERROR", e.DISABLED = "DISABLED", e.ACCOUNT_UNAVAILABLE = "ACCOUNT_UNAVAILABLE";
  }(NativeStatusCode = NativeStatusCode || {}), {
    extensionError: {
      code: "ContentError"
    },
    userSwitch: {
      code: "user_switch",
      desc: "User attempted to switch accounts in the native broker, which is not allowed. All new accounts must sign-in through the standard web flow first, please try again."
    },
    tokensNotFoundInCache: {
      code: "tokens_not_found_in_internal_memory_cache",
      desc: "Tokens not cached in MSAL JS internal memory, please make the WAM request"
    }
  }),
  NativeAuthError = function (n) {
    function i(e, t, r) {
      e = n.call(this, e, t) || this;
      return Object.setPrototypeOf(e, i.prototype), e.name = "NativeAuthError", e.ext = r, e;
    }
    return __extends$g(i, n), i.prototype.isFatal = function () {
      return !(!this.ext || !this.ext.status || this.ext.status !== NativeStatusCode.PERSISTENT_ERROR && this.ext.status !== NativeStatusCode.DISABLED) || this.errorCode === NativeAuthErrorMessage.extensionError.code;
    }, i.createError = function (e, t, r) {
      if (r && r.status) switch (r.status) {
        case NativeStatusCode.ACCOUNT_UNAVAILABLE:
          return InteractionRequiredAuthError.createNativeAccountUnavailableError();
        case NativeStatusCode.USER_INTERACTION_REQUIRED:
          return new InteractionRequiredAuthError(e, t);
        case NativeStatusCode.USER_CANCEL:
          return BrowserAuthError.createUserCancelledError();
        case NativeStatusCode.NO_NETWORK:
          return BrowserAuthError.createNoNetworkConnectivityError();
      }
      return new i(e, t, r);
    }, i.createUserSwitchError = function () {
      return new i(NativeAuthErrorMessage.userSwitch.code, NativeAuthErrorMessage.userSwitch.desc);
    }, i.createTokensNotFoundInCacheError = function () {
      return new i(NativeAuthErrorMessage.tokensNotFoundInCache.code, NativeAuthErrorMessage.tokensNotFoundInCache.desc);
    }, i;
  }(AuthError),
  SilentCacheClient = function (e) {
    function t() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends$g(t, e), t.prototype.acquireToken = function (o) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return t = this.performanceClient.startMeasurement(PerformanceEvents.SilentCacheClientAcquireToken, o.correlationId), n = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent_silentFlow), [4, this.createSilentFlowClient(n, o.authority, o.azureCloudOptions)];
            case 1:
              r = e.sent(), this.logger.verbose("Silent auth client created"), e.label = 2;
            case 2:
              return e.trys.push([2, 4,, 5]), [4, r.acquireCachedToken(o)];
            case 3:
              return n = e.sent(), t.endMeasurement({
                success: !0,
                fromCache: !0
              }), [2, n];
            case 4:
              throw (i = e.sent()) instanceof BrowserAuthError && i.errorCode === BrowserAuthErrorMessage.signingKeyNotFoundInStorage.code && this.logger.verbose("Signing keypair for bound access token not found. Refreshing bound access token and generating a new crypto keypair."), t.endMeasurement({
                errorCode: i instanceof AuthError && i.errorCode || void 0,
                subErrorCode: i instanceof AuthError && i.subError || void 0,
                success: !1
              }), i;
            case 5:
              return [2];
          }
        });
      });
    }, t.prototype.logout = function () {
      return Promise.reject(BrowserAuthError.createSilentLogoutUnsupportedError());
    }, t.prototype.createSilentFlowClient = function (r, n, i) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId), [4, this.getClientConfiguration(r, n, i)];
            case 1:
              return t = e.sent(), [2, new SilentFlowClient(t, this.performanceClient)];
          }
        });
      });
    }, t.prototype.initializeSilentRequest = function (r, n) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.performanceClient.addQueueMeasurement(PerformanceEvents.InitializeSilentRequest, this.correlationId), this.performanceClient.setPreQueueTime(PerformanceEvents.InitializeBaseRequest, this.correlationId), t = [__assign$5({}, r)], [4, this.initializeBaseRequest(r, n)];
            case 1:
              return [2, __assign$5.apply(void 0, [__assign$5.apply(void 0, t.concat([e.sent()])), {
                account: n,
                forceRefresh: r.forceRefresh || !1
              }])];
          }
        });
      });
    }, t;
  }(StandardInteractionClient),
  NativeInteractionClient = function (d) {
    function e(e, t, r, n, i, o, a, s, l, c, u, h) {
      t = d.call(this, e, t, r, n, i, o, s, l, h) || this;
      return t.apiId = a, t.accountId = c, t.nativeMessageHandler = l, t.nativeStorageManager = u, t.silentCacheClient = new SilentCacheClient(e, t.nativeStorageManager, r, n, i, o, s, l, h), t;
    }
    return __extends$g(e, d), e.prototype.acquireToken = function (a) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i, o;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.logger.trace("NativeInteractionClient - acquireToken called."), t = this.performanceClient.startMeasurement(PerformanceEvents.NativeInteractionClientAcquireToken, a.correlationId), r = TimeUtils.nowSeconds(), [4, this.initializeNativeRequest(a)];
            case 1:
              n = e.sent(), e.label = 2;
            case 2:
              return e.trys.push([2, 4,, 5]), [4, this.acquireTokensFromCache(this.accountId, n)];
            case 3:
              return i = e.sent(), t.endMeasurement({
                success: !0,
                isNativeBroker: !1,
                fromCache: !0
              }), [2, i];
            case 4:
              return e.sent(), this.logger.info("MSAL internal Cache does not contain tokens, proceed to make a native call"), [3, 5];
            case 5:
              return i = {
                method: NativeExtensionMethod.GetToken,
                request: n
              }, [4, this.nativeMessageHandler.sendMessage(i)];
            case 6:
              return o = e.sent(), o = this.validateNativeResponse(o), [2, this.handleNativeResponse(o, n, r).then(function (e) {
                return t.endMeasurement({
                  success: !0,
                  isNativeBroker: !0,
                  requestId: e.requestId
                }), e;
              }).catch(function (e) {
                throw t.endMeasurement({
                  success: !1,
                  errorCode: e.errorCode,
                  subErrorCode: e.subError,
                  isNativeBroker: !0
                }), e;
              })];
          }
        });
      });
    }, e.prototype.createSilentCacheRequest = function (e, t) {
      return {
        authority: e.authority,
        correlationId: this.correlationId,
        scopes: ScopeSet.fromString(e.scope).asArray(),
        account: t,
        forceRefresh: !1
      };
    }, e.prototype.acquireTokensFromCache = function (n, i) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (!n) throw this.logger.warning("NativeInteractionClient:acquireTokensFromCache - No nativeAccountId provided"), ClientAuthError.createNoAccountFoundError();
              if (!(t = this.browserStorage.getAccountInfoFilteredBy({
                nativeAccountId: n
              }))) throw ClientAuthError.createNoAccountFoundError();
              e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), r = this.createSilentCacheRequest(i, t), [4, this.silentCacheClient.acquireToken(r)];
            case 2:
              return [2, e.sent()];
            case 3:
              throw e.sent();
            case 4:
              return [2];
          }
        });
      });
    }, e.prototype.acquireTokenRedirect = function (a) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i, o;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.logger.trace("NativeInteractionClient - acquireTokenRedirect called."), [4, this.initializeNativeRequest(a)];
            case 1:
              t = e.sent(), r = {
                method: NativeExtensionMethod.GetToken,
                request: t
              }, e.label = 2;
            case 2:
              return e.trys.push([2, 4,, 5]), [4, this.nativeMessageHandler.sendMessage(r)];
            case 3:
              return n = e.sent(), this.validateNativeResponse(n), [3, 5];
            case 4:
              if ((n = e.sent()) instanceof NativeAuthError && n.isFatal()) throw n;
              return [3, 5];
            case 5:
              return this.browserStorage.setTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, JSON.stringify(t), !0), i = {
                apiId: ApiId.acquireTokenRedirect,
                timeout: this.config.system.redirectNavigationTimeout,
                noHistory: !1
              }, o = this.config.auth.navigateToLoginRequestUrl ? window.location.href : this.getRedirectUri(a.redirectUri), [4, this.navigationClient.navigateExternal(o, i)];
            case 6:
              return e.sent(), [2];
          }
        });
      });
    }, e.prototype.handleRedirectPromise = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (this.logger.trace("NativeInteractionClient - handleRedirectPromise called."), !this.browserStorage.isInteractionInProgress(!0)) return this.logger.info("handleRedirectPromise called but there is no interaction in progress, returning null."), [2, null];
              if (!(t = this.browserStorage.getCachedNativeRequest())) return this.logger.verbose("NativeInteractionClient - handleRedirectPromise called but there is no cached request, returning null."), [2, null];
              r = t.prompt, t = __rest(t, ["prompt"]), r && this.logger.verbose("NativeInteractionClient - handleRedirectPromise called and prompt was included in the original request, removing prompt from cached request to prevent second interaction with native broker window."), this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST)), r = {
                method: NativeExtensionMethod.GetToken,
                request: t
              }, n = TimeUtils.nowSeconds(), e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), this.logger.verbose("NativeInteractionClient - handleRedirectPromise sending message to native broker."), [4, this.nativeMessageHandler.sendMessage(r)];
            case 2:
              return i = e.sent(), this.validateNativeResponse(i), i = this.handleNativeResponse(i, t, n), this.browserStorage.setInteractionInProgress(!1), [2, i];
            case 3:
              throw i = e.sent(), this.browserStorage.setInteractionInProgress(!1), i;
            case 4:
              return [2];
          }
        });
      });
    }, e.prototype.logout = function () {
      return this.logger.trace("NativeInteractionClient - logout called."), Promise.reject("Logout not implemented yet");
    }, e.prototype.handleNativeResponse = function (o, a, s) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (this.logger.trace("NativeInteractionClient - handleNativeResponse called."), o.account.id !== a.accountId) throw NativeAuthError.createUserSwitchError();
              return [4, this.getDiscoveredAuthority(a.authority)];
            case 1:
              return i = e.sent(), n = i.getPreferredCache(), t = this.createIdTokenObj(o), r = this.createHomeAccountIdentifier(o, t), n = this.createAccountEntity(o, r, t, n), [4, this.generateAuthenticationResult(o, a, t, n, i.canonicalAuthority, s)];
            case 2:
              return i = e.sent(), this.cacheAccount(n), this.cacheNativeTokens(o, a, r, n, t, i.accessToken, i.tenantId, s), [2, i];
          }
        });
      });
    }, e.prototype.createIdTokenObj = function (e) {
      return new AuthToken(e.id_token || Constants.EMPTY_STRING, this.browserCrypto);
    }, e.prototype.createHomeAccountIdentifier = function (e, t) {
      return AccountEntity.generateHomeAccountId(e.client_info || Constants.EMPTY_STRING, AuthorityType.Default, this.logger, this.browserCrypto, t);
    }, e.prototype.createAccountEntity = function (e, t, r, n) {
      return AccountEntity.createAccount(e.client_info, t, r, void 0, void 0, void 0, n, e.account.id);
    }, e.prototype.generateScopes = function (e, t) {
      return e.scope ? ScopeSet.fromString(e.scope) : ScopeSet.fromString(t.scope);
    }, e.prototype.generatePopAccessToken = function (n, i) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (i.tokenType !== AuthenticationScheme.POP) return [3, 2];
              if (n.shr) return this.logger.trace("handleNativeServerResponse: SHR is enabled in native layer"), [2, n.shr];
              if (t = new PopTokenGenerator(this.browserCrypto), r = {
                resourceRequestMethod: i.resourceRequestMethod,
                resourceRequestUri: i.resourceRequestUri,
                shrClaims: i.shrClaims,
                shrNonce: i.shrNonce
              }, i.keyId) return [4, t.signPopToken(n.access_token, i.keyId, r)];
              throw ClientAuthError.createKeyIdMissingError();
            case 1:
              return [2, e.sent()];
            case 2:
              return [2, n.access_token];
          }
        });
      });
    }, e.prototype.generateAuthenticationResult = function (s, l, c, u, h, d) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i, o, a;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return t = this.addTelemetryFromNativeResponse(s), r = s.scope ? ScopeSet.fromString(s.scope) : ScopeSet.fromString(l.scope), i = s.account.properties || {}, n = i.UID || c.claims.oid || c.claims.sub || Constants.EMPTY_STRING, i = i.TenantId || c.claims.tid || Constants.EMPTY_STRING, [4, this.generatePopAccessToken(s, l)];
            case 1:
              return o = e.sent(), a = l.tokenType === AuthenticationScheme.POP ? AuthenticationScheme.POP : AuthenticationScheme.BEARER, [2, {
                authority: h,
                uniqueId: n,
                tenantId: i,
                scopes: r.asArray(),
                account: u.getAccountInfo(),
                idToken: s.id_token,
                idTokenClaims: c.claims,
                accessToken: o,
                fromCache: !!t && this.isResponseFromCache(t),
                expiresOn: new Date(1e3 * Number(d + s.expires_in)),
                tokenType: a,
                correlationId: this.correlationId,
                state: s.state,
                fromNativeBroker: !0
              }];
          }
        });
      });
    }, e.prototype.cacheAccount = function (e) {
      var t = this;
      this.browserStorage.setAccount(e), this.browserStorage.removeAccountContext(e).catch(function (e) {
        t.logger.error("Error occurred while removing account context from browser storage. " + e);
      });
    }, e.prototype.cacheNativeTokens = function (e, t, r, n, i, o, a, s) {
      var l = IdTokenEntity.createIdTokenEntity(r, t.authority, e.id_token || Constants.EMPTY_STRING, t.clientId, i.claims.tid || Constants.EMPTY_STRING),
        s = s + (t.tokenType === AuthenticationScheme.POP ? Constants.SHR_NONCE_VALIDITY : ("string" == typeof e.expires_in ? parseInt(e.expires_in, 10) : e.expires_in) || 0),
        e = this.generateScopes(e, t),
        r = AccessTokenEntity.createAccessTokenEntity(r, t.authority, o, t.clientId, i ? i.claims.tid || Constants.EMPTY_STRING : a, e.printScopes(), s, 0, this.browserCrypto),
        o = new CacheRecord(n, l, r);
      this.nativeStorageManager.saveCacheRecord(o);
    }, e.prototype.addTelemetryFromNativeResponse = function (e) {
      e = this.getMATSFromResponse(e);
      return e ? (this.performanceClient.addStaticFields({
        extensionId: this.nativeMessageHandler.getExtensionId(),
        extensionVersion: this.nativeMessageHandler.getExtensionVersion(),
        matsBrokerVersion: e.broker_version,
        matsAccountJoinOnStart: e.account_join_on_start,
        matsAccountJoinOnEnd: e.account_join_on_end,
        matsDeviceJoin: e.device_join,
        matsPromptBehavior: e.prompt_behavior,
        matsApiErrorCode: e.api_error_code,
        matsUiVisible: e.ui_visible,
        matsSilentCode: e.silent_code,
        matsSilentBiSubCode: e.silent_bi_sub_code,
        matsSilentMessage: e.silent_message,
        matsSilentStatus: e.silent_status,
        matsHttpStatus: e.http_status,
        matsHttpEventCount: e.http_event_count
      }, this.correlationId), e) : null;
    }, e.prototype.validateNativeResponse = function (e) {
      if (e.hasOwnProperty("access_token") && e.hasOwnProperty("id_token") && e.hasOwnProperty("client_info") && e.hasOwnProperty("account") && e.hasOwnProperty("scope") && e.hasOwnProperty("expires_in")) return e;
      throw NativeAuthError.createUnexpectedError("Response missing expected properties.");
    }, e.prototype.getMATSFromResponse = function (e) {
      if (e.properties.MATS) try {
        return JSON.parse(e.properties.MATS);
      } catch (e) {
        this.logger.error("NativeInteractionClient - Error parsing MATS telemetry, returning null instead");
      }
      return null;
    }, e.prototype.isResponseFromCache = function (e) {
      return void 0 === e.is_cached ? (this.logger.verbose("NativeInteractionClient - MATS telemetry does not contain field indicating if response was served from cache. Returning false."), !1) : !!e.is_cached;
    }, e.prototype.initializeNativeRequest = function (s) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t,
          r,
          n,
          i,
          o,
          a = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return (this.logger.trace("NativeInteractionClient - initializeNativeRequest called"), t = s.authority || this.config.auth.authority, s.account) ? [4, this.validateRequestAuthority(t, s.account)] : [3, 2];
            case 1:
              e.sent(), e.label = 2;
            case 2:
              return ((i = new UrlString(t)).validateAsUri(), o = s.scopes, n = __rest(s, ["scopes"]), (o = new ScopeSet(o || [])).appendScopes(OIDC_DEFAULT_SCOPES), r = function () {
                switch (a.apiId) {
                  case ApiId.ssoSilent:
                  case ApiId.acquireTokenSilent_silentFlow:
                    return a.logger.trace("initializeNativeRequest: silent request sets prompt to none"), PromptValue.NONE;
                }
                if (s.prompt) switch (s.prompt) {
                  case PromptValue.NONE:
                  case PromptValue.CONSENT:
                  case PromptValue.LOGIN:
                    return a.logger.trace("initializeNativeRequest: prompt is compatible with native flow"), s.prompt;
                  default:
                    throw a.logger.trace("initializeNativeRequest: prompt = " + s.prompt + " is not compatible with native flow"), BrowserAuthError.createNativePromptParameterNotSupportedError();
                } else a.logger.trace("initializeNativeRequest: prompt was not provided");
              }, n = __assign$5(__assign$5({}, n), {
                accountId: this.accountId,
                clientId: this.config.auth.clientId,
                authority: i.urlString,
                scope: o.printScopes(),
                redirectUri: this.getRedirectUri(s.redirectUri),
                prompt: r(),
                correlationId: this.correlationId,
                tokenType: s.authenticationScheme,
                windowTitleSubstring: document.title,
                extraParameters: __assign$5(__assign$5(__assign$5({}, s.extraQueryParameters), s.tokenQueryParameters), {
                  telemetry: NativeConstants.MATS_TELEMETRY
                }),
                extendedExpiryToken: !1
              }), s.authenticationScheme !== AuthenticationScheme.POP) ? [3, 4] : (i = {
                resourceRequestUri: s.resourceRequestUri,
                resourceRequestMethod: s.resourceRequestMethod,
                shrClaims: s.shrClaims,
                shrNonce: s.shrNonce
              }, [4, new PopTokenGenerator(this.browserCrypto).generateCnf(i)]);
            case 3:
              o = e.sent(), n.reqCnf = o.reqCnfString, n.keyId = o.kid, e.label = 4;
            case 4:
              return [2, n];
          }
        });
      });
    }, e;
  }(BaseInteractionClient),
  NativeMessageHandler = function () {
    function a(e, t, r, n) {
      this.logger = e, this.handshakeTimeoutMs = t, this.extensionId = n, this.resolvers = new Map(), this.handshakeResolvers = new Map(), this.responseId = 0, this.messageChannel = new MessageChannel(), this.windowListener = this.onWindowMessage.bind(this), this.performanceClient = r, this.handshakeEvent = r.startMeasurement(PerformanceEvents.NativeMessageHandlerHandshake);
    }
    return a.prototype.sendMessage = function (t) {
      return __awaiter$3(this, void 0, void 0, function () {
        var r,
          n = this;
        return __generator$3(this, function (e) {
          return this.logger.trace("NativeMessageHandler - sendMessage called."), r = {
            channel: NativeConstants.CHANNEL_ID,
            extensionId: this.extensionId,
            responseId: this.responseId++,
            body: t
          }, this.logger.trace("NativeMessageHandler - Sending request to browser extension"), this.logger.tracePii("NativeMessageHandler - Sending request to browser extension: " + JSON.stringify(r)), this.messageChannel.port1.postMessage(r), [2, new Promise(function (e, t) {
            n.resolvers.set(r.responseId, {
              resolve: e,
              reject: t
            });
          })];
        });
      });
    }, a.createProvider = function (n, i, o) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              n.trace("NativeMessageHandler - createProvider called."), e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 5]), [4, (t = new a(n, i, o, NativeConstants.PREFERRED_EXTENSION_ID)).sendHandshakeRequest()];
            case 2:
              return e.sent(), [2, t];
            case 3:
              return e.sent(), [4, (r = new a(n, i, o)).sendHandshakeRequest()];
            case 4:
              return e.sent(), [2, r];
            case 5:
              return [2];
          }
        });
      });
    }, a.prototype.sendHandshakeRequest = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        var r,
          n = this;
        return __generator$3(this, function (e) {
          return this.logger.trace("NativeMessageHandler - sendHandshakeRequest called."), window.addEventListener("message", this.windowListener, !1), r = {
            channel: NativeConstants.CHANNEL_ID,
            extensionId: this.extensionId,
            responseId: this.responseId++,
            body: {
              method: NativeExtensionMethod.HandshakeRequest
            }
          }, this.handshakeEvent.addStaticFields({
            extensionId: this.extensionId,
            extensionHandshakeTimeoutMs: this.handshakeTimeoutMs
          }), this.messageChannel.port1.onmessage = function (e) {
            n.onChannelMessage(e);
          }, window.postMessage(r, window.origin, [this.messageChannel.port2]), [2, new Promise(function (e, t) {
            n.handshakeResolvers.set(r.responseId, {
              resolve: e,
              reject: t
            }), n.timeoutId = window.setTimeout(function () {
              window.removeEventListener("message", n.windowListener, !1), n.messageChannel.port1.close(), n.messageChannel.port2.close(), n.handshakeEvent.endMeasurement({
                extensionHandshakeTimedOut: !0,
                success: !1
              }), t(BrowserAuthError.createNativeHandshakeTimeoutError()), n.handshakeResolvers.delete(r.responseId);
            }, n.handshakeTimeoutMs);
          })];
        });
      });
    }, a.prototype.onWindowMessage = function (e) {
      this.logger.trace("NativeMessageHandler - onWindowMessage called"), e.source !== window || !(e = e.data).channel || e.channel !== NativeConstants.CHANNEL_ID || e.extensionId && e.extensionId !== this.extensionId || e.body.method === NativeExtensionMethod.HandshakeRequest && (this.logger.verbose(e.extensionId ? "Extension with id: " + e.extensionId + " not installed" : "No extension installed"), clearTimeout(this.timeoutId), this.messageChannel.port1.close(), this.messageChannel.port2.close(), window.removeEventListener("message", this.windowListener, !1), e = this.handshakeResolvers.get(e.responseId)) && (this.handshakeEvent.endMeasurement({
        success: !1,
        extensionInstalled: !1
      }), e.reject(BrowserAuthError.createNativeExtensionNotInstalledError()));
    }, a.prototype.onChannelMessage = function (t) {
      this.logger.trace("NativeMessageHandler - onChannelMessage called.");
      var e = t.data,
        r = this.resolvers.get(e.responseId),
        n = this.handshakeResolvers.get(e.responseId);
      try {
        var i = e.body.method;
        if (i === NativeExtensionMethod.Response) {
          if (r) {
            var o = e.body.response;
            if (this.logger.trace("NativeMessageHandler - Received response from browser extension"), this.logger.tracePii("NativeMessageHandler - Received response from browser extension: " + JSON.stringify(o)), "Success" !== o.status) r.reject(NativeAuthError.createError(o.code, o.description, o.ext));else {
              if (!o.result) throw AuthError.createUnexpectedError("Event does not contain result.");
              o.result.code && o.result.description ? r.reject(NativeAuthError.createError(o.result.code, o.result.description, o.result.ext)) : r.resolve(o.result);
            }
            this.resolvers.delete(e.responseId);
          }
        } else i === NativeExtensionMethod.HandshakeResponse && n && (clearTimeout(this.timeoutId), window.removeEventListener("message", this.windowListener, !1), this.extensionId = e.extensionId, this.extensionVersion = e.body.version, this.logger.verbose("NativeMessageHandler - Received HandshakeResponse from extension: " + this.extensionId), this.handshakeEvent.endMeasurement({
          extensionInstalled: !0,
          success: !0
        }), n.resolve(), this.handshakeResolvers.delete(e.responseId));
      } catch (e) {
        this.logger.error("Error parsing response from WAM Extension"), this.logger.errorPii("Error parsing response from WAM Extension: " + e.toString()), this.logger.errorPii("Unable to parse " + t), r ? r.reject(e) : n && n.reject(e);
      }
    }, a.prototype.getExtensionId = function () {
      return this.extensionId;
    }, a.prototype.getExtensionVersion = function () {
      return this.extensionVersion;
    }, a.isNativeAvailable = function (e, t, r, n) {
      if (t.trace("isNativeAvailable called"), !e.system.allowNativeBroker) return t.trace("isNativeAvailable: allowNativeBroker is not enabled, returning false"), !1;
      if (!r) return t.trace("isNativeAvailable: WAM extension provider is not initialized, returning false"), !1;
      if (n) switch (n) {
        case AuthenticationScheme.BEARER:
        case AuthenticationScheme.POP:
          return t.trace("isNativeAvailable: authenticationScheme is supported, returning true"), !0;
        default:
          return t.trace("isNativeAvailable: authenticationScheme is not supported, returning false"), !1;
      }
      return !0;
    }, a;
  }(),
  RedirectClient = function (u) {
    function e(e, t, r, n, i, o, a, s, l, c) {
      e = u.call(this, e, t, r, n, i, o, a, l, c) || this;
      return e.nativeStorage = s, e;
    }
    return __extends$g(e, u), e.prototype.acquireToken = function (c) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t,
          r,
          n,
          i,
          o,
          a,
          s,
          l = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, c.correlationId), [4, this.initializeAuthorizationRequest(c, InteractionType.Redirect)];
            case 1:
              t = e.sent(), this.browserStorage.updateCacheEntries(t.state, t.nonce, t.authority, t.loginHint || Constants.EMPTY_STRING, t.account || null), r = this.initializeServerTelemetryManager(ApiId.acquireTokenRedirect), n = function (e) {
                e.persisted && (l.logger.verbose("Page was restored from back/forward cache. Clearing temporary cache."), l.browserStorage.cleanRequestByState(t.state), l.eventHandler.emitEvent(EventType.RESTORE_FROM_BFCACHE, InteractionType.Redirect));
              }, e.label = 2;
            case 2:
              return e.trys.push([2, 7,, 8]), this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, c.correlationId), [4, this.initializeAuthorizationCodeRequest(t)];
            case 3:
              return i = e.sent(), this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, c.correlationId), [4, this.createAuthCodeClient(r, t.authority, t.azureCloudOptions)];
            case 4:
              return a = e.sent(), this.logger.verbose("Auth code client created"), o = new RedirectHandler(a, this.browserStorage, i, this.logger, this.browserCrypto, this.performanceClient), [4, a.getAuthCodeUrl(__assign$5(__assign$5({}, t), {
                nativeBroker: NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, c.authenticationScheme)
              }))];
            case 5:
              return a = e.sent(), s = this.getRedirectStartPage(c.redirectStartPage), this.logger.verbosePii("Redirect start page: " + s), window.addEventListener("pageshow", n), [4, o.initiateAuthRequest(a, {
                navigationClient: this.navigationClient,
                redirectTimeout: this.config.system.redirectNavigationTimeout,
                redirectStartPage: s,
                onRedirectNavigate: c.onRedirectNavigate
              })];
            case 6:
              return [2, e.sent()];
            case 7:
              throw (s = e.sent()) instanceof AuthError && s.setCorrelationId(this.correlationId), window.removeEventListener("pageshow", n), r.cacheFailedRequest(s), this.browserStorage.cleanRequestByState(t.state), s;
            case 8:
              return [2];
          }
        });
      });
    }, e.prototype.handleRedirectPromise = function (h) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i, o, a, s, l, c, u;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              t = this.initializeServerTelemetryManager(ApiId.handleRedirectPromise), e.label = 1;
            case 1:
              if (e.trys.push([1, 10,, 11]), !this.browserStorage.isInteractionInProgress(!0)) return this.logger.info("handleRedirectPromise called but there is no interaction in progress, returning null."), [2, null];
              if (!(r = this.getRedirectResponseHash(h || window.location.hash))) return this.logger.info("handleRedirectPromise did not detect a response hash as a result of a redirect. Cleaning temporary cache."), this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect), [2, null];
              n = void 0;
              try {
                i = UrlString.getDeserializedHash(r), n = this.validateAndExtractStateFromHash(i, InteractionType.Redirect), this.logger.verbose("State extracted from hash");
              } catch (e) {
                return this.logger.info("handleRedirectPromise was unable to extract state due to: " + e), this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect), [2, null];
              }
              return (o = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, !0) || Constants.EMPTY_STRING, a = UrlString.removeHashFromUrl(o), c = UrlString.removeHashFromUrl(window.location.href), a === c && this.config.auth.navigateToLoginRequestUrl) ? (this.logger.verbose("Current page is loginRequestUrl, handling hash"), [4, this.handleHash(r, n, t)]) : [3, 3];
            case 2:
              return a = e.sent(), -1 < o.indexOf("#") && BrowserUtils.replaceHash(o), [2, a];
            case 3:
              return this.config.auth.navigateToLoginRequestUrl ? [3, 4] : (this.logger.verbose("NavigateToLoginRequestUrl set to false, handling hash"), [2, this.handleHash(r, n, t)]);
            case 4:
              return BrowserUtils.isInIframe() && !this.config.system.allowRedirectInIframe ? [3, 9] : (this.browserStorage.setTemporaryCache(TemporaryCacheKeys.URL_HASH, r, !0), s = {
                apiId: ApiId.handleRedirectPromise,
                timeout: this.config.system.redirectNavigationTimeout,
                noHistory: !0
              }, l = !0, o && "null" !== o ? [3, 6] : (c = BrowserUtils.getHomepage(), this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, c, !0), this.logger.warning("Unable to get valid login request url from cache, redirecting to home page"), [4, this.navigationClient.navigateInternal(c, s)]));
            case 5:
              return l = e.sent(), [3, 8];
            case 6:
              return this.logger.verbose("Navigating to loginRequestUrl: " + o), [4, this.navigationClient.navigateInternal(o, s)];
            case 7:
              l = e.sent(), e.label = 8;
            case 8:
              if (!l) return [2, this.handleHash(r, n, t)];
              e.label = 9;
            case 9:
              return [2, null];
            case 10:
              throw (u = e.sent()) instanceof AuthError && u.setCorrelationId(this.correlationId), t.cacheFailedRequest(u), this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect), u;
            case 11:
              return [2];
          }
        });
      });
    }, e.prototype.getRedirectResponseHash = function (e) {
      return this.logger.verbose("getRedirectResponseHash called"), UrlString.hashContainsKnownProperties(e) ? (BrowserUtils.clearHash(window), this.logger.verbose("Hash contains known properties, returning response hash")) : (e = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.URL_HASH, !0), this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH)), this.logger.verbose("Hash does not contain known properties, returning cached hash")), e;
    }, e.prototype.handleHash = function (o, a, s) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t,
          r,
          n,
          i = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (t = this.browserStorage.getCachedRequest(a, this.browserCrypto), this.logger.verbose("handleHash called, retrieved cached request"), (r = UrlString.getDeserializedHash(o)).accountId) {
                if (this.logger.verbose("Account id found in hash, calling WAM for token"), this.nativeMessageHandler) return r = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenPopup, this.performanceClient, this.nativeMessageHandler, r.accountId, this.nativeStorage, t.correlationId), n = ProtocolUtils.parseRequestState(this.browserCrypto, a).userRequestState, [2, r.acquireToken(__assign$5(__assign$5({}, t), {
                  state: n,
                  prompt: void 0
                })).finally(function () {
                  i.browserStorage.cleanRequestByState(a);
                })];
                throw BrowserAuthError.createNativeConnectionNotEstablishedError();
              }
              if (r = this.browserStorage.getCachedAuthority(a)) return this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, t.correlationId), [4, this.createAuthCodeClient(s, r)];
              throw BrowserAuthError.createNoCachedAuthorityError();
            case 1:
              return n = e.sent(), this.logger.verbose("Auth code client created"), ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, t), [4, new RedirectHandler(n, this.browserStorage, t, this.logger, this.browserCrypto, this.performanceClient).handleCodeResponseFromHash(o, a, n.authority, this.networkClient)];
            case 2:
              return [2, e.sent()];
          }
        });
      });
    }, e.prototype.logout = function (a) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i, o;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              this.logger.verbose("logoutRedirect called"), t = this.initializeLogoutRequest(a), r = this.initializeServerTelemetryManager(ApiId.logout), e.label = 1;
            case 1:
              return e.trys.push([1, 10,, 11]), this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Redirect, a), [4, this.clearCacheOnLogout(t.account)];
            case 2:
              return e.sent(), n = {
                apiId: ApiId.logout,
                timeout: this.config.system.redirectNavigationTimeout,
                noHistory: !1
              }, this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, t.correlationId), [4, this.createAuthCodeClient(r, a && a.authority)];
            case 3:
              return (i = e.sent(), this.logger.verbose("Auth code client created"), i = i.getLogoutUri(t), this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, t), a && "function" == typeof a.onRedirectNavigate) ? !1 === a.onRedirectNavigate(i) ? [3, 5] : (this.logger.verbose("Logout onRedirectNavigate did not return false, navigating"), this.browserStorage.getInteractionInProgress() || this.browserStorage.setInteractionInProgress(!0), [4, this.navigationClient.navigateExternal(i, n)]) : [3, 7];
            case 4:
              return e.sent(), [2];
            case 5:
              this.browserStorage.setInteractionInProgress(!1), this.logger.verbose("Logout onRedirectNavigate returned false, stopping navigation"), e.label = 6;
            case 6:
              return [3, 9];
            case 7:
              return this.browserStorage.getInteractionInProgress() || this.browserStorage.setInteractionInProgress(!0), [4, this.navigationClient.navigateExternal(i, n)];
            case 8:
              return e.sent(), [2];
            case 9:
              return [3, 11];
            case 10:
              throw (o = e.sent()) instanceof AuthError && o.setCorrelationId(this.correlationId), r.cacheFailedRequest(o), this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Redirect, null, o), this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect), o;
            case 11:
              return this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect), [2];
          }
        });
      });
    }, e.prototype.getRedirectStartPage = function (e) {
      e = e || window.location.href;
      return UrlString.getAbsoluteUrl(e, BrowserUtils.getCurrentUri());
    }, e;
  }(StandardInteractionClient),
  PopupClient = function (u) {
    function e(e, t, r, n, i, o, a, s, l, c) {
      e = u.call(this, e, t, r, n, i, o, a, l, c) || this;
      return e.unloadWindow = e.unloadWindow.bind(e), e.nativeStorage = s, e;
    }
    return __extends$g(e, u), e.prototype.acquireToken = function (e) {
      try {
        var t,
          r = this.generatePopupName(e.scopes || OIDC_DEFAULT_SCOPES, e.authority || this.config.auth.authority),
          n = e.popupWindowAttributes || {};
        return this.config.system.asyncPopups ? (this.logger.verbose("asyncPopups set to true, acquiring token"), this.acquireTokenPopupAsync(e, r, n)) : (this.logger.verbose("asyncPopup set to false, opening popup before acquiring token"), t = this.openSizedPopup("about:blank", r, n), this.acquireTokenPopupAsync(e, r, n, t));
      } catch (e) {
        return Promise.reject(e);
      }
    }, e.prototype.logout = function (e) {
      try {
        this.logger.verbose("logoutPopup called");
        var t,
          r = this.initializeLogoutRequest(e),
          n = this.generateLogoutPopupName(r),
          i = e && e.authority,
          o = e && e.mainWindowRedirectUri,
          a = (null == e ? void 0 : e.popupWindowAttributes) || {};
        return this.config.system.asyncPopups ? (this.logger.verbose("asyncPopups set to true"), this.logoutPopupAsync(r, n, a, i, void 0, o)) : (this.logger.verbose("asyncPopup set to false, opening popup"), t = this.openSizedPopup("about:blank", n, a), this.logoutPopupAsync(r, n, a, i, t, o));
      } catch (e) {
        return Promise.reject(e);
      }
    }, e.prototype.acquireTokenPopupAsync = function (p, f, _, m) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t,
          r,
          n,
          i,
          o,
          a,
          s,
          l,
          c,
          u,
          h,
          d = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.logger.verbose("acquireTokenPopupAsync called"), t = this.initializeServerTelemetryManager(ApiId.acquireTokenPopup), this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, p.correlationId), [4, this.initializeAuthorizationRequest(p, InteractionType.Popup)];
            case 1:
              r = e.sent(), this.browserStorage.updateCacheEntries(r.state, r.nonce, r.authority, r.loginHint || Constants.EMPTY_STRING, r.account || null), e.label = 2;
            case 2:
              return e.trys.push([2, 8,, 9]), this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, p.correlationId), [4, this.initializeAuthorizationCodeRequest(r)];
            case 3:
              return n = e.sent(), this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, p.correlationId), [4, this.createAuthCodeClient(t, r.authority, r.azureCloudOptions)];
            case 4:
              return i = e.sent(), this.logger.verbose("Auth code client created"), a = NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, p.authenticationScheme), o = void 0, a && (o = this.performanceClient.startMeasurement(PerformanceEvents.FetchAccountIdWithNativeBroker, p.correlationId)), [4, i.getAuthCodeUrl(__assign$5(__assign$5({}, r), {
                nativeBroker: a
              }))];
            case 5:
              return a = e.sent(), s = new InteractionHandler(i, this.browserStorage, n, this.logger, this.performanceClient), l = {
                popup: m,
                popupName: f,
                popupWindowAttributes: _
              }, l = this.initiateAuthRequest(a, l), this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {
                popupWindow: l
              }, null), [4, this.monitorPopupForHash(l)];
            case 6:
              if (l = e.sent(), h = UrlString.getDeserializedHash(l), c = this.validateAndExtractStateFromHash(h, InteractionType.Popup, r.correlationId), ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, n), h.accountId) {
                if (this.logger.verbose("Account id found in hash, calling WAM for token"), o && o.endMeasurement({
                  success: !0,
                  isNativeBroker: !0
                }), this.nativeMessageHandler) return h = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenPopup, this.performanceClient, this.nativeMessageHandler, h.accountId, this.nativeStorage, r.correlationId), u = ProtocolUtils.parseRequestState(this.browserCrypto, c).userRequestState, [2, h.acquireToken(__assign$5(__assign$5({}, r), {
                  state: u,
                  prompt: void 0
                })).finally(function () {
                  d.browserStorage.cleanRequestByState(c);
                })];
                throw BrowserAuthError.createNativeConnectionNotEstablishedError();
              }
              return [4, s.handleCodeResponseFromHash(l, c, i.authority, this.networkClient)];
            case 7:
              return [2, e.sent()];
            case 8:
              throw h = e.sent(), m && m.close(), h instanceof AuthError && h.setCorrelationId(this.correlationId), t.cacheFailedRequest(h), this.browserStorage.cleanRequestByState(r.state), h;
            case 9:
              return [2];
          }
        });
      });
    }, e.prototype.logoutPopupAsync = function (i, o, a, s, l, c) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              this.logger.verbose("logoutPopupAsync called"), this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Popup, i), t = this.initializeServerTelemetryManager(ApiId.logoutPopup), e.label = 1;
            case 1:
              return e.trys.push([1, 5,, 6]), [4, this.clearCacheOnLogout(i.account)];
            case 2:
              return e.sent(), this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, i.correlationId), [4, this.createAuthCodeClient(t, s)];
            case 3:
              return r = e.sent(), this.logger.verbose("Auth code client created"), r = r.getLogoutUri(i), this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, i), r = this.openPopup(r, {
                popupName: o,
                popupWindowAttributes: a,
                popup: l
              }), this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {
                popupWindow: r
              }, null), [4, this.waitForLogoutPopup(r)];
            case 4:
              return e.sent(), c ? (r = {
                apiId: ApiId.logoutPopup,
                timeout: this.config.system.redirectNavigationTimeout,
                noHistory: !1
              }, n = UrlString.getAbsoluteUrl(c, BrowserUtils.getCurrentUri()), this.logger.verbose("Redirecting main window to url specified in the request"), this.logger.verbosePii("Redirecting main window to: " + n), this.navigationClient.navigateInternal(n, r)) : this.logger.verbose("No main window navigation requested"), [3, 6];
            case 5:
              throw n = e.sent(), l && l.close(), n instanceof AuthError && n.setCorrelationId(this.correlationId), this.browserStorage.setInteractionInProgress(!1), this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Popup, null, n), this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup), t.cacheFailedRequest(n), n;
            case 6:
              return this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup), [2];
          }
        });
      });
    }, e.prototype.initiateAuthRequest = function (e, t) {
      if (StringUtils.isEmpty(e)) throw this.logger.error("Navigate url is empty"), BrowserAuthError.createEmptyNavigationUriError();
      return this.logger.infoPii("Navigate to: " + e), this.openPopup(e, t);
    }, e.prototype.monitorPopupForHash = function (s) {
      var l = this;
      return new Promise(function (r, n) {
        var i = l.config.system.windowHashTimeout / l.config.system.pollIntervalMilliseconds,
          o = 0,
          a = (l.logger.verbose("PopupHandler.monitorPopupForHash - polling started"), setInterval(function () {
            if (s.closed) l.logger.error("PopupHandler.monitorPopupForHash - window closed"), l.cleanPopup(), clearInterval(a), n(BrowserAuthError.createUserCancelledError());else {
              var e = Constants.EMPTY_STRING,
                t = Constants.EMPTY_STRING;
              try {
                e = s.location.href, t = s.location.hash;
              } catch (e) {}
              StringUtils.isEmpty(e) || "about:blank" === e || (l.logger.verbose("PopupHandler.monitorPopupForHash - popup window is on same origin as caller"), o++, t ? (l.logger.verbose("PopupHandler.monitorPopupForHash - found hash in url"), clearInterval(a), l.cleanPopup(s), UrlString.hashContainsKnownProperties(t) ? (l.logger.verbose("PopupHandler.monitorPopupForHash - hash contains known properties, returning."), r(t)) : (l.logger.error("PopupHandler.monitorPopupForHash - found hash in url but it does not contain known properties. Check that your router is not changing the hash prematurely."), l.logger.errorPii("PopupHandler.monitorPopupForHash - hash found: " + t), n(BrowserAuthError.createHashDoesNotContainKnownPropertiesError()))) : i < o && (l.logger.error("PopupHandler.monitorPopupForHash - unable to find hash in url, timing out"), clearInterval(a), n(BrowserAuthError.createMonitorPopupTimeoutError())));
            }
          }, l.config.system.pollIntervalMilliseconds));
      });
    }, e.prototype.waitForLogoutPopup = function (n) {
      var i = this;
      return new Promise(function (t) {
        i.logger.verbose("PopupHandler.waitForLogoutPopup - polling started");
        var r = setInterval(function () {
          n.closed && (i.logger.error("PopupHandler.waitForLogoutPopup - window closed"), i.cleanPopup(), clearInterval(r), t());
          var e = Constants.EMPTY_STRING;
          try {
            e = n.location.href;
          } catch (e) {}
          StringUtils.isEmpty(e) || "about:blank" === e || (i.logger.verbose("PopupHandler.waitForLogoutPopup - popup window is on same origin as caller, closing."), clearInterval(r), i.cleanPopup(n), t());
        }, i.config.system.pollIntervalMilliseconds);
      });
    }, e.prototype.openPopup = function (e, t) {
      try {
        var r = void 0;
        if (t.popup ? (r = t.popup, this.logger.verbosePii("Navigating popup window to: " + e), r.location.assign(e)) : void 0 === t.popup && (this.logger.verbosePii("Opening popup window to: " + e), r = this.openSizedPopup(e, t.popupName, t.popupWindowAttributes)), r) return r.focus && r.focus(), this.currentWindow = r, window.addEventListener("beforeunload", this.unloadWindow), r;
        throw BrowserAuthError.createEmptyWindowCreatedError();
      } catch (e) {
        throw this.logger.error("error opening popup " + e.message), this.browserStorage.setInteractionInProgress(!1), BrowserAuthError.createPopupWindowError(e.toString());
      }
    }, e.prototype.openSizedPopup = function (e, t, r) {
      var n = window.screenLeft || window.screenX,
        i = window.screenTop || window.screenY,
        o = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
        a = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight,
        s = null == (s = r.popupSize) ? void 0 : s.width,
        l = null == (l = r.popupSize) ? void 0 : l.height,
        c = null == (c = r.popupPosition) ? void 0 : c.top,
        r = null == (r = r.popupPosition) ? void 0 : r.left;
      return (!s || s < 0 || o < s) && (this.logger.verbose("Default popup window width used. Window width not configured or invalid."), s = BrowserConstants.POPUP_WIDTH), (!l || l < 0 || a < l) && (this.logger.verbose("Default popup window height used. Window height not configured or invalid."), l = BrowserConstants.POPUP_HEIGHT), (!c || c < 0 || a < c) && (this.logger.verbose("Default popup window top position used. Window top not configured or invalid."), c = Math.max(0, a / 2 - BrowserConstants.POPUP_HEIGHT / 2 + i)), (!r || r < 0 || o < r) && (this.logger.verbose("Default popup window left position used. Window left not configured or invalid."), r = Math.max(0, o / 2 - BrowserConstants.POPUP_WIDTH / 2 + n)), window.open(e, t, "width=" + s + ", height=" + l + ", top=" + c + ", left=" + r + ", scrollbars=yes");
    }, e.prototype.unloadWindow = function (e) {
      this.browserStorage.cleanRequestByInteractionType(InteractionType.Popup), this.currentWindow && this.currentWindow.close(), e.preventDefault();
    }, e.prototype.cleanPopup = function (e) {
      e && e.close(), window.removeEventListener("beforeunload", this.unloadWindow), this.browserStorage.setInteractionInProgress(!1);
    }, e.prototype.generatePopupName = function (e, t) {
      return BrowserConstants.POPUP_NAME_PREFIX + "." + this.config.auth.clientId + "." + e.join("-") + "." + t + "." + this.correlationId;
    }, e.prototype.generateLogoutPopupName = function (e) {
      e = e.account && e.account.homeAccountId;
      return BrowserConstants.POPUP_NAME_PREFIX + "." + this.config.auth.clientId + "." + e + "." + this.correlationId;
    }, e;
  }(StandardInteractionClient),
  NavigationClient = function () {
    function r() {}
    return r.prototype.navigateInternal = function (e, t) {
      return r.defaultNavigateWindow(e, t);
    }, r.prototype.navigateExternal = function (e, t) {
      return r.defaultNavigateWindow(e, t);
    }, r.defaultNavigateWindow = function (e, t) {
      return t.noHistory ? window.location.replace(e) : window.location.assign(e), new Promise(function (e) {
        setTimeout(function () {
          e(!0);
        }, t.timeout);
      });
    }, r;
  }(),
  DEFAULT_POPUP_TIMEOUT_MS = 6e4,
  DEFAULT_IFRAME_TIMEOUT_MS = 6e3,
  DEFAULT_REDIRECT_TIMEOUT_MS = 3e4,
  DEFAULT_NATIVE_BROKER_HANDSHAKE_TIMEOUT_MS = 2e3;
function buildConfiguration(e, t) {
  var r = e.auth,
    n = e.cache,
    i = e.system,
    e = e.telemetry,
    o = {
      clientId: Constants.EMPTY_STRING,
      authority: "" + Constants.DEFAULT_AUTHORITY,
      knownAuthorities: [],
      cloudDiscoveryMetadata: Constants.EMPTY_STRING,
      authorityMetadata: Constants.EMPTY_STRING,
      redirectUri: Constants.EMPTY_STRING,
      postLogoutRedirectUri: Constants.EMPTY_STRING,
      navigateToLoginRequestUrl: !0,
      clientCapabilities: [],
      protocolMode: ProtocolMode.AAD,
      azureCloudOptions: {
        azureCloudInstance: AzureCloudInstance.None,
        tenant: Constants.EMPTY_STRING
      },
      skipAuthorityMetadataCache: !1
    },
    a = {
      cacheLocation: BrowserCacheLocation.SessionStorage,
      temporaryCacheLocation: BrowserCacheLocation.SessionStorage,
      storeAuthStateInCookie: !1,
      secureCookies: !1,
      cacheMigrationEnabled: !(!n || n.cacheLocation !== BrowserCacheLocation.LocalStorage),
      claimsBasedCachingEnabled: !0
    },
    s = {
      loggerCallback: function () {},
      logLevel: LogLevel.Info,
      piiLoggingEnabled: !1
    },
    t = __assign$5(__assign$5({}, DEFAULT_SYSTEM_OPTIONS), {
      loggerOptions: s,
      networkClient: t ? BrowserUtils.getBrowserNetworkClient() : StubbedNetworkModule,
      navigationClient: new NavigationClient(),
      loadFrameTimeout: 0,
      windowHashTimeout: (null == i ? void 0 : i.loadFrameTimeout) || DEFAULT_POPUP_TIMEOUT_MS,
      iframeHashTimeout: (null == i ? void 0 : i.loadFrameTimeout) || DEFAULT_IFRAME_TIMEOUT_MS,
      navigateFrameWait: t && BrowserUtils.detectIEOrEdge() ? 500 : 0,
      redirectNavigationTimeout: DEFAULT_REDIRECT_TIMEOUT_MS,
      asyncPopups: !1,
      allowRedirectInIframe: !1,
      allowNativeBroker: !1,
      nativeBrokerHandshakeTimeout: (null == i ? void 0 : i.nativeBrokerHandshakeTimeout) || DEFAULT_NATIVE_BROKER_HANDSHAKE_TIMEOUT_MS,
      pollIntervalMilliseconds: BrowserConstants.DEFAULT_POLL_INTERVAL_MS,
      cryptoOptions: {
        useMsrCrypto: !1,
        entropy: void 0
      }
    }),
    i = __assign$5(__assign$5({}, i), {
      loggerOptions: (null == i ? void 0 : i.loggerOptions) || s
    }),
    s = {
      application: {
        appName: Constants.EMPTY_STRING,
        appVersion: Constants.EMPTY_STRING
      }
    };
  return {
    auth: __assign$5(__assign$5({}, o), r),
    cache: __assign$5(__assign$5({}, a), n),
    system: __assign$5(__assign$5({}, t), i),
    telemetry: __assign$5(__assign$5({}, s), e)
  };
}
var CryptoKeyStoreNames,
  SilentHandler = function (a) {
    function e(e, t, r, n, i, o) {
      e = a.call(this, e, t, r, n, o) || this;
      return e.navigateFrameWait = i.navigateFrameWait, e.pollIntervalMilliseconds = i.pollIntervalMilliseconds, e;
    }
    return __extends$g(e, a), e.prototype.initiateAuthRequest = function (t) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerInitiateAuthRequest, this.authCodeRequest.correlationId), StringUtils.isEmpty(t)) throw this.logger.info("Navigate url is empty"), BrowserAuthError.createEmptyNavigationUriError();
              return this.navigateFrameWait ? (this.performanceClient.setPreQueueTime(PerformanceEvents.SilentHandlerLoadFrame, this.authCodeRequest.correlationId), [4, this.loadFrame(t)]) : [3, 2];
            case 1:
              return [2, e.sent()];
            case 2:
              return [2, this.loadFrameSync(t)];
          }
        });
      });
    }, e.prototype.monitorIframeForHash = function (a, e) {
      var s = this;
      return this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerMonitorIframeForHash, this.authCodeRequest.correlationId), new Promise(function (r, n) {
        e < DEFAULT_IFRAME_TIMEOUT_MS && s.logger.warning("system.loadFrameTimeout or system.iframeHashTimeout set to lower (" + e + "ms) than the default (" + DEFAULT_IFRAME_TIMEOUT_MS + "ms). This may result in timeouts.");
        var i = window.performance.now() + e,
          o = setInterval(function () {
            if (window.performance.now() > i) s.removeHiddenIframe(a), clearInterval(o), n(BrowserAuthError.createMonitorIframeTimeoutError());else {
              var e = Constants.EMPTY_STRING,
                t = a.contentWindow;
              try {
                e = t ? t.location.href : Constants.EMPTY_STRING;
              } catch (e) {}
              StringUtils.isEmpty(e) || (e = t ? t.location.hash : Constants.EMPTY_STRING, UrlString.hashContainsKnownProperties(e) && (s.removeHiddenIframe(a), clearInterval(o), r(e)));
            }
          }, s.pollIntervalMilliseconds);
      });
    }, e.prototype.loadFrame = function (n) {
      var i = this;
      return this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerLoadFrame, this.authCodeRequest.correlationId), new Promise(function (e, t) {
        var r = i.createHiddenIframe();
        setTimeout(function () {
          r ? (r.src = n, e(r)) : t("Unable to load iframe");
        }, i.navigateFrameWait);
      });
    }, e.prototype.loadFrameSync = function (e) {
      var t = this.createHiddenIframe();
      return t.src = e, t;
    }, e.prototype.createHiddenIframe = function () {
      var e = document.createElement("iframe");
      return e.style.visibility = "hidden", e.style.position = "absolute", e.style.width = e.style.height = "0", e.style.border = "0", e.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms"), document.getElementsByTagName("body")[0].appendChild(e), e;
    }, e.prototype.removeHiddenIframe = function (e) {
      document.body === e.parentNode && document.body.removeChild(e);
    }, e;
  }(InteractionHandler),
  SilentIframeClient = function (h) {
    function e(e, t, r, n, i, o, a, s, l, c, u) {
      e = h.call(this, e, t, r, n, i, o, s, c, u) || this;
      return e.apiId = a, e.nativeStorage = l, e;
    }
    return __extends$g(e, h), e.prototype.acquireToken = function (o) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentIframeClientAcquireToken, o.correlationId), this.logger.verbose("acquireTokenByIframe called"), t = this.performanceClient.startMeasurement(PerformanceEvents.SilentIframeClientAcquireToken, o.correlationId), StringUtils.isEmpty(o.loginHint) && StringUtils.isEmpty(o.sid) && (!o.account || StringUtils.isEmpty(o.account.username)) && this.logger.warning("No user hint provided. The authorization server may need more information to complete this request."), o.prompt && o.prompt !== PromptValue.NONE && o.prompt !== PromptValue.NO_SESSION) throw t.endMeasurement({
                success: !1
              }), BrowserAuthError.createSilentPromptValueError(o.prompt);
              return this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, o.correlationId), [4, this.initializeAuthorizationRequest(__assign$5(__assign$5({}, o), {
                prompt: o.prompt || PromptValue.NONE
              }), InteractionType.Silent)];
            case 1:
              r = e.sent(), this.browserStorage.updateCacheEntries(r.state, r.nonce, r.authority, r.loginHint || Constants.EMPTY_STRING, r.account || null), n = this.initializeServerTelemetryManager(this.apiId), e.label = 2;
            case 2:
              return e.trys.push([2, 5,, 6]), this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, o.correlationId), [4, this.createAuthCodeClient(n, r.authority, r.azureCloudOptions)];
            case 3:
              return i = e.sent(), this.logger.verbose("Auth code client created"), this.performanceClient.setPreQueueTime(PerformanceEvents.SilentIframeClientTokenHelper, o.correlationId), [4, this.silentTokenHelper(i, r).then(function (e) {
                return t.endMeasurement({
                  success: !0,
                  fromCache: !1,
                  requestId: e.requestId
                }), e;
              })];
            case 4:
              return [2, e.sent()];
            case 5:
              throw (i = e.sent()) instanceof AuthError && i.setCorrelationId(this.correlationId), n.cacheFailedRequest(i), this.browserStorage.cleanRequestByState(r.state), t.endMeasurement({
                errorCode: i instanceof AuthError && i.errorCode || void 0,
                subErrorCode: i instanceof AuthError && i.subError || void 0,
                success: !1
              }), i;
            case 6:
              return [2];
          }
        });
      });
    }, e.prototype.logout = function () {
      return Promise.reject(BrowserAuthError.createSilentLogoutUnsupportedError());
    }, e.prototype.silentTokenHelper = function (c, u) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t,
          r,
          n,
          i,
          o,
          a,
          s,
          l = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentIframeClientTokenHelper, u.correlationId), this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, u.correlationId), [4, this.initializeAuthorizationCodeRequest(u)];
            case 1:
              return t = e.sent(), this.performanceClient.setPreQueueTime(PerformanceEvents.GetAuthCodeUrl, u.correlationId), [4, c.getAuthCodeUrl(__assign$5(__assign$5({}, u), {
                nativeBroker: NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, u.authenticationScheme)
              }))];
            case 2:
              return n = e.sent(), r = new SilentHandler(c, this.browserStorage, t, this.logger, this.config.system, this.performanceClient), this.performanceClient.setPreQueueTime(PerformanceEvents.SilentHandlerInitiateAuthRequest, u.correlationId), [4, r.initiateAuthRequest(n)];
            case 3:
              return n = e.sent(), this.performanceClient.setPreQueueTime(PerformanceEvents.SilentHandlerMonitorIframeForHash, u.correlationId), [4, r.monitorIframeForHash(n, this.config.system.iframeHashTimeout)];
            case 4:
              if (i = e.sent(), a = UrlString.getDeserializedHash(i), o = this.validateAndExtractStateFromHash(a, InteractionType.Silent, t.correlationId), a.accountId) {
                if (this.logger.verbose("Account id found in hash, calling WAM for token"), this.nativeMessageHandler) return a = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.apiId, this.performanceClient, this.nativeMessageHandler, a.accountId, this.browserStorage, this.correlationId), s = ProtocolUtils.parseRequestState(this.browserCrypto, o).userRequestState, [2, a.acquireToken(__assign$5(__assign$5({}, u), {
                  state: s,
                  prompt: u.prompt || PromptValue.NONE
                })).finally(function () {
                  l.browserStorage.cleanRequestByState(o);
                })];
                throw BrowserAuthError.createNativeConnectionNotEstablishedError();
              }
              return this.performanceClient.setPreQueueTime(PerformanceEvents.HandleCodeResponseFromHash, u.correlationId), [2, r.handleCodeResponseFromHash(i, o, c.authority, this.networkClient)];
          }
        });
      });
    }, e;
  }(StandardInteractionClient),
  SilentRefreshClient = function (e) {
    function t() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends$g(t, e), t.prototype.acquireToken = function (s) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t,
          r,
          n,
          i,
          o,
          a = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentRefreshClientAcquireToken, s.correlationId), this.performanceClient.setPreQueueTime(PerformanceEvents.InitializeBaseRequest, s.correlationId), r = [__assign$5({}, s)], [4, this.initializeBaseRequest(s, s.account)];
            case 1:
              return t = __assign$5.apply(void 0, r.concat([e.sent()])), n = this.performanceClient.startMeasurement(PerformanceEvents.SilentRefreshClientAcquireToken, t.correlationId), i = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent_silentFlow), [4, this.createRefreshTokenClient(i, t.authority, t.azureCloudOptions)];
            case 2:
              return o = e.sent(), this.logger.verbose("Refresh token client created"), this.performanceClient.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, s.correlationId), [2, o.acquireTokenByRefreshToken(t).then(function (e) {
                return n.endMeasurement({
                  success: !0,
                  fromCache: e.fromCache,
                  requestId: e.requestId
                }), e;
              }).catch(function (e) {
                throw e instanceof AuthError && e.setCorrelationId(a.correlationId), i.cacheFailedRequest(e), n.endMeasurement({
                  errorCode: e.errorCode,
                  subErrorCode: e.subError,
                  success: !1
                }), e;
              })];
          }
        });
      });
    }, t.prototype.logout = function () {
      return Promise.reject(BrowserAuthError.createSilentLogoutUnsupportedError());
    }, t.prototype.createRefreshTokenClient = function (r, n, i) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId), [4, this.getClientConfiguration(r, n, i)];
            case 1:
              return t = e.sent(), [2, new RefreshTokenClient(t, this.performanceClient)];
          }
        });
      });
    }, t;
  }(StandardInteractionClient),
  EventHandler = function () {
    function e(e, t) {
      this.eventCallbacks = new Map(), this.logger = e, this.browserCrypto = t, this.listeningToStorageEvents = !1, this.handleAccountCacheChange = this.handleAccountCacheChange.bind(this);
    }
    return e.prototype.addEventCallback = function (e) {
      var t;
      return "undefined" != typeof window ? (t = this.browserCrypto.createNewGuid(), this.eventCallbacks.set(t, e), this.logger.verbose("Event callback registered with id: " + t), t) : null;
    }, e.prototype.removeEventCallback = function (e) {
      this.eventCallbacks.delete(e), this.logger.verbose("Event callback " + e + " removed.");
    }, e.prototype.enableAccountStorageEvents = function () {
      "undefined" != typeof window && (this.listeningToStorageEvents ? this.logger.verbose("Account storage listener already registered.") : (this.logger.verbose("Adding account storage listener."), this.listeningToStorageEvents = !0, window.addEventListener("storage", this.handleAccountCacheChange)));
    }, e.prototype.disableAccountStorageEvents = function () {
      "undefined" != typeof window && (this.listeningToStorageEvents ? (this.logger.verbose("Removing account storage listener."), window.removeEventListener("storage", this.handleAccountCacheChange), this.listeningToStorageEvents = !1) : this.logger.verbose("No account storage listener registered."));
    }, e.prototype.emitEvent = function (r, e, t, n) {
      var i,
        o = this;
      "undefined" != typeof window && (i = {
        eventType: r,
        interactionType: e || null,
        payload: t || null,
        error: n || null,
        timestamp: Date.now()
      }, this.logger.info("Emitting event: " + r), this.eventCallbacks.forEach(function (e, t) {
        o.logger.verbose("Emitting event to callback " + t + ": " + r), e.apply(null, [i]);
      }));
    }, e.prototype.handleAccountCacheChange = function (e) {
      try {
        var t,
          r,
          n = e.newValue || e.oldValue;
        n && "object" == typeof (t = JSON.parse(n)) && AccountEntity.isAccountEntity(t) && (r = CacheManager.toObject(new AccountEntity(), t).getAccountInfo(), !e.oldValue && e.newValue ? (this.logger.info("Account was added to cache in a different window"), this.emitEvent(EventType.ACCOUNT_ADDED, void 0, r)) : !e.newValue && e.oldValue && (this.logger.info("Account was removed from cache in a different window"), this.emitEvent(EventType.ACCOUNT_REMOVED, void 0, r)));
      } catch (e) {}
    }, e;
  }(),
  MathUtils = function () {
    function e() {}
    return e.decimalToHex = function (e) {
      for (var t = e.toString(16); t.length < 2;) t = "0" + t;
      return t;
    }, e;
  }(),
  GuidGenerator = function () {
    function e(e) {
      this.cryptoObj = e;
    }
    return e.prototype.generateGuid = function () {
      try {
        var e = new Uint8Array(16);
        return this.cryptoObj.getRandomValues(e), e[6] |= 64, e[6] &= 79, e[8] |= 128, e[8] &= 191, MathUtils.decimalToHex(e[0]) + MathUtils.decimalToHex(e[1]) + MathUtils.decimalToHex(e[2]) + MathUtils.decimalToHex(e[3]) + "-" + MathUtils.decimalToHex(e[4]) + MathUtils.decimalToHex(e[5]) + "-" + MathUtils.decimalToHex(e[6]) + MathUtils.decimalToHex(e[7]) + "-" + MathUtils.decimalToHex(e[8]) + MathUtils.decimalToHex(e[9]) + "-" + MathUtils.decimalToHex(e[10]) + MathUtils.decimalToHex(e[11]) + MathUtils.decimalToHex(e[12]) + MathUtils.decimalToHex(e[13]) + MathUtils.decimalToHex(e[14]) + MathUtils.decimalToHex(e[15]);
      } catch (e) {
        for (var t = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx", r = "0123456789abcdef", n = 0, i = Constants.EMPTY_STRING, o = 0; o < 36; o++) "-" !== t[o] && "4" !== t[o] && (n = 16 * Math.random() | 0), i += "x" === t[o] ? r[n] : "y" === t[o] ? r[n = n & 3 | 8] : t[o];
        return i;
      }
    }, e.prototype.isGuid = function (e) {
      return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e);
    }, e;
  }(),
  BrowserStringUtils = function () {
    function e() {}
    return e.stringToUtf8Arr = function (e) {
      for (var t, r = 0, n = e.length, i = 0; i < n; i++) r += (t = e.charCodeAt(i)) < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : t < 2097152 ? 4 : t < 67108864 ? 5 : 6;
      for (var o = new Uint8Array(r), a = 0, s = 0; a < r; s++) (t = e.charCodeAt(s)) < 128 ? o[a++] = t : (t < 2048 ? o[a++] = 192 + (t >>> 6) : (t < 65536 ? o[a++] = 224 + (t >>> 12) : (t < 2097152 ? o[a++] = 240 + (t >>> 18) : (t < 67108864 ? o[a++] = 248 + (t >>> 24) : (o[a++] = 252 + (t >>> 30), o[a++] = 128 + (t >>> 24 & 63)), o[a++] = 128 + (t >>> 18 & 63)), o[a++] = 128 + (t >>> 12 & 63)), o[a++] = 128 + (t >>> 6 & 63)), o[a++] = 128 + (63 & t));
      return o;
    }, e.stringToArrayBuffer = function (e) {
      for (var t = new ArrayBuffer(e.length), r = new Uint8Array(t), n = 0; n < e.length; n++) r[n] = e.charCodeAt(n);
      return t;
    }, e.utf8ArrToString = function (e) {
      for (var t, r = Constants.EMPTY_STRING, n = e.length, i = 0; i < n; i++) t = e[i], r += String.fromCharCode(251 < t && t < 254 && i + 5 < n ? 1073741824 * (t - 252) + (e[++i] - 128 << 24) + (e[++i] - 128 << 18) + (e[++i] - 128 << 12) + (e[++i] - 128 << 6) + e[++i] - 128 : 247 < t && t < 252 && i + 4 < n ? (t - 248 << 24) + (e[++i] - 128 << 18) + (e[++i] - 128 << 12) + (e[++i] - 128 << 6) + e[++i] - 128 : 239 < t && t < 248 && i + 3 < n ? (t - 240 << 18) + (e[++i] - 128 << 12) + (e[++i] - 128 << 6) + e[++i] - 128 : 223 < t && t < 240 && i + 2 < n ? (t - 224 << 12) + (e[++i] - 128 << 6) + e[++i] - 128 : 191 < t && t < 224 && i + 1 < n ? (t - 192 << 6) + e[++i] - 128 : t);
      return r;
    }, e.getSortedObjectString = function (e) {
      return JSON.stringify(e, Object.keys(e).sort());
    }, e;
  }(),
  Base64Encode = function () {
    function e() {}
    return e.prototype.urlEncode = function (e) {
      return encodeURIComponent(this.encode(e).replace(/=/g, Constants.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_"));
    }, e.prototype.urlEncodeArr = function (e) {
      return this.base64EncArr(e).replace(/=/g, Constants.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_");
    }, e.prototype.encode = function (e) {
      e = BrowserStringUtils.stringToUtf8Arr(e);
      return this.base64EncArr(e);
    }, e.prototype.base64EncArr = function (e) {
      for (var t, r = (3 - e.length % 3) % 3, n = Constants.EMPTY_STRING, i = e.length, o = 0, a = 0; a < i; a++) o |= e[a] << (16 >>> (t = a % 3) & 24), 2 != t && e.length - a != 1 || (n += String.fromCharCode(this.uint6ToB64(o >>> 18 & 63), this.uint6ToB64(o >>> 12 & 63), this.uint6ToB64(o >>> 6 & 63), this.uint6ToB64(63 & o)), o = 0);
      return 0 == r ? n : n.substring(0, n.length - r) + (1 == r ? "=" : "==");
    }, e.prototype.uint6ToB64 = function (e) {
      return e < 26 ? e + 65 : e < 52 ? e + 71 : e < 62 ? e - 4 : 62 === e ? 43 : 63 === e ? 47 : 65;
    }, e;
  }(),
  Base64Decode = function () {
    function e() {}
    return e.prototype.decode = function (e) {
      var t = e.replace(/-/g, "+").replace(/_/g, "/");
      switch (t.length % 4) {
        case 0:
          break;
        case 2:
          t += "==";
          break;
        case 3:
          t += "=";
          break;
        default:
          throw new Error("Invalid base64 string");
      }
      e = this.base64DecToArr(t);
      return BrowserStringUtils.utf8ArrToString(e);
    }, e.prototype.base64DecToArr = function (e, t) {
      for (var r, n = e.replace(/[^A-Za-z0-9\+\/]/g, Constants.EMPTY_STRING), i = n.length, o = t ? Math.ceil((3 * i + 1 >>> 2) / t) * t : 3 * i + 1 >>> 2, a = new Uint8Array(o), s = void 0, l = 0, c = 0, u = 0; u < i; u++) if (r = 3 & u, l |= this.b64ToUint6(n.charCodeAt(u)) << 18 - 6 * r, 3 == r || i - u == 1) {
        for (s = 0; s < 3 && c < o; s++, c++) a[c] = l >>> (16 >>> s & 24) & 255;
        l = 0;
      }
      return a;
    }, e.prototype.b64ToUint6 = function (e) {
      return 64 < e && e < 91 ? e - 65 : 96 < e && e < 123 ? e - 71 : 47 < e && e < 58 ? e + 4 : 43 === e ? 62 : 47 === e ? 63 : 0;
    }, e;
  }(),
  RANDOM_BYTE_ARR_LENGTH = 32,
  PkceGenerator = function () {
    function e(e) {
      this.base64Encode = new Base64Encode(), this.cryptoObj = e;
    }
    return e.prototype.generateCodes = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return t = this.generateCodeVerifier(), [4, this.generateCodeChallengeFromVerifier(t)];
            case 1:
              return r = e.sent(), [2, {
                verifier: t,
                challenge: r
              }];
          }
        });
      });
    }, e.prototype.generateCodeVerifier = function () {
      try {
        var e = new Uint8Array(RANDOM_BYTE_ARR_LENGTH);
        return this.cryptoObj.getRandomValues(e), this.base64Encode.urlEncodeArr(e);
      } catch (e) {
        throw BrowserAuthError.createPkceNotGeneratedError(e);
      }
    }, e.prototype.generateCodeChallengeFromVerifier = function (r) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return e.trys.push([0, 2,, 3]), [4, this.cryptoObj.sha256Digest(r)];
            case 1:
              return t = e.sent(), [2, this.base64Encode.urlEncodeArr(new Uint8Array(t))];
            case 2:
              throw t = e.sent(), BrowserAuthError.createPkceNotGeneratedError(t);
            case 3:
              return [2];
          }
        });
      });
    }, e;
  }(),
  ModernBrowserCrypto = function () {
    function e() {}
    return e.prototype.getRandomValues = function (e) {
      return window.crypto.getRandomValues(e);
    }, e.prototype.generateKey = function (t, r, n) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, window.crypto.subtle.generateKey(t, r, n)];
        });
      });
    }, e.prototype.exportKey = function (t) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, window.crypto.subtle.exportKey(KEY_FORMAT_JWK, t)];
        });
      });
    }, e.prototype.importKey = function (t, r, n, i) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, window.crypto.subtle.importKey(KEY_FORMAT_JWK, t, r, n, i)];
        });
      });
    }, e.prototype.sign = function (t, r, n) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, window.crypto.subtle.sign(t, r, n)];
        });
      });
    }, e.prototype.digest = function (t, r) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, window.crypto.subtle.digest(t, r)];
        });
      });
    }, e;
  }(),
  MsrBrowserCrypto = function () {
    function e() {}
    return e.prototype.initPrng = function (e) {
      return window.msrCrypto.initPrng(__spread(e));
    }, e.prototype.getRandomValues = function (e) {
      return window.msrCrypto.getRandomValues(e);
    }, e.prototype.generateKey = function (t, r, n) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, window.msrCrypto.subtle.generateKey(t, r, n)];
        });
      });
    }, e.prototype.exportKey = function (t) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, window.msrCrypto.subtle.exportKey(KEY_FORMAT_JWK, t)];
        });
      });
    }, e.prototype.importKey = function (t, r, n, i) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, window.msrCrypto.subtle.importKey(KEY_FORMAT_JWK, t, r, n, i)];
        });
      });
    }, e.prototype.sign = function (t, r, n) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, window.msrCrypto.subtle.sign(t, r, n)];
        });
      });
    }, e.prototype.digest = function (t, r) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, window.msrCrypto.subtle.digest(t, r)];
        });
      });
    }, e;
  }(),
  MsBrowserCrypto = function () {
    function e() {}
    return e.prototype.getRandomValues = function (e) {
      return window.msCrypto.getRandomValues(e);
    }, e.prototype.generateKey = function (n, i, o) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, new Promise(function (t, r) {
            var e = window.msCrypto.subtle.generateKey(n, i, o);
            e.addEventListener("complete", function (e) {
              t(e.target.result);
            }), e.addEventListener("error", function (e) {
              r(e);
            });
          })];
        });
      });
    }, e.prototype.exportKey = function (t) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, new Promise(function (r, n) {
            var e = window.msCrypto.subtle.exportKey(KEY_FORMAT_JWK, t);
            e.addEventListener("complete", function (e) {
              var t = e.target.result,
                t = BrowserStringUtils.utf8ArrToString(new Uint8Array(t)).replace(/\r/g, Constants.EMPTY_STRING).replace(/\n/g, Constants.EMPTY_STRING).replace(/\t/g, Constants.EMPTY_STRING).split(" ").join(Constants.EMPTY_STRING).replace("\0", Constants.EMPTY_STRING);
              try {
                r(JSON.parse(t));
              } catch (e) {
                n(e);
              }
            }), e.addEventListener("error", function (e) {
              n(e);
            });
          })];
        });
      });
    }, e.prototype.importKey = function (r, i, o, a) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, n;
        return __generator$3(this, function (e) {
          return t = BrowserStringUtils.getSortedObjectString(r), n = BrowserStringUtils.stringToArrayBuffer(t), [2, new Promise(function (t, r) {
            var e = window.msCrypto.subtle.importKey(KEY_FORMAT_JWK, n, i, o, a);
            e.addEventListener("complete", function (e) {
              t(e.target.result);
            }), e.addEventListener("error", function (e) {
              r(e);
            });
          })];
        });
      });
    }, e.prototype.sign = function (n, i, o) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, new Promise(function (t, r) {
            var e = window.msCrypto.subtle.sign(n, i, o);
            e.addEventListener("complete", function (e) {
              t(e.target.result);
            }), e.addEventListener("error", function (e) {
              r(e);
            });
          })];
        });
      });
    }, e.prototype.digest = function (n, i) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, new Promise(function (t, r) {
            var e = window.msCrypto.subtle.digest(n, i.buffer);
            e.addEventListener("complete", function (e) {
              t(e.target.result);
            }), e.addEventListener("error", function (e) {
              r(e);
            });
          })];
        });
      });
    }, e;
  }(),
  PKCS1_V15_KEYGEN_ALG = "RSASSA-PKCS1-v1_5",
  S256_HASH_ALG = "SHA-256",
  MODULUS_LENGTH = 2048,
  PUBLIC_EXPONENT = new Uint8Array([1, 0, 1]),
  BrowserCrypto = function () {
    function e(e, t) {
      if (this.logger = e, this.cryptoOptions = t, this.hasBrowserCrypto()) this.logger.verbose("BrowserCrypto: modern crypto interface available"), this.subtleCrypto = new ModernBrowserCrypto();else if (this.hasIECrypto()) this.logger.verbose("BrowserCrypto: MS crypto interface available"), this.subtleCrypto = new MsBrowserCrypto();else {
        if (!this.hasMsrCrypto() || null == (e = this.cryptoOptions) || !e.useMsrCrypto) throw this.hasMsrCrypto() && this.logger.info("BrowserCrypto: MSR Crypto interface available but system.cryptoOptions.useMsrCrypto not enabled"), this.logger.error("BrowserCrypto: No crypto interfaces available."), BrowserAuthError.createCryptoNotAvailableError("Browser crypto, msCrypto, or msrCrypto interfaces not available.");
        this.logger.verbose("BrowserCrypto: MSR crypto interface available"), this.subtleCrypto = new MsrBrowserCrypto();
      }
      if (this.subtleCrypto.initPrng) {
        if (this.logger.verbose("BrowserCrypto: Interface requires entropy"), null == (t = this.cryptoOptions) || !t.entropy) throw this.logger.error("BrowserCrypto: Interface requires entropy but none provided."), BrowserConfigurationAuthError.createEntropyNotProvided();
        this.logger.verbose("BrowserCrypto: Entropy provided"), this.subtleCrypto.initPrng(this.cryptoOptions.entropy);
      }
      this.keygenAlgorithmOptions = {
        name: PKCS1_V15_KEYGEN_ALG,
        hash: S256_HASH_ALG,
        modulusLength: MODULUS_LENGTH,
        publicExponent: PUBLIC_EXPONENT
      };
    }
    return e.prototype.hasIECrypto = function () {
      return "msCrypto" in window;
    }, e.prototype.hasBrowserCrypto = function () {
      return "crypto" in window;
    }, e.prototype.hasMsrCrypto = function () {
      return "msrCrypto" in window;
    }, e.prototype.sha256Digest = function (r) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          return t = BrowserStringUtils.stringToUtf8Arr(r), [2, this.subtleCrypto.digest({
            name: S256_HASH_ALG
          }, t)];
        });
      });
    }, e.prototype.getRandomValues = function (e) {
      return this.subtleCrypto.getRandomValues(e);
    }, e.prototype.generateKeyPair = function (t, r) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, this.subtleCrypto.generateKey(this.keygenAlgorithmOptions, t, r)];
        });
      });
    }, e.prototype.exportJwk = function (t) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, this.subtleCrypto.exportKey(t)];
        });
      });
    }, e.prototype.importJwk = function (t, r, n) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, this.subtleCrypto.importKey(t, this.keygenAlgorithmOptions, r, n)];
        });
      });
    }, e.prototype.sign = function (t, r) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, this.subtleCrypto.sign(this.keygenAlgorithmOptions, t, r)];
        });
      });
    }, e;
  }(),
  DatabaseStorage = function () {
    function e() {
      this.dbName = DB_NAME, this.version = DB_VERSION, this.tableName = DB_TABLE_NAME, this.dbOpen = !1;
    }
    return e.prototype.open = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        var n = this;
        return __generator$3(this, function (e) {
          return [2, new Promise(function (t, e) {
            var r = window.indexedDB.open(n.dbName, n.version);
            r.addEventListener("upgradeneeded", function (e) {
              e.target.result.createObjectStore(n.tableName);
            }), r.addEventListener("success", function (e) {
              n.db = e.target.result, n.dbOpen = !0, t();
            }), r.addEventListener("error", function () {
              return e(BrowserAuthError.createDatabaseUnavailableError());
            });
          })];
        });
      });
    }, e.prototype.closeConnection = function () {
      var e = this.db;
      e && this.dbOpen && (e.close(), this.dbOpen = !1);
    }, e.prototype.validateDbIsOpen = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.dbOpen ? [3, 2] : [4, this.open()];
            case 1:
              return [2, e.sent()];
            case 2:
              return [2];
          }
        });
      });
    }, e.prototype.getItem = function (i) {
      return __awaiter$3(this, void 0, void 0, function () {
        var n = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.validateDbIsOpen()];
            case 1:
              return e.sent(), [2, new Promise(function (t, r) {
                if (!n.db) return r(BrowserAuthError.createDatabaseNotOpenError());
                var e = n.db.transaction([n.tableName], "readonly").objectStore(n.tableName).get(i);
                e.addEventListener("success", function (e) {
                  n.closeConnection(), t(e.target.result);
                }), e.addEventListener("error", function (e) {
                  n.closeConnection(), r(e);
                });
              })];
          }
        });
      });
    }, e.prototype.setItem = function (i, o) {
      return __awaiter$3(this, void 0, void 0, function () {
        var n = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.validateDbIsOpen()];
            case 1:
              return e.sent(), [2, new Promise(function (e, t) {
                if (!n.db) return t(BrowserAuthError.createDatabaseNotOpenError());
                var r = n.db.transaction([n.tableName], "readwrite").objectStore(n.tableName).put(o, i);
                r.addEventListener("success", function () {
                  n.closeConnection(), e();
                }), r.addEventListener("error", function (e) {
                  n.closeConnection(), t(e);
                });
              })];
          }
        });
      });
    }, e.prototype.removeItem = function (i) {
      return __awaiter$3(this, void 0, void 0, function () {
        var n = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.validateDbIsOpen()];
            case 1:
              return e.sent(), [2, new Promise(function (e, t) {
                if (!n.db) return t(BrowserAuthError.createDatabaseNotOpenError());
                var r = n.db.transaction([n.tableName], "readwrite").objectStore(n.tableName).delete(i);
                r.addEventListener("success", function () {
                  n.closeConnection(), e();
                }), r.addEventListener("error", function (e) {
                  n.closeConnection(), t(e);
                });
              })];
          }
        });
      });
    }, e.prototype.getKeys = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        var n = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.validateDbIsOpen()];
            case 1:
              return e.sent(), [2, new Promise(function (t, r) {
                if (!n.db) return r(BrowserAuthError.createDatabaseNotOpenError());
                var e = n.db.transaction([n.tableName], "readonly").objectStore(n.tableName).getAllKeys();
                e.addEventListener("success", function (e) {
                  n.closeConnection(), t(e.target.result);
                }), e.addEventListener("error", function (e) {
                  n.closeConnection(), r(e);
                });
              })];
          }
        });
      });
    }, e.prototype.containsKey = function (i) {
      return __awaiter$3(this, void 0, void 0, function () {
        var n = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.validateDbIsOpen()];
            case 1:
              return e.sent(), [2, new Promise(function (t, r) {
                if (!n.db) return r(BrowserAuthError.createDatabaseNotOpenError());
                var e = n.db.transaction([n.tableName], "readonly").objectStore(n.tableName).count(i);
                e.addEventListener("success", function (e) {
                  n.closeConnection(), t(1 === e.target.result);
                }), e.addEventListener("error", function (e) {
                  n.closeConnection(), r(e);
                });
              })];
          }
        });
      });
    }, e.prototype.deleteDatabase = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return this.db && this.dbOpen && this.closeConnection(), [2, new Promise(function (e, t) {
            var r = window.indexedDB.deleteDatabase(DB_NAME);
            r.addEventListener("success", function () {
              return e(!0);
            }), r.addEventListener("blocked", function () {
              return e(!0);
            }), r.addEventListener("error", function () {
              return t(!1);
            });
          })];
        });
      });
    }, e;
  }(),
  AsyncMemoryStorage = function () {
    function e(e, t) {
      this.inMemoryCache = new MemoryStorage(), this.indexedDBCache = new DatabaseStorage(), this.logger = e, this.storeName = t;
    }
    return e.prototype.handleDatabaseAccessError = function (e) {
      if (!(e instanceof BrowserAuthError && e.errorCode === BrowserAuthErrorMessage.databaseUnavailable.code)) throw e;
      this.logger.error("Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.");
    }, e.prototype.getItem = function (n) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (t = this.inMemoryCache.getItem(n)) return [3, 4];
              e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), this.logger.verbose("Queried item not found in in-memory cache, now querying persistent storage."), [4, this.indexedDBCache.getItem(n)];
            case 2:
              return [2, e.sent()];
            case 3:
              return r = e.sent(), this.handleDatabaseAccessError(r), [3, 4];
            case 4:
              return [2, t];
          }
        });
      });
    }, e.prototype.setItem = function (r, n) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              this.inMemoryCache.setItem(r, n), e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), [4, this.indexedDBCache.setItem(r, n)];
            case 2:
              return e.sent(), [3, 4];
            case 3:
              return t = e.sent(), this.handleDatabaseAccessError(t), [3, 4];
            case 4:
              return [2];
          }
        });
      });
    }, e.prototype.removeItem = function (r) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              this.inMemoryCache.removeItem(r), e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), [4, this.indexedDBCache.removeItem(r)];
            case 2:
              return e.sent(), [3, 4];
            case 3:
              return t = e.sent(), this.handleDatabaseAccessError(t), [3, 4];
            case 4:
              return [2];
          }
        });
      });
    }, e.prototype.getKeys = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (0 !== (t = this.inMemoryCache.getKeys()).length) return [3, 4];
              e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), this.logger.verbose("In-memory cache is empty, now querying persistent storage."), [4, this.indexedDBCache.getKeys()];
            case 2:
              return [2, e.sent()];
            case 3:
              return r = e.sent(), this.handleDatabaseAccessError(r), [3, 4];
            case 4:
              return [2, t];
          }
        });
      });
    }, e.prototype.containsKey = function (n) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (t = this.inMemoryCache.containsKey(n)) return [3, 4];
              e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), this.logger.verbose("Key not found in in-memory cache, now querying persistent storage."), [4, this.indexedDBCache.containsKey(n)];
            case 2:
              return [2, e.sent()];
            case 3:
              return r = e.sent(), this.handleDatabaseAccessError(r), [3, 4];
            case 4:
              return [2, t];
          }
        });
      });
    }, e.prototype.clearInMemory = function () {
      this.logger.verbose("Deleting in-memory keystore " + this.storeName), this.inMemoryCache.clear(), this.logger.verbose("In-memory keystore " + this.storeName + " deleted");
    }, e.prototype.clearPersistent = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return e.trys.push([0, 2,, 3]), this.logger.verbose("Deleting persistent keystore"), [4, this.indexedDBCache.deleteDatabase()];
            case 1:
              return (t = e.sent()) && this.logger.verbose("Persistent keystore deleted"), [2, t];
            case 2:
              return t = e.sent(), this.handleDatabaseAccessError(t), [2, !1];
            case 3:
              return [2];
          }
        });
      });
    }, e;
  }(),
  CryptoKeyStore = (!function (e) {
    e.asymmetricKeys = "asymmetricKeys", e.symmetricKeys = "symmetricKeys";
  }(CryptoKeyStoreNames = CryptoKeyStoreNames || {}), function () {
    function e(e) {
      this.logger = e, this.asymmetricKeys = new AsyncMemoryStorage(this.logger, CryptoKeyStoreNames.asymmetricKeys), this.symmetricKeys = new AsyncMemoryStorage(this.logger, CryptoKeyStoreNames.symmetricKeys);
    }
    return e.prototype.clear = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              this.asymmetricKeys.clearInMemory(), this.symmetricKeys.clearInMemory(), e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), [4, this.asymmetricKeys.clearPersistent()];
            case 2:
              return e.sent(), [2, !0];
            case 3:
              return (t = e.sent()) instanceof Error ? this.logger.error("Clearing keystore failed with error: " + t.message) : this.logger.error("Clearing keystore failed with unknown error"), [2, !1];
            case 4:
              return [2];
          }
        });
      });
    }, e;
  }()),
  CryptoOps = function () {
    function l(e, t, r) {
      this.logger = e, this.browserCrypto = new BrowserCrypto(this.logger, r), this.b64Encode = new Base64Encode(), this.b64Decode = new Base64Decode(), this.guidGenerator = new GuidGenerator(this.browserCrypto), this.pkceGenerator = new PkceGenerator(this.browserCrypto), this.cache = new CryptoKeyStore(this.logger), this.performanceClient = t;
    }
    return l.prototype.createNewGuid = function () {
      return this.guidGenerator.generateGuid();
    }, l.prototype.base64Encode = function (e) {
      return this.b64Encode.encode(e);
    }, l.prototype.base64Decode = function (e) {
      return this.b64Decode.decode(e);
    }, l.prototype.generatePkceCodes = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          return [2, this.pkceGenerator.generateCodes()];
        });
      });
    }, l.prototype.getPublicKeyThumbprint = function (a) {
      var s;
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i, o;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return t = null == (s = this.performanceClient) ? void 0 : s.startMeasurement(PerformanceEvents.CryptoOptsGetPublicKeyThumbprint, a.correlationId), [4, this.browserCrypto.generateKeyPair(l.EXTRACTABLE, l.POP_KEY_USAGES)];
            case 1:
              return r = e.sent(), [4, this.browserCrypto.exportJwk(r.publicKey)];
            case 2:
              return i = e.sent(), i = {
                e: i.e,
                kty: i.kty,
                n: i.n
              }, i = BrowserStringUtils.getSortedObjectString(i), [4, this.hashString(i)];
            case 3:
              return n = e.sent(), [4, this.browserCrypto.exportJwk(r.privateKey)];
            case 4:
              return i = e.sent(), [4, this.browserCrypto.importJwk(i, !1, ["sign"])];
            case 5:
              return o = e.sent(), [4, this.cache.asymmetricKeys.setItem(n, {
                privateKey: o,
                publicKey: r.publicKey,
                requestMethod: a.resourceRequestMethod,
                requestUri: a.resourceRequestUri
              })];
            case 6:
              return e.sent(), t && t.endMeasurement({
                success: !0
              }), [2, n];
          }
        });
      });
    }, l.prototype.removeTokenBindingKey = function (t) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.cache.asymmetricKeys.removeItem(t)];
            case 1:
              return e.sent(), [4, this.cache.asymmetricKeys.containsKey(t)];
            case 2:
              return [2, !e.sent()];
          }
        });
      });
    }, l.prototype.clearKeystore = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.cache.clear()];
            case 1:
              return [2, e.sent()];
          }
        });
      });
    }, l.prototype.signJwt = function (s, l, c) {
      var u;
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i, o, a;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return t = null == (u = this.performanceClient) ? void 0 : u.startMeasurement(PerformanceEvents.CryptoOptsSignJwt, c), [4, this.cache.asymmetricKeys.getItem(l)];
            case 1:
              if (r = e.sent()) return [4, this.browserCrypto.exportJwk(r.publicKey)];
              throw BrowserAuthError.createSigningKeyNotFoundInStorageError(l);
            case 2:
              return o = e.sent(), n = BrowserStringUtils.getSortedObjectString(o), i = this.b64Encode.urlEncode(JSON.stringify({
                kid: l
              })), i = JoseHeader.getShrHeaderString({
                kid: i,
                alg: o.alg
              }), o = this.b64Encode.urlEncode(i), s.cnf = {
                jwk: JSON.parse(n)
              }, i = this.b64Encode.urlEncode(JSON.stringify(s)), n = o + "." + i, o = BrowserStringUtils.stringToArrayBuffer(n), [4, this.browserCrypto.sign(r.privateKey, o)];
            case 3:
              return i = e.sent(), o = this.b64Encode.urlEncodeArr(new Uint8Array(i)), a = n + "." + o, t && t.endMeasurement({
                success: !0
              }), [2, a];
          }
        });
      });
    }, l.prototype.hashString = function (r) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.browserCrypto.sha256Digest(r)];
            case 1:
              return t = e.sent(), t = new Uint8Array(t), [2, this.b64Encode.urlEncodeArr(t)];
          }
        });
      });
    }, l.POP_KEY_USAGES = ["sign", "verify"], l.EXTRACTABLE = !0, l;
  }(),
  BrowserPerformanceMeasurement = function () {
    function r(e, t) {
      this.correlationId = t, this.measureName = r.makeMeasureName(e, t), this.startMark = r.makeStartMark(e, t), this.endMark = r.makeEndMark(e, t);
    }
    return r.makeMeasureName = function (e, t) {
      return "msal.measure." + e + "." + t;
    }, r.makeStartMark = function (e, t) {
      return "msal.start." + e + "." + t;
    }, r.makeEndMark = function (e, t) {
      return "msal.end." + e + "." + t;
    }, r.supportsBrowserPerformance = function () {
      return "undefined" != typeof window && void 0 !== window.performance && "function" == typeof window.performance.mark && "function" == typeof window.performance.measure && "function" == typeof window.performance.clearMarks && "function" == typeof window.performance.clearMeasures && "function" == typeof window.performance.getEntriesByName;
    }, r.flushMeasurements = function (t, e) {
      if (r.supportsBrowserPerformance()) try {
        e.forEach(function (e) {
          e = r.makeMeasureName(e.name, t);
          0 < window.performance.getEntriesByName(e, "measure").length && (window.performance.clearMeasures(e), window.performance.clearMarks(r.makeStartMark(e, t)), window.performance.clearMarks(r.makeEndMark(e, t)));
        });
      } catch (e) {}
    }, r.prototype.startMeasurement = function () {
      if (r.supportsBrowserPerformance()) try {
        window.performance.mark(this.startMark);
      } catch (e) {}
    }, r.prototype.endMeasurement = function () {
      if (r.supportsBrowserPerformance()) try {
        window.performance.mark(this.endMark), window.performance.measure(this.measureName, this.startMark, this.endMark);
      } catch (e) {}
    }, r.prototype.flushMeasurement = function () {
      if (r.supportsBrowserPerformance()) try {
        var e,
          t = window.performance.getEntriesByName(this.measureName, "measure");
        if (0 < t.length) return e = t[0].duration, window.performance.clearMeasures(this.measureName), window.performance.clearMarks(this.startMark), window.performance.clearMarks(this.endMark), e;
      } catch (e) {}
      return null;
    }, r;
  }(),
  BrowserPerformanceClient = function (s) {
    function e(e, t, r, n, i, o, a) {
      e = s.call(this, e, t, r, n, i, o) || this;
      return e.browserCrypto = new BrowserCrypto(e.logger, a), e.guidGenerator = new GuidGenerator(e.browserCrypto), e;
    }
    return __extends$g(e, s), e.prototype.startPerformanceMeasuremeant = function (e, t) {
      return new BrowserPerformanceMeasurement(e, t);
    }, e.prototype.generateId = function () {
      return this.guidGenerator.generateGuid();
    }, e.prototype.getPageVisibility = function () {
      var e;
      return (null == (e = document.visibilityState) ? void 0 : e.toString()) || null;
    }, e.prototype.deleteIncompleteSubMeasurements = function (e) {
      var t = this.eventsByCorrelationId.get(e.event.correlationId),
        r = t && t.eventId === e.event.eventId,
        n = [];
      r && null != t && t.incompleteSubMeasurements && t.incompleteSubMeasurements.forEach(function (e) {
        n.push(__assign$5({}, e));
      }), 0 < n.length && BrowserPerformanceMeasurement.flushMeasurements(e.event.correlationId, n);
    }, e.prototype.supportsBrowserPerformanceNow = function () {
      return "undefined" != typeof window && void 0 !== window.performance && "function" == typeof window.performance.now;
    }, e.prototype.startMeasurement = function (e, t) {
      var r = this,
        n = this.getPageVisibility(),
        i = s.prototype.startMeasurement.call(this, e, t);
      return __assign$5(__assign$5({}, i), {
        endMeasurement: function (e) {
          e = i.endMeasurement(__assign$5({
            startPageVisibility: n,
            endPageVisibility: r.getPageVisibility()
          }, e));
          return r.deleteIncompleteSubMeasurements(i), e;
        },
        discardMeasurement: function () {
          i.discardMeasurement(), r.deleteIncompleteSubMeasurements(i), i.measurement.flushMeasurement();
        }
      });
    }, e.prototype.setPreQueueTime = function (e, t) {
      var r;
      this.supportsBrowserPerformanceNow() ? t ? ((r = this.preQueueTimeByCorrelationId.get(t)) && (this.logger.trace("BrowserPerformanceClient: Incomplete pre-queue " + r.name + " found", t), this.addQueueMeasurement(r.name, t, void 0, !0)), this.preQueueTimeByCorrelationId.set(t, {
        name: e,
        time: window.performance.now()
      })) : this.logger.trace("BrowserPerformanceClient: correlationId for " + e + " not provided, unable to set telemetry queue time") : this.logger.trace("BrowserPerformanceClient: window performance API not available, unable to set telemetry queue time for " + e);
    }, e.prototype.addQueueMeasurement = function (e, t, r, n) {
      if (this.supportsBrowserPerformanceNow()) {
        if (t) {
          var i,
            o = s.prototype.getPreQueueTime.call(this, e, t);
          if (o) return i = window.performance.now(), r = r || s.prototype.calculateQueuedTime.call(this, o, i), s.prototype.addQueueMeasurement.call(this, e, t, r, n);
        } else this.logger.trace("BrowserPerformanceClient: correlationId for " + e + " not provided, unable to add queue measurement");
      } else this.logger.trace("BrowserPerformanceClient: window performance API not available, unable to add queue measurement for " + e);
    }, e;
  }(PerformanceClient),
  TokenCache = function () {
    function e(e, t, r, n) {
      this.isBrowserEnvironment = "undefined" != typeof window, this.config = e, this.storage = t, this.logger = r, this.cryptoObj = n;
    }
    return e.prototype.loadExternalTokens = function (e, t, r) {
      if (this.logger.info("TokenCache - loadExternalTokens called"), !t.id_token) throw BrowserAuthError.createUnableToLoadTokenError("Please ensure server response includes id token.");
      var n = new AuthToken(t.id_token, this.cryptoObj);
      if (e.account) var i = this.loadAccount(n, e.account.environment, void 0, void 0, e.account.homeAccountId),
        o = new CacheRecord(i, this.loadIdToken(n, i.homeAccountId, e.account.environment, e.account.tenantId), this.loadAccessToken(e, t, i.homeAccountId, e.account.environment, e.account.tenantId, r), this.loadRefreshToken(e, t, i.homeAccountId, e.account.environment));else {
        if (!e.authority) throw BrowserAuthError.createUnableToLoadTokenError("Please provide a request with an account or a request with authority.");
        var a = Authority.generateAuthority(e.authority, e.azureCloudOptions),
          s = {
            protocolMode: this.config.auth.protocolMode,
            knownAuthorities: this.config.auth.knownAuthorities,
            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
            authorityMetadata: this.config.auth.authorityMetadata,
            skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
          },
          a = new Authority(a, this.config.system.networkClient, this.storage, s, this.logger);
        if (r.clientInfo) {
          this.logger.trace("TokenCache - homeAccountId from options");
          i = this.loadAccount(n, a.hostnameAndPort, r.clientInfo, a.authorityType);
        } else {
          if (!t.client_info) throw BrowserAuthError.createUnableToLoadTokenError("Please provide clientInfo in the response or options.");
          this.logger.trace("TokenCache - homeAccountId from response");
          i = this.loadAccount(n, a.hostnameAndPort, t.client_info, a.authorityType);
        }
        o = new CacheRecord(i, this.loadIdToken(n, i.homeAccountId, a.hostnameAndPort, a.tenant), this.loadAccessToken(e, t, i.homeAccountId, a.hostnameAndPort, a.tenant, r), this.loadRefreshToken(e, t, i.homeAccountId, a.hostnameAndPort));
      }
      return this.generateAuthenticationResult(e, n, o, a);
    }, e.prototype.loadAccount = function (e, t, r, n, i) {
      var o;
      if (i ? o = i : void 0 !== n && r && (o = AccountEntity.generateHomeAccountId(r, n, this.logger, this.cryptoObj, e)), !o) throw BrowserAuthError.createUnableToLoadTokenError("Unexpected missing homeAccountId");
      i = r ? AccountEntity.createAccount(r, o, e, void 0, void 0, void 0, t) : AccountEntity.createGenericAccount(o, e, void 0, void 0, void 0, t);
      if (this.isBrowserEnvironment) return this.logger.verbose("TokenCache - loading account"), this.storage.setAccount(i), i;
      throw BrowserAuthError.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.");
    }, e.prototype.loadIdToken = function (e, t, r, n) {
      t = IdTokenEntity.createIdTokenEntity(t, r, e.rawToken, this.config.auth.clientId, n);
      if (this.isBrowserEnvironment) return this.logger.verbose("TokenCache - loading id token"), this.storage.setIdTokenCredential(t), t;
      throw BrowserAuthError.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.");
    }, e.prototype.loadAccessToken = function (e, t, r, n, i, o) {
      if (!t.access_token) return this.logger.verbose("TokenCache - No access token provided for caching"), null;
      if (!t.expires_in) throw BrowserAuthError.createUnableToLoadTokenError("Please ensure server response includes expires_in value.");
      if (!o.extendedExpiresOn) throw BrowserAuthError.createUnableToLoadTokenError("Please provide an extendedExpiresOn value in the options.");
      var e = new ScopeSet(e.scopes).printScopes(),
        a = o.expiresOn || t.expires_in + new Date().getTime() / 1e3,
        o = o.extendedExpiresOn,
        r = AccessTokenEntity.createAccessTokenEntity(r, n, t.access_token, this.config.auth.clientId, i, e, a, o, this.cryptoObj);
      if (this.isBrowserEnvironment) return this.logger.verbose("TokenCache - loading access token"), this.storage.setAccessTokenCredential(r), r;
      throw BrowserAuthError.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.");
    }, e.prototype.loadRefreshToken = function (e, t, r, n) {
      if (!t.refresh_token) return this.logger.verbose("TokenCache - No refresh token provided for caching"), null;
      r = RefreshTokenEntity.createRefreshTokenEntity(r, n, t.refresh_token, this.config.auth.clientId);
      if (this.isBrowserEnvironment) return this.logger.verbose("TokenCache - loading refresh token"), this.storage.setRefreshTokenCredential(r), r;
      throw BrowserAuthError.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.");
    }, e.prototype.generateAuthenticationResult = function (e, t, r, n) {
      var i,
        o = Constants.EMPTY_STRING,
        a = [],
        s = null,
        l = (null != r && r.accessToken && (o = r.accessToken.secret, a = ScopeSet.fromString(r.accessToken.target).asArray(), s = new Date(1e3 * Number(r.accessToken.expiresOn)), i = new Date(1e3 * Number(r.accessToken.extendedExpiresOn))), (null == t ? void 0 : t.claims.oid) || (null == t ? void 0 : t.claims.sub) || Constants.EMPTY_STRING),
        c = (null == t ? void 0 : t.claims.tid) || Constants.EMPTY_STRING;
      return {
        authority: n ? n.canonicalAuthority : Constants.EMPTY_STRING,
        uniqueId: l,
        tenantId: c,
        scopes: a,
        account: null != r && r.account ? r.account.getAccountInfo() : null,
        idToken: t ? t.rawToken : Constants.EMPTY_STRING,
        idTokenClaims: t ? t.claims : {},
        accessToken: o,
        fromCache: !0,
        expiresOn: s,
        correlationId: e.correlationId || Constants.EMPTY_STRING,
        requestId: Constants.EMPTY_STRING,
        extExpiresOn: i,
        familyId: Constants.EMPTY_STRING,
        tokenType: (null == (n = null == r ? void 0 : r.accessToken) ? void 0 : n.tokenType) || Constants.EMPTY_STRING,
        state: Constants.EMPTY_STRING,
        cloudGraphHostName: (null == (l = null == r ? void 0 : r.account) ? void 0 : l.cloudGraphHostName) || Constants.EMPTY_STRING,
        msGraphHost: (null == (c = null == r ? void 0 : r.account) ? void 0 : c.msGraphHost) || Constants.EMPTY_STRING,
        code: void 0,
        fromNativeBroker: !1
      };
    }, e;
  }(),
  HybridSpaAuthorizationCodeClient = function (t) {
    function e(e) {
      e = t.call(this, e) || this;
      return e.includeRedirectUri = !1, e;
    }
    return __extends$g(e, t), e;
  }(AuthorizationCodeClient),
  SilentAuthCodeClient = function (u) {
    function e(e, t, r, n, i, o, a, s, l, c) {
      e = u.call(this, e, t, r, n, i, o, s, l, c) || this;
      return e.apiId = a, e;
    }
    return __extends$g(e, u), e.prototype.acquireToken = function (o) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (this.logger.trace("SilentAuthCodeClient.acquireToken called"), o.code) return this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, o.correlationId), [4, this.initializeAuthorizationRequest(o, InteractionType.Silent)];
              throw BrowserAuthError.createAuthCodeRequiredError();
            case 1:
              t = e.sent(), this.browserStorage.updateCacheEntries(t.state, t.nonce, t.authority, t.loginHint || Constants.EMPTY_STRING, t.account || null), r = this.initializeServerTelemetryManager(this.apiId), e.label = 2;
            case 2:
              return e.trys.push([2, 4,, 5]), n = __assign$5(__assign$5({}, t), {
                code: o.code
              }), this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetClientConfiguration, o.correlationId), [4, this.getClientConfiguration(r, t.authority)];
            case 3:
              return i = e.sent(), i = new HybridSpaAuthorizationCodeClient(i), this.logger.verbose("Auth code client created"), [2, new SilentHandler(i, this.browserStorage, n, this.logger, this.config.system, this.performanceClient).handleCodeResponseFromServer({
                code: o.code,
                msgraph_host: o.msGraphHost,
                cloud_graph_host_name: o.cloudGraphHostName,
                cloud_instance_host_name: o.cloudInstanceHostName
              }, t.state, i.authority, this.networkClient, !1)];
            case 4:
              throw (i = e.sent()) instanceof AuthError && i.setCorrelationId(this.correlationId), r.cacheFailedRequest(i), this.browserStorage.cleanRequestByState(t.state), i;
            case 5:
              return [2];
          }
        });
      });
    }, e.prototype.logout = function () {
      return Promise.reject(BrowserAuthError.createSilentLogoutUnsupportedError());
    }, e;
  }(StandardInteractionClient),
  ClientApplication = function () {
    function e(e) {
      this.isBrowserEnvironment = "undefined" != typeof window, this.config = buildConfiguration(e, this.isBrowserEnvironment), this.initialized = !1, this.logger = new Logger(this.config.system.loggerOptions, name$2, version$4), this.networkClient = this.config.system.networkClient, this.navigationClient = this.config.system.navigationClient, this.redirectResponse = new Map(), this.hybridAuthCodeResponses = new Map(), this.performanceClient = this.isBrowserEnvironment ? new BrowserPerformanceClient(this.config.auth.clientId, this.config.auth.authority, this.logger, name$2, version$4, this.config.telemetry.application, this.config.system.cryptoOptions) : new StubPerformanceClient(this.config.auth.clientId, this.config.auth.authority, this.logger, name$2, version$4, this.config.telemetry.application), this.browserCrypto = this.isBrowserEnvironment ? new CryptoOps(this.logger, this.performanceClient, this.config.system.cryptoOptions) : DEFAULT_CRYPTO_IMPLEMENTATION, this.eventHandler = new EventHandler(this.logger, this.browserCrypto), this.browserStorage = this.isBrowserEnvironment ? new BrowserCacheManager(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger) : DEFAULT_BROWSER_CACHE_MANAGER(this.config.auth.clientId, this.logger);
      e = {
        cacheLocation: BrowserCacheLocation.MemoryStorage,
        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,
        storeAuthStateInCookie: !1,
        secureCookies: !1,
        cacheMigrationEnabled: !1,
        claimsBasedCachingEnabled: !0
      };
      this.nativeInternalStorage = new BrowserCacheManager(this.config.auth.clientId, e, this.browserCrypto, this.logger), this.tokenCache = new TokenCache(this.config, this.browserStorage, this.logger, this.browserCrypto), this.trackPageVisibilityWithMeasurement = this.trackPageVisibilityWithMeasurement.bind(this);
    }
    return e.prototype.initialize = function () {
      return __awaiter$3(this, void 0, void 0, function () {
        var t, r, n, i, o;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              if (this.logger.trace("initialize called"), this.initialized) return this.logger.info("initialize has already been called, exiting early."), [2];
              if (t = this.config.system.allowNativeBroker, r = this.performanceClient.startMeasurement(PerformanceEvents.InitializeClientApplication), this.eventHandler.emitEvent(EventType.INITIALIZE_START), !t) return [3, 4];
              e.label = 1;
            case 1:
              return e.trys.push([1, 3,, 4]), n = this, [4, NativeMessageHandler.createProvider(this.logger, this.config.system.nativeBrokerHandshakeTimeout, this.performanceClient)];
            case 2:
              return n.nativeExtensionProvider = e.sent(), [3, 4];
            case 3:
              return i = e.sent(), this.logger.verbose(i), [3, 4];
            case 4:
              return this.config.cache.claimsBasedCachingEnabled ? [3, 6] : (this.logger.verbose("Claims-based caching is disabled. Clearing the previous cache with claims"), o = this.performanceClient.startMeasurement(PerformanceEvents.ClearTokensAndKeysWithClaims), [4, this.browserStorage.clearTokensAndKeysWithClaims()]);
            case 5:
              e.sent(), o.endMeasurement({
                success: !0
              }), e.label = 6;
            case 6:
              return this.initialized = !0, this.eventHandler.emitEvent(EventType.INITIALIZE_END), r.endMeasurement({
                allowNativeBroker: t,
                success: !0
              }), [2];
          }
        });
      });
    }, e.prototype.handleRedirectPromise = function (s) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t,
          r,
          n,
          i,
          o,
          a = this;
        return __generator$3(this, function (e) {
          return this.logger.verbose("handleRedirectPromise called"), BrowserUtils.blockNativeBrokerCalledBeforeInitialized(this.config.system.allowNativeBroker, this.initialized), t = this.getAllAccounts(), this.isBrowserEnvironment ? (r = s || Constants.EMPTY_STRING, void 0 === (n = this.redirectResponse.get(r)) ? (this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_START, InteractionType.Redirect), this.logger.verbose("handleRedirectPromise has been called for the first time, storing the promise"), o = this.browserStorage.getCachedNativeRequest(), i = void 0, i = o && NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeExtensionProvider) && this.nativeExtensionProvider && !s ? (this.logger.trace("handleRedirectPromise - acquiring token from native platform"), new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.handleRedirectPromise, this.performanceClient, this.nativeExtensionProvider, o.accountId, this.nativeInternalStorage, o.correlationId).handleRedirectPromise()) : (this.logger.trace("handleRedirectPromise - acquiring token from web flow"), o = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.CORRELATION_ID, !0) || Constants.EMPTY_STRING, this.createRedirectClient(o).handleRedirectPromise(s)), n = i.then(function (e) {
            return e && (t.length < a.getAllAccounts().length ? (a.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Redirect, e), a.logger.verbose("handleRedirectResponse returned result, login success")) : (a.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Redirect, e), a.logger.verbose("handleRedirectResponse returned result, acquire token success"))), a.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect), e;
          }).catch(function (e) {
            throw 0 < t.length ? a.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e) : a.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e), a.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect), e;
          }), this.redirectResponse.set(r, n)) : this.logger.verbose("handleRedirectPromise has been called previously, returning the result from the first call"), [2, n]) : (this.logger.verbose("handleRedirectPromise returns null, not browser environment"), [2, null]);
        });
      });
    }, e.prototype.acquireTokenRedirect = function (i) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t,
          r,
          n = this;
        return __generator$3(this, function (e) {
          return t = this.getRequestCorrelationId(i), this.logger.verbose("acquireTokenRedirect called", t), this.preflightBrowserEnvironmentCheck(InteractionType.Redirect), (r = 0 < this.getAllAccounts().length) ? this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Redirect, i) : this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Redirect, i), [2, (this.nativeExtensionProvider && this.canUseNative(i) ? new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenRedirect, this.performanceClient, this.nativeExtensionProvider, this.getNativeAccountId(i), this.nativeInternalStorage, i.correlationId).acquireTokenRedirect(i).catch(function (e) {
            if (e instanceof NativeAuthError && e.isFatal()) return n.nativeExtensionProvider = void 0, n.createRedirectClient(i.correlationId).acquireToken(i);
            if (e instanceof InteractionRequiredAuthError) return n.logger.verbose("acquireTokenRedirect - Resolving interaction required error thrown by native broker by falling back to web flow"), n.createRedirectClient(i.correlationId).acquireToken(i);
            throw n.browserStorage.setInteractionInProgress(!1), e;
          }) : this.createRedirectClient(i.correlationId).acquireToken(i)).catch(function (e) {
            throw r ? n.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e) : n.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e), e;
          })];
        });
      });
    }, e.prototype.acquireTokenPopup = function (t) {
      var r = this,
        e = this.getRequestCorrelationId(t),
        n = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenPopup, e);
      try {
        this.logger.verbose("acquireTokenPopup called", e), this.preflightBrowserEnvironmentCheck(InteractionType.Popup);
      } catch (e) {
        return Promise.reject(e);
      }
      var i = this.getAllAccounts();
      return 0 < i.length ? this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Popup, t) : this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Popup, t), (this.canUseNative(t) ? this.acquireTokenNative(t, ApiId.acquireTokenPopup).then(function (e) {
        return r.browserStorage.setInteractionInProgress(!1), n.endMeasurement({
          success: !0,
          isNativeBroker: !0,
          requestId: e.requestId
        }), e;
      }).catch(function (e) {
        if (e instanceof NativeAuthError && e.isFatal()) return r.nativeExtensionProvider = void 0, r.createPopupClient(t.correlationId).acquireToken(t);
        if (e instanceof InteractionRequiredAuthError) return r.logger.verbose("acquireTokenPopup - Resolving interaction required error thrown by native broker by falling back to web flow"), r.createPopupClient(t.correlationId).acquireToken(t);
        throw r.browserStorage.setInteractionInProgress(!1), e;
      }) : this.createPopupClient(t.correlationId).acquireToken(t)).then(function (e) {
        return i.length < r.getAllAccounts().length ? r.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Popup, e) : r.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Popup, e), n.addStaticFields({
          accessTokenSize: e.accessToken.length,
          idTokenSize: e.idToken.length
        }), n.endMeasurement({
          success: !0,
          requestId: e.requestId
        }), e;
      }).catch(function (e) {
        return 0 < i.length ? r.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Popup, null, e) : r.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Popup, null, e), n.endMeasurement({
          errorCode: e.errorCode,
          subErrorCode: e.subError,
          success: !1
        }), Promise.reject(e);
      });
    }, e.prototype.trackPageVisibilityWithMeasurement = function () {
      var e = this.ssoSilentMeasurement || this.acquireTokenByCodeAsyncMeasurement;
      e && (this.logger.info("Perf: Visibility change detected in ", e.event.name), e.increment({
        visibilityChangeCount: 1
      }));
    }, e.prototype.ssoSilent = function (i) {
      var o;
      return __awaiter$3(this, void 0, void 0, function () {
        var t,
          r,
          n = this;
        return __generator$3(this, function (e) {
          return t = this.getRequestCorrelationId(i), r = __assign$5(__assign$5({}, i), {
            prompt: i.prompt,
            correlationId: t
          }), this.preflightBrowserEnvironmentCheck(InteractionType.Silent), this.ssoSilentMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SsoSilent, t), null != (o = this.ssoSilentMeasurement) && o.increment({
            visibilityChangeCount: 0
          }), document.addEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement), this.logger.verbose("ssoSilent called", t), this.eventHandler.emitEvent(EventType.SSO_SILENT_START, InteractionType.Silent, r), [2, (this.canUseNative(r) ? this.acquireTokenNative(r, ApiId.ssoSilent).catch(function (e) {
            if (e instanceof NativeAuthError && e.isFatal()) return n.nativeExtensionProvider = void 0, n.createSilentIframeClient(r.correlationId).acquireToken(r);
            throw e;
          }) : this.createSilentIframeClient(r.correlationId).acquireToken(r)).then(function (e) {
            var t;
            return n.eventHandler.emitEvent(EventType.SSO_SILENT_SUCCESS, InteractionType.Silent, e), null != (t = n.ssoSilentMeasurement) && t.addStaticFields({
              accessTokenSize: e.accessToken.length,
              idTokenSize: e.idToken.length
            }), null != (t = n.ssoSilentMeasurement) && t.endMeasurement({
              success: !0,
              isNativeBroker: e.fromNativeBroker,
              requestId: e.requestId
            }), e;
          }).catch(function (e) {
            var t;
            throw n.eventHandler.emitEvent(EventType.SSO_SILENT_FAILURE, InteractionType.Silent, null, e), null != (t = n.ssoSilentMeasurement) && t.endMeasurement({
              errorCode: e.errorCode,
              subErrorCode: e.subError,
              success: !1
            }), e;
          }).finally(function () {
            document.removeEventListener("visibilitychange", n.trackPageVisibilityWithMeasurement);
          })];
        });
      });
    }, e.prototype.acquireTokenByCode = function (a) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t,
          r,
          n,
          i,
          o = this;
        return __generator$3(this, function (e) {
          t = this.getRequestCorrelationId(a), this.preflightBrowserEnvironmentCheck(InteractionType.Silent), this.logger.trace("acquireTokenByCode called", t), this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_START, InteractionType.Silent, a), r = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenByCode, a.correlationId);
          try {
            if (a.code && a.nativeAccountId) throw BrowserAuthError.createSpaCodeAndNativeAccountIdPresentError();
            if (a.code) return n = a.code, (i = this.hybridAuthCodeResponses.get(n)) ? (this.logger.verbose("Existing acquireTokenByCode request found", a.correlationId), r.discardMeasurement()) : (this.logger.verbose("Initiating new acquireTokenByCode request", t), i = this.acquireTokenByCodeAsync(__assign$5(__assign$5({}, a), {
              correlationId: t
            })).then(function (e) {
              return o.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_SUCCESS, InteractionType.Silent, e), o.hybridAuthCodeResponses.delete(n), r.addStaticFields({
                accessTokenSize: e.accessToken.length,
                idTokenSize: e.idToken.length
              }), r.endMeasurement({
                success: !0,
                isNativeBroker: e.fromNativeBroker,
                requestId: e.requestId
              }), e;
            }).catch(function (e) {
              throw o.hybridAuthCodeResponses.delete(n), o.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_FAILURE, InteractionType.Silent, null, e), r.endMeasurement({
                errorCode: e.errorCode,
                subErrorCode: e.subError,
                success: !1
              }), e;
            }), this.hybridAuthCodeResponses.set(n, i)), [2, i];
            if (a.nativeAccountId) {
              if (this.canUseNative(a, a.nativeAccountId)) return [2, this.acquireTokenNative(a, ApiId.acquireTokenByCode, a.nativeAccountId).catch(function (e) {
                throw e instanceof NativeAuthError && e.isFatal() && (o.nativeExtensionProvider = void 0), e;
              })];
              throw BrowserAuthError.createUnableToAcquireTokenFromNativePlatformError();
            }
            throw BrowserAuthError.createAuthCodeOrNativeAccountIdRequiredError();
          } catch (e) {
            throw this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_FAILURE, InteractionType.Silent, null, e), r.endMeasurement({
              errorCode: e instanceof AuthError && e.errorCode || void 0,
              subErrorCode: e instanceof AuthError && e.subError || void 0,
              success: !1
            }), e;
          }
          return [2];
        });
      });
    }, e.prototype.acquireTokenByCodeAsync = function (t) {
      var n;
      return __awaiter$3(this, void 0, void 0, function () {
        var r = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return this.logger.trace("acquireTokenByCodeAsync called", t.correlationId), this.acquireTokenByCodeAsyncMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenByCodeAsync, t.correlationId), null != (n = this.acquireTokenByCodeAsyncMeasurement) && n.increment({
                visibilityChangeCount: 0
              }), document.addEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement), [4, this.createSilentAuthCodeClient(t.correlationId).acquireToken(t).then(function (e) {
                var t;
                return null != (t = r.acquireTokenByCodeAsyncMeasurement) && t.endMeasurement({
                  success: !0,
                  fromCache: e.fromCache,
                  isNativeBroker: e.fromNativeBroker,
                  requestId: e.requestId
                }), e;
              }).catch(function (e) {
                var t;
                throw null != (t = r.acquireTokenByCodeAsyncMeasurement) && t.endMeasurement({
                  errorCode: e.errorCode,
                  subErrorCode: e.subError,
                  success: !1
                }), e;
              }).finally(function () {
                document.removeEventListener("visibilitychange", r.trackPageVisibilityWithMeasurement);
              })];
            case 1:
              return [2, e.sent()];
          }
        });
      });
    }, e.prototype.acquireTokenFromCache = function (t, r, n) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          switch (this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenFromCache, r.correlationId), n.cacheLookupPolicy) {
            case CacheLookupPolicy.Default:
            case CacheLookupPolicy.AccessToken:
            case CacheLookupPolicy.AccessTokenAndRefreshToken:
              return [2, t.acquireToken(r)];
            default:
              throw ClientAuthError.createRefreshRequiredError();
          }
          return [2];
        });
      });
    }, e.prototype.acquireTokenByRefreshToken = function (r, n) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          switch (this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenByRefreshToken, r.correlationId), n.cacheLookupPolicy) {
            case CacheLookupPolicy.Default:
            case CacheLookupPolicy.AccessTokenAndRefreshToken:
            case CacheLookupPolicy.RefreshToken:
            case CacheLookupPolicy.RefreshTokenAndNetwork:
              return t = this.createSilentRefreshClient(r.correlationId), this.performanceClient.setPreQueueTime(PerformanceEvents.SilentRefreshClientAcquireToken, r.correlationId), [2, t.acquireToken(r)];
            default:
              throw ClientAuthError.createRefreshRequiredError();
          }
          return [2];
        });
      });
    }, e.prototype.acquireTokenBySilentIframe = function (r) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          return this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenBySilentIframe, r.correlationId), t = this.createSilentIframeClient(r.correlationId), this.performanceClient.setPreQueueTime(PerformanceEvents.SilentIframeClientAcquireToken, r.correlationId), [2, t.acquireToken(r)];
        });
      });
    }, e.prototype.logout = function (r) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          return t = this.getRequestCorrelationId(r), this.logger.warning("logout API is deprecated and will be removed in msal-browser v3.0.0. Use logoutRedirect instead.", t), [2, this.logoutRedirect(__assign$5({
            correlationId: t
          }, r))];
        });
      });
    }, e.prototype.logoutRedirect = function (r) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          return t = this.getRequestCorrelationId(r), this.preflightBrowserEnvironmentCheck(InteractionType.Redirect), [2, this.createRedirectClient(t).logout(r)];
        });
      });
    }, e.prototype.logoutPopup = function (e) {
      try {
        var t = this.getRequestCorrelationId(e);
        return this.preflightBrowserEnvironmentCheck(InteractionType.Popup), this.createPopupClient(t).logout(e);
      } catch (e) {
        return Promise.reject(e);
      }
    }, e.prototype.getAllAccounts = function () {
      return this.logger.verbose("getAllAccounts called"), this.isBrowserEnvironment ? this.browserStorage.getAllAccounts() : [];
    }, e.prototype.getAccountByUsername = function (e) {
      var t;
      return this.logger.trace("getAccountByUsername called"), e ? (t = this.browserStorage.getAccountInfoFilteredBy({
        username: e
      })) ? (this.logger.verbose("getAccountByUsername: Account matching username found, returning"), this.logger.verbosePii("getAccountByUsername: Returning signed-in accounts matching username: " + e), t) : (this.logger.verbose("getAccountByUsername: No matching account found, returning null"), null) : (this.logger.warning("getAccountByUsername: No username provided"), null);
    }, e.prototype.getAccountByHomeId = function (e) {
      var t;
      return this.logger.trace("getAccountByHomeId called"), e ? (t = this.browserStorage.getAccountInfoFilteredBy({
        homeAccountId: e
      })) ? (this.logger.verbose("getAccountByHomeId: Account matching homeAccountId found, returning"), this.logger.verbosePii("getAccountByHomeId: Returning signed-in accounts matching homeAccountId: " + e), t) : (this.logger.verbose("getAccountByHomeId: No matching account found, returning null"), null) : (this.logger.warning("getAccountByHomeId: No homeAccountId provided"), null);
    }, e.prototype.getAccountByLocalId = function (e) {
      var t;
      return this.logger.trace("getAccountByLocalId called"), e ? (t = this.browserStorage.getAccountInfoFilteredBy({
        localAccountId: e
      })) ? (this.logger.verbose("getAccountByLocalId: Account matching localAccountId found, returning"), this.logger.verbosePii("getAccountByLocalId: Returning signed-in accounts matching localAccountId: " + e), t) : (this.logger.verbose("getAccountByLocalId: No matching account found, returning null"), null) : (this.logger.warning("getAccountByLocalId: No localAccountId provided"), null);
    }, e.prototype.setActiveAccount = function (e) {
      this.browserStorage.setActiveAccount(e);
    }, e.prototype.getActiveAccount = function () {
      return this.browserStorage.getActiveAccount();
    }, e.prototype.preflightBrowserEnvironmentCheck = function (e, t) {
      if (void 0 === t && (t = !0), this.logger.verbose("preflightBrowserEnvironmentCheck started"), BrowserUtils.blockNonBrowserEnvironment(this.isBrowserEnvironment), BrowserUtils.blockRedirectInIframe(e, this.config.system.allowRedirectInIframe), BrowserUtils.blockReloadInHiddenIframes(), BrowserUtils.blockAcquireTokenInPopups(), BrowserUtils.blockNativeBrokerCalledBeforeInitialized(this.config.system.allowNativeBroker, this.initialized), e === InteractionType.Redirect && this.config.cache.cacheLocation === BrowserCacheLocation.MemoryStorage && !this.config.cache.storeAuthStateInCookie) throw BrowserConfigurationAuthError.createInMemoryRedirectUnavailableError();
      e !== InteractionType.Redirect && e !== InteractionType.Popup || this.preflightInteractiveRequest(t);
    }, e.prototype.preflightInteractiveRequest = function (e) {
      this.logger.verbose("preflightInteractiveRequest called, validating app environment"), BrowserUtils.blockReloadInHiddenIframes(), e && this.browserStorage.setInteractionInProgress(!0);
    }, e.prototype.acquireTokenNative = function (t, r, n) {
      return __awaiter$3(this, void 0, void 0, function () {
        return __generator$3(this, function (e) {
          if (this.logger.trace("acquireTokenNative called"), this.nativeExtensionProvider) return [2, new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, r, this.performanceClient, this.nativeExtensionProvider, n || this.getNativeAccountId(t), this.nativeInternalStorage, t.correlationId).acquireToken(t)];
          throw BrowserAuthError.createNativeConnectionNotEstablishedError();
        });
      });
    }, e.prototype.canUseNative = function (e, t) {
      if (this.logger.trace("canUseNative called"), !NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeExtensionProvider, e.authenticationScheme)) return this.logger.trace("canUseNative: isNativeAvailable returned false, returning false"), !1;
      if (e.prompt) switch (e.prompt) {
        case PromptValue.NONE:
        case PromptValue.CONSENT:
        case PromptValue.LOGIN:
          this.logger.trace("canUseNative: prompt is compatible with native flow");
          break;
        default:
          return this.logger.trace("canUseNative: prompt = " + e.prompt + " is not compatible with native flow, returning false"), !1;
      }
      return !(!t && !this.getNativeAccountId(e) && (this.logger.trace("canUseNative: nativeAccountId is not available, returning false"), 1));
    }, e.prototype.getNativeAccountId = function (e) {
      e = e.account || this.browserStorage.getAccountInfoByHints(e.loginHint, e.sid) || this.getActiveAccount();
      return e && e.nativeAccountId || "";
    }, e.prototype.createPopupClient = function (e) {
      return new PopupClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, e);
    }, e.prototype.createRedirectClient = function (e) {
      return new RedirectClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, e);
    }, e.prototype.createSilentIframeClient = function (e) {
      return new SilentIframeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.ssoSilent, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, e);
    }, e.prototype.createSilentCacheClient = function (e) {
      return new SilentCacheClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeExtensionProvider, e);
    }, e.prototype.createSilentRefreshClient = function (e) {
      return new SilentRefreshClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeExtensionProvider, e);
    }, e.prototype.createSilentAuthCodeClient = function (e) {
      return new SilentAuthCodeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenByCode, this.performanceClient, this.nativeExtensionProvider, e);
    }, e.prototype.addEventCallback = function (e) {
      return this.eventHandler.addEventCallback(e);
    }, e.prototype.removeEventCallback = function (e) {
      this.eventHandler.removeEventCallback(e);
    }, e.prototype.addPerformanceCallback = function (e) {
      return this.performanceClient.addPerformanceCallback(e);
    }, e.prototype.removePerformanceCallback = function (e) {
      return this.performanceClient.removePerformanceCallback(e);
    }, e.prototype.enableAccountStorageEvents = function () {
      this.eventHandler.enableAccountStorageEvents();
    }, e.prototype.disableAccountStorageEvents = function () {
      this.eventHandler.disableAccountStorageEvents();
    }, e.prototype.getTokenCache = function () {
      return this.tokenCache;
    }, e.prototype.getLogger = function () {
      return this.logger;
    }, e.prototype.setLogger = function (e) {
      this.logger = e;
    }, e.prototype.initializeWrapperLibrary = function (e, t) {
      this.browserStorage.setWrapperMetadata(e, t);
    }, e.prototype.setNavigationClient = function (e) {
      this.navigationClient = e;
    }, e.prototype.getConfiguration = function () {
      return this.config;
    }, e.prototype.getRequestCorrelationId = function (e) {
      return null != e && e.correlationId ? e.correlationId : this.isBrowserEnvironment ? this.browserCrypto.createNewGuid() : Constants.EMPTY_STRING;
    }, e;
  }(),
  PublicClientApplication = function (t) {
    function e(e) {
      e = t.call(this, e) || this;
      return e.astsAsyncMeasurement = void 0, e.activeSilentTokenRequests = new Map(), e.trackPageVisibility = e.trackPageVisibility.bind(e), e;
    }
    return __extends$g(e, t), e.prototype.loginRedirect = function (r) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t;
        return __generator$3(this, function (e) {
          return t = this.getRequestCorrelationId(r), this.logger.verbose("loginRedirect called", t), [2, this.acquireTokenRedirect(__assign$5({
            correlationId: t
          }, r || DEFAULT_REQUEST))];
        });
      });
    }, e.prototype.loginPopup = function (e) {
      var t = this.getRequestCorrelationId(e);
      return this.logger.verbose("loginPopup called", t), this.acquireTokenPopup(__assign$5({
        correlationId: t
      }, e || DEFAULT_REQUEST));
    }, e.prototype.acquireTokenSilent = function (s) {
      return __awaiter$3(this, void 0, void 0, function () {
        var t,
          r,
          n,
          i,
          o,
          a = this;
        return __generator$3(this, function (e) {
          if (t = this.getRequestCorrelationId(s), (r = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenSilent, t)).addStaticFields({
            cacheLookupPolicy: s.cacheLookupPolicy
          }), this.preflightBrowserEnvironmentCheck(InteractionType.Silent), this.logger.verbose("acquireTokenSilent called", t), o = s.account || this.getActiveAccount()) return i = {
            clientId: this.config.auth.clientId,
            authority: s.authority || Constants.EMPTY_STRING,
            scopes: s.scopes,
            homeAccountIdentifier: o.homeAccountId,
            claims: s.claims,
            authenticationScheme: s.authenticationScheme,
            resourceRequestMethod: s.resourceRequestMethod,
            resourceRequestUri: s.resourceRequestUri,
            shrClaims: s.shrClaims,
            sshKid: s.sshKid
          }, n = JSON.stringify(i), void 0 === (i = this.activeSilentTokenRequests.get(n)) ? (this.logger.verbose("acquireTokenSilent called for the first time, storing active request", t), this.performanceClient.setPreQueueTime(PerformanceEvents.AcquireTokenSilentAsync, t), o = this.acquireTokenSilentAsync(__assign$5(__assign$5({}, s), {
            correlationId: t
          }), o).then(function (e) {
            return a.activeSilentTokenRequests.delete(n), r.addStaticFields({
              accessTokenSize: e.accessToken.length,
              idTokenSize: e.idToken.length
            }), r.endMeasurement({
              success: !0,
              fromCache: e.fromCache,
              isNativeBroker: e.fromNativeBroker,
              cacheLookupPolicy: s.cacheLookupPolicy,
              requestId: e.requestId
            }), e;
          }).catch(function (e) {
            throw a.activeSilentTokenRequests.delete(n), r.endMeasurement({
              errorCode: e.errorCode,
              subErrorCode: e.subError,
              success: !1
            }), e;
          }), this.activeSilentTokenRequests.set(n, o), [2, o]) : (this.logger.verbose("acquireTokenSilent has been called previously, returning the result from the first call", t), r.discardMeasurement(), [2, i]);
          throw BrowserAuthError.createNoAccountError();
        });
      });
    }, e.prototype.trackPageVisibility = function () {
      this.astsAsyncMeasurement && (this.logger.info("Perf: Visibility change detected"), this.astsAsyncMeasurement.increment({
        visibilityChangeCount: 1
      }));
    }, e.prototype.acquireTokenSilentAsync = function (l, n) {
      var i;
      return __awaiter$3(this, void 0, void 0, function () {
        var t,
          r,
          o,
          a,
          s = this;
        return __generator$3(this, function (e) {
          switch (e.label) {
            case 0:
              return (this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenSilentAsync, l.correlationId), this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Silent, l), this.astsAsyncMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenSilentAsync, l.correlationId), null != (i = this.astsAsyncMeasurement) && i.increment({
                visibilityChangeCount: 0
              }), document.addEventListener("visibilitychange", this.trackPageVisibility), NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeExtensionProvider, l.authenticationScheme) && n.nativeAccountId) ? (this.logger.verbose("acquireTokenSilent - attempting to acquire token from native platform"), t = __assign$5(__assign$5({}, l), {
                account: n
              }), t = this.acquireTokenNative(t, ApiId.acquireTokenSilent_silentFlow).catch(function (t) {
                return __awaiter$3(s, void 0, void 0, function () {
                  return __generator$3(this, function (e) {
                    if (t instanceof NativeAuthError && t.isFatal()) return this.logger.verbose("acquireTokenSilent - native platform unavailable, falling back to web flow"), this.nativeExtensionProvider = void 0, [2, this.createSilentIframeClient(l.correlationId).acquireToken(l)];
                    throw t;
                  });
                });
              }), [3, 3]) : [3, 1];
            case 1:
              return this.logger.verbose("acquireTokenSilent - attempting to acquire token from web flow"), r = this.createSilentCacheClient(l.correlationId), this.performanceClient.setPreQueueTime(PerformanceEvents.InitializeSilentRequest, l.correlationId), [4, r.initializeSilentRequest(l, n)];
            case 2:
              o = e.sent(), a = __assign$5(__assign$5({}, l), {
                cacheLookupPolicy: l.cacheLookupPolicy || CacheLookupPolicy.Default
              }), this.performanceClient.setPreQueueTime(PerformanceEvents.AcquireTokenFromCache, o.correlationId), t = this.acquireTokenFromCache(r, o, a).catch(function (e) {
                if (a.cacheLookupPolicy === CacheLookupPolicy.AccessToken) throw e;
                return BrowserUtils.blockReloadInHiddenIframes(), s.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_NETWORK_START, InteractionType.Silent, o), s.performanceClient.setPreQueueTime(PerformanceEvents.AcquireTokenByRefreshToken, o.correlationId), s.acquireTokenByRefreshToken(o, a).catch(function (e) {
                  var t = e instanceof ServerError,
                    r = e instanceof InteractionRequiredAuthError,
                    n = e.errorCode === InteractionRequiredAuthErrorMessage.noTokensFoundError.code,
                    i = e.errorCode === BrowserConstants.INVALID_GRANT_ERROR;
                  if (t && i && !r && a.cacheLookupPolicy !== CacheLookupPolicy.AccessTokenAndRefreshToken && a.cacheLookupPolicy !== CacheLookupPolicy.RefreshToken || a.cacheLookupPolicy === CacheLookupPolicy.Skip || n) return s.logger.verbose("Refresh token expired/invalid or CacheLookupPolicy is set to Skip, attempting acquire token by iframe.", l.correlationId), s.performanceClient.setPreQueueTime(PerformanceEvents.AcquireTokenBySilentIframe, o.correlationId), s.acquireTokenBySilentIframe(o);
                  throw e;
                });
              }), e.label = 3;
            case 3:
              return [2, t.then(function (e) {
                var t;
                return s.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, e), null != (t = s.astsAsyncMeasurement) && t.endMeasurement({
                  success: !0,
                  fromCache: e.fromCache,
                  isNativeBroker: e.fromNativeBroker,
                  requestId: e.requestId
                }), e;
              }).catch(function (e) {
                var t;
                throw s.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Silent, null, e), null != (t = s.astsAsyncMeasurement) && t.endMeasurement({
                  errorCode: e.errorCode,
                  subErrorCode: e.subError,
                  success: !1
                }), e;
              }).finally(function () {
                document.removeEventListener("visibilitychange", s.trackPageVisibility);
              })];
          }
        });
      });
    }, e;
  }(ClientApplication);
function e(e) {
  this.message = e;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function (t) {
  var r = String(t).replace(/=+$/, "");
  if (r.length % 4 == 1) throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n, i, o = 0, a = 0, s = ""; i = r.charAt(a++); ~i && (n = o % 4 ? 64 * n + i : i, o++ % 4) && (s += String.fromCharCode(255 & n >> (-2 * o & 6)))) i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(i);
  return s;
};
function t(e) {
  var t = e.replace(/-/g, "+").replace(/_/g, "/");
  switch (t.length % 4) {
    case 0:
      break;
    case 2:
      t += "==";
      break;
    case 3:
      t += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return decodeURIComponent(r(t).replace(/(.)/g, function (e, t) {
      t = t.charCodeAt(0).toString(16).toUpperCase();
      return "%" + (t = t.length < 2 ? "0" + t : t);
    }));
  } catch (e) {
    return r(t);
  }
}
function n(e) {
  this.message = e;
}
function o(e, r) {
  if ("string" != typeof e) throw new n("Invalid token specified");
  r = !0 === (r = r || {}).header ? 0 : 1;
  try {
    return JSON.parse(t(e.split(".")[r]));
  } catch (e) {
    throw new n("Invalid token specified: " + e.message);
  }
}
n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
var AuthenticationManager = function () {
    function a(e) {
      var i = this,
        t = (this.fallbackStorage = {}, this._triggerTokenFetch = function (e) {
          return void 0 === e && (e = !1), new Promise(function (r, n) {
            "function" != typeof i.options.getToken ? n(new Error("Token cannot be ".concat(e ? "fetched" : "renewed", " because getToken was not set or is not a function."))) : i.options.getToken(function (e) {
              try {
                var t = i._getTokenExpiry(e) - a.constants.tokenRefreshClockSkew;
                i._storeToken(e), i._setTimeoutTokenFetch(t), r();
              } catch (e) {
                n(new Error("Invalid token returned by getToken function"));
              }
            }, function (e) {
              n(e);
            }, i.map);
          });
        }, this._setTimeoutTokenFetch = function (e) {
          clearTimeout(i.tokenTimeOutHandle), i.tokenTimeOutHandle = setTimeout(i._triggerTokenFetch, Math.min(1e3 * e, 2147483647));
        }, e.getServiceOptions());
      this.options = t.authOptions, this.sessionId = t.sessionId, this.map = e;
    }
    return a.prototype.initialize = function () {
      var n = this;
      return this.initPromise || (this.initPromise = new Promise(function (e, t) {
        if (n.options.authType === AuthenticationType.subscriptionKey) e();else if (n.options.authType === AuthenticationType.aad) n.options.authContext = n.options.authContext || a.getDefaultAuthContext(n.options), n.options.authContext.handleRedirectPromise().then(function () {
          setTimeout(function () {
            return n._loginAndAcquireTokenForAAD(e, t);
          });
        }).catch(function (e) {
          t(new Error("Error logging in the AAD users: " + e));
        });else if (n.options.authType === AuthenticationType.anonymous) e(n._triggerTokenFetch(!0));else if (n.options.authType === AuthenticationType.sas) {
          if (n.options.sasToken) {
            var r = -1;
            try {
              r = n._getTokenExpiry(n.options.sasToken);
            } catch (e) {
              return void t(new Error("An invalid sasToken was provided."));
            }
            if (r > a.constants.tokenRefreshClockSkew) return n._storeToken(n.options.sasToken), n._setTimeoutTokenFetch(r - a.constants.tokenRefreshClockSkew), void e();
          }
          e(n._triggerTokenFetch());
        } else t(new Error("An invalid authentication type was specified."));
      })), this.initPromise;
    }, a.prototype.dispose = function () {
      this.tokenTimeOutHandle && (clearTimeout(this.tokenTimeOutHandle), this.tokenTimeOutHandle = null);
    }, a.getDefaultAuthContext = function (e) {
      if (!e.aadAppId) throw new Error("No AAD app ID was specified.");
      if (e.aadTenant) return this.defaultAuthContext || (this.defaultAuthContext = new PublicClientApplication({
        auth: {
          authority: "".concat(e.aadInstance || env.aadInstance).concat(e.aadTenant),
          clientId: e.aadAppId
        },
        cache: {
          cacheLocation: this.constants.preferredCacheLocation
        }
      })), this.defaultAuthContext;
      throw new Error("No AAD tenant was specified.");
    }, a.prototype._loginAndAcquireTokenForAAD = function (e, t) {
      var r = (null == (r = this.options.authContext) ? void 0 : r.getAllAccounts()) || [];
      0 === r.length ? (this.options.authContext.loginRedirect(), e()) : (this.options.authContext.setActiveAccount(r[0]), this._acquireTokenForAAD(e, t));
    }, a.prototype._acquireTokenForAAD = function (r, t) {
      var n = this,
        i = {
          scopes: [constants.aadResourceId]
        };
      this.options.authContext.acquireTokenSilent(i).then(function (e) {
        n._saveItem(a.constants.storage.tokenKey, e.accessToken);
        var t = {
            map: n.map,
            type: a.constants.events.tokenAcquired
          },
          t = (n.map.events.invoke(a.constants.events.tokenAcquired, t), clearTimeout(n.tokenTimeOutHandle), new Date(e.expiresOn).getTime() - Date.now());
        n.tokenTimeOutHandle = setTimeout(function () {
          return n._acquireTokenForAAD();
        }, t), null != r && r();
      }).catch(function (e) {
        if (e instanceof InteractionRequiredAuthError) return n.options.authContext.acquireTokenRedirect(i), null == r ? void 0 : r();
        null != t && t(e);
      });
    }, a.prototype.getAuthType = function () {
      return this.options.authType;
    }, a.prototype.getClientId = function () {
      return this.options.clientId;
    }, a.prototype.getToken = function () {
      if (this.options.authType === AuthenticationType.aad) return this._getItem(a.constants.storage.tokenKey);
      if (this.options.authType !== AuthenticationType.anonymous && this.options.authType !== AuthenticationType.sas) return this.options.authType === AuthenticationType.subscriptionKey ? this.options.subscriptionKey : void 0;
      var e = this._getItem(a.constants.storage.tokenKey);
      if (e) {
        var t = this._getTokenExpiry(e);
        if (t < 300 && 0 < t) this._triggerTokenFetch();else if (t <= 0) throw this._saveItem(a.constants.storage.tokenKey, ""), new Error(a.constants.errors.tokenExpired);
      } else this._triggerTokenFetch();
      return e;
    }, a.prototype._getTokenExpiry = function (e) {
      var e = o(e).exp,
        t = this._getCurrentTime();
      return 0 < e - t ? e - t : -1;
    }, a.prototype._storeToken = function (e) {
      this._saveItem(a.constants.storage.tokenKey, e);
      e = {
        map: this.map,
        type: a.constants.events.tokenAcquired
      };
      this.map.events.invoke(a.constants.events.tokenAcquired, e);
    }, a.prototype._saveItem = function (e, t) {
      return this._supportsLocalStorage() ? localStorage.setItem(e, t) : this._supportsSessionStorage() ? sessionStorage.setItem(e, t) : this.fallbackStorage[e] = t, !0;
    }, a.prototype._getItem = function (e) {
      return this._supportsLocalStorage() ? localStorage.getItem(e) : this._supportsSessionStorage() ? sessionStorage.getItem(e) : e in this.fallbackStorage ? this.fallbackStorage[e] : null;
    }, a.prototype._supportsLocalStorage = function () {
      try {
        return window.localStorage ? (window.localStorage.setItem(a.constants.storage.testStorageKey, "A"), "A" === window.localStorage.getItem(a.constants.storage.testStorageKey) && (window.localStorage.removeItem(a.constants.storage.testStorageKey), !window.localStorage.getItem(a.constants.storage.testStorageKey))) : !1;
      } catch (e) {
        return !1;
      }
    }, a.prototype._supportsSessionStorage = function () {
      try {
        return window.sessionStorage ? (window.sessionStorage.setItem(a.constants.storage.testStorageKey, "A"), "A" === window.sessionStorage.getItem(a.constants.storage.testStorageKey) && (window.sessionStorage.removeItem(a.constants.storage.testStorageKey), !window.sessionStorage.getItem(a.constants.storage.testStorageKey))) : !1;
      } catch (e) {
        return !1;
      }
    }, a.prototype._getCurrentTime = function () {
      return Math.round(new Date().getTime() / 1e3);
    }, a.prototype.signRequest = function (e) {
      e.headers = e.headers || {}, e.headers[constants.sessionIdHeaderName] = this.sessionId, e.headers[constants.msOriginHeaderName] = constants.msOriginHeaderValue, e.headers[constants.mapAgentHeaderName] = "MapControl/".concat(version$3, " (Web)");
      var t = this.getToken();
      switch (this.options.authType) {
        case AuthenticationType.aad:
        case AuthenticationType.anonymous:
          e.headers[constants.msClientIdHeaderName] = this.options.clientId, e.headers[constants.authorizationHeaderName] = constants.authorizationTokenPrefix + t;
          break;
        case AuthenticationType.sas:
          e.headers[constants.authorizationHeaderName] = constants.jwtSasPrefix + t;
          break;
        case AuthenticationType.subscriptionKey:
          e.headers["subscription-key"] = t;
          break;
        default:
          throw new Error("An invalid authentication type was specified");
      }
      return e;
    }, a.constants = {
      preferredCacheLocation: "localStorage",
      storage: {
        tokenKey: "access.token.key",
        testStorageKey: "testStorage"
      },
      events: {
        tokenAcquired: "tokenacquired"
      },
      tokenExpiresIn: 3599,
      tokenRefreshClockSkew: 300,
      errors: {
        tokenExpired: "Token Expired, Try again"
      }
    }, a;
  }(),
  __values$c = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  ControlManager = function () {
    function e(e) {
      for (var t in this.map = e, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add("atlas-control-container"), ControlPosition) {
        var r;
        ControlPosition.hasOwnProperty(t) && ((r = document.createElement("div")).classList.add(ControlPosition[t]), r.classList.add("subcontrol-container"), this.controlContainer.appendChild(r));
      }
      this.map.getMapContainer().appendChild(this.controlContainer), this.controls = new Set();
    }
    return e.prototype.add = function (e, t) {
      var r, n;
      if (Array.isArray(e)) try {
        for (var i = __values$c(e), o = i.next(); !o.done; o = i.next()) {
          var a = o.value;
          this._add(a, t);
        }
      } catch (e) {
        r = {
          error: e
        };
      } finally {
        try {
          o && !o.done && (n = i.return) && n.call(i);
        } finally {
          if (r) throw r.error;
        }
      } else this._add(e, t);
    }, e.prototype.getControls = function () {
      return Array.from(this.controls);
    }, e.prototype.remove = function (e) {
      var t, r;
      if (Array.isArray(e)) try {
        for (var n = __values$c(e), i = n.next(); !i.done; i = n.next()) {
          var o = i.value;
          this._remove(o);
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n);
        } finally {
          if (t) throw t.error;
        }
      } else this._remove(e);
    }, e.prototype._add = function (e, t) {
      this.controls.add(e);
      var r = new ControlOptions().merge(t),
        e = e.onAdd(this.map, t),
        t = this.controlContainer.getElementsByClassName(r.position);
      if (!(0 < t.length)) throw new Error("Control position ".concat(r.position, " does not exist."));
      t.item(0).appendChild(e);
    }, e.prototype._remove = function (e) {
      e.onRemove(), this.controls.delete(e);
    }, e;
  }(),
  __assign$3 = window && window.__assign || function () {
    return (__assign$3 = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      return e;
    }).apply(this, arguments);
  },
  MapCallbackHandler = function () {
    function e(e) {
      this.callbacks = new Dictionary(), this.map = e;
    }
    return e.prototype.addCallback = function (a, s, l, e, c) {
      var t,
        u,
        h = this;
      if (e) t = function (e) {
        var t = e.lngLat ? new Position(e.lngLat.lng, e.lngLat.lat) : void 0,
          r = e.point ? [e.point.x, e.point.y] : void 0,
          n = e.features ? e.features.map(function (e) {
            return new Feature(e.geometry, e.properties, e.id);
          }) : [],
          e = {
            type: e.type,
            originalEvent: e.originalEvent,
            position: t,
            coordinate: r,
            features: n
          };
        l(e);
      };else switch (a) {
        case "data":
        case "sourcedata":
        case "styledata":
          t = function (e) {
            e = __assign$3(__assign$3({
              dataType: e.dataType
            }, "source" === e.dataType && __assign$3(__assign$3(__assign$3({
              isSourceLoaded: e.isSourceLoaded
            }, e.sourceDataType && {
              sourceDataType: e.sourceDataType
            }), {
              source: h.map.sources.getById(e.sourceId)
            }), e.tile && {
              tile: {
                id: {
                  x: e.tile.tileID.canonical.x,
                  y: e.tile.tileID.canonical.y,
                  z: e.tile.tileID.canonical.z
                },
                size: e.tile.tileSize,
                state: e.tile.state
              }
            })), {
              map: h.map,
              type: e.type
            });
            c && h.map.events._removeListener(a, s, l), l(e);
          };
          break;
        case "error":
          t = function (e) {
            e = {
              error: e.error,
              map: h.map,
              type: e.type
            };
            c && h.map.events._removeListener(a, s, l), l(e);
          };
          break;
        case "touchstart":
        case "touchend":
        case "touchmove":
        case "touchcancel":
          t = function (e) {
            if (e.originalEvent) {
              if (e.originalEvent === u) return;
              u = e.originalEvent;
            }
            var t = e.point ? new Pixel(e.point.x, e.point.y) : void 0,
              r = e.points ? e.points.map(function (e) {
                return new Pixel(e.x, e.y);
              }) : [],
              n = e.lngLat ? new Position(e.lngLat.lng, e.lngLat.lat) : void 0,
              i = e.lngLats ? e.lngLats.map(function (e) {
                return new Position(e.lng, e.lat);
              }) : [],
              o = n ? h.map.layers.getRenderedShapes(new Point(n), s ? [s] : void 0) : [],
              t = {
                map: h.map,
                originalEvent: e.originalEvent,
                pixel: t,
                pixels: r,
                position: n,
                positions: i,
                shapes: o,
                layerId: s || void 0,
                preventDefault: function () {
                  return e.preventDefault();
                },
                type: e.type
              };
            c && h.map.events._removeListener(a, s, l), l(t);
          };
          break;
        case "mousedown":
        case "mouseup":
        case "mouseover":
        case "mousemove":
        case "click":
        case "dblclick":
        case "mouseout":
        case "mouseenter":
        case "mouseleave":
        case "contextmenu":
          t = function (e) {
            if (e.originalEvent) {
              if (e.originalEvent === u) return;
              u = e.originalEvent;
            }
            var t = e.lngLat ? new Position(e.lngLat.lng, e.lngLat.lat) : void 0,
              r = e.point ? new Pixel(e.point.x, e.point.y) : void 0,
              n = t ? h.map.layers.getRenderedShapes(new Point(t), s ? [s] : void 0) : [],
              t = {
                map: h.map,
                originalEvent: e.originalEvent,
                position: t,
                pixel: r,
                preventDefault: function () {
                  return e.preventDefault();
                },
                shapes: n,
                layerId: s || void 0,
                type: e.type
              };
            c && h.map.events._removeListener(a, s, l), l(t);
          };
          break;
        case "styleimagemissing":
          t = function (e) {
            c && h.map.events._removeListener(a, s, l), l(e.id);
          };
          break;
        case "wheel":
          t = function (e) {
            if (e.originalEvent) {
              if (e.originalEvent === u) return;
              u = e.originalEvent;
            }
            var t = {
              map: h.map,
              originalEvent: e.originalEvent,
              preventDefault: function () {
                return e.preventDefault();
              },
              type: e.type
            };
            c && h.map.events._removeListener(a, s, l), l(t);
          };
          break;
        case "resize":
          t = function (e) {
            var t,
              r = {
                map: h.map,
                type: e.type
              };
            for (t in e) "type" !== t && "target" !== t && (r[t] = e[t]);
            c && h.map.events._removeListener(a, s, l), l(r);
          };
          break;
        default:
          t = function (e) {
            var t = {
              map: h.map,
              type: e.type
            };
            e.originalEvent && (t.originalEvent = e.originalEvent), c && h.map.events._removeListener(a, s, l), l(t);
          };
      }
      this.callbacks.has(s) || this.callbacks.set(s, new Dictionary()), this.callbacks.get(s).has(a) || this.callbacks.get(s).set(a, new Map()), this.callbacks.get(s).get(a).set(l, [t, c]);
    }, e.prototype.removeCallback = function (e, t, r) {
      this.callbacks.has(t) && this.callbacks.get(t).has(e) && this.callbacks.get(t).get(e).has(r) && this.callbacks.get(t).get(e).delete(r);
    }, e.prototype.getModifiedCallback = function (e, t, r) {
      if (this.callbacks.has(t) && this.callbacks.get(t).has(e) && this.callbacks.get(t).get(e).has(r)) return this.callbacks.get(t).get(e).get(r)[0];
    }, e.prototype.getLayerCallbacks = function (e) {
      if (this.callbacks.has(e)) return this.callbacks.get(e);
    }, e.prototype.getEventCallbacks = function (e, t) {
      if (this.callbacks.has(t)) {
        t = this.callbacks.get(t);
        if (t.has(e)) return t.get(e);
      }
    }, e;
  }(),
  __values$b = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  __read$7 = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  MAP_CLIENT_EVENTS = ["maxzoomchanged", "minzoomchanged", "mapconfigurationchanged"],
  EventManager = function () {
    function e(e) {
      this.map = e, this.mapCallbackHandler = new MapCallbackHandler(this.map);
    }
    return e.prototype.add = function (e, t, r) {
      var n, i;
      if ("function" == typeof t) this._addGlobalListener(e, t, !1, !1);else {
        t = Array.isArray(t) ? t : [t];
        try {
          for (var o = __values$b(t), a = o.next(); !a.done; a = o.next()) {
            var s = a.value;
            s instanceof Layer && Layer._isMBoxEvent(e) ? this._addLayerListener(e, s, r, !1, !1) : s._addEventListener(e, r, !1);
          }
        } catch (e) {
          n = {
            error: e
          };
        } finally {
          try {
            a && !a.done && (i = o.return) && i.call(o);
          } finally {
            if (n) throw n.error;
          }
        }
      }
    }, e.prototype.addOnce = function (e, t, r) {
      "function" == typeof t ? this._addGlobalListener(e, t, !1, !0) : t instanceof Layer && Layer._isMBoxEvent(e) ? this._addLayerListener(e, t, r, !1, !0) : t._addEventListener(e, r, !0);
    }, e.prototype._addLegacy = function (e, t, r) {
      "function" == typeof t ? this._addGlobalListener(e, t, !0, !1) : this._addLayerListener(e, t, r, !0, !1);
    }, e.prototype._addLayerListener = function (e, t, r, n, i) {
      var o,
        a,
        s,
        l,
        t = t instanceof Layer ? t.getId() : t,
        c = this.map.layers.getLayerById(t),
        u = this.mapCallbackHandler.getModifiedCallback(e, t, r);
      if (u && c) try {
        for (var h = __values$b(c._getLayerIds()), d = h.next(); !d.done; d = h.next()) {
          var p = d.value;
          this.map._getMap().off(e, p, u);
        }
      } catch (e) {
        o = {
          error: e
        };
      } finally {
        try {
          d && !d.done && (a = h.return) && a.call(h);
        } finally {
          if (o) throw o.error;
        }
      }
      if (this.mapCallbackHandler.addCallback(e, t, r, n, i), c) {
        u = this.mapCallbackHandler.getModifiedCallback(e, t, r);
        try {
          for (var f = __values$b(c._getLayerIds()), _ = f.next(); !_.done; _ = f.next()) {
            p = _.value;
            this.map._getMap().on(e, p, u);
          }
        } catch (e) {
          s = {
            error: e
          };
        } finally {
          try {
            _ && !_.done && (l = f.return) && l.call(f);
          } finally {
            if (s) throw s.error;
          }
        }
      }
    }, e.prototype._addGlobalListener = function (e, t, r, n) {
      var i, o, a, s;
      MAP_CLIENT_EVENTS.includes(e) ? this.map._addEventListener(e, t, n) : (i = this.mapCallbackHandler.getModifiedCallback(e, "", t), this.mapCallbackHandler.addCallback(e, "", t, r, n), o = this.mapCallbackHandler.getModifiedCallback(e, "", t), "load" === e && this.map._isLoaded() ? (a = {
        type: "load",
        map: this.map
      }, setTimeout(function () {
        return o(a);
      })) : "ready" === e ? this.map._isReady() && (s = {
        type: "ready",
        map: this.map
      }, setTimeout(function () {
        return o(s);
      })) : (i && this.map._getMap().off(e, i), this.map._getMap().on(e, o)));
    }, e.prototype.invoke = function (e, t, r) {
      if (void 0 === r) this._invokeListeners(e, "", t);else if (t instanceof Layer && Layer._isMBoxEvent(e)) this._invokeListeners(e, t.getId(), r);else {
        if (!(t instanceof EventEmitter)) throw new Error("The invoke target is invalid.");
        t._invokeEvent(e, r);
      }
    }, e.prototype._invokeListeners = function (r, n, i) {
      var o = this,
        e = new Dictionary(this.mapCallbackHandler.getEventCallbacks(r, n));
      e ? e.forEach(function (e, t) {
        e = __read$7(e, 2);
        e[0], e[1] && o._removeListener(r, n, t), t(i);
      }) : "error" === r && console.error("error" in i ? i.error : i);
    }, e.prototype.remove = function (e, t, r) {
      var n, i;
      if ("function" == typeof t) this._removeListener(e, "", t);else {
        t = Array.isArray(t) ? t : [t];
        try {
          for (var o = __values$b(t), a = o.next(); !a.done; a = o.next()) {
            var s = a.value;
            s instanceof Layer && Layer._isMBoxEvent(e) ? this._removeListener(e, s, r) : null != s && s._removeEventListener(e, r);
          }
        } catch (e) {
          n = {
            error: e
          };
        } finally {
          try {
            a && !a.done && (i = o.return) && i.call(o);
          } finally {
            if (n) throw n.error;
          }
        }
      }
    }, e.prototype._removeLegacy = function (e, t, r) {
      "function" == typeof t ? this._removeListener(e, "", t) : this._removeListener(e, t, r);
    }, e.prototype._removeListener = function (e, t, r) {
      var n, i;
      if (MAP_CLIENT_EVENTS.includes(e)) this.map._removeEventListener(e, r);else {
        var t = t instanceof Layer ? t.getId() : t,
          o = this.mapCallbackHandler.getModifiedCallback(e, t, r);
        if (o) if (t) {
          var a = this.map.layers.getLayerById(t);
          if (a) try {
            for (var s = __values$b(a._getLayerIds()), l = s.next(); !l.done; l = s.next()) {
              var c = l.value;
              this.map._getMap().off(e, c, o);
            }
          } catch (e) {
            n = {
              error: e
            };
          } finally {
            try {
              l && !l.done && (i = s.return) && i.call(s);
            } finally {
              if (n) throw n.error;
            }
          }
        } else this.map._getMap().off(e, o);
        this.mapCallbackHandler.removeCallback(e, t, r);
      }
    }, e.prototype._enableLayerEvents = function (l) {
      var c = this,
        e = this.mapCallbackHandler.getLayerCallbacks(l.getId());
      e && e.forEach(function (e, s) {
        e.forEach(function (e) {
          var t,
            r,
            n = __read$7(e, 1)[0];
          try {
            for (var i = __values$b(l._getLayerIds()), o = i.next(); !o.done; o = i.next()) {
              var a = o.value;
              c.map._getMap().on(s, a, n);
            }
          } catch (e) {
            t = {
              error: e
            };
          } finally {
            try {
              o && !o.done && (r = i.return) && r.call(i);
            } finally {
              if (t) throw t.error;
            }
          }
        });
      });
    }, e.prototype._disableLayerEvents = function (l) {
      var c = this,
        e = this.mapCallbackHandler.getLayerCallbacks(l.getId());
      e && e.forEach(function (e, s) {
        e.forEach(function (e) {
          var t,
            r,
            n = __read$7(e, 1)[0];
          try {
            for (var i = __values$b(l._getLayerIds()), o = i.next(); !o.done; o = i.next()) {
              var a = o.value;
              c.map._getMap().off(s, a, n);
            }
          } catch (e) {
            t = {
              error: e
            };
          } finally {
            try {
              o && !o.done && (r = i.return) && r.call(i);
            } finally {
              if (t) throw t.error;
            }
          }
        });
      });
    }, e;
  }(),
  __values$a = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  HtmlMarkerManager = function () {
    function e(e) {
      this.markers = new Set(), this.map = e;
    }
    return e.prototype.add = function (e, t) {
      var r, n;
      if (Array.isArray(e)) try {
        for (var i = __values$a(e), o = i.next(); !o.done; o = i.next()) {
          var a = o.value;
          this._addMarker(a, t);
        }
      } catch (e) {
        r = {
          error: e
        };
      } finally {
        try {
          o && !o.done && (n = i.return) && n.call(i);
        } finally {
          if (r) throw r.error;
        }
      } else this._addMarker(e, t);
    }, e.prototype._addMarker = function (e, t) {
      e._addToMap(this.map, t), this.markers.add(e);
    }, e.prototype.getMarkers = function () {
      return Array.from(this.markers);
    }, e.prototype.remove = function (e) {
      var t, r;
      if (Array.isArray(e)) try {
        for (var n = __values$a(e), i = n.next(); !i.done; i = n.next()) {
          var o = i.value;
          this._removeMarker(o);
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n);
        } finally {
          if (t) throw t.error;
        }
      } else this._removeMarker(e);
    }, e.prototype._removeMarker = function (t) {
      var r = this;
      t instanceof HtmlMarker ? (t._removeFromMap(), this.markers.delete(t)) : this.markers.forEach(function (e) {
        e._getId() === t && (e._removeFromMap(), r.markers.delete(e));
      });
    }, e.prototype.clear = function () {
      var t = this;
      this.markers.forEach(function (e) {
        e._removeFromMap(), t.markers.delete(e);
      });
    }, e;
  }(),
  ImageSpriteManager = function () {
    function e(e) {
      this.userImages = new Dictionary(), this.imageLoadTimeout = 5e3, this.map = e;
    }
    return e.prototype.add = function (a, t, s) {
      var l = this;
      return new Promise(function (r, n) {
        var i, e, o;
        l.userImages.has(a) ? r() : t instanceof HTMLImageElement || t instanceof ImageData ? (l.map._getMap().addImage(a, t, s), l.userImages.set(a, {
          image: t,
          meta: s
        }), r()) : "string" == typeof t && (e = void 0, e = /<svg/i.test(t) && !/^data:/i.test(t) ? "data:image/svg+xml;base64," + window.btoa(t) : t, o = !1, l.map._sendRequest(e, "Image").then(function (e) {
          return o ? void 0 : e.blob();
        }).then(function (e) {
          var t;
          !o && e && (clearTimeout(i), (t = new Image()).onload = function () {
            l.map._getMap().addImage(a, t, s), l.userImages.set(a, {
              image: t,
              meta: s
            }), r();
          }, t.onerror = t.onabort = function () {
            n("Failed to load image into HTML element.");
          }, t.src = URL.createObjectURL(e));
        }).catch(function () {
          o || (clearTimeout(i), n("Failed to load image into HTML element."));
        }), i = setTimeout(function () {
          o = !0, n("Failed to load image within specified timeout: ".concat(l.imageLoadTimeout, " ms."));
        }, l.imageLoadTimeout));
      });
    }, e.prototype.clear = function () {
      var r = this;
      this.userImages.forEach(function (e, t) {
        r.map._getMap().removeImage(t);
      }), this.userImages.clear();
    }, e.prototype.getImageIds = function () {
      var r = [];
      return this.userImages.forEach(function (e, t) {
        r.push(t);
      }), r;
    }, e.prototype.createFromTemplate = function (e, t, r, n, i) {
      r = r || "#1A73AA", n = n || "#fff";
      t = (t = getImageTemplate(t, i)).replace(/{color}/g, r).replace(/{secondaryColor}/g, n).replace(/{text}/g, "");
      return this.add(e, t);
    }, e.prototype.hasImage = function (e) {
      return this.userImages.has(e);
    }, e.prototype.remove = function (e) {
      this.map._getMap().removeImage(e), this.userImages.delete(e);
    }, e.prototype._restoreImages = function () {
      var r = this;
      this.userImages.forEach(function (e, t) {
        r.map._getMap().hasImage(t) || r.map._getMap().addImage(t, e.image, e.meta);
      });
    }, e;
  }(),
  __extends$e = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __values$9 = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  FundamentalMapLayer = function (r) {
    function e(e, t) {
      t = r.call(this, t) || this;
      return t.layers = e, t;
    }
    return __extends$e(e, r), e.prototype._buildLayers = function () {
      return this.layers;
    }, e.prototype._getLayerIds = function () {
      return this.layers.map(function (e) {
        return e.id;
      });
    }, e.prototype._getSourceIds = function () {
      var t,
        e,
        r = new Set();
      try {
        for (var n = __values$9(this.layers), i = n.next(); !i.done; i = n.next()) {
          var o = i.value;
          "source" in o && "string" == typeof o.source ? r.add(o.source) : "source" in o && o.source && r.add(o.id);
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          i && !i.done && (e = n.return) && e.call(n);
        } finally {
          if (t) throw t.error;
        }
      }
      return r;
    }, e.prototype._updateLayoutProperty = function (t, r, e, n) {
      var i;
      isEqual$1(r, e) || (i = this.map._getMap(), this.layers.forEach(function (e) {
        i.getLayer(e.id) ? i.setLayoutProperty(e.id, t, n || r) : console.warn("Could not update layout property ".concat(t, " for layer ").concat(e.id, " to ").concat(n || r));
      }));
    }, e;
  }(Layer),
  __values$8 = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  __read$6 = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  __spreadArray$6 = window && window.__spreadArray || function (e, t, r) {
    if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++) !n && i in t || ((n = n || Array.prototype.slice.call(t, 0, i))[i] = t[i]);
    return e.concat(n || Array.prototype.slice.call(t));
  },
  LayerManager = function () {
    function e(e) {
      this.layerIndex = [], this.userLayers = [], this.map = e;
    }
    return e.prototype.add = function (e, t) {
      var r,
        n,
        i = t instanceof Layer ? t.getId() : t;
      if (Array.isArray(e)) try {
        for (var o = __values$8(e), a = o.next(); !a.done; a = o.next()) {
          var s = a.value;
          this._addLayer(s, i);
        }
      } catch (e) {
        r = {
          error: e
        };
      } finally {
        try {
          a && !a.done && (n = o.return) && n.call(o);
        } finally {
          if (r) throw r.error;
        }
      } else this._addLayer(e, i);
    }, e.prototype._addLayer = function (t, r) {
      if (!(this.map._isReady() || t instanceof FundamentalMapLayer)) throw new Error("The layer '".concat(t.getId(), "' could not be added to the map because ") + "the map is not ready. Please use a ready event listener to guarantee the map is ready before adding a layer to it.");
      var e, n, i, o;
      r !== t.getId() && this.layerIndex.find(function (e) {
        return r === e.getId();
      }) ? this._getMapboxLayerExists(t) ? (n = this.layerIndex.findIndex(function (e) {
        return e.getId() === t.getId();
      }), i = this.userLayers.findIndex(function (e) {
        return e.layer.getId() === t.getId();
      }), this._removeMapboxLayers(t), this._addMapboxLayers(t, r), (o = this.layerIndex[n]) && this.map.events._disableLayerEvents(o), this.map.events._enableLayerEvents(t), this.layerIndex.splice(n, 1), e = this.layerIndex.findIndex(function (e) {
        return e.getId() === r;
      }), this.layerIndex.splice(e, 0, t), t instanceof FundamentalMapLayer || (this.userLayers[i] = {
        layer: t,
        before: r
      }), o && o.onRemove()) : (this._addMapboxLayers(t, r), this.map.events._enableLayerEvents(t), e = this.layerIndex.findIndex(function (e) {
        return e.getId() === r;
      }), this.layerIndex.splice(e, 0, t), t instanceof FundamentalMapLayer || this.userLayers.push({
        layer: t,
        before: r
      })) : (n = this.layerIndex.findIndex(function (e) {
        return e.getId() === t.getId();
      }), i = this.userLayers.findIndex(function (e) {
        return e.layer.getId() === t.getId();
      }), 0 <= n && 0 <= i ? (o = this.layerIndex[n], this._removeMapboxLayers(o), this._addMapboxLayers(t, n + 1), this.map.events._disableLayerEvents(o), this.map.events._enableLayerEvents(t), (this.layerIndex[n] = t) instanceof FundamentalMapLayer || (this.userLayers[i] = {
        layer: t,
        before: void 0
      }), o.onRemove()) : (this._addMapboxLayers(t), this.map.events._enableLayerEvents(t), this.layerIndex.push(t), t instanceof FundamentalMapLayer || this.userLayers.push({
        layer: t,
        before: r
      }))), t.onAdd(this.map);
    }, e.prototype._addMapboxLayers = function (e, t) {
      var r, n;
      if (!(e instanceof TileLayer) || e.getOptions().tileUrl) {
        if (!(e instanceof FundamentalMapLayer)) {
          e instanceof SourceBuildingLayer && (this.map._getMap().addSource(e._getSourceId(), e._buildSource()), this.map.sources.setSourceState(e._getSourceWrapper()));
          var i = this._getMapboxBefore(t);
          try {
            for (var o = __values$8(e._buildLayers()), a = o.next(); !a.done; a = o.next()) {
              var s = a.value;
              this.map._getMap().addLayer(s, i);
            }
          } catch (e) {
            r = {
              error: e
            };
          } finally {
            try {
              a && !a.done && (n = o.return) && n.call(o);
            } finally {
              if (r) throw r.error;
            }
          }
        }
        this.map.events._enableLayerEvents(e);
      }
    }, e.prototype._removeMapboxLayers = function (e, t) {
      var r, n;
      if (e instanceof FundamentalMapLayer && !t) this.map.events._disableLayerEvents(e);else {
        try {
          for (var i = __values$8(e._getLayerIds()), o = i.next(); !o.done; o = i.next()) {
            var a = o.value;
            this.map._getMap().getLayer(a) && this.map._getMap().removeLayer(a);
          }
        } catch (e) {
          r = {
            error: e
          };
        } finally {
          try {
            o && !o.done && (n = i.return) && n.call(i);
          } finally {
            if (r) throw r.error;
          }
        }
        this.map.events._disableLayerEvents(e), e instanceof SourceBuildingLayer && this.map._getMap().getSource(e._getSourceId()) && this.map._getMap().removeSource(e._getSourceId());
      }
    }, e.prototype._getMapboxLayerExists = function (t) {
      var r = this,
        n = !1;
      return "string" == typeof t ? !!(t = this.layerIndex.find(function (e) {
        return e.getId() === t;
      })) : (t._getLayerIds().forEach(function (e) {
        r.map._getMap().getLayer(e) && (n = !0);
      }), n);
    }, e.prototype._getMapboxBefore = function (t) {
      var r, e, n, i;
      if ("string" == typeof t) {
        var o = this.layerIndex.find(function (e) {
          return e.getId() === t;
        });
        if (!o) return;
        try {
          for (var a = __values$8(o._getLayerIds()), s = a.next(); !s.done; s = a.next()) {
            var l = s.value;
            if (this.map._getMap().getLayer(l)) return l;
          }
        } catch (e) {
          r = {
            error: e
          };
        } finally {
          try {
            s && !s.done && (e = a.return) && e.call(a);
          } finally {
            if (r) throw r.error;
          }
        }
        t = this.layerIndex.findIndex(function (e) {
          return e.getId() === t;
        }) + 1;
      }
      for (var c = t; c < this.layerIndex.length; c++) try {
        n = void 0;
        for (var u = __values$8(this.layerIndex[c]._getLayerIds()), h = u.next(); !h.done; h = u.next()) {
          l = h.value;
          if (this.map._getMap().getLayer(l)) return l;
        }
      } catch (e) {
        n = {
          error: e
        };
      } finally {
        try {
          h && !h.done && (i = u.return) && i.call(u);
        } finally {
          if (n) throw n.error;
        }
      }
    }, e.prototype.clear = function () {
      for (var e = this.layerIndex.length - 1; 0 <= e; e--) {
        var t = this.layerIndex[e];
        t && (this._removeMapboxLayers(t, !0), this.layerIndex.splice(e, 1), t.onRemove());
      }
      this.userLayers = [];
    }, e.prototype.getLayerById = function (t) {
      var e = this.layerIndex.find(function (e) {
        return e.getId() === t;
      });
      if (e) return e;
    }, e.prototype.getLayers = function () {
      return this.layerIndex.slice(0);
    }, e.prototype._getSourceIds = function () {
      var t,
        e,
        r = new Set();
      try {
        for (var n = __values$8(this.layerIndex), i = n.next(); !i.done; i = n.next()) i.value._getSourceIds().forEach(function (e) {
          return r.add(e);
        });
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          i && !i.done && (e = n.return) && e.call(n);
        } finally {
          if (t) throw t.error;
        }
      }
      return r;
    }, e.prototype._getUserLayers = function () {
      return Array.from(this.userLayers);
    }, e.prototype.move = function (e, t) {
      var r = e instanceof Layer ? e.getId() : e,
        n = t instanceof Layer ? t.getId() : t;
      if (!this.layerIndex.find(function (e) {
        return e.getId() === r;
      })) throw new Error("The layer '".concat(r, "' has not been added to the map and cannot be moved."));
      t = this.layerIndex.findIndex(function (e) {
        return e.getId() === r;
      }), this._moveMapboxLayers(this.layerIndex[t], n), e = this.layerIndex[t], this.layerIndex.splice(t, 1), t = this.layerIndex.findIndex(function (e) {
        return e.getId() === n;
      }), -1 < t ? this.layerIndex.splice(t, 0, e) : this.layerIndex.push(e), t = this.userLayers.find(function (e) {
        return e.layer.getId() === r;
      });
      t && (t.before = n);
    }, e.prototype._moveMapboxLayers = function (e, t) {
      var r,
        n,
        i = this._getMapboxBefore(t);
      try {
        for (var o = __values$8(e._getLayerIds()), a = o.next(); !a.done; a = o.next()) {
          var s = a.value;
          this.map._getMap().moveLayer(s, i);
        }
      } catch (e) {
        r = {
          error: e
        };
      } finally {
        try {
          a && !a.done && (n = o.return) && n.call(o);
        } finally {
          if (r) throw r.error;
        }
      }
    }, e.prototype.getRenderedShapes = function (e, t, r) {
      var n,
        i,
        o,
        a = this;
      if (e = e || [-180, -85.0511, 180, 85.0511], Array.isArray(e) ? 4 === e.length || 6 === e.length ? o = this.map.positionsToPixels([BoundingBox.getSouthWest(e), BoundingBox.getNorthEast(e)]) : 2 !== e.length && 3 !== e.length || (o = this.map.positionsToPixels([e])[0]) : o = this.map.positionsToPixels([e.coordinates])[0], t) {
        t = Array.isArray(t) ? t : [t];
        var s = [],
          l = this;
        try {
          for (var c = __values$8(t), u = c.next(); !u.done; u = c.next()) !function (e) {
            var t = e instanceof Layer ? e.getId() : e,
              e = l.layerIndex.findIndex(function (e) {
                return e.getId() === t;
              });
            if (!(-1 < e)) throw new Error("The layer '".concat(t, "' has not been added to the map ") + "and its rendered features cannot be retrieved.");
            s.push.apply(s, __spreadArray$6([], __read$6(l.layerIndex[e]._getLayerIds().filter(function (e) {
              return !!a.map._getMap().getLayer(e);
            })), !1));
          }(u.value);
        } catch (e) {
          n = {
            error: e
          };
        } finally {
          try {
            u && !u.done && (i = c.return) && i.call(c);
          } finally {
            if (n) throw n.error;
          }
        }
      }
      e = this.map._getMap().queryRenderedFeatures(o, {
        layers: s,
        filter: r
      });
      return this.map.sources._mapFeaturesToShapes(e);
    }, e.prototype.remove = function (e) {
      var t, r;
      if (Array.isArray(e)) try {
        for (var n = __values$8(e), i = n.next(); !i.done; i = n.next()) {
          var o = i.value;
          this._removeLayer(o);
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n);
        } finally {
          if (t) throw t.error;
        }
      } else this._removeLayer(e);
    }, e.prototype._removeLayer = function (e) {
      var t = e instanceof Layer ? e.getId() : e,
        r = this.layerIndex.findIndex(function (e) {
          return e.getId() === t;
        });
      if (-1 == r) throw new Error("The layer '".concat(t, "' has not been added to the map and cannot be removed."));
      var n = this.layerIndex[r],
        r = (this._removeMapboxLayers(n), this.layerIndex.splice(r, 1), this.userLayers.findIndex(function (e) {
          return e.layer.getId() === t;
        }));
      -1 != r && this.userLayers.splice(r, 1), e instanceof SourceBuildingLayer && this.map.sources.unsetSourceState(e._getSourceId()), n.onRemove();
    }, e;
  }(),
  __values$7 = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  PopupManager = function () {
    function t(e) {
      var n = this;
      this._onDrag = function (e) {
        var t, r;
        "mousemove" === e.type ? (t = e.clientX, r = e.clientY) : "touchmove" === e.type && (t = e.touches[0].clientX, r = e.touches[0].clientY), n.draggedPopups.forEach(function (e) {
          e._dragToPixel([t, r]);
        });
      }, this._onUp = function () {
        n.map.getMapContainer().removeEventListener("mousemove", n._onDrag), n.map.getMapContainer().removeEventListener("touchmove", n._onDrag), n.map.getMapContainer().removeEventListener("mouseup", n._onUp), n.map.getMapContainer().removeEventListener("touchend", n._onUp), n.draggedPopups.forEach(function (e) {
          n.draggedPopups.delete(e), e._onUp();
        });
      }, this.map = e, this.popups = new Set(), this.draggedPopups = new Set();
    }
    return t.prototype.add = function (e) {
      var t, r;
      e = Array.isArray(e) ? e : [e];
      try {
        for (var n = __values$7(e), i = n.next(); !i.done; i = n.next()) {
          var o = i.value;
          this.popups.has(o) || (this.popups.add(o), o.attach(this.map));
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n);
        } finally {
          if (t) throw t.error;
        }
      }
    }, t.prototype.clear = function () {
      var t = this;
      this.popups.forEach(function (e) {
        t.popups.delete(e), e.remove();
      });
    }, t.prototype.remove = function (e) {
      var t, r;
      e = Array.isArray(e) ? e : [e];
      try {
        for (var n = __values$7(e), i = n.next(); !i.done; i = n.next()) {
          var o = i.value;
          this.popups.has(o) && (this.popups.delete(o), o.remove());
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n);
        } finally {
          if (t) throw t.error;
        }
      }
    }, t.prototype.getPopups = function () {
      return Array.from(this.popups);
    }, t.prototype._getCollectionDiv = function () {
      var e = this.map.getMapContainer().querySelector(".".concat(t.Css.collection));
      return e || ((e = document.createElement("div")).classList.add(t.Css.collection), e.setAttribute("aria-label", "Map Information"), this.map.getMapContainer().appendChild(e)), e;
    }, t.prototype._addDraggedPopup = function (e) {
      0 === this.draggedPopups.size && (this.map.getMapContainer().addEventListener("mousemove", this._onDrag), this.map.getMapContainer().addEventListener("touchmove", this._onDrag), this.map.getMapContainer().addEventListener("mouseup", this._onUp), this.map.getMapContainer().addEventListener("touchend", this._onUp)), this.draggedPopups.add(e);
    }, t.Css = {
      collection: "popup-collection-container"
    }, t;
  }(),
  __values$6 = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  SourceManager = function () {
    function e(e) {
      this.map = e, this.sources = new Dictionary();
    }
    return e.prototype.add = function (e, t) {
      var r, n;
      if (void 0 === t && (t = !0), Array.isArray(e)) try {
        for (var i = __values$6(e), o = i.next(); !o.done; o = i.next()) {
          var a = o.value;
          this._addSource(a, t);
        }
      } catch (e) {
        r = {
          error: e
        };
      } finally {
        try {
          o && !o.done && (n = i.return) && n.call(i);
        } finally {
          if (r) throw r.error;
        }
      } else this._addSource(e, t);
    }, e.prototype.getRenderedShapes = function (e, t, r) {
      e = "string" == typeof e ? e : e.getId(), r = this.map._getMap().querySourceFeatures(e, {
        sourceLayer: r,
        filter: t
      });
      return this.map.sources._mapFeaturesToShapes(r, !0, this.sources.get(e));
    }, e.prototype.getFeatureState = function (e, t, r) {
      e = "string" == typeof e ? e : e instanceof Shape ? e.getId() : e.id, t = "string" == typeof t ? t : t.getId();
      return this.map._getMap().getFeatureState({
        id: e,
        source: t,
        sourceLayer: r
      });
    }, e.prototype.removeFeatureState = function (e, t, r, n) {
      e = "string" == typeof e ? e : e instanceof Shape ? e.getId() : e.id, t = "string" == typeof t ? t : t.getId();
      this.map._getMap().removeFeatureState({
        id: e,
        source: t,
        sourceLayer: r
      }, n);
    }, e.prototype.setFeatureState = function (e, t, r, n) {
      e = "string" == typeof e ? e : e instanceof Shape ? e.getId() : e.id, t = "string" == typeof t ? t : t.getId();
      this.map._getMap().setFeatureState({
        id: e,
        source: t,
        sourceLayer: n
      }, r);
    }, e.prototype._buildSources = function () {
      var t = {};
      return this.sources.forEach(function (e) {
        t[e.getId()] = e._buildSource();
      }), t;
    }, e.prototype.clear = function () {
      var t = this;
      this.sources.forEach(function (e) {
        t.remove(e);
      });
    }, e.prototype.getById = function (e) {
      return this.sources.get(e);
    }, e.prototype.getSources = function () {
      return Array.from(this.sources.values());
    }, e.prototype.isSourceLoaded = function (e) {
      e = e instanceof Source ? e.getId() : e;
      return this.map._getMap().isSourceLoaded(e);
    }, e.prototype.remove = function (e, t) {
      var r, n;
      if (void 0 === t && (t = !0), Array.isArray(e)) try {
        for (var i = __values$6(e), o = i.next(); !o.done; o = i.next()) {
          var a = o.value;
          this._removeSource(a, t);
        }
      } catch (e) {
        r = {
          error: e
        };
      } finally {
        try {
          o && !o.done && (n = i.return) && n.call(i);
        } finally {
          if (r) throw r.error;
        }
      } else this._removeSource(e, t);
    }, e.prototype.setSourceState = function (e, t) {
      void 0 === t && (t = !0), this.sources.set(e.getId(), e), e._setMap(this.map, t);
    }, e.prototype.unsetSourceState = function (e) {
      this.sources.has(e) && (this.sources.get(e)._setMap(null), this.sources.delete(e));
    }, e.prototype._removeSource = function (e, t) {
      e = e instanceof Source ? e.getId() : e;
      if (!this.sources.has(e)) throw new Error("'".concat(e, "' is not added to the map"));
      if (this.map._getMap().getSource(e) && t && this.map._getMap().removeSource(e), this.map._getMap().getSource(e) && t) throw new Error("One or more layers have a dependency on the source '".concat(e, "'"));
      this.unsetSourceState(e);
    }, e.prototype._addSource = function (e, t) {
      if (this.sources.has(e.getId())) {
        if (t) throw new Error("'".concat(e.getId(), "' is already added to the map"));
        this.unsetSourceState(e.getId());
      }
      if (t) {
        if (!this.map._isReady()) throw new Error("The source '".concat(e.getId(), "' could not be added to the map because ") + "the map is not ready. Please use a ready event listener to guarantee the map is ready before adding a source to it.");
        this.map._getMap().addSource(e.getId(), e._buildSource());
      }
      this.setSourceState(e);
    }, e.prototype._mapFeaturesToShapes = function (e, t, r) {
      var n,
        i,
        o = [];
      try {
        for (var a = __values$6(e), s = a.next(); !s.done; s = a.next()) {
          var l = s.value;
          if ((r || "string" == typeof l.source) && "string" == typeof l.properties[Shape._shapeIdPropName]) {
            var c = r || this.sources.get(l.source);
            if (c instanceof DataSource) {
              var u = c.getShapeById(l.properties[Shape._shapeIdPropName]);
              if (u instanceof Shape) {
                o.push(u);
                continue;
              }
            }
          }
          t || o.push(l);
        }
      } catch (e) {
        n = {
          error: e
        };
      } finally {
        try {
          s && !s.done && (i = a.return) && i.call(a);
        } finally {
          if (n) throw n.error;
        }
      }
      return o;
    }, e.prototype._syncSources = function (i) {
      var n = this;
      i ? (Object.keys(i).map(function (e) {
        var t,
          r = i[e];
        switch (r.type) {
          case "vector":
          case "raster":
          case "raster-dem":
            t = new FundamentalMapSource(e, {
              name: e,
              tiles: r.tiles,
              type: r.type,
              url: r.url,
              tileSize: "tileSize" in r ? r.tileSize : void 0
            });
            break;
          case "canvas":
            t = new CanvasSource(e, r);
            break;
          case "geojson":
            var n = new DataSource(e, {
              maxZoom: r.maxzoom,
              cluster: r.cluster,
              clusterRadius: r.clusterRadius,
              tolerance: r.tolerance,
              lineMetrics: r.lineMetrics,
              clusterProperties: r.clusterProperties,
              buffer: r.buffer,
              clusterMinPoints: r.clusterMinPoints,
              generateId: r.generateId,
              promoteId: r.promoteId,
              filter: r.filter
            });
            "string" != typeof r.data && void 0 !== r.data && n._addNoUpdate(r.data), t = n;
            break;
          case "image":
            t = new ImageSource(e, r);
            break;
          case "video":
            t = new VideoSource(e, r);
            break;
          default:
            t = new UnknownSource(e, r);
        }
        return t;
      }).forEach(function (e) {
        var t = n.sources.get(e.getId()),
          r = t && e._isDeepEqual(t);
        !r && t && n.unsetSourceState(t.getId()), n.setSourceState(e, !r);
      }), Array.from(this.sources.keys()).filter(function (e) {
        return !(e in i);
      }).forEach(function (e) {
        return n.unsetSourceState(e);
      })) : console.warn("syncSources called with no style sources which is unexpected.");
    }, e;
  }(),
  __extends$d = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  AnimationOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.duration = 1e3, e.type = "jump", e;
    }
    return __extends$d(e, t), e;
  }(Options),
  __extends$c = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  Padding = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.bottom = 0, e.left = 0, e.right = 0, e.top = 0, e;
    }
    return __extends$c(e, t), e;
  }(Options),
  __extends$b = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __values$5 = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  __read$5 = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  __spreadArray$5 = window && window.__spreadArray || function (e, t, r) {
    if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++) !n && i in t || ((n = n || Array.prototype.slice.call(t, 0, i))[i] = t[i]);
    return e.concat(n || Array.prototype.slice.call(t));
  },
  CameraBoundsOptions = function (s) {
    function e() {
      var e = null !== s && s.apply(this, arguments) || this;
      return e.bounds = [-180, -89, 180, 90], e.maxBounds = void 0, e.maxZoom = 20, e.offset = new Pixel(0, 0), e.padding = new Padding(), e;
    }
    return __extends$b(e, s), e.prototype.merge = function () {
      for (var t, e, r = [], n = 0; n < arguments.length; n++) r[n] = arguments[n];
      try {
        for (var i = __values$5(r), o = i.next(); !o.done; o = i.next()) {
          var a = o.value;
          a && "number" == typeof a.padding && (a.padding = {
            top: a.padding,
            bottom: a.padding,
            left: a.padding,
            right: a.padding
          });
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          o && !o.done && (e = i.return) && e.call(i);
        } finally {
          if (t) throw t.error;
        }
      }
      return s.prototype.merge.apply(this, __spreadArray$5([], __read$5(r), !1));
    }, e;
  }(Options),
  __extends$a = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  CameraOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.zoom = 1, e.center = new Position(0, 0), e.centerOffset = new Pixel(0, 0), e.bearing = 0, e.pitch = 0, e.minZoom = 1, e.maxZoom = 20, e.minPitch = 0, e.maxPitch = 60, e.maxBounds = void 0, e;
    }
    return __extends$a(e, t), e;
  }(Options),
  __extends$9 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  LayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.name = void 0, e.before = void 0, e.minZoom = 1, e.maxZoom = 20, e.overwrite = !1, e.opacity = 1, e;
    }
    return __extends$9(e, t), e;
  }(Options),
  __extends$8 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  CircleLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.color = "rgba(0,0,0,.5)", e.outlineColor = "#000", e.radius = 1, e.outlineWidth = 5, e.name = "default-circles", e;
    }
    return __extends$8(e, t), e;
  }(LayerOptions),
  __extends$7 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  LinestringLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.cap = "butt", e.join = "miter", e.name = "default-linestrings", e.color = "#000", e.width = 1, e;
    }
    return __extends$7(e, t), e;
  }(LayerOptions),
  __extends$6 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  PinLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.iconSize = 1, e.fontSize = 14, e.fontColor = "#000", e.textFont = "SegoeUi-Regular", e.cluster = !0, e.clusterIcon = void 0, e.textOffset = [0, 0], e.name = "default-pins", e.icon = "pin-darkblue", e.title = "", e;
    }
    return __extends$6(e, t), e;
  }(LayerOptions),
  __extends$5 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  PolygonLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.color = "rgba(0,0,0,.5)", e.outlineColor = "#000", e.name = "default-polygons", e;
    }
    return __extends$5(e, t), e;
  }(LayerOptions),
  __extends$4 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  RasterLayerOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.name = "default-raster", e;
    }
    return __extends$4(e, t), e;
  }(LayerOptions),
  __extends$3 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  LightOptions = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.anchor = "map", e.color = "#FFFFFF", e.intensity = .5, e.position = [1.15, 210, 30], e;
    }
    return __extends$3(e, t), e;
  }(Options),
  __extends$2 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __values$4 = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  __read$4 = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  __spreadArray$4 = window && window.__spreadArray || function (e, t, r) {
    if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++) !n && i in t || ((n = n || Array.prototype.slice.call(t, 0, i))[i] = t[i]);
    return e.concat(n || Array.prototype.slice.call(t));
  },
  StyleOptions = function (s) {
    function e() {
      var e = null !== s && s.apply(this, arguments) || this;
      return e.antialias = void 0, e.autoResize = !0, e.language = getLanguage(), e.light = new LightOptions(), e.preserveDrawingBuffer = !1, e.progressiveLoading = !1, e.progressiveLoadingInitialLayerGroups = ["base"], e.renderWorldCopies = !0, e.showBuildingModels = !1, e.showFeedbackLink = !0, e.showLogo = !0, e.showLabels = !0, e.customAttribution = void 0, e.showTileBoundaries = !1, e.style = void 0, e.view = getView(), e.userRegion = e.view, e.customStyleTransform = void 0, e;
    }
    return __extends$2(e, s), e.prototype.merge = function () {
      for (var t, e, r = [], n = 0; n < arguments.length; n++) r[n] = arguments[n];
      try {
        for (var i = __values$4(r), o = i.next(); !o.done; o = i.next()) {
          var a = o.value;
          a && (a.hasOwnProperty("view") ? a.userRegion = a.view : a.hasOwnProperty("userRegion") && (a.view = a.userRegion), "string" == typeof a.language) && (a.language = Localizer.getCode(a.language));
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          o && !o.done && (e = i.return) && e.call(i);
        } finally {
          if (t) throw t.error;
        }
      }
      return s.prototype.merge.apply(this, __spreadArray$4([], __read$4(r), !1));
    }, e;
  }(Options),
  __extends$1 = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __assign$2 = window && window.__assign || function () {
    return (__assign$2 = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      return e;
    }).apply(this, arguments);
  },
  __values$3 = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  __read$3 = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  __spreadArray$3 = window && window.__spreadArray || function (e, t, r) {
    if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++) !n && i in t || ((n = n || Array.prototype.slice.call(t, 0, i))[i] = t[i]);
    return e.concat(n || Array.prototype.slice.call(t));
  },
  composeTransformers = function (e) {
    return 0 == e.length ? void 0 : e.slice(1).reduce(function (r, n) {
      return function (e, t) {
        e = r(e, t);
        return __assign$2(__assign$2({}, e), n(e.url, t));
      };
    }, e[0]);
  },
  ServiceOptions = function (u) {
    function e() {
      var e = null !== u && u.apply(this, arguments) || this;
      return e.authOptions = getAuthenticationOptions(), e.disableTelemetry = "atlas.azure.us" === getDomain(), e["disable-telemetry"] = e.disableTelemetry, e.domain = getDomain(), e.staticAssetsDomain = getStaticAssetsDomain(), e.styleDefinitionsPath = getStyleDefinitionsPath(), e.styleDefinitionsVersion = getStyleDefinitionsVersion(), e.styleAPIVersion = getStyleAPIVersion(), e.mapConfiguration = void 0, e.styleSet = void 0, e.enableAccessibility = !0, e["enable-accessibility"] = e.enableAccessibility, e.enableAccessibilityLocationFallback = !0, e.maxParallelImageRequests = getMaxParallelImageRequests(), e.refreshExpiredTiles = !0, e.subscriptionKey = getSubscriptionKey(), e["subscription-key"] = e.subscriptionKey, e.sessionId = getSessionId(), e["session-id"] = e.sessionId, e._transformers = [], e.transformRequest = void 0, e.workerCount = getWorkerCount(), e.fadeDuration = 300, e.localIdeographFontFamily = "sans-serif", e.validateStyle = !1, e;
    }
    return __extends$1(e, u), e.prototype.merge = function () {
      for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
      var r = this.styleDefinitionsVersion;
      try {
        for (var n = __values$3(e), i = n.next(); !i.done; i = n.next()) {
          var o = i.value;
          o && (o.authOptions ? "string" == typeof o.authOptions.subscriptionKey && (o.subscriptionKey = o["subscription-key"] = o.authOptions.subscriptionKey) : "string" == typeof o.subscriptionKey ? (o["subscription-key"] = o.subscriptionKey, o.authOptions = {
            authType: AuthenticationType.subscriptionKey,
            subscriptionKey: o.subscriptionKey
          }) : "string" == typeof o["subscription-key"] && (o.subscriptionKey = o["subscription-key"], o.authOptions = {
            authType: AuthenticationType.subscriptionKey,
            subscriptionKey: o["subscription-key"]
          }), "string" == typeof o.sessionId ? o["session-id"] = o.sessionId : "string" == typeof o["session-id"] && (o.sessionId = o["session-id"]), "boolean" == typeof o.disableTelemetry ? o["disable-telemetry"] = o.disableTelemetry : "boolean" == typeof o["disable-telemetry"] && (o.disableTelemetry = o["disable-telemetry"]), "boolean" == typeof o.enableAccessibility ? o["enable-accessibility"] = o.enableAccessibility : "boolean" == typeof o["enable-accessibility"] && (o.enableAccessibility = o["enable-accessibility"]));
        }
      } catch (e) {
        l = {
          error: e
        };
      } finally {
        try {
          i && !i.done && (s = n.return) && s.call(n);
        } finally {
          if (l) throw l.error;
        }
      }
      var a = this._transformers,
        s = e ? e.filter(function (e) {
          return void 0 !== e;
        }).reduce(function (e, t) {
          return __spreadArray$3(__spreadArray$3([], __read$3(e), !1), __read$3(t._transformers || []), !1);
        }, []) : [],
        l = u.prototype.merge.apply(this, __spreadArray$3([], __read$3(e), !1)),
        s = (l.authOptions.authType !== AuthenticationType.subscriptionKey && (l["subscription-key"] = l.subscriptionKey = void 0), void 0 !== l.styleSet && void 0 === l.mapConfiguration && (l.mapConfiguration = l.styleSet), l.mapConfiguration && "string" != typeof l.mapConfiguration && (l.mapConfiguration = __assign$2(__assign$2({}, l.mapConfiguration), {
          defaultConfiguration: l.mapConfiguration.defaultConfiguration || l.mapConfiguration.defaultStyle,
          configurations: l.mapConfiguration.configurations || l.mapConfiguration.styles
        })), this._transformers = __spreadArray$3(__spreadArray$3([], __read$3(a || []), !1), __read$3(s.filter(function (e) {
          return !a.includes(e);
        })), !1), this.transformRequest && !this._transformers.includes(this.transformRequest) && this._transformers.push(this.transformRequest), new Date(Date.UTC(2023, 0))),
        c = new Date(this.styleDefinitionsVersion);
      return (isNaN(c.getTime()) || c.getTime() < s.getTime()) && (console.warn("Style definition version ".concat(this.styleDefinitionsVersion, " is invalid or deprecated, style definition version is unchanged (").concat(r, ")")), this.styleDefinitionsVersion = r), this.transformRequest = composeTransformers(this._transformers), l;
    }, e.prototype.addTransformer = function (e) {
      this._transformers || (this._transformers = []), this._transformers.push(e), this.transformRequest = composeTransformers(this._transformers);
    }, e.prototype.removeTransformer = function (t) {
      this._transformers && (this._transformers = this._transformers.filter(function (e) {
        return t !== e;
      }), this.transformRequest = composeTransformers(this._transformers));
    }, e._cloneCustomizer = function (e) {
      if ("object" == typeof e) return Object.assign({}, e);
    }, e;
  }(Options),
  LayerGroupComparator = function () {
    function e() {}
    return e.getLayerGroup = function (e) {
      return "string" != typeof e && e.metadata && e.metadata["microsoft.maps:layerGroup"] ? e.metadata["microsoft.maps:layerGroup"] : (e = "string" != typeof e ? e.id : e).startsWith("microsoft.") && 4 <= (e = e.split(".")).length ? e[3] : void 0;
    }, e;
  }(),
  HijackablePromise = function () {
    function t(e) {
      var i = this;
      this.isHijacked = function () {
        return void 0 !== i._hijackedToResolve || void 0 !== i._hijackedToReject;
      }, this.isResolved = function () {
        return void 0 !== i._hijackedToResolve || void 0 !== i._toResolve;
      }, this.isRejected = function () {
        return void 0 !== i._hijackedToReject || void 0 !== i._toReject;
      }, this.resultIfResolved = function () {
        return i._hijackedToResolve || i._toResolve;
      }, this.errorIfRejected = function () {
        return i._hijackedToReject || i._toReject;
      }, this._thenResolver = function (t, r) {
        var n;
        i._hijackedToResolve ? t(i._hijackedToResolve) : i._hijackedToReject ? r(i._hijackedToReject) : (n = i.origin, i.origin.then(function (e) {
          i.isHijacked() || (n !== i.origin ? i._thenResolver(t, r) : (i._toResolve = e, t(e)));
        }).catch(function (e) {
          i.isHijacked() || (n !== i.origin ? i._thenResolver(t, r) : (i._toReject = e, r(e)));
        }));
      }, this.origin = e, this[Symbol.toStringTag] = this.origin[Symbol.toStringTag];
    }
    return t.resolve = function (e) {
      return new t(Promise.resolve(e));
    }, t.reject = function (e) {
      return new t(Promise.reject(e));
    }, t.prototype.then = function (e, t) {
      var r = this;
      return new Promise(function (e, t) {
        r._resolve = e, r._reject = t, r._thenResolver(e, t);
      }).then(e, t);
    }, t.prototype.catch = function (e) {
      var r = this;
      return new Promise(function (e, t) {
        r._resolve = e, r._reject = t, r._thenResolver(e, t);
      }).catch(e);
    }, t.prototype.finally = function (e) {
      var r = this;
      return new Promise(function (e, t) {
        r._resolve = e, r._reject = t, r._thenResolver(e, t);
      }).finally(e);
    }, t.prototype.hijackAndResolve = function (e) {
      this._hijackedToResolve = e, this._resolve && this._resolve(e);
    }, t.prototype.hijackAndReject = function (e) {
      this._hijackedToReject = e, this._reject && this._reject(e);
    }, t.prototype.switchWith = function (e) {
      this.origin = e, this._toResolve = void 0, this._toReject = void 0;
    }, t;
  }(),
  styleNamesMap = {
    road: "Road",
    satellite: "Satellite",
    satellite_road_labels: "Hybrid",
    grayscale_dark: "Grayscale (Dark)",
    grayscale_light: "Grayscale (Light)",
    night: "Night",
    road_shaded_relief: "Terra",
    blank: "Blank",
    blank_accessible: "Blank (Accessible)",
    high_contrast_dark: "High contrast (Dark)",
    high_contrast_light: "High contrast (Light)"
  },
  __assign$1 = window && window.__assign || function () {
    return (__assign$1 = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      return e;
    }).apply(this, arguments);
  },
  __awaiter$1 = window && window.__awaiter || function (e, a, s, l) {
    return new (s = s || Promise)(function (r, t) {
      function n(e) {
        try {
          o(l.next(e));
        } catch (e) {
          t(e);
        }
      }
      function i(e) {
        try {
          o(l.throw(e));
        } catch (e) {
          t(e);
        }
      }
      function o(e) {
        var t;
        e.done ? r(e.value) : ((t = e.value) instanceof s ? t : new s(function (e) {
          e(t);
        })).then(n, i);
      }
      o((l = l.apply(e, a || [])).next());
    });
  },
  __generator$1 = window && window.__generator || function (n, i) {
    var o,
      a,
      s,
      l = {
        label: 0,
        sent: function () {
          if (1 & s[0]) throw s[1];
          return s[1];
        },
        trys: [],
        ops: []
      },
      c = {
        next: e(0),
        throw: e(1),
        return: e(2)
      };
    return "function" == typeof Symbol && (c[Symbol.iterator] = function () {
      return this;
    }), c;
    function e(r) {
      return function (e) {
        var t = [r, e];
        if (o) throw new TypeError("Generator is already executing.");
        for (; l = c && t[c = 0] ? 0 : l;) try {
          if (o = 1, a && (s = 2 & t[0] ? a.return : t[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, t[1])).done) return s;
          switch (a = 0, (t = s ? [2 & t[0], s.value] : t)[0]) {
            case 0:
            case 1:
              s = t;
              break;
            case 4:
              return l.label++, {
                value: t[1],
                done: !1
              };
            case 5:
              l.label++, a = t[1], t = [0];
              continue;
            case 7:
              t = l.ops.pop(), l.trys.pop();
              continue;
            default:
              if (!(s = 0 < (s = l.trys).length && s[s.length - 1]) && (6 === t[0] || 2 === t[0])) {
                l = 0;
                continue;
              }
              if (3 === t[0] && (!s || t[1] > s[0] && t[1] < s[3])) l.label = t[1];else if (6 === t[0] && l.label < s[1]) l.label = s[1], s = t;else {
                if (!(s && l.label < s[2])) {
                  s[2] && l.ops.pop(), l.trys.pop();
                  continue;
                }
                l.label = s[2], l.ops.push(t);
              }
          }
          t = i.call(n, l);
        } catch (e) {
          t = [6, e], a = 0;
        } finally {
          o = s = 0;
        }
        if (5 & t[0]) throw t[1];
        return {
          value: t[0] ? t[1] : void 0,
          done: !0
        };
      };
    }
  },
  __read$2 = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  __spreadArray$2 = window && window.__spreadArray || function (e, t, r) {
    if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++) !n && i in t || ((n = n || Array.prototype.slice.call(t, 0, i))[i] = t[i]);
    return e.concat(n || Array.prototype.slice.call(t));
  },
  __values$2 = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  StyleManager = function () {
    function e(e, t) {
      var u = this;
      this.definitions = function () {
        var e = u.initPromise || u.initStyleset();
        return e;
      }, this.indoorState = void 0, this.preservedPreindoorMapConfiguration = void 0, this._progressiveLoadingState = {
        mapStyle: void 0,
        pendingVisibilityChange: void 0
      }, this._deferLayerGroupVisibilities = function (t, e) {
        var r,
          i,
          n,
          o,
          a = e.filter(function (e) {
            return e in t;
          });
        0 !== a.length && (r = u.map._getMap(), i = r.getZoom(), n = u.map.getStyle().style, u._progressiveLoadingState.pendingVisibilityChange && (u.map.events.remove("load", u._progressiveLoadingState.pendingVisibilityChange), u._progressiveLoadingState.pendingVisibilityChange = null), u._progressiveLoadingState.mapStyle = n, (o = Object.entries(t).reduce(function (e, t) {
          var t = __read$2(t, 2),
            r = t[0],
            t = t[1],
            n = a.includes(r);
          return __spreadArray$2(__spreadArray$2([], __read$2(e), !1), __read$2(t.filter(function (e) {
            if ("custom" === e.type) return !1;
            if (n) if ("number" == typeof e.maxzoom && "number" == typeof e.minzoom) {
              if (i <= e.maxzoom && i >= e.minzoom) return !1;
            } else if ("number" == typeof e.minzoom) {
              if (i >= e.minzoom) return !1;
            } else {
              if ("number" != typeof e.maxzoom) return !1;
              if (i <= e.maxzoom) return !1;
            }
            return "none" !== (null == (e = e.layout) ? void 0 : e.visibility);
          })), !1);
        }, [])).forEach(function (e) {
          e.layout = e.layout || {}, e.layout.visibility = "none";
        }), u._progressiveLoadingState.pendingVisibilityChange = function () {
          u._progressiveLoadingState.pendingVisibilityChange = null;
          var e = u.map.getStyle().style;
          n === e && (o.forEach(function (e) {
            e.layout.visibility = "visible", r.setLayoutProperty(e.id, "visibility", "visible");
          }), null != (e = u.map.copyrightDelegate)) && e.reloadAttribution();
        }, u.map.events.addOnce("load", u._progressiveLoadingState.pendingVisibilityChange));
      }, this._onStyleData = function (e) {
        u.map.events.invoke("stylechanged", {
          style: e.name,
          map: u.map,
          type: "stylechanged"
        });
      }, this._lookUp = function (e) {
        var t,
          r,
          n = u.definitions(),
          i = n.errorIfRejected(),
          o = n.resultIfResolved();
        if (i || !o) return null;
        var n = o.configurations,
          a = void 0;
        try {
          for (var s = __values$2(n), l = s.next(); !l.done; l = s.next()) {
            var c = l.value;
            if (c.name === e.style) return c;
            c.name === o.defaultConfiguration && (a = a || c);
          }
        } catch (e) {
          t = {
            error: e
          };
        } finally {
          try {
            l && !l.done && (r = s.return) && r.call(s);
          } finally {
            if (t) throw t.error;
          }
        }
        return a = a || n[0];
      }, this._lookUpAsync = function (r) {
        return __awaiter$1(u, void 0, void 0, function () {
          var t;
          return __generator$1(this, function (e) {
            switch (e.label) {
              case 0:
                return [4, this.definitions()];
              case 1:
                return t = e.sent(), [2, t.configurations.find(function (e) {
                  return e.name === (r.style || t.defaultConfiguration);
                }) || t.configurations.find(function (e) {
                  return e.name === t.defaultConfiguration;
                }) || t.configurations[0]];
            }
          });
        });
      }, this.map = e, this.serviceOptions = t;
    }
    return e.prototype.updateIndoorState = function (e, t) {
      var r,
        n,
        i = this,
        o = this.map.styles.getMapConfiguration();
      o ? (this.preservedPreindoorMapConfiguration = o, r = this.map.getStyle().style ? "".concat(this.map.getStyle().style, "_indoor").concat("dark" === e ? "_dark" : "", "_tileset_").concat(t) : void 0, this.map.styles.setMapConfiguration("defaultIndoor_".concat(t), "microsoft-maps:default" === o ? r : void 0)) : (n = (null == (o = this.indoorState) ? void 0 : o.tilesetId) !== t, this.indoorState = {
        tilesetId: t,
        theme: e
      }, this.initStyleset(), this.definitions().then(function (e) {
        var t = (i.map.getStyle().style || e.defaultConfiguration).replace("_indoor_dark", "").replace("_indoor", ""),
          r = "".concat(t, "_indoor"),
          t = e.configurations.find(function (e) {
            return e.name.startsWith(r);
          });
        t && i.map.setStyle({
          style: t.name
        }, !n);
      }));
    }, e.prototype.unsetIndoorState = function () {
      var r = this,
        e = this.preservedPreindoorMapConfiguration;
      e ? this.map.styles.setMapConfiguration(e) : (this.indoorState = void 0, this.initStyleset(), this.definitions().then(function (e) {
        var t = r.map.getStyle().style;
        t.includes("_indoor") && t.split("_indoor")[0] ? r.map.setStyle({
          style: t.split("_indoor")[0]
        }) : r.map.setStyle({
          style: void 0
        });
      }));
    }, e.prototype.initStyleset = function () {
      var e,
        r = this;
      return e = this.serviceOptions.mapConfiguration ? "string" == typeof this.serviceOptions.mapConfiguration ? (e = this.map.authentication ? this.map.authentication.initialize() : Promise.resolve(), new HijackablePromise(e.then(function () {
        return r._request(r.serviceOptions.domain, "".concat(constants.styleResourcePath, "/mapconfigurations/metadata/").concat(r.serviceOptions.mapConfiguration), "StyleDefinitions").then(function (e) {
          return __assign$1(__assign$1({}, e), {
            defaultConfiguration: e.defaultConfiguration || e.defaultStyle,
            configurations: e.configurations || e.styles
          });
        });
      }))) : HijackablePromise.resolve(this.serviceOptions.mapConfiguration) : (e = this.map.authentication ? this.map.authentication.initialize() : Promise.resolve(), new HijackablePromise(e.then(function () {
        return r._request(r.serviceOptions.staticAssetsDomain, "".concat(constants.stylePath, "/").concat(constants.styleResourcePath), "StyleDefinitions", {
          version: r.serviceOptions.styleDefinitionsVersion,
          mcv: version$3.replace(/\./g, "")
        }).then(function (t) {
          return {
            version: isNaN(t.version) ? 0 : parseFloat(t.version),
            defaultConfiguration: t.defaultStyle,
            configurations: t.styles.filter(function (e) {
              return r.indoorState ? "auto" === r.indoorState.theme ? e.name.endsWith("dark" === e.theme ? "_indoor_dark" : "_indoor") : e.name.endsWith("dark" === r.indoorState.theme ? "_indoor_dark" : "_indoor") : !e.name.includes("indoor");
            }).map(function (e) {
              return {
                copyright: e.copyright.join(" "),
                name: e.name,
                displayName: function (e) {
                  e = r.indoorState && e.includes("_indoor") ? e.split("_indoor")[0] : e;
                  return e in styleNamesMap ? styleNamesMap[e] : e;
                }(e.name),
                theme: e.theme,
                thumbnail: new Url({
                  domain: r.serviceOptions.staticAssetsDomain,
                  path: e.thumbnail,
                  protocol: "https"
                }).toString(),
                url: new Url({
                  domain: r.serviceOptions.staticAssetsDomain,
                  path: "".concat(constants.stylePath, "/").concat(constants.styleResourcePath, "/").concat(e.name),
                  queryParams: {
                    styleVersion: void 0 !== t.version && null !== t.version ? t.version : r.serviceOptions.styleDefinitionsVersion,
                    mcv: version$3.replace(/\./g, "")
                  },
                  protocol: "https"
                }).toString()
              };
            })
          };
        });
      }))), this.initPromise && this.initPromise.switchWith(e), this.initPromise = e, this.initPromise.then(function (e) {
        return r.map._invokeEvent("mapconfigurationchanged", e);
      }), this.initPromise;
    }, e.prototype.getStyle = function (e) {
      e = this._lookUp(e);
      if (!e) throw Error("Style definition is not available.");
      if (e.url) return e.url;
      if (e.style) return e.style;
      throw Error("Style definition neither contains URL nor style object.");
    }, e.prototype.deriveNewStyleAndLayerGroups = function (e, t) {
      for (var r, n, i = this.map.getStyle(), o = this.map.getTraffic(), a = {}, s = 0; s < t.layers.length; s++) {
        var l = t.layers[s],
          c = LayerGroupComparator.getLayerGroup(l);
        c ? (a[c] || (a[c] = []), a[c].push(l), i.showBuildingModels || "fill-extrusion" !== l.type ? "fill-extrusion" === l.type && (l.layout = null != (r = l.layout) ? r : {}, l.layout.visibility = "visible") : (l.layout = null != (r = l.layout) ? r : {}, l.layout.visibility = "none"), "none" !== o.flow && c && c === "traffic_".concat(o.flow) && "line" == l.type && (l.layout = null != (n = l.layout) ? n : {}, l.layout.visibility = "visible"), "labels" !== c && "labels_places" !== c && "labels_indoor" !== c || "symbol" !== l.type || (i.showLabels && "none" !== (null == (n = l.layout) ? void 0 : n.visibility) ? (l.layout = null != (c = l.layout) ? c : {}, l.layout.visibility = "visible") : (l.layout = null != (c = l.layout) ? c : {}, l.layout.visibility = "none"))) : a[l.id] = [l];
      }
      return [t, a];
    }, e.prototype.injectUserLayersIntoStyle = function (a, s, l) {
      return a ? this.map.layers._getUserLayers().reduce(function (r, t) {
        var n, e, i, o;
        return t.layer instanceof WebGLLayer || (n = (null == (e = null == (e = null == l ? void 0 : l[t.before]) ? void 0 : e[0]) ? void 0 : e.id) || t.before, e = a.layers.find(function (e) {
          return e.id === t.layer.getId();
        }), -1 < (i = s.layers.findIndex(function (e) {
          return e.id === t.layer.getId();
        })) && s.layers.splice(i, 1), e && (i = new Set(Array.from(t.layer._getSourceIds()).map(function (e) {
          return a.sources[e] ? {
            source: a.sources[e],
            id: e
          } : void 0;
        }).filter(function (e) {
          return void 0 !== e;
        })), -1 < (o = n ? r.layers.findIndex(function (e) {
          return e.id === n;
        }) : -1) ? r.layers.splice(o, 0, e) : r.layers.push(e), i.forEach(function (e) {
          var t = e.source,
            e = e.id;
          r.sources[e] = t;
        }))), r;
      }, __assign$1({}, s)) : s;
    }, e.prototype.setStyle = function (i, e) {
      var o = this,
        t = (void 0 === e && (e = !0), this._lookUp(i));
      if (!t) throw Error("Style definition ".concat(i.style, " is not available."));
      if (!t.url && !t.style) throw Error("Style definition neither contains URL nor style object.");
      var r = function () {
          return o._onStyleData(t);
        },
        a = function () {
          o.map.events.remove("styledata", r), o.map.events.addOnce("styledata", r);
        },
        n = i && i.customStyleTransform ? function (e, t) {
          e = i.customStyleTransform(e, t);
          return a(), e;
        } : function (e, t) {
          var r = __assign$1(__assign$1({}, t), {
              layers: __spreadArray$2([], __read$2(t.layers), !1),
              sources: __assign$1({}, t.sources)
            }),
            n = i.progressiveLoading && !o.map._isLoaded(),
            t = (n && Array.isArray(null == t ? void 0 : t.layers) && ((r = __assign$1({}, t)).layers = r.layers.map(function (e) {
              var t = __assign$1({}, e);
              return e.layout && (t.layout = __assign$1({}, e.layout)), t;
            })), __read$2(o.deriveNewStyleAndLayerGroups(e, r), 2)),
            r = t[0],
            t = t[1],
            n = (n && (n = i.progressiveLoadingInitialLayerGroups, Array.isArray(n)) && 0 < n.length && o._deferLayerGroupVisibilities(t, n), o.injectUserLayersIntoStyle(e, r, t)),
            e = Object.entries(t).map(function (e) {
              var e = __read$2(e, 2),
                t = e[0],
                e = e[1];
              return o._buildFundamentalLayerFrom(e, t);
            }),
            r = o.map.layers._getUserLayers().reduce(function (e, t) {
              var r = t.before ? e.findIndex(function (e) {
                return e.getId() === t.before;
              }) : -1;
              return -1 < r ? e.splice(r, 0, t.layer) : e.push(t.layer), e;
            }, e);
          return o.map.layers.layerIndex = r, o.map.sources._syncSources(n.sources), a(), n;
        };
      this.map._getMap().setStyle(t.url || t.style, {
        diff: e,
        validate: this.serviceOptions.validateStyle,
        transformStyle: n
      });
    }, e.prototype.getTheme = function (e) {
      e = this._lookUp(e);
      if (e) return e.theme.toLowerCase();
    }, e.prototype.getThemeAsync = function (t) {
      return __awaiter$1(this, void 0, void 0, function () {
        return __generator$1(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this._lookUpAsync(t)];
            case 1:
              return [2, e.sent().theme];
          }
        });
      });
    }, e.prototype.setMapConfiguration = function (e, r) {
      var n = this;
      "string" == typeof (this.serviceOptions.mapConfiguration = e) ? this.initStyleset() : this.initPromise ? this.initPromise.hijackAndResolve(e) : this.initPromise = HijackablePromise.resolve(e), this.definitions().then(function (e) {
        var t = e.defaultConfiguration;
        e.configurations.find(function (e) {
          return e.name === r;
        }) && (t = r), n.map.setStyle({
          style: t
        });
      });
    }, e.prototype.getMapConfiguration = function () {
      return this.serviceOptions.mapConfiguration;
    }, e.prototype.setStyleSet = function (e) {
      this.updateIndoorState("indoor_dark" === e ? "dark" : "light", null);
    }, e.prototype.getStyleSet = function () {
      return void 0 !== this.indoorState ? "dark" === this.indoorState.theme ? "indoor_dark" : "indoor" : "base";
    }, e.prototype.clearStyleSet = function () {
      this.unsetIndoorState();
    }, e.prototype._buildFundamentalLayerFrom = function (e, t) {
      if (e && 0 < e.length) return (e = new FundamentalMapLayer(e, t)).onAdd(this.map), e;
      throw new Error("Unable to construct fundamental map layer for ID: ".concat(t, "."));
    }, e.prototype._transformStyleRequest = function (e, t) {
      e.includes(constants.domainPlaceHolder) && (t.url = t.url.replace(constants.domainPlaceHolder, this.serviceOptions.domain)), e.includes(constants.stylePathHolder) && (t.url = t.url.replace(constants.stylePathHolder, constants.stylePath)), e.includes(constants.styleResourcePlaceholder) && (t.url = t.url.replace(constants.styleResourcePlaceholder, constants.styleResourcePath)), (t.url.toLocaleLowerCase().includes(this.serviceOptions.domain.toLocaleLowerCase()) || t.url.toLocaleLowerCase().includes(this.serviceOptions.staticAssetsDomain.toLocaleLowerCase())) && ((e = new URL(t.url)).searchParams.get(constants.apiVersionQueryParameter) || (e.searchParams.set(constants.apiVersionQueryParameter, this.serviceOptions.styleAPIVersion), t.url = e.href), null != (e = this.map.authentication) && e.signRequest(t), this._deleteAuthTokenForStaticAssets(t));
    }, e.prototype._request = function (n, i, o, a) {
      var s;
      return void 0 === a && (a = {}), __awaiter$1(this, void 0, void 0, function () {
        var t, r;
        return __generator$1(this, function (e) {
          switch (e.label) {
            case 0:
              return r = {
                url: new Url({
                  protocol: "https",
                  domain: n,
                  path: i,
                  queryParams: __assign$1(((r = {})[constants.apiVersionQueryParameter] = this.serviceOptions.styleAPIVersion, r), a)
                }).toString()
              }, "function" == typeof this.serviceOptions.transformRequest && o && (r = this.serviceOptions.transformRequest(r.url, o)), null != (s = this.map.authentication) && s.signRequest(r), this._deleteAuthTokenForStaticAssets(r), t = {
                method: "GET",
                mode: "cors"
              }, r.credentials && (t.credentials = r.credentials), r.headers && (t.headers = r.headers), [4, fetch(r.url, t).then(function (e) {
                if (e.ok) return e.json();
                throw new Error("HTTP ".concat(e.status, ": ").concat(e.statusText, " "));
              })];
            case 1:
              return [2, e.sent()];
          }
        });
      });
    }, e.prototype._deleteAuthTokenForStaticAssets = function (e) {
      e.url.startsWith("https://".concat(this.serviceOptions.staticAssetsDomain, "/").concat(constants.stylePath)) && (delete e.headers[constants.msClientIdHeaderName], delete e.headers[constants.authorizationHeaderName]);
    }, e;
  }(),
  isHMREnabled = function () {
    return "ENVIRONMENT" in window && !!window.ENVIRONMENT.hmr;
  },
  __values$1 = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  AccessibleIndicatorManager = function () {
    function t(e) {
      this.map = e, this.indicators = new Set();
    }
    return t.prototype.add = function (e) {
      var t, r;
      e = Array.isArray(e) ? e : [e];
      try {
        for (var n = __values$1(e), i = n.next(); !i.done; i = n.next()) {
          var o = i.value;
          this.indicators.has(o) || (this.indicators.add(o), o.attach(this.map));
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n);
        } finally {
          if (t) throw t.error;
        }
      }
    }, t.prototype.clear = function () {
      var t = this;
      this.indicators.forEach(function (e) {
        t.indicators.delete(e), e.remove();
      });
    }, t.prototype.remove = function (e) {
      var t, r;
      e = Array.isArray(e) ? e : [e];
      try {
        for (var n = __values$1(e), i = n.next(); !i.done; i = n.next()) {
          var o = i.value;
          this.indicators.has(o) && (this.indicators.delete(o), o.remove());
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n);
        } finally {
          if (t) throw t.error;
        }
      }
    }, t.prototype.getIndicators = function () {
      return Array.from(this.indicators);
    }, t.prototype._getCollectionDiv = function () {
      var e = this.map.getMapContainer().querySelector(".".concat(t.Css.collection));
      return e || ((e = document.createElement("div")).setAttribute("aria-label", "map data"), e.setAttribute("role", "listbox"), e.classList.add(t.Css.collection), this.map.getMapContainer().appendChild(e)), e;
    }, t.Css = {
      collection: "accessible-indicator-collection-container"
    }, t;
  }(),
  __extends = window && window.__extends || function () {
    var n = function (e, t) {
      return (n = Object.setPrototypeOf || ({
        __proto__: []
      } instanceof Array ? function (e, t) {
        e.__proto__ = t;
      } : function (e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
      }))(e, t);
    };
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
      function r() {
        this.constructor = e;
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());
    };
  }(),
  __assign = window && window.__assign || function () {
    return (__assign = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      return e;
    }).apply(this, arguments);
  },
  __awaiter = window && window.__awaiter || function (e, a, s, l) {
    return new (s = s || Promise)(function (r, t) {
      function n(e) {
        try {
          o(l.next(e));
        } catch (e) {
          t(e);
        }
      }
      function i(e) {
        try {
          o(l.throw(e));
        } catch (e) {
          t(e);
        }
      }
      function o(e) {
        var t;
        e.done ? r(e.value) : ((t = e.value) instanceof s ? t : new s(function (e) {
          e(t);
        })).then(n, i);
      }
      o((l = l.apply(e, a || [])).next());
    });
  },
  __generator = window && window.__generator || function (n, i) {
    var o,
      a,
      s,
      l = {
        label: 0,
        sent: function () {
          if (1 & s[0]) throw s[1];
          return s[1];
        },
        trys: [],
        ops: []
      },
      c = {
        next: e(0),
        throw: e(1),
        return: e(2)
      };
    return "function" == typeof Symbol && (c[Symbol.iterator] = function () {
      return this;
    }), c;
    function e(r) {
      return function (e) {
        var t = [r, e];
        if (o) throw new TypeError("Generator is already executing.");
        for (; l = c && t[c = 0] ? 0 : l;) try {
          if (o = 1, a && (s = 2 & t[0] ? a.return : t[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, t[1])).done) return s;
          switch (a = 0, (t = s ? [2 & t[0], s.value] : t)[0]) {
            case 0:
            case 1:
              s = t;
              break;
            case 4:
              return l.label++, {
                value: t[1],
                done: !1
              };
            case 5:
              l.label++, a = t[1], t = [0];
              continue;
            case 7:
              t = l.ops.pop(), l.trys.pop();
              continue;
            default:
              if (!(s = 0 < (s = l.trys).length && s[s.length - 1]) && (6 === t[0] || 2 === t[0])) {
                l = 0;
                continue;
              }
              if (3 === t[0] && (!s || t[1] > s[0] && t[1] < s[3])) l.label = t[1];else if (6 === t[0] && l.label < s[1]) l.label = s[1], s = t;else {
                if (!(s && l.label < s[2])) {
                  s[2] && l.ops.pop(), l.trys.pop();
                  continue;
                }
                l.label = s[2], l.ops.push(t);
              }
          }
          t = i.call(n, l);
        } catch (e) {
          t = [6, e], a = 0;
        } finally {
          o = s = 0;
        }
        if (5 & t[0]) throw t[1];
        return {
          value: t[0] ? t[1] : void 0,
          done: !0
        };
      };
    }
  },
  __read$1 = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  __spreadArray$1 = window && window.__spreadArray || function (e, t, r) {
    if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++) !n && i in t || ((n = n || Array.prototype.slice.call(t, 0, i))[i] = t[i]);
    return e.concat(n || Array.prototype.slice.call(t));
  },
  __values = window && window.__values || function (e) {
    var t = "function" == typeof Symbol && Symbol.iterator,
      r = t && e[t],
      n = 0;
    if (r) return r.call(e);
    if (e && "number" == typeof e.length) return {
      next: function () {
        return {
          value: (e = e && n >= e.length ? void 0 : e) && e[n++],
          done: !e
        };
      }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  },
  Map$1 = function (c) {
    function u(e, t) {
      var r,
        n,
        i = c.call(this) || this,
        o = (i.removed = !1, i.loaded = !1, i.ready = !1, i._windowResizeCallback = function () {
          return i.resize();
        }, !0);
      i._updateGlobalDefaults(t), i.serviceOptions = new ServiceOptions().merge(t), i.styleOptions = new StyleOptions().merge(t), i.trafficOptions = new TrafficOptions(), i.styles = new StyleManager(i, i.serviceOptions), i.insights = new Insights(i.serviceOptions), i.serviceOptions.authOptions.subscriptionKey && (i.serviceOptions.authOptions.subscriptionKey = encodeURIComponent(i.serviceOptions.authOptions.subscriptionKey)), r = i.serviceOptions.authOptions.clientId || (i.serviceOptions.authOptions.subscriptionKey ? i.serviceOptions.authOptions.subscriptionKey.replace(/.(?=.{3,}$)/g, "*") : "invalid-setting"), i.insights && i.insights.setAuthenticatedUserContext(i.serviceOptions.sessionId, r), arguments[2] && isHMREnabled() ? (n = arguments[2], i.ready = !0, i.loaded = !0) : (r = {
        antialias: i.styleOptions.antialias,
        attributionControl: !1,
        container: e,
        fadeDuration: i.serviceOptions.fadeDuration,
        localIdeographFontFamily: i.serviceOptions.localIdeographFontFamily,
        preserveDrawingBuffer: i.styleOptions.preserveDrawingBuffer,
        refreshExpiredTiles: i.serviceOptions.refreshExpiredTiles,
        renderWorldCopies: i.styleOptions.renderWorldCopies,
        trackResize: !1,
        transformRequest: function (e, t) {
          var r = {
            url: e
          };
          return "Tile" === t || "Source" === t ? (e.includes(constants.legacyDomainPlaceHolder) && i.insights && i.insights.trackEvent({
            name: "TileLoad"
          }), i._substituteDomainLanguageViewAndSignInRequest(e, r)) : "Style" !== t && "SpriteJSON" !== t && "SpriteImage" !== t && "Glyphs" !== t || i.styles._transformStyleRequest(e, r), i.serviceOptions.transformRequest && merge$1(r, i.serviceOptions.transformRequest(r.url, t)), r;
        }
      }, n = new maplibregl.Map(r));
      try {
        i.map = n, i.authentication = new AuthenticationManager(i), i.controls = new ControlManager(i), i.events = new EventManager(i), i.imageSprite = new ImageSpriteManager(i), i.layers = new LayerManager(i), i.markers = new HtmlMarkerManager(i), i.sources = new SourceManager(i), i.popups = new PopupManager(i), i.indicators = new AccessibleIndicatorManager(i), i.map.getContainer().classList.add(u.Css.container), i.map.getCanvasContainer().classList.add(u.Css.canvasContainer), i.map.getCanvas().classList.add(u.Css.canvas), i._detectHighContrast(), i.copyrightControl = new CopyrightControl({
          showFeedbackLink: i.styleOptions.showFeedbackLink,
          showLogo: i.styleOptions.showLogo,
          customAttribution: i.styleOptions.customAttribution
        }), i.controls.add(i.copyrightControl, {
          position: ControlPosition.NonFixed
        });
        var a = i.authentication ? i.authentication.initialize() : Promise.resolve();
        if (i.removed) return i;
        var s = function () {
            i.loaded = !0, i.map.off("load", s);
          },
          l = (i.map.on("load", s), function () {
            i.ready = !0, i.map.off("styledata", l), i.events.invoke("ready", {
              map: i,
              type: "ready"
            });
          });
        i.map.on("styledata", l), i._setAutoResize(i.styleOptions.autoResize), i.map.showTileBoundaries = i.styleOptions.showTileBoundaries, i.localizedStringsPromise = Localizer.getStrings(i.styleOptions.language), a.then(function () {
          return i.styles.definitions();
        }).then(function (e) {
          if (!i.removed) {
            if (i.authentication && !i.authentication.getToken()) throw new Error("AuthenticationManager finished initializing, but no token is available");
            i.serviceOptions["enable-accessibility"] && i.accessibleMapDelegate.addToMap(), i._setStyleComponents(i.styleOptions), i.copyrightDelegate && i.copyrightDelegate.addToMap();
          }
        }).catch(function (e) {
          e = e instanceof Error ? e : new Error(e), i.insights.trackException({
            error: e
          }), e = {
            map: i,
            type: "error",
            error: e
          };
          i.events.invoke("error", e);
        }), i.setCamera(__assign(__assign({
          minZoom: 1
        }, t), {
          type: "jump",
          duration: 0
        })), i.incidentDelegate = new IncidentServiceDelegate(i), i.flowDelegate = new FlowServiceDelegate(i), i.accessibleMapDelegate = new AccessibleMapDelegate(i), i.userInteractionDelegate = new UserInteractionDelegate(i, t), i.userInteractionDelegate.addToMap(), i.copyrightDelegate = new CopyrightDelegate(i, i.copyrightControl, i.styleOptions);
      } catch (e) {
        throw o = !1, i.insights.trackException({
          error: e instanceof Error ? e : new Error(e)
        }), e;
      } finally {
        i.insights.trackEvent({
          name: "MapLoad"
        }, {
          success: o,
          supported: supported(),
          supportedWithPerformance: supported({
            failIfMajorPerformanceCaveat: !0
          })
        }), i.insights.flush();
      }
      return i;
    }
    return __extends(u, c), Object.defineProperty(u.prototype, "isDisposed", {
      get: function () {
        return this.removed;
      },
      enumerable: !1,
      configurable: !0
    }), u.prototype.getCanvas = function () {
      return this.map.getCanvas();
    }, u.prototype.getCanvasContainer = function () {
      return this.map.getCanvasContainer();
    }, u.prototype.getMapContainer = function () {
      return this.map.getContainer();
    }, u.prototype.getServiceOptions = function () {
      return cloneDeepWith$1(this.serviceOptions, ServiceOptions._cloneCustomizer);
    }, u.prototype.setServiceOptions = function (e) {
      this.serviceOptions = new ServiceOptions().merge(this.serviceOptions, e), this.serviceOptions["enable-accessibility"] ? this.accessibleMapDelegate.addToMap() : this.accessibleMapDelegate.removeFromMap();
      e = this.styles.serviceOptions.mapConfiguration !== this.serviceOptions.mapConfiguration || this.styles.serviceOptions.staticAssetsDomain !== this.serviceOptions.staticAssetsDomain || this.styles.serviceOptions.styleDefinitionsVersion !== this.serviceOptions.styleDefinitionsVersion || this.styles.serviceOptions.domain !== this.serviceOptions.domain || this.styles.serviceOptions.styleAPIVersion !== this.serviceOptions.styleAPIVersion;
      this.styles.serviceOptions = this.serviceOptions, e && (this.styles.initPromise = null, this.setStyle({}));
    }, u.prototype.addRequestTransformer = function (e) {
      this.serviceOptions.addTransformer(e);
    }, u.prototype.removeRequestTransformer = function (e) {
      this.serviceOptions.removeTransformer(e);
    }, u.prototype.setCamera = function (e, t) {
      if (void 0 === t && (t = !1), "padding" in e || "offset" in e || "bounds" in e) {
        var r,
          n = new CameraBoundsOptions().merge({
            maxZoom: this.getCamera().maxZoom
          }, e),
          i = this._generateSafeBounds(n.bounds),
          o = {
            padding: n.padding,
            offset: n.offset,
            maxZoom: n.maxZoom
          };
        if (!(r = this.map.cameraForBounds(i, o))) throw a = {
          message: "The map cannot be fit to the current canvas with the given CameraBoundsOptions.",
          containerWidth: null == (a = null == (a = this.map) ? void 0 : a.getContainer()) ? void 0 : a.clientWidth,
          containerHeight: null == a ? void 0 : a.clientHeight,
          safeBounds: i,
          cameraForBoundsOptions: o
        }, new Error(JSON.stringify(a));
        "pitch" in e && (r.pitch = e.pitch), "bearing" in e && (r.bearing = e.bearing), "minPitch" in e && this.map.setMinPitch(e.minPitch), "maxPitch" in e && this.map.setMaxPitch(e.maxPitch), this.map.setMaxZoom(n.maxZoom), this._invokeEvent("maxzoomchanged", this.map.getMaxZoom()), i = this._generateSafeBounds(n.maxBounds);
      } else {
        o = new CameraOptions().merge(this.getCamera(), e);
        o.centerOffset && 2 <= o.centerOffset.length && (a = o.centerOffset, (n = mercatorPositionsToPixels([o.center], o.zoom))[0][0] += a[0], n[0][1] += a[1], o.center = mercatorPixelsToPositions(n, o.zoom)[0]), r = {
          center: o.center,
          zoom: o.zoom,
          bearing: o.bearing,
          pitch: o.pitch,
          around: void 0
        }, this.map.setMinZoom(o.minZoom), this.map.setMaxZoom(o.maxZoom), o.minPitch && this.map.setMinPitch(o.minPitch), o.maxPitch && this.map.setMaxPitch(o.maxPitch), this._invokeEvent("minzoomchanged", this.map.getMinZoom()), this._invokeEvent("maxzoomchanged", this.map.getMaxZoom()), i = this._generateSafeBounds(o.maxBounds);
      }
      i ? this.map.setMaxBounds(i) : this.map.setMaxBounds(null);
      var a = new AnimationOptions().merge(e),
        n = {
          duration: a.duration,
          easing: function (e) {
            return e;
          },
          offset: [0, 0],
          animate: !0
        },
        o = {
          fromControl: t
        };
      "jump" === a.type ? this.map.jumpTo(r, o) : "ease" === a.type ? this.map.easeTo(__assign(__assign({}, r), n), o) : "fly" === a.type && this.map.flyTo(__assign(__assign({}, r), n), o);
    }, u.prototype.setCameraBounds = function (e) {
      this.setCamera(e);
    }, u.prototype.getCamera = function () {
      var e = this.map.getBounds().getSouthWest().toArray(),
        t = this.map.getBounds().getNorthEast().toArray();
      return {
        zoom: this.map.getZoom(),
        center: this.map.getCenter().toArray(),
        bearing: this.map.getBearing(),
        pitch: this.map.getPitch(),
        bounds: new BoundingBox(e, t),
        minZoom: this.map.getMinZoom(),
        maxZoom: this.map.getMaxZoom()
      };
    }, u.prototype.setStyle = function (e, t) {
      void 0 === t && (t = !0), delete e.preserveDrawingBuffer;
      e = new StyleOptions().merge(this.styleOptions, e), e.autoResize !== this.styleOptions.autoResize && this._setAutoResize(e.autoResize), e.language !== this.styleOptions.language && (this.localizedStringsPromise = Localizer.getStrings(e.language)), e.renderWorldCopies !== this.styleOptions.renderWorldCopies && this.map.setRenderWorldCopies(e.renderWorldCopies), e.showFeedbackLink !== this.styleOptions.showFeedbackLink && this.copyrightControl.setOptions({
        showFeedbackLink: e.showFeedbackLink
      }), e.customAttribution !== this.styleOptions.customAttribution && this.copyrightControl.setOptions({
        customAttribution: e.customAttribution
      }), e.showLogo !== this.styleOptions.showLogo && this.copyrightControl.setOptions({
        showLogo: e.showLogo
      }), e.showTileBoundaries !== this.styleOptions.showTileBoundaries && (this.map.showTileBoundaries = e.showTileBoundaries), e.showBuildingModels && console.warn("showBuildingModels is deprecated."), t = t && this.styleOptions.language === e.language && this.styleOptions.view === e.view;
      this.styleOptions = e, this._setStyleComponents(e, t);
    }, u.prototype.getStyle = function () {
      return cloneDeep$1(this.styleOptions);
    }, u.prototype.addIcon = function (e, t) {
      this.imageSprite.add(e, t);
    }, u.prototype.addPins = function (e, t) {
      var t = new PinLayerOptions().merge(t),
        r = this.layers.getLayerById(t.name),
        n = !1;
      if (r || (n = !0, r = new SymbolLayer("".concat(t.name, "-source"), t.name, {
        source: "".concat(t.name, "-source"),
        minZoom: t.minZoom,
        maxZoom: t.maxZoom,
        iconOptions: {
          anchor: "center",
          size: t.iconSize,
          image: ["case", ["has", "icon"], ["get", "icon"], t.icon],
          ignorePlacement: !t.cluster,
          opacity: t.opacity
        },
        textOptions: {
          anchor: "center",
          textField: ["case", ["has", "point_count"], ["to-string", ["get", "point_count"]], ["has", "title"], ["to-string", ["get", "title"]], t.title],
          font: ["case", ["has", "point_count"], ["literal", ["StandardFontCondensed-Bold"]], ["literal", [t.textFont]]],
          size: ["case", ["has", "point_count"], 20, t.fontSize],
          ignorePlacement: !t.cluster,
          opacity: t.opacity,
          offset: ["case", ["has", "point_count"], ["literal", [.5, -.45]], ["literal", [t.textOffset[0] / 16, t.textOffset[1] / 16]]],
          color: t.fontColor
        }
      })), !(r instanceof SymbolLayer)) throw new Error("A layer with name '".concat(t.name, "' already exists but it is not a SymbolLayer.") + "A SymbolLayer should be used for rendering pins.");
      var i = r.getSource(),
        o = ("string" == typeof i ? (a = i, i = this.sources.getById(a)) : a = i.getId(), !1);
      if (i || (o = !0, i = new DataSource(a, {
        cluster: t.cluster
      })), !(i instanceof DataSource)) throw new Error("The source with name '".concat(a, "' already exists but it is not a DataSource.") + "New data can only be added to a DataSource.");
      o && this.sources.add(i), n && this.layers.add(r, t.before);
      var a = new FeatureCollection(e);
      t.overwrite ? i.setShapes(a) : i.add(a);
    }, u.prototype.addCircles = function (e, t) {
      var t = new CircleLayerOptions().merge(t),
        r = this.layers.getLayerById(t.name),
        n = !1;
      if (r || (n = !0, r = new BubbleLayer("".concat(t.name, "-source"), t.name, {
        source: "".concat(t.name, "-source"),
        minZoom: t.minZoom,
        maxZoom: t.maxZoom,
        opacity: t.opacity,
        radius: ["case", ["has", "radius"], ["get", "radius"], t.radius],
        color: ["case", ["has", "color"], ["get", "color"], t.color],
        strokeColor: ["case", ["has", "outlineColor"], ["get", "outlineColor"], t.outlineColor],
        strokeWidth: ["case", ["has", "outlineWidth"], ["get", "outlineWidth"], t.outlineWidth]
      })), !(r instanceof BubbleLayer)) throw new Error("A layer with name '".concat(t.name, "' already exists but it is not a BubbleLayer.") + "A BubbleLayer should be used for rendering circles.");
      var i = r.getSource(),
        o = ("string" == typeof i ? (a = i, i = this.sources.getById(a)) : a = i.getId(), !1);
      if (i || (o = !0, i = new DataSource(a)), !(i instanceof DataSource)) throw new Error("The source with name '".concat(a, "' already exists but it is not a DataSource.") + "New data can only be added to a DataSource.");
      o && this.sources.add(i), n && this.layers.add(r, t.before);
      var a = new FeatureCollection(e);
      t.overwrite ? i.setShapes(a) : i.add(a);
    }, u.prototype.addLinestrings = function (e, t) {
      var t = new LinestringLayerOptions().merge(t),
        r = this.layers.getLayerById(t.name),
        n = !1;
      if (r || (n = !0, r = new LineLayer("".concat(t.name, "-source"), t.name, {
        source: "".concat(t.name, "-source"),
        minZoom: t.minZoom,
        maxZoom: t.maxZoom,
        lineCap: t.cap,
        lineJoin: t.join,
        strokeOpacity: t.opacity,
        strokeColor: ["case", ["has", "color"], ["get", "color"], t.color],
        strokeWidth: ["case", ["has", "width"], ["get", "width"], t.width]
      })), !(r instanceof LineLayer)) throw new Error("A layer with name '".concat(t.name, "' already exists but it is not a LineLayer.") + "A LineLayer should be used for rendering linestrings.");
      var i = r.getSource(),
        o = ("string" == typeof i ? (a = i, i = this.sources.getById(a)) : a = i.getId(), !1);
      if (i || (o = !0, i = new DataSource(a)), !(i instanceof DataSource)) throw new Error("The source with name '".concat(a, "' already exists but it is not a DataSource.") + "New data can only be added to a DataSource.");
      o && this.sources.add(i), n && this.layers.add(r, t.before);
      var a = new FeatureCollection(e);
      t.overwrite ? i.setShapes(a) : i.add(a);
    }, u.prototype.addPolygons = function (e, t) {
      var t = new PolygonLayerOptions().merge(t),
        r = this.layers.getLayerById(t.name),
        n = !1;
      if (r || (n = !0, r = new PolygonLayer("".concat(t.name, "-source"), t.name, {
        source: "".concat(t.name, "-source"),
        minZoom: t.minZoom,
        maxZoom: t.maxZoom,
        fillOpacity: t.opacity,
        fillColor: ["case", ["has", "color"], ["get", "color"], t.color]
      })), !(r instanceof PolygonLayer)) throw new Error("A layer with name '".concat(t.name, "' already exists but it is not a PolygonLayer.") + "A PolygonLayer should be used for rendering linestrings.");
      var i = r.getSource(),
        o = ("string" == typeof i ? (a = i, i = this.sources.getById(a)) : a = i.getId(), !1);
      if (i || (o = !0, i = new DataSource(a)), !(i instanceof DataSource)) throw new Error("The source with name '".concat(a, "' already exists but it is not a DataSource.") + "New data can only be added to a DataSource.");
      o && this.sources.add(i), n && this.layers.add(r, t.before);
      var a = new FeatureCollection(e);
      t.overwrite ? i.setShapes(a) : i.add(a);
    }, u.prototype.addRaster = function (e, t) {
      var r,
        t = new RasterLayerOptions().merge(t),
        n = this.layers.getLayerById(t.name);
      if (!((n = n || new TileLayer({
        maxZoom: t.maxZoom,
        minZoom: t.minZoom,
        opacity: t.opacity,
        tileSize: 256,
        tileUrl: "{subdomain}"
      }, t.name)) instanceof TileLayer)) throw new Error("A layer with name '".concat(t.name, "' already exists but it is not a TileLayer.") + "A TileLayer should be used for rendering raster images.");
      if ("{subdomain}" !== n.getOptions().tileUrl) throw new Error("A TileLayer with name '".concat(t.name, "' already exists but was configured ") + "for a single tile url [default for new TileLayer(...)].");
      (r = !t.overwrite && n.getOptions().subdomains || []).push.apply(r, __spreadArray$1([], __read$1(e), !1)), n._setOptionsNoUpdate({
        subdomains: r
      }), this.layers.add(n, t.before);
    }, u.prototype.getLayers = function () {
      return this.layers.getLayers().map(function (e) {
        return e.getId();
      });
    }, u.prototype.removeLayers = function (e) {
      var t, r;
      try {
        for (var n = __values(e), i = n.next(); !i.done; i = n.next()) {
          var o,
            a = i.value;
          this.layers.getLayerById(a) && (this.layers.remove(a), o = "".concat(a, "-source"), this.sources.getById(o)) && this.sources.remove(o);
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n);
        } finally {
          if (t) throw t.error;
        }
      }
    }, u.prototype.addHtml = function (e, t) {
      e.id || (e.id = "marker_".concat(uuid()));
      var r = new HtmlMarker({
        htmlContent: e
      });
      return this.markers.add(r, t), e.id;
    }, u.prototype.removeHtml = function (e) {
      this.markers.remove(e);
    }, u.prototype.addEventListener = function (e, t, r) {
      this.events._addLegacy(e, t, r);
    }, u.prototype.removeEventListener = function (e, t, r) {
      this.events._removeLegacy(e, t, r);
    }, u.prototype.setUserInteraction = function (e) {
      this.userInteractionDelegate.setOptions(e);
    }, u.prototype.getUserInteraction = function () {
      return this.userInteractionDelegate.getOptions();
    }, u.prototype.addControl = function (e, t) {
      this.controls.add(e, t);
    }, u.prototype.removeControl = function (e) {
      this.controls.remove(e);
    }, u.prototype.setTraffic = function (e) {
      var t = this.trafficOptions.incidents,
        r = this.trafficOptions.flow;
      if (this.trafficOptions = new TrafficOptions().merge(this.trafficOptions, e), this.controls.getControls().filter(function (e) {
        return e instanceof TrafficControl;
      }).forEach(function (e) {
        return e.updateButtonState();
      }), this.incidentDelegate && (this.trafficOptions.incidents ? t || this.incidentDelegate.addToMap() : this.incidentDelegate.removeFromMap()), this.trafficOptions.flow && "none" !== this.trafficOptions.flow) {
        ["absolute", "relative-delay"].includes(this.trafficOptions.flow) && console.warn("The 'absolute' and 'relative-delay' flow options are deprecated. Please use 'relative' instead.");
        try {
          this.trafficOptions.flow !== r && this.flowDelegate.addToMap();
        } catch (e) {
          throw this.trafficOptions.flow = r, e;
        }
      } else this.flowDelegate.removeFromMap();
    }, u.prototype.getTraffic = function () {
      return cloneDeep$1(this.trafficOptions);
    }, u.prototype.remove = function () {
      this.dispose();
    }, u.prototype.clear = function () {
      this.popups.clear(), this.layers.clear(), this.sources.clear(), this.markers.clear(), this.indicators.clear();
    }, u.prototype.dispose = function () {
      var e;
      for (this.clear(), this.map.remove(), null != (e = this.authentication) && e.dispose(), this.removed = !0, window.removeEventListener("resize", this._windowResizeCallback); this.getMapContainer().firstChild;) {
        var t = this.getMapContainer().firstChild;
        this.getMapContainer().removeChild(t);
      }
    }, u.prototype.resize = function (e, t, r) {
      "number" != typeof e && "string" != typeof e || "number" != typeof t && "string" != typeof t ? r = e : (e = e, this.getMapContainer().style.height = "number" == typeof e ? "".concat(e, "px") : e, this.getMapContainer().style.width = "number" == typeof t ? "".concat(t, "px") : t);
      e = this.getMapContainer().style.overflow;
      this.getMapContainer().style.overflow = "hidden", this.map.resize(r), this.getMapContainer().style.overflow = e;
    }, u.prototype.pixelsToPositions = function (e) {
      var t,
        r,
        n = [];
      try {
        for (var i = __values(e), o = i.next(); !o.done; o = i.next()) {
          var a = o.value,
            s = this.map.unproject(a);
          n.push(new Position(s.lng, s.lat));
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          o && !o.done && (r = i.return) && r.call(i);
        } finally {
          if (t) throw t.error;
        }
      }
      return n;
    }, u.prototype.positionsToPixels = function (e) {
      var t,
        r,
        n = [];
      try {
        for (var i = __values(e), o = i.next(); !o.done; o = i.next()) {
          var a = o.value,
            s = this.map.project(a);
          n.push(new Pixel(s.x, s.y));
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          o && !o.done && (r = i.return) && r.call(i);
        } finally {
          if (t) throw t.error;
        }
      }
      return n;
    }, u.prototype.areTilesLoaded = function () {
      return this.map.areTilesLoaded();
    }, u.prototype.stop = function () {
      this.map.stop();
    }, u.prototype.triggerRepaint = function () {
      this.map.triggerRepaint();
    }, u.prototype.enableElevation = function (e, t) {
      this.map.setTerrain("string" == typeof e ? {
        source: e,
        exaggeration: t
      } : {
        source: e.getId(),
        exaggeration: t
      });
    }, u.prototype.disableElevation = function () {
      this.map.setTerrain(null);
    }, u.prototype._getMap = function () {
      return this.map;
    }, u.prototype._rebuildStyle = function (t) {
      return void 0 === t && (t = !0), __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (e) {
          return this.styles.setStyle(this.styleOptions, t), this.imageSprite._restoreImages(), [2];
        });
      });
    }, u.prototype._isLoaded = function () {
      return this.loaded;
    }, u.prototype._isReady = function () {
      return this.ready;
    }, u.prototype._getLocalizedStrings = function () {
      return this.localizedStringsPromise;
    }, u.prototype._sendRequest = function (e, t, r) {
      var n;
      return (n = "function" == typeof this.serviceOptions.transformRequest ? this.serviceOptions.transformRequest(e, t) : n) ? fetch(n.url || e, {
        credentials: n.credentials,
        headers: __assign(__assign({}, r), n.headers),
        method: "GET",
        mode: "cors"
      }) : fetch(e, {
        headers: r,
        method: "GET",
        mode: "cors"
      });
    }, u.prototype._substituteDomainLanguageViewAndSignInRequest = function (e, t) {
      var r;
      (e.includes(constants.legacyDomainPlaceHolder) || e.includes(constants.domainPlaceHolder)) && (r = new RegExp("[^{]".concat(constants.legacyDomainPlaceHolder, "[^}]")), e.match(r) && (t.url = t.url.replace(constants.legacyDomainPlaceHolder, constants.domainPlaceHolder)), Url.protoRegEx.test(this.serviceOptions.domain) ? (r = t.url.indexOf(constants.domainPlaceHolder), t.url = this.serviceOptions.domain + t.url.substring(r + constants.domainPlaceHolder.length)) : t.url = t.url.replace(constants.domainPlaceHolder, this.serviceOptions.domain)), (t.url.toLocaleLowerCase().includes(this.serviceOptions.domain.toLocaleLowerCase()) || t.url.toLocaleLowerCase().includes(this.serviceOptions.staticAssetsDomain.toLocaleLowerCase())) && null != (r = this.authentication) && r.signRequest(t), e.includes(constants.languagePlaceHolder) && (t.url = t.url.replace(constants.languagePlaceHolder, this.styleOptions.language)), e.includes(constants.viewPlaceHolder) && (t.url = this.styleOptions.view ? t.url.replace(constants.viewPlaceHolder, this.styleOptions.view) : t.url.replace(constants.viewPlaceHolder, "").replace("&".concat(constants.viewParameter, "="), ""));
    }, u.prototype._setAutoResize = function (e) {
      e ? window.addEventListener("resize", this._windowResizeCallback) : window.removeEventListener("resize", this._windowResizeCallback);
    }, u.prototype._setStyleComponents = function (s, l) {
      var c = this;
      void 0 === l && (l = !0), this.removed || this.styles.definitions().then(function (e) {
        var t,
          r,
          n = !0;
        if (c.styleOptions.style) try {
          for (var i = __values(e.configurations), o = i.next(); !o.done; o = i.next()) {
            var a = o.value;
            if (c.styleOptions.style === a.name) {
              n = !1;
              break;
            }
          }
        } catch (e) {
          t = {
            error: e
          };
        } finally {
          try {
            o && !o.done && (r = i.return) && r.call(i);
          } finally {
            if (t) throw t.error;
          }
        }
        n && (c.styleOptions.style = e.defaultConfiguration), c.styleOptions = s, c._rebuildStyle(l);
      });
    }, u.prototype._updateGlobalDefaults = function (e) {
      e && (e.authOptions && !_hasSetAuthenticationOptions() && setAuthenticationOptions(e.authOptions), e.domain && !_hasSetDomain() && setDomain(e.domain), e.styleDefinitionsPath && !_hasSetStyleDefinitionsPath() && setStyleDefinitionsPath(e.styleDefinitionsPath), e.workerCount && !_hasWorkerCount() && setWorkerCount(e.workerCount), e.maxParallelImageRequests && !_hasMaxParallelImageRequests() && setMaxParallelImageRequests(e.maxParallelImageRequests), !e.subscriptionKey && !e["subscription-key"] || _hasSetAuthenticationOptions() || setSubscriptionKey(e.subscriptionKey || e["subscription-key"]), !e.sessionId && !e["session-id"] || _hasSetSessionId() || setSessionId(e.sessionId || e["session-id"]), e.language && !_hasSetLanguage() && setLanguage(e.language), !e.userRegion && !e.view || _hasSetView() || setUserRegion(e.userRegion || e.view));
    }, u.prototype._generateSafeBounds = function (e) {
      if (e) {
        var t = BoundingBox.getSouth(e),
          r = BoundingBox.getWest(e),
          n = BoundingBox.getNorth(e),
          i = BoundingBox.getEast(e);
        if (!(isFinite(t) && isFinite(r) && isFinite(n) && isFinite(i))) throw new Error("The bounds specified are invalid: [".concat(e, "]"));
        for (; i < r;) i += 360;
        return new BoundingBox([r, t, i, n]);
      }
      return e;
    }, u.prototype._detectHighContrast = function () {
      var e, t;
      switch (Media.getHighContrastMode()) {
        case "invert":
        case "light":
          e = u.Css.hcLight, t = "high_contrast_light";
          break;
        case "dark":
          e = u.Css.hcDark, t = "high_contrast_dark";
      }
      e && this.map.getContainer().classList.add(e), t && "road" === this.styleOptions.style && (this.styleOptions.style = t);
    }, u.Css = {
      canvasContainer: "atlas-map-canvas-container",
      canvas: "atlas-map-canvas",
      container: "atlas-map",
      hcDark: "high-contrast-dark",
      hcLight: "high-contrast-light"
    }, u;
  }(EventEmitter),
  __read = window && window.__read || function (e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator];
    if (!r) return e;
    var n,
      i,
      o = r.call(e),
      a = [];
    try {
      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) a.push(n.value);
    } catch (e) {
      i = {
        error: e
      };
    } finally {
      try {
        n && !n.done && (r = o.return) && r.call(o);
      } finally {
        if (i) throw i.error;
      }
    }
    return a;
  },
  __spreadArray = window && window.__spreadArray || function (e, t, r) {
    if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++) !n && i in t || ((n = n || Array.prototype.slice.call(t, 0, i))[i] = t[i]);
    return e.concat(n || Array.prototype.slice.call(t));
  },
  PopupTemplate = function () {
    function u() {
      this.detectHyperlinks = !0, this.parsePropertyPaths = !0;
    }
    return u.applyTemplate = function (t, r) {
      var n,
        i,
        e,
        o = this,
        a = document.createElement("div");
      return a.classList.add(u.Css.template), t && ("boolean" != typeof (r = r || {}).singleDescription && (r.singleDescription = !0), r.sandboxContent = "boolean" != typeof r.sandboxContent || r.sandboxContent, r.title && "string" == typeof r.content && (r.content.includes("{title}") || r.content.includes("{name}")) || (t.title ? r.title = "{title}" : t.name && (r.title = "{name}")), "boolean" != typeof r.detectHyperlinks && (r.detectHyperlinks = !0), "boolean" != typeof r.parsePropertyPaths && (r.parsePropertyPaths = !0), r.textColor && (a.style.color = r.textColor), r.fillColor && (a.style.backgroundColor = r.fillColor), r.title && ((e = this._applyStringTemplate(t, r.title, r)).innerText = e.textContent || e.innerText || "", this._appendChild(a, e, u.Css.title)), (n = document.createElement("div")).classList.add(u.Css.content), Array.isArray(r.content) ? 0 < r.content.length && r.content[0].propertyPath ? this._appendChild(n, this._generateContent(t, r.content, r), u.Css.item) : r.content.forEach(function (e) {
        o._appendChild(n, o._generateContent(t, e, r), u.Css.item);
      }) : (i = 0, e = void (t.description && Object.keys(t).forEach(function (e) {
        o._ignoreProperty(e, t[e]) || i++;
      })), 1 === i || r.singleDescription && t.description || 2 === i && t.Snippet ? (e = document.createElement("div")).innerHTML = t.description : e = this._generateContent(t, r.content, r), this._appendChild(n, e, u.Css.item)), "" !== n.innerHTML) && (r.sandboxContent ? a.appendChild(u._createSandboxedIframe(n, r)) : a.appendChild(n)), a;
    }, u._createSandboxedIframe = function (e, t) {
      var r = document.createElement("iframe"),
        e = (r.sandbox.add("allow-popups"), e.innerHTML),
        n = !1,
        i = 100,
        o = 550,
        a = 10,
        s = (document.body.scrollWidth <= 340 && (o = 300, i = 50), e.split(/<(tr|div|br|li|h[0-9]|p>)/)),
        l = Math.max.apply(Math, __spreadArray([], __read(s.map(function (e) {
          return e.replace(/<[a-zA-Z0-9\s=\/]+>/g, "").length;
        })), !1)) - 1,
        c = Math.ceil(3.5 * l),
        l = (c < o && (o = c, i = l), e.includes("<img") || e.includes("<video") ? (n = !0, r.width = "550px") : (c = -1 < e.indexOf(u.Css.table) ? 25 : 20, a += Math.max(.5 * s.length * c, Math.ceil(e.replace(/<[a-zA-Z0-9\s=\/]+>/g, "").length / i) * c)), r.width = o + "px", r.height = n || 280 < a ? "280px" : a + "px", t.textColor ? "color:".concat(t.textColor, ";") : ""),
        s = t.fillColor ? "background-color:".concat(t.fillColor, ";") : "",
        i = '<html><head><title></title><meta charset="utf-8" /><meta http-equiv="x-ua-compatible" content="IE=Edge" />' + '<link rel="stylesheet" href="'.concat(u._cssUrl, '" type="text/css"/>') + "<style>html, body{margin:0;padding:0;".concat(l).concat(s, "}</style></head>") + '<body><div class="'.concat(u.Css.template, '" style="padding:0;width:').concat(o - 20, 'px">').concat(e, "</div></body></html>");
      return void 0 === r.srcdoc ? r.src = "data:text/html;charset=utf-8," + encodeURI(i) : r.srcdoc = i, r;
    }, u._appendChild = function (e, t, r) {
      t && (r && (t.className = (t.className ? t.className + " " : "") + r), e.appendChild(t));
    }, u._generateContent = function (e, t, r) {
      return t ? Array.isArray(t) ? this._generatePropertyInfoTable(e, t, r) : this._applyStringTemplate(e, t, r) : (t = this._generateDynamicTableHtml(e, null, r)) ? ((e = document.createElement("div")).innerHTML = t, e) : null;
    }, u._applyStringTemplate = function (e, t, r) {
      if (t) {
        for (var n, i, o = t, a = this._placeholderRx.exec(t); a;) 2 <= a.length && (n = this._getPropertyValue(e, a[1], r), o = o.replace(a[0], n)), a = this._placeholderRx.exec(t);
        if (o) return (o = o.trim()).includes("<") && (o = o.replace(/[\r\n]+/g, "<br/>")), (i = document.createElement("div")).innerHTML = o, i;
      }
      return null;
    }, u._getPropertyValue = function (e, t, r, n) {
      var i = r.parsePropertyPaths ? t.split("/") : [t],
        o = i.length;
      if (0 < o && e) {
        var a = i[0],
          s = e[a];
        if (r.detectHyperlinks && "link" === t && (!n || n.hyperlinkFormat)) {
          var l,
            c,
            u,
            h = [];
          if (Array.isArray(s) ? s.forEach(function (e) {
            e.href ? h.push(e) : "string" == typeof e && h.push({
              href: e
            });
          }) : s.href && h.push(s), 0 < h.length) return n && n.hyperlinkFormat ? l = n.hyperlinkFormat : r && r.hyperlinkFormat && (l = r.hyperlinkFormat), c = l && l.target ? l.target : "_blank", u = [], h.forEach(function (e) {
            e.title || l && l.label || !e.rel || u.push(e.rel, " - "), u.push('<a href="', e.href, '" target="', c, '">'), e.title ? u.push(e.title) : l && l.label ? u.push(l.label) : u.push(e.href), u.push("</a>", "<br/>");
          }), u.pop(), u.join("");
        }
        if (null != s) {
          for (var d = void 0, d = 1; d < o && (s = s[i[d]], a = i[d], null != s); d++);
          if (d === o && null != s) {
            e = void 0;
            if ((e = void 0 !== s.value ? s.value : s) instanceof Date) return n && n.dateFormat ? e.toLocaleString(void 0, n.dateFormat) : r.dateFormat ? e.toLocaleString(void 0, r.dateFormat) : e.toISOString();
            if ("object" == typeof e) return (p = this._generateDynamicTableHtml(e, i.slice(1), r)) || "";
            if ("number" == typeof e) {
              if (n) {
                if (n.dateFormat) return new Date(e).toLocaleString(void 0, n.dateFormat);
                if (n.numberFormat) return e.toLocaleString(void 0, n.numberFormat);
              } else if (/(timestamp|date)/gi.test(a)) return new Date(e).toISOString();
              return e.toLocaleString(void 0, r.numberFormat);
            }
            if ("string" == typeof e && "" !== e && !/[\n\r<>\s]/g.test(e) && (r.detectHyperlinks || n && n.hyperlinkFormat)) {
              var p,
                e = e.trim(),
                t = this._isUrlRx.test(e) || n && n.hyperlinkFormat,
                f = this._isImageUrlRx.test(e) && (t || e.startsWith("data:image")),
                _ = this._emailRx.test(e);
              if (t || f || _) return t = void 0, p = void (n && n.hyperlinkFormat ? t = n.hyperlinkFormat : r && r.hyperlinkFormat && (t = r.hyperlinkFormat)), p = t && t.target ? ' target="'.concat(t.target, '"') : ' target="_blank"', n = "".concat(t && t.label ? t.label : e), t && t.scheme ? e = t.scheme + e : _ && (e = "mailto:" + e), r = t && t.label ? ' alt="'.concat(t.label, '"') : "", (t && t.isImage || f) && (n = '<img src="'.concat(e, '" style="max-width:100%"').concat(r, '"/>')), '<a href="'.concat(e, '"').concat(p, ">").concat(n, "</a>");
            }
            return e.toString();
          }
        }
      }
      return "";
    }, u._generatePropertyInfoTable = function (r, e, n) {
      var i, o;
      return r && e && 0 < e.length ? ((i = []).push('<table class="'.concat((o = this).Css.table, '">')), e.forEach(function (e) {
        var t = o._getPropertyValue(r, e.propertyPath, n, e);
        e.hideLabel ? i.push('<tr><td colspan="2">', t, "</td></tr>") : (e = e.label || e.propertyPath.split("/")[0], i.push("<tr><th>", e, "</th><td>", t, "</td></tr>"));
      }), i.push("</table>"), (e = document.createElement("div")).innerHTML = i.join(""), e) : null;
    }, u._generateDynamicTableHtml = function (t, e, r) {
      var n,
        i,
        o,
        a,
        s = this;
      return !t || ((n = []).push('<table class="'.concat((i = this).Css.table, '">')), o = e && 0 < e.length ? e.join("/") + "/" : "", a = 0, Object.keys(t).forEach(function (e) {
        s._ignoreProperty(e, t[e]) || (n.push("<tr><th>", e, "</th><td>", i._getPropertyValue(t, o + e, r), "</td></tr>"), a++);
      }), 0 === a) ? null : (n.push("</table>"), n.join(""));
    }, u._ignoreProperty = function (e, t) {
      switch (e) {
        case "title":
        case "name":
        case "base":
        case "popupTemplate":
        case "anchor":
        case "icon":
        case "image":
        case "imageUrl":
        case "rotation":
        case "color":
        case "size":
        case "offset":
        case "strokeColor":
        case "strokeWidth":
        case "strokeOpacity":
        case "subType":
        case "fillColor":
        case "fillOpacity":
        case "visibility":
        case "visible":
          return !0;
        default:
          if (0 === e.indexOf("_") || null == t || "" === t) return !0;
      }
      return !1;
    }, u._placeholderRx = /\{([a-zA-Z0-9_\/\s]+)\}/gi, u._isUrlRx = /^(http|https|ftp|tel|mailto):\/\//i, u._isImageUrlRx = /(^data:image|.png$|.jpg$|.jpeg$|.gif$|.bmp$|.svg|.tif|.tiff$)/i, u._emailRx = /^[^\.\s@:](?:[^\s@:]*[^\s@:\.])?@[^\.\s@]+(?:\.[^\.\s@]+)*$/, u._cssUrl = new Url({
      domain: env.staticAssetsDomain,
      path: "sdk/javascript/mapcontrol/".concat(Version$1.getEndpointVersion(), "/atlas.min.css")
    }).toString(), u.Css = {
      template: "azure-maps-control-popup-template",
      title: "azure-maps-control-popup-template-title",
      content: "azure-maps-control-popup-template-content",
      item: "azure-maps-control-popup-template-content-item",
      table: "azure-maps-control-popup-template-table"
    }, u;
  }(),
  rtlPluginUrl = new Url({
    domain: env.staticAssetsDomain,
    path: "sdk/javascript/mapcontrol/".concat(Version$1.getEndpointVersion(), "/mapbox-gl-rtl-text.min.js")
  });
  (maplibregl.setRTLTextPlugin(rtlPluginUrl.toString(), function (e) {
    e && console.warn(e);
  }, !0), Object.freeze({
    __proto__: null,
    get AuthenticationType() {
      return AuthenticationType;
    },
    get ControlPosition() {
      return ControlPosition;
    },
    get ControlStyle() {
      return ControlStyle;
    },
    HtmlMarker: HtmlMarker,
    Map: Map$1,
    Pixel: Pixel,
    Popup: Popup,
    PopupTemplate: PopupTemplate,
    Shape: Shape,
    _getAssetDomain: _getAssetDomain,
    _getDomain: _getDomain,
    _hasMaxParallelImageRequests: _hasMaxParallelImageRequests,
    _hasSetAuthenticationOptions: _hasSetAuthenticationOptions,
    _hasSetDomain: _hasSetDomain,
    _hasSetLanguage: _hasSetLanguage,
    _hasSetSessionId: _hasSetSessionId,
    _hasSetStyleDefinitionsPath: _hasSetStyleDefinitionsPath,
    _hasSetStyleDefinitionsVersion: _hasSetStyleDefinitionsVersion,
    _hasSetView: _hasSetView,
    _hasWorkerCount: _hasWorkerCount,
    addImageTemplate: addImageTemplate,
    clearPrewarmedResources: clearPrewarmedResources,
    control: index$2,
    data: index$4,
    getAllImageTemplateNames: getAllImageTemplateNames,
    getAuthenticationOptions: getAuthenticationOptions,
    getDomain: getDomain,
    getImageTemplate: getImageTemplate,
    getLanguage: getLanguage,
    getMaxParallelImageRequests: getMaxParallelImageRequests,
    getSessionId: getSessionId,
    getStaticAssetsDomain: getStaticAssetsDomain,
    getStyleAPIVersion: getStyleAPIVersion,
    getStyleDefinitionsPath: getStyleDefinitionsPath,
    getStyleDefinitionsVersion: getStyleDefinitionsVersion,
    getSubscriptionKey: getSubscriptionKey,
    getUserRegion: getUserRegion,
    getVersion: getVersion,
    getView: getView,
    getWorkerCount: getWorkerCount,
    internal: index$5,
    isSupported: isSupported,
    layer: index,
    math: index$3,
    prewarm: prewarm,
    setAuthenticationOptions: setAuthenticationOptions,
    setDomain: setDomain,
    setLanguage: setLanguage,
    setMaxParallelImageRequests: setMaxParallelImageRequests,
    setSessionId: setSessionId,
    setStyleAPIVersion: setStyleAPIVersion,
    setStyleDefinitionsPath: setStyleDefinitionsPath,
    setStyleDefinitionsVersion: setStyleDefinitionsVersion,
    setSubscriptionKey: setSubscriptionKey,
    setUserRegion: setUserRegion,
    setView: setView,
    setWorkerCount: setWorkerCount,
    source: index$1
  }));

function dataToCoordSize(dataSize, dataItem) {
  var finalDataItem = dataItem || [0, 0];
  return echarts.util.map([0, 1], function (dimIdx) {
    var val = finalDataItem[dimIdx];
    var halfSize = dataSize[dimIdx] / 2;
    var p1 = [];
    var p2 = [];
    p1[dimIdx] = val - halfSize;
    p2[dimIdx] = val + halfSize;
    p1[1 - dimIdx] = p2[1 - dimIdx] = finalDataItem[1 - dimIdx];
    return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
  }, this);
}
function AzureMapCoordSys(azuremap, api) {
  this._azuremap = azuremap;
  this.dimensions = ['lng', 'lat'];
  this._mapOffset = [0, 0];
  this._api = api;
}
var AzureMapCoordSysProto = AzureMapCoordSys.prototype;
AzureMapCoordSysProto.type = COMPONENT_TYPE;
AzureMapCoordSysProto.dimensions = ['lng', 'lat'];
AzureMapCoordSysProto.setZoom = function (zoom) {
  this._zoom = zoom;
};
AzureMapCoordSysProto.setCenter = function (center) {
  //Format coordinates as longitude, latitude.
  var latlng = index$4.Position.fromLatLng(center[0], center[1]);
  // Represent a pixel coordinate or offset. Extends an array of [x, y].
  var _this$_azuremap$posit = _slicedToArray(this._azuremap.positionsToPixels([latlng])[0], 2),
    x = _this$_azuremap$posit[0],
    y = _this$_azuremap$posit[1];
  this._center = {
    x: x,
    y: y
  };
};
AzureMapCoordSysProto.setMapOffset = function (mapOffset) {
  this._mapOffset = mapOffset;
};
AzureMapCoordSysProto.setAzureMap = function (azmap) {
  this._azuremap = azmap;
};
AzureMapCoordSysProto.getAzureMap = function () {
  return this._azuremap;
};
AzureMapCoordSysProto.dataToPoint = function (data) {
  var latlng = index$4.Position.fromLatLng(data);
  var _this$_azuremap$posit2 = _slicedToArray(this._azuremap.positionsToPixels([latlng])[0], 2),
    x = _this$_azuremap$posit2[0],
    y = _this$_azuremap$posit2[1];
  var mapOffset = this._mapOffset;
  return [x - mapOffset[0], y - mapOffset[1]];
};
AzureMapCoordSysProto.pointToData = function (pt) {
  var mapOffset = this._mapOffset;
  // https://learn.microsoft.com/zh-cn/javascript/api/azure-maps-control/atlas.map?view=azure-maps-typescript-latest#azure-maps-control-atlas-map-pixelstopositions
  var _this$_azuremap$pixel = _slicedToArray(this._azuremap.pixelsToPositions([new Pixel(pt[0] + mapOffset[0], pt[1] + mapOffset[1])])[0], 2),
    lat = _this$_azuremap$pixel[0],
    lng = _this$_azuremap$pixel[1];
  return [lng, lat];
};
AzureMapCoordSysProto.getViewRect = function () {
  var api = this._api;
  return new echarts.graphic.BoundingRect(0, 0, api.getWidth(), api.getHeight());
};
AzureMapCoordSysProto.getRoamTransform = function () {
  return echarts.matrix.create();
};
AzureMapCoordSysProto.prepareCustoms = function () {
  var rect = this.getViewRect();
  return {
    coordSys: {
      // The name exposed to user is always 'cartesian2d' but not 'grid'.
      type: COMPONENT_TYPE,
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    api: {
      coord: echarts.util.bind(this.dataToPoint, this),
      size: echarts.util.bind(dataToCoordSize, this)
    }
  };
};
AzureMapCoordSysProto.convertToPixel = function (_ecModel, _finder, value) {
  // here we ignore finder as only one azuremap component is allowed
  return this.dataToPoint(value);
};
AzureMapCoordSysProto.convertFromPixel = function (_ecModel, _finder, value) {
  return this.pointToData(value);
};

// For deciding which dimensions to use when creating list data
AzureMapCoordSys.dimensions = AzureMapCoordSysProto.dimensions;

// let Overlay;
AzureMapCoordSys.create = function (ecModel, api) {
  var azureMapCoordSys;
  var root = api.getDom();
  ecModel.eachComponent(COMPONENT_TYPE, function (azuremapModel) {
    var painter = api.getZr().painter;
    var viewportRoot = painter.getViewportRoot();
    // Overlay =
    //   Overlay ||
    //   new atlas.layer.WebGLLayer('ec-map-layer', {
    //     renderer: {
    //       onAdd: function (mapInstance) {
    //         mapInstance.getCanvasContainer().appendChild(viewportRoot);
    //       },
    //       render: function () {},
    //     },
    //   });
    if (azureMapCoordSys) {
      throw new Error('Only one azuremap component can exist');
    }
    var azuremap = azuremapModel.getAzureMap();
    if (!azuremap) {
      var azuremapRoot = root.querySelector('.ec-extension-azure-map');
      viewportRoot.className = 'azure-ec-layer';
      viewportRoot.style.pointerEvents = 'auto';
      viewportRoot.style.position = 'absolute';
      viewportRoot.style.display = 'none';
      viewportRoot.style.left = '0px';
      viewportRoot.style.top = '0px';
      if (azuremapRoot) {
        viewportRoot.style.left = '0px';
        viewportRoot.style.top = '0px';
        root.removeChild(azuremapRoot);
      }
      azuremapRoot = document.createElement('div');
      azuremapRoot.style.cssText = 'position:absolute;top:0;left:0;right:0;bottom:0;';
      azuremapRoot.className = 'ec-extension-azure-map';
      root.appendChild(azuremapRoot);
      var mapOptions = azuremapModel.get();
      if (mapOptions) {
        mapOptions = echarts.util.clone(mapOptions);
      }
      azuremap = new Map$1(azuremapRoot, mapOptions);
      azuremapModel.setAzureMap(azuremap);
      azuremap.events.add('ready', function () {
        azuremap.getCanvasContainer().appendChild(viewportRoot);
        viewportRoot.style.display = '';
        // azuremap.layers.add(Overlay);
      });

      // Override
      painter.getViewportRootOffset = function () {
        return {
          offsetLeft: 0,
          offsetTop: 0
        };
      };
    }
    // Set azuremap options
    // centerAndZoom before layout and render
    var center = azuremapModel.get('center');
    var zoom = azuremapModel.get('zoom');
    if (center && zoom) {
      var azuremapCenter = azuremap.getCamera().center;
      var azuremapZoom = azuremap.getCamera().zoom;
      var centerOrZoomChanged = azuremapModel.centerOrZoomChanged(azuremapCenter, azuremapZoom);
      if (centerOrZoomChanged) {
        azuremap.setCamera({
          center: center,
          zoom: zoom
        });
      }
    }
    azureMapCoordSys = new AzureMapCoordSys(azuremap, api);
    azureMapCoordSys.setMapOffset(azuremapModel.__mapOffset || [0, 0]);
    azureMapCoordSys.setZoom(zoom);
    azureMapCoordSys.setCenter(center);
    azuremapModel.coordinateSystem = azureMapCoordSys;
  });
  ecModel.eachSeries(function (seriesModel) {
    if (seriesModel.get('coordinateSystem') === COMPONENT_TYPE) {
      seriesModel.coordinateSystem = azureMapCoordSys;
    }
  });
  return azureMapCoordSys && [azureMapCoordSys];
};

var AzureMapModel = {
  type: COMPONENT_TYPE,
  setAzureMap: function setAzureMap(azuremap) {
    this.__azuremap = azuremap;
  },
  getAzureMap: function getAzureMap() {
    // __azuremap is injected when creating AzureMapCoordSys
    return this.__azuremap;
  },
  setEChartsLayer: function setEChartsLayer(layer) {
    this.__echartsLayer = layer;
  },
  getEChartsLayer: function getEChartsLayer() {
    return this.__echartsLayer;
  },
  setCenterAndZoom: function setCenterAndZoom(center, zoom) {
    this.option.center = center;
    this.option.zoom = zoom;
  },
  centerOrZoomChanged: function centerOrZoomChanged(center, zoom) {
    var option = this.option;
    return !(v2Equal(center, option.center) && zoom === option.zoom);
  },
  defaultOption: {
    view: 'Auto',
    center: [104.1064453125, 37.54457732085582],
    zoom: 5
  }
};
var AzureMapModel$1 = isNewEC ? echarts.ComponentModel.extend(AzureMapModel) : AzureMapModel;

var AzureMapView = {
  type: COMPONENT_TYPE,
  render: function render(azMapModel, ecModel, api) {
    var rendering = true;
    var azmap = azMapModel.getAzureMap();
    var viewportRoot = api.getZr().painter.getViewportRoot();
    var coordSys = azMapModel.coordinateSystem;
    var moveHandler = function moveHandler() {
      if (rendering) {
        return;
      }
      var offsetEl = azmap.getMapContainer();
      var mapOffset = [-parseInt(offsetEl.style.left, 10) || 0, -parseInt(offsetEl.style.top, 10) || 0];
      var viewportRootStyle = viewportRoot.style;
      var offsetLeft = "".concat(mapOffset[0], "px");
      var offsetTop = "".concat(mapOffset[1], "px");
      if (viewportRootStyle.left !== offsetLeft) {
        viewportRootStyle.left = offsetLeft;
      }
      if (viewportRootStyle.top !== offsetTop) {
        viewportRootStyle.top = offsetTop;
      }
      coordSys.setMapOffset(mapOffset);
      azMapModel.__mapOffset = mapOffset;
      api.dispatchAction({
        type: ACTION_TYPE,
        animation: {
          duration: 0
        }
      });
    };
    function zoomEndHandler() {
      if (rendering) {
        return;
      }
      api.dispatchAction({
        type: ACTION_TYPE,
        animation: {
          duration: 0
        }
      });
    }
    azmap.events.remove('move', this._oldMoveHandler);
    azmap.events.remove('moveend', this._oldMoveHandler);
    azmap.events.remove('zoomend', this._oldZoomEndHandler);
    azmap.events.add('move', moveHandler);
    azmap.events.add('moveend', moveHandler);
    azmap.events.add('zoomend', zoomEndHandler);
    this._oldMoveHandler = moveHandler;
    this._oldZoomEndHandler = zoomEndHandler;
    rendering = false;
  },
  dispose: function dispose() {
    var component = this.__model;
    delete this._oldMoveHandler;
    delete this._oldZoomEndHandler;
    if (component) {
      component.getAzureMap().dispose();
      component.setAzureMap(null);
      component.getEChartsLayer(null);
      if (component.coordinateSystem) {
        component.coordinateSystem.setAzureMap(null);
        component.coordinateSystem = null;
      }
    }
  }
};
var AzureMapView$1 = isNewEC ? echarts.ComponentView.extend(AzureMapView) : AzureMapView;

var name = "echarts-extension-azure-map";
var version = "1.0.0";

function install(registers) {
  // add coordinate system support for pie series for ECharts < 5.4.0
  if (!isNewEC || ecVer[0] === 5 && ecVer[1] < 4) {
    registers.registerLayout(function (ecModel) {
      ecModel.eachSeriesByType('pie', function (seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var data = seriesModel.getData();
        var valueDim = data.mapDimension('value');
        if (coordSys && coordSys.type === COMPONENT_TYPE) {
          var center = seriesModel.get('center');
          var point = coordSys.dataToPoint(center);
          var cx = point[0];
          var cy = point[1];
          data.each(valueDim, function (_value, idx) {
            var layout = data.getItemLayout(idx);
            layout.cx = cx;
            layout.cy = cy;
          });
        }
      });
    });
  }
  // Model
  isNewEC ? registers.registerComponentModel(AzureMapModel$1) : registers.extendComponentModel(AzureMapModel$1);
  // View
  isNewEC ? registers.registerComponentView(AzureMapView$1) : registers.extendComponentView(AzureMapView$1);
  // Coordinate System
  registers.registerCoordinateSystem(COMPONENT_TYPE, AzureMapCoordSys);
  // Action
  registers.registerAction({
    type: ACTION_TYPE,
    event: ACTION_TYPE,
    update: 'updateLayout'
  }, function (_payload, ecModel) {
    ecModel.eachComponent(COMPONENT_TYPE, function (azMapModel) {
      var azmap = azMapModel.getAzureMap();
      var center = azmap.getCamera().center;
      var zoom = azmap.getCamera().zoom;
      azMapModel.setCenterAndZoom(center, zoom);
    });
  });
}

isNewEC ? echarts.use(install) : install(echarts);

exports.name = name;
exports.version = version;
